import fs from 'fs'
import path from 'path'

import { DEFAULT_LOCALE } from 'domains/common/constants/locales'
import uniq from 'lodash/uniq'
import getTitle from 'title'


/**
 * Generates regex for searching file by locale with default locale fallback
 * @param locale - current locale
 */
function getFileNameRegexp (locale: string): RegExp {
    return new RegExp(`\\.(?:${locale}|${DEFAULT_LOCALE}).mdx?$`, 'i')
}

export type NavItem = {
    label: string
    route: string
    external?: boolean
    children?: Array<NavItem>
}

type FileMetaInfo = {
    name: string
    isDir: boolean
}

type ItemDescription =
    string | // File name mapping
    { href: string, title: string } // External resource

export type ArticleInfo = {
    label: string
    route: string
}

/**
 * Compares FileMetaInfo by name
 * @param lhs - left-hand side
 * @param rhs - right-hand side
 */
function _fileComparer (lhs: FileMetaInfo, rhs: FileMetaInfo) {
    if (lhs.name < rhs.name) {
        return -1
    } else if (lhs.name === rhs.name) {
        return 0
    } else {
        return 1
    }
}

/**
 * Generates nested navigation tree (root node are excluded, so return type is Array of top-level nodes)
 * Recursively:
 * 1. Find all matching doc files in dir
 * 2. Find meta file for specific locale
 * 3. For each key in meta:
 *  i. If it's an existing file, return localized name and its relative path (route)
 *  ii. If it's an existing dir, return localize name, its relative path (route) and trigger function for nested objects
 *  iii. If it's an external link, return external flag with external route.
 * 4. For each file / dir which was not in meta and left after step 3 doing same process, but title are generated from filename itself.
 * @param dir - dir to scan files
 * @param locale - current locale used to generate file regex
 * @param rootDir - root dir to generate routes (relative paths)
 */
export function getNavTree (dir: string, locale: string, rootDir: string): Array<NavItem> {
    const fileRegexp = getFileNameRegexp(locale)
    // Extract all files in dir
    const filePaths = fs.readdirSync(dir, { withFileTypes: true })
    // Filter MD files without extension
    const files = uniq(filePaths
        .filter(file => {
            return file.isFile() && fileRegexp.test(file.name)
        })
        .map(file => file.name.split('.')[0]))
    // Filter dirs
    const dirs = filePaths
        .filter(file => file.isDirectory())
        .map(file => file.name)
    // Obtain meta info
    const metaPath = path.join(dir, `_meta.${locale}.json`)
    const meta: Record<string, ItemDescription> = fs.existsSync(metaPath)
        ? JSON.parse(fs.readFileSync(metaPath, 'utf-8'))
        : {}
    const result: Array<NavItem> = []

    // Process meta
    for (const [key, value] of Object.entries(meta)) {
        if (files.includes(key) && typeof value === 'string') {
            files.splice(files.indexOf(key), 1)
            result.push({
                label: value,
                route: path.relative(rootDir, path.join(dir, key)),
            })

        } else if (dirs.includes(key) && typeof value === 'string') {
            dirs.splice(dirs.indexOf(key), 1)
            const children = getNavTree(path.join(dir, key), locale, rootDir)
            if (children.length) {
                result.push({
                    label: value,
                    route: path.relative(rootDir, path.join(dir, key)),
                    children,
                })
            }
        } else if (typeof value === 'object' && 'title' in value && 'href' in value) {
            result.push({
                label: value.title,
                route: value.href,
                external: true,
            })
        }
    }

    // Sort rest of the files (was not in meta) alphabetically
    const restFiles: Array<FileMetaInfo> = [
        ...files.map(name => ({ name, isDir: false })),
        ...dirs.map(name => ({ name, isDir: true })),
    ]
    restFiles.sort(_fileComparer)

    // Process rest of the files using title pkg for generation titles
    for (const fileInfo of restFiles) {
        const label = getTitle(fileInfo.name)
        const route = path.relative(rootDir, path.join(dir, fileInfo.name))

        if (fileInfo.isDir) {
            const children = getNavTree(path.join(dir, fileInfo.name), locale, rootDir)
            if (children.length) {
                result.push({ label, route, children })
            }
        } else {
            result.push({ label, route })
        }
    }

    return result
}

/**
 * Traverse tree generated by getNavTree function to get flat array of leafs (articles)
 * @param navTree - tree generated by getNavTree
 */
export function *getFlatArticles (navTree: Array<NavItem>): IterableIterator<ArticleInfo> {
    for (const item of navTree) {
        if (item.children) {
            yield *getFlatArticles(item.children)
        } else if (!item.external) {
            yield { label: item.label, route: item.route }
        }
    }
}

/**
 * Recursively gets all doc files in folder. Finds localized version or its fallback with default locale.
 * Used for generating docs static paths
 * @param dir - dir to find files in
 * @param locale - current locale
 * @param rootDir - root docs dir to generate relative paths (routes)
 */
export function *getAllRoutes (dir: string, locale: string, rootDir: string): IterableIterator<string> {
    const fileRegexp = getFileNameRegexp(locale)
    const files = fs.readdirSync(dir, { withFileTypes: true })
    const includedFiles: Array<string> = []
    for (const file of files) {
        if (file.isDirectory()) {
            yield *getAllRoutes(path.join(dir, file.name), locale, rootDir)
        } else if (file.isFile() && fileRegexp.test(file.name)) {
            const filePrefix = file.name.split('.')[0]
            if (!includedFiles.includes(filePrefix)) {
                includedFiles.push(filePrefix)
                yield path.relative(rootDir, path.join(dir, filePrefix))
            }
        }
    }
}

/**
 * By given current route and built navigation extracts localized nested path like following:
 * 'folder/index' -> ["Section", "PageTitle"]
 * @param route - current page route
 * @param nav - tree generated by getNavTree
 */
export function extractLocalizedTitleParts (route: string, nav: Array<NavItem>): Array<string> {
    const parts = route.split('/')
    let candidates = nav
    const result: Array<string> = []
    for (let i = 0; i < parts.length; ++i) {
        const subRoute = parts.slice(0, i + 1).join('/')
        const matchingNode = candidates.find(node => node.route === subRoute)
        if (matchingNode) {
            result.push(matchingNode.label)
            if (matchingNode.children) {
                candidates = matchingNode.children
            } else {
                return result
            }
        } else {
            return result
        }
    }

    return result
}