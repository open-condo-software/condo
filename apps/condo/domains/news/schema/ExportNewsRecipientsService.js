/**
 * Generated by `createservice news.ExportNewsRecipientsService --type mutations`
 */
const { createHash } = require('crypto')

const dayjs = require('dayjs')
const compact = require('lodash/compact')
const filter = require('lodash/filter')
const find = require('lodash/find')
const get = require('lodash/get')
const identity = require('lodash/identity')
const pick = require('lodash/pick')
const pickBy = require('lodash/pickBy')


const conf = require('@open-condo/config')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')
const { i18n } = require('@open-condo/locales/loader')

const { createExportFile } = require('@condo/domains/common/utils/createExportFile')
const { getHeadersTranslations, EXPORT_TYPE_NEWS_RECIPIENTS } = require('@condo/domains/common/utils/exportToExcel')
const { loadListByChunks } = require('@condo/domains/common/utils/serverSchema')
const access = require('@condo/domains/news/access/ExportNewsRecipientsService')
const { queryFindResidentsByOrganizationAndScopes } = require('@condo/domains/news/utils/accessSchema')
const { getUnitsFromProperty } = require('@condo/domains/news/utils/serverSchema/recipientsCounterUtils')
const { Property } = require('@condo/domains/property/utils/serverSchema')
const { Resident } = require('@condo/domains/resident/utils/serverSchema')

const buildExportFile = async ({ rows, locale }) => {
    const YesMessage = i18n('Yes', { locale })
    const NoMessage = i18n('No', { locale })
    const HeaderMessage = i18n('excelExport.sheetNames.newsRecipients', { locale })

    const processedRows = rows.reduce((acc, row) => {
        row.hasResident = row.hasResident ? YesMessage : NoMessage
        return [...acc, row]
    }, [])
    const { url: linkToFile } = await createExportFile({
        fileName: `news_recipients_${dayjs().format('DD_MM')}.xlsx`,
        templatePath: './domains/news/templates/NewsRecipientsExportTemplate.xlsx',
        replaces: {
            header: HeaderMessage,
            newsRecipients: processedRows,
            i18n: {
                ...getHeadersTranslations(EXPORT_TYPE_NEWS_RECIPIENTS, locale),
                sheetName: i18n('excelExport.sheetNames.newsRecipients', { locale }),
            },
        },
        meta: {
            listkey: 'NewsRecipients',
            id: createHash('md5').update(JSON.stringify(rows)).digest('hex'),
        },
    })

    return linkToFile
}

const ExportNewsRecipientsService = new GQLCustomSchema('ExportNewsRecipientsService', {
    types: [
        {
            access: true,
            type: 'input ExportNewsRecipientsInput { dv: Int!, sender: JSON!, organization: OrganizationWhereUniqueInput!, newsItemScopes: [NewsItemScopeWhereInput] }',
        },
        {
            access: true,
            type: 'type ExportNewsRecipientsOutput { status: String!, linkToFile: String! }',
        },
    ],

    mutations: [
        {
            access: access.canExportNewsRecipients,
            schema: 'exportNewsRecipients(data: ExportNewsRecipientsInput!): ExportNewsRecipientsOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { newsItemScopes, organization: { id: organizationId } } } = args
                const locale = extractReqLocale(context.req) || conf.DEFAULT_LOCALE

                /**
                 * @type {{ property: PropertyWhereUniqueInput, unitType: String, unitName: String }[]}
                 */
                const residentsData = []
                await loadListByChunks({
                    context,
                    list: Resident,
                    chunkSize: 50,
                    where: {
                        ...queryFindResidentsByOrganizationAndScopes(organizationId, newsItemScopes),
                        deletedAt: null,
                    },
                    /**
                     * @param {Resident[]} chunk
                     * @returns {Resident[]}
                     */
                    chunkProcessor: (chunk) => {
                        residentsData.push(...chunk.map((resident) => ({
                            property: { id: resident.property.id },
                            unitType: resident.unitType,
                            unitName: resident.unitName,
                        })))

                        return []
                    },
                })

                const recipientsByNewsItemsScope = []
                const recipientsByOrganization = []
                const isAllOrganization = filter(newsItemScopes, { property: null, unitType: null, unitName: null }).length > 0

                if (isAllOrganization) {
                    await loadListByChunks({
                        context,
                        list: Property,
                        chunkSize: 50,
                        where: {
                            organization: {
                                id: organizationId,
                            },
                            deletedAt: null,
                        },
                        /**
                         * @param {Property[]} chunk
                         * @returns {Property[]}
                         */
                        chunkProcessor: (chunk) => {
                            for (const property of chunk) {
                                const units = getUnitsFromProperty(property)

                                const recipientsData = units.map(({ unitName, unitType }) => ({
                                    address: property.address,
                                    unitName,
                                    hasResident: !!find(residentsData, { unitName, unitType, property: { id: property.id } }),
                                }))
                                recipientsByOrganization.push(...recipientsData)
                            }

                            return []
                        },
                    })
                } else {
                    const compactedNewsItemScopes = compact(newsItemScopes)
                    const propertiesIds = new Set()
                    for (let newsItemScope of compactedNewsItemScopes) {
                        if (get(newsItemScope, 'property.id')) {
                            const property = await Property.getOne(context, {
                                id: newsItemScope.property.id,
                                deletedAt: null,
                            })

                            propertiesIds.add(property.id)

                            const units = getUnitsFromProperty(property)

                            const unitsFilter = pickBy(pick(newsItemScope, ['unitName', 'unitType']), identity)

                            const filteredUnits = filter(units, unitsFilter)
                            const filteredResidents = filter(residentsData, unitsFilter)
                            const recipientsData = filteredUnits.map(({ unitName, unitType }) => ({
                                address: property.address,
                                unitName,
                                hasResident: !!find(filteredResidents, { unitName, unitType, property: { id: property.id } }),
                            }))
                            recipientsByNewsItemsScope.push(...recipientsData)
                        }
                    }
                }

                const unitsData = [...recipientsByNewsItemsScope, ...recipientsByOrganization]

                const linkToFile = await buildExportFile({ rows: unitsData, locale })

                return { linkToFile, status: 'OK' }
            },
        },
    ],

})

module.exports = {
    ExportNewsRecipientsService,
}
