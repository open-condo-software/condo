/**
 * Generated by `createservice news.ExportNewsRecipientsService --type mutations`
 */

const get = require('lodash/get')
const isEmpty = require('lodash/isEmpty')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/news/access/ExportNewsRecipientsService')
const { Property } = require('@condo/domains/property/utils/serverSchema')
const { Resident } = require('@condo/domains/resident/utils/serverSchema')


const getUnitsFromProperty = ({ map }) => (
    map?.sections?.reduce((acc, section) => ([
        ...acc,
        ...getUnitsFromSection(section),
    ]), []) || []
)

const getUnitsFromSection = (section) => section.floors.flatMap(floor => floor.units.map(unit => ({ unitName: unit.name, unitType: unit.unitType })))
/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const errors = {
    MISSING_PROPERTY: {
        mutation: 'exportNewsRecipients',
        code: INTERNAL_ERROR,
        type: NOT_FOUND,
        message: 'Could not found property related to newsItemScope',
        messageForUser: 'api.user.exportNewsRecipients.MISSING_PROPERTY',
    },
}

const ExportNewsRecipientsService = new GQLCustomSchema('ExportNewsRecipientsService', {
    types: [
        {
            access: true,
            type: 'input ExportNewsRecipientsInput { dv: Int!, sender: JSON!, organizationId: ID!, newsItemScopes: [NewsItemScopeWhereInput] }',
        },
        {
            access: true,
            type: 'type ExportNewsRecipientsOutput { status: String, linkToFile: String }',
        },
    ],
    
    mutations: [
        {
            access: access.canExportNewsRecipients,
            schema: 'exportNewsRecipients(data: ExportNewsRecipientsInput!): ExportNewsRecipientsOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { newsItemScopes, organizationId } } = args

                let properties
                if (!isEmpty(newsItemScopes)) {
                    properties = newsItemScopes.map(newsItemScope => {
                        if (newsItemScope.property) return newsItemScope.property.id
                    })
                }


                let residentsByProperties
                if (!isEmpty(properties)) {
                    residentsByProperties = await Resident.getAll(context, {
                        property: {
                            id_in: properties,
                        },
                        deletedAt: null,
                    })
                }

                const recipientsByOrganization = []
                if (organizationId && isEmpty(newsItemScopes)) {
                    const residentsByOrganization = await Resident.getAll(context, {
                        organization: {
                            id: organizationId,
                        },
                        deletedAt: null,
                    })

                    const propertiesByOrganization = await Property.getAll(context, {
                        organization: {
                            id: organizationId,
                        },
                        deletedAt: null,
                    })

                    for (let property of propertiesByOrganization) {
                        const units = getUnitsFromProperty({ map: property.map })

                        const recipientsData = units.reduce((acc, unit) => {
                            if (residentsByOrganization.find((resident) => unit.unitName === resident.unitName)) {
                                acc.push({ address: property.name, unitName: unit.unitName, isResident: true })
                                return [...acc]
                            }
                            acc.push({ address: property.name, unitName: unit.unitName, isResident: false })
                            return [...acc]
                        }, [])
                        recipientsByOrganization.push(...recipientsData)
                    }



                }

                const recipientsByProperty = []
                const recipientsByUnitType = []
                const recipientsByUnitName = []
                if (!isEmpty(newsItemScopes)) {
                    for (let newsItemScope of newsItemScopes) {
                        if (get(newsItemScope, 'property.id')) {
                            const property = await Property.getOne(context, {
                                id: newsItemScope.property.id,
                                deletedAt: null,
                            })

                            const units = getUnitsFromProperty({ map: property.map })

                            if (!newsItemScope.unitName && !newsItemScope.unitType) {
                                const recipientsData = units.reduce((acc, unit) => {
                                    if (residentsByProperties.find((resident) => unit.unitName === resident.unitName)) {
                                        return acc.push({ address: property.name, unitName: unit.unitName, isResident: true })
                                    }
                                    return acc.push({ address: property.name, unitName: unit.unitName, isResident: false })
                                }, [])
                                recipientsByProperty.push(...recipientsData)
                            }

                            if (!newsItemScope.unitName && newsItemScope.unitType) {
                                const unitsFilteredByType = units.reduce((acc, unit) => {
                                    if (unit.unitType === newsItemScope.unitType) {
                                        return acc.push(unit)
                                    }
                                }, [])

                                const recipientsData = unitsFilteredByType.reduce((acc, unit) => {
                                    if (residentsByProperties.find(resident => unit.unitName === resident.unitName)) {
                                        return acc.push({ address: property.name, unitName: unit.unitName, isResident: true })
                                    }
                                    return acc.push({ address: property.name, unitName: unit.unitName, isResident: false })
                                }, [])

                                recipientsByUnitType.push(...recipientsData)
                            }

                            if (!newsItemScope.unitType && newsItemScope.unitName) {
                                if (residentsByProperties.find(resident => resident.unitName === newsItemScope.unitName)) {
                                    recipientsByUnitName.push({ address: property.name, unitName: newsItemScope.unitName, isResident: true })
                                }
                                recipientsByUnitName.push({ address: property.name, unitName: newsItemScope.unitName, isResident: false })
                            }
                        }
                    }
                }

                const result = [...recipientsByOrganization, ...recipientsByProperty, ...recipientsByUnitType, ...recipientsByUnitName]

                return {
                    result,
                    status: 'OK',
                }
            },
        },
    ],
    
})

module.exports = {
    ExportNewsRecipientsService,
}
