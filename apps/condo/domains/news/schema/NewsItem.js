/**
 * Generated by `createschema news.OrganizationNewsItem 'organization:Relationship:Organization:CASCADE; title:Text; body:Text; type:Select:common,emergency'`
 */

const BadWordsNext = require('bad-words-next')
const badWordsRu = require('bad-words-next/data/ru.json')
const badWordsRuLat = require('bad-words-next/data/ru_lat.json')
const dayjs = require('dayjs')
const get = require('lodash/get')
const isEmpty = require('lodash/isEmpty')

const { canOnlyServerSideWithoutUserRequest } = require('@open-condo/keystone/access')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { itemsQuery } = require('@open-condo/keystone/schema')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/news/access/NewsItem')
const { BAD_WORDS_EXCLUSIONS_CONFIG } = require('@condo/domains/news/constants/badWordsExclusions')
const { SENDING_DELAY_SEC } = require('@condo/domains/news/constants/common')
const {
    EMPTY_VALID_BEFORE_DATE,
    VALIDITY_DATE_LESS_THAN_SEND_DATE,
    EDIT_DENIED_ALREADY_SENT,
    EDIT_DENIED_PUBLISHED,
    PROFANITY_TITLE_DETECTED_MOT_ERF_KER,
    PROFANITY_BODY_DETECTED_MOT_ERF_KER,
    WRONG_SEND_DATE,
    NO_NEWS_ITEM_SCOPES,
} = require('@condo/domains/news/constants/errors')
const { NEWS_TYPES, NEWS_TYPE_EMERGENCY, NEWS_TYPE_COMMON } = require('@condo/domains/news/constants/newsTypes')
const { NewsItemScope } = require('@condo/domains/news/utils/serverSchema')
const { ORGANIZATION_OWNED_FIELD } = require('@condo/domains/organization/schema/fields')


const badWords = new BadWordsNext()
badWords.add(badWordsRu)
badWords.add(badWordsRuLat)
const badWordsExclusions = new BadWordsNext()
badWordsExclusions.add(BAD_WORDS_EXCLUSIONS_CONFIG)

const ERRORS = {
    EMPTY_VALID_BEFORE_DATE: {
        code: BAD_USER_INPUT,
        type: EMPTY_VALID_BEFORE_DATE,
        message: 'The date the news item valid before is empty',
        messageForUser: 'api.newsItem.EMPTY_VALID_BEFORE_DATE',
        mutation: 'createNewsItem',
        variable: ['data', 'validBefore'],
    },
    VALIDITY_DATE_LESS_THAN_SEND_DATE: {
        code: BAD_USER_INPUT,
        type: VALIDITY_DATE_LESS_THAN_SEND_DATE,
        message: 'The validity date is less than send date',
        messageForUser: 'api.newsItem.VALIDITY_DATE_LESS_THAN_SEND_DATE',
        mutation: 'updateNewsItem',
    },
    EDIT_DENIED_ALREADY_SENT: {
        code: BAD_USER_INPUT,
        type: EDIT_DENIED_ALREADY_SENT,
        message: 'The sent news item is restricted from editing',
        messageForUser: 'api.newsItem.EDIT_DENIED_ALREADY_SENT',
        mutation: 'updateNewsItem',
    },
    EDIT_DENIED_PUBLISHED: {
        code: BAD_USER_INPUT,
        type: EDIT_DENIED_PUBLISHED,
        message: 'The published news item is restricted from editing',
        messageForUser: 'api.newsItem.EDIT_DENIED_PUBLISHED',
        mutation: 'updateNewsItem',
    },
    PROFANITY_TITLE_DETECTED_MOT_ERF_KER: {
        code: BAD_USER_INPUT,
        type: PROFANITY_TITLE_DETECTED_MOT_ERF_KER,
        message: 'Profanity in title detected',
        messageForUser: 'api.newsItem.PROFANITY_TITLE_DETECTED_MOT_ERF_KER',
    },
    PROFANITY_BODY_DETECTED_MOT_ERF_KER: {
        code: BAD_USER_INPUT,
        type: PROFANITY_BODY_DETECTED_MOT_ERF_KER,
        message: 'Profanity in body detected',
        messageForUser: 'api.newsItem.PROFANITY_BODY_DETECTED_MOT_ERF_KER',
    },
    WRONG_SEND_DATE: {
        code: BAD_USER_INPUT,
        type: WRONG_SEND_DATE,
        message: 'Wrong send date',
        messageForUser: 'api.newsItem.WRONG_SEND_DATE',
    },
    NO_NEWS_ITEM_SCOPES: {
        code: BAD_USER_INPUT,
        type: NO_NEWS_ITEM_SCOPES,
        message: 'The news item without scopes publishing is forbidden',
        messageForUser: 'api.newsItem.NO_NEWS_ITEM_SCOPES',
    },
}

const COMPACT_SCOPES_SIZE = 2
const readOnlyFieldsWhenPublished = ['organization', 'title', 'body', 'type', 'sendAt']

const NewsItem = new GQLListSchema('NewsItem', {
    schemaDoc: 'The news item created by the organization to show on resident\'s mobile devices',
    labelResolver: ({ title, type }) => `${type === NEWS_TYPE_EMERGENCY ? 'ðŸš¨' : ''} ${title}`,
    fields: {

        organization: ORGANIZATION_OWNED_FIELD,

        number: {
            schemaDoc: 'The news item number',
            type: 'AutoIncrementInteger',
            isRequired: false,
            autoIncrementScopeFields: ['organization'],
        },

        title: {
            schemaDoc: 'The news item title',
            type: 'Text',
            isRequired: true,
        },

        body: {
            schemaDoc: 'The news item main body',
            type: 'Text',
            isRequired: true,
        },

        type: {
            schemaDoc: 'The news item type. The `common` type generates push messages no more than 1 per hour per single user. Also, the resident may disable push messages for this type. The `emergency` type will always be accompanied by a push message and shown at the top of the news list. Also, this type always has a news item validity date.',
            type: 'Select',
            options: NEWS_TYPES,
            isRequired: true,
        },

        validBefore: {
            schemaDoc: 'Date before which the news item makes sense',
            type: 'DateTimeUtc',
        },

        sendAt: {
            schemaDoc: 'UTC (!)' +
                '\nDate to publish the news item and to send notifications.' +
                '\nIf left blank, it will be published immediately.',
            type: 'DateTimeUtc',
        },

        deliverAt: {
            schemaDoc: '(Internal auto-calculated field)' +
                '\nStart time for sending notifications.' +
                '\nThis field is updated when the "isPublished" field is updated.' +
                '\nIf set "isPublished" to false then "deliverAt" set to null.' +
                '\nIf set "isPublished" to true then "deliverAt" depends on the "sendAt" field:' +
                '\n 1) If "sendAt" is empty, then current time + delay of 15 seconds is specified;' +
                '\n 2) If "sendAt" is specified, then the value is taken from it.',
            type: 'DateTimeUtc',
            hooks: {
                resolveInput: async ({ existingItem, resolvedData, fieldName }) => {
                    const newItem = { ...existingItem, ...resolvedData }
                    const prevIsPublished = get(existingItem, 'isPublished', false)
                    const sendAt = get(newItem, 'sendAt', null)
                    const isPublished = get(newItem, 'isPublished', false)
                    const updatedIsPublished = prevIsPublished !== isPublished

                    if (!updatedIsPublished) return get(resolvedData, fieldName)
                    if (!isPublished) return null
                    if (!sendAt) return dayjs().add(SENDING_DELAY_SEC, 'second').toISOString()
                    return sendAt
                },
            },
            access: {
                read: true,
                create: false,
                update: false,
            },
        },

        scopes: {
            type: 'Relationship',
            ref: 'NewsItemScope.newsItem',
            many: true,
            access: {
                read: ({ authentication: { item: user } }) => (user.isAdmin || user.isSupport),
                create: false,
                update: false,
            },
        },

        compactScopes: {
            schemaDoc: 'Returns the number of scopes that are specified for sending the news, and also the first two of them.\n' +
                'Used to reduce requests for get of scopes in the UI',
            type: 'Virtual',
            extendGraphQLTypes: ['type ShortScopesField { count: Int!, firstOnes: [NewsItemScope]! }'],
            graphQLReturnType: 'ShortScopesField',
            resolver: async (item) => {
                const firstOnesScopes = await itemsQuery('NewsItemScope', {
                    where: {
                        newsItem: { id: item.id }, deletedAt: null,
                    },
                    first: COMPACT_SCOPES_SIZE + 1,
                    orderBy: 'createdAt_ASC',
                })

                let count = 0
                if (firstOnesScopes.length > COMPACT_SCOPES_SIZE) {
                    const { count: countObjs } = await itemsQuery('NewsItemScope', {
                        where: {
                            newsItem: { id: item.id }, deletedAt: null,
                        },
                    }, { meta: true })
                    count = countObjs
                } else {
                    count = firstOnesScopes.length
                }

                return {
                    count,
                    firstOnes: firstOnesScopes.slice(0, COMPACT_SCOPES_SIZE),
                }
            },
        },

        sentAt: {
            schemaDoc: 'The date when newsItem was sent to residents.' +
                ' This is an internal field used to detect was the message has already been sent or not.',
            type: 'DateTimeUtc',
            access: {
                read: true,
                create: canOnlyServerSideWithoutUserRequest,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        isPublished: {
            schemaDoc: 'Shows if the news item is ready to be shown and send to residents',
            type: 'Checkbox',
            defaultValue: false,
        },

        publishedAt: {
            schemaDoc: 'The date when the news item was published. It is an auto-Calculated field.',
            type: 'DateTimeUtc',
            hooks: {
                resolveInput: ({ resolvedData, fieldPath }) => (
                    resolvedData['isPublished'] ? dayjs().toISOString() : resolvedData[fieldPath]
                ),
            },
            access: {
                read: true,
                create: false,
                update: false,
            },
        },

    },
    hooks: {
        resolveInput: async (args) => {
            const { resolvedData, existingItem } = args
            const resultItemData = { ...existingItem, ...resolvedData }

            if (!get(resultItemData, 'type')) {
                resolvedData['type'] = NEWS_TYPE_COMMON
            }

            return resolvedData
        },
        validateInput: async (args) => {
            const { resolvedData, existingItem, context, operation } = args
            const resultItemData = { ...existingItem, ...resolvedData }

            const sendAt = get(resolvedData, 'sendAt')
            const sentAt = get(existingItem, 'sentAt')
            const resultSendAt = get(resultItemData, 'sendAt')
            const resultValidBefore = get(resultItemData, 'validBefore')
            const isPublished = get(existingItem, 'isPublished')
            const type = get(resultItemData, 'type')
            const resolvedIsPublished = get(resolvedData, 'isPublished')

            if (resolvedIsPublished) {
                const scopesCount = existingItem ? await NewsItemScope.count(context, { newsItem: { id: existingItem.id } }) : 0
                if (scopesCount === 0) {
                    throw new GQLError(ERRORS.NO_NEWS_ITEM_SCOPES, context)
                }
            }

            if (operation === 'update') {
                if (sentAt) {
                    throw new GQLError(ERRORS.EDIT_DENIED_ALREADY_SENT, context)
                }
                if (isPublished) {
                    for (const readOnlyField of readOnlyFieldsWhenPublished) {
                        if (!isEmpty(get(resolvedData, readOnlyField))) {
                            throw new GQLError(ERRORS.EDIT_DENIED_PUBLISHED, context)
                        }
                    }
                }
            }

            if (type === NEWS_TYPE_EMERGENCY && !resultValidBefore) {
                throw new GQLError(ERRORS.EMPTY_VALID_BEFORE_DATE, context)
            }

            if (!!sendAt && Date.parse(sendAt) < Date.parse(dayjs())) {
                throw new GQLError(ERRORS.WRONG_SEND_DATE, context)
            }

            if (!!resultSendAt && !!resultValidBefore && Date.parse(resultValidBefore) < Date.parse(resultSendAt)) {
                throw new GQLError(ERRORS.VALIDITY_DATE_LESS_THAN_SEND_DATE, context)
            }

            const titleBadWords = []
            const nextTitle = get(resolvedData, 'title')
            if (nextTitle) {
                badWords.filter(nextTitle, (badWord) => {
                    if (badWordsExclusions.check(badWord)) return
                    titleBadWords.push(badWord)
                })
            }

            const bodyBadWords = []
            const nextBody = get(resolvedData, 'body')
            if (nextBody) {
                badWords.filter(nextBody, (badWord) => {
                    if (badWordsExclusions.check(badWord)) return
                    bodyBadWords.push(badWord)
                })
            }

            if (titleBadWords.length > 0) {
                throw new GQLError({
                    ...ERRORS.PROFANITY_TITLE_DETECTED_MOT_ERF_KER,
                    badWords: [...titleBadWords].join(','),
                }, context)
            }
            if (bodyBadWords.length > 0) {
                throw new GQLError({
                    ...ERRORS.PROFANITY_BODY_DETECTED_MOT_ERF_KER,
                    badWords: [...bodyBadWords].join(','),
                }, context)
            }
        },

        afterChange: async ({ updatedItem }) => {
            if (
                updatedItem.isPublished
                && !updatedItem.sendAt // There is a cron task to send delayed news items
                && !updatedItem.sentAt
            ) {
                // Publish connected NewsItemSharing items
                // Todo: @toplenboren (DOMA-7887) turn this on when one of miniapps is ready
                // await publishSharedNewsItemsByNewsItem.delay(updatedItem.id)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadNewsItems,
        create: access.canManageNewsItems,
        update: access.canManageNewsItems,
        delete: false,
        auth: true,
    },
})

module.exports = {
    NewsItem,
}
