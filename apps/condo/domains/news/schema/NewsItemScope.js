/**
 * Generated by `createschema news.NewsItemScope 'newsItem:Relationship:NewsItem:CASCADE; property:Relationship:Property:CASCADE; unitType:Select:get,from,constant,unit_types; unitName:Text'`
 */
const get = require('lodash/get')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/news/access/NewsItemScope')
const {
    EDIT_DENIED_ALREADY_SENT,
    EDIT_DENIED_PUBLISHED,
    EMPTY_NEWS_ITEM_SCOPE,
    UNIT_NAME_WITHOUT_UNIT_TYPE,
} = require('@condo/domains/news/constants/errors')
const { UNIT_TYPES } = require('@condo/domains/property/constants/common')

const ERRORS = {
    EDIT_DENIED_PUBLISHED: {
        code: BAD_USER_INPUT,
        type: EDIT_DENIED_PUBLISHED,
        message: 'The published news item is restricted from editing',
        messageForUser: 'api.newsItem.EDIT_DENIED_PUBLISHED',
    },
    EDIT_DENIED_ALREADY_SENT: {
        code: BAD_USER_INPUT,
        type: EDIT_DENIED_ALREADY_SENT,
        message: 'The sent news item is restricted from editing',
        messageForUser: 'api.newsItem.EDIT_DENIED_ALREADY_SENT',
    },
    EMPTY_NEWS_ITEM_SCOPE: {
        code: BAD_USER_INPUT,
        type: EMPTY_NEWS_ITEM_SCOPE,
        message: 'News item scope is empty',
        messageForUser: 'api.newsItem.EMPTY_NEWS_ITEM_SCOPE',
    },
    UNIT_NAME_WITHOUT_UNIT_TYPE: {
        code: BAD_USER_INPUT,
        type: UNIT_NAME_WITHOUT_UNIT_TYPE,
        message: 'You set unitName without unitType',
        messageForUser: 'api.newsItem.UNIT_NAME_WITHOUT_UNIT_TYPE',
    },
}

const NewsItemScope = new GQLListSchema('NewsItemScope', {
    schemaDoc: 'Which residents can see the particular news item',
    fields: {

        newsItem: {
            schemaDoc: 'The news item to control access for',
            type: 'Relationship',
            ref: 'NewsItem.scopes',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },

        property: {
            schemaDoc: 'Filter on Resident by property, who can read news',
            type: 'Relationship',
            ref: 'Property',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },

        unitType: {
            schemaDoc: 'Filter on Resident by unit type, who can read news',
            type: 'Select',
            options: UNIT_TYPES,
        },

        unitName: {
            schemaDoc: 'Filter on Resident by unit name, who can read news. Because in case when a Property will have several units of different types, NewsItem can go to wrong recipients. In practice, when an organization needs to address specific residents it is usually assumed, that they are from units of some specific type, for example, a flat. Without this restriction, a NewsItem, targeted only to unitName 1 can potentially be received by residents of flat 1, parking 1 etc.',
            type: 'Text',
        },

    },
    hooks: {
        validateInput: async (args) => {
            const { resolvedData, existingItem, context, operation } = args
            const possibleItemData = { ...existingItem, ...resolvedData }

            if (!get(possibleItemData, 'property') && !get(possibleItemData, 'unitType') && !get(possibleItemData, 'unitName')) {
                throw new GQLError(ERRORS.EMPTY_NEWS_ITEM_SCOPE, context)
            }

            if (get(possibleItemData, 'unitName') && !get(possibleItemData, 'unitType')) {
                throw new GQLError(ERRORS.UNIT_NAME_WITHOUT_UNIT_TYPE, context)
            }

            let newsItemId
            if (operation === 'create') {
                newsItemId = get(resolvedData, 'newsItem')
            } else if (operation === 'update') {
                newsItemId = get(existingItem, 'id')
            }

            /** @type {null|NewsItem} */
            const newsItem = await getById('NewsItem', newsItemId)

            if (!!newsItem && newsItem.sentAt) {
                throw new GQLError(ERRORS.EDIT_DENIED_ALREADY_SENT, context)
            }

            if (!!newsItem && newsItem.isPublished) {
                throw new GQLError(ERRORS.EDIT_DENIED_PUBLISHED, context)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadNewsItemScopes,
        create: access.canManageNewsItemScopes,
        update: access.canManageNewsItemScopes,
        delete: false,
        auth: true,
    },
})

module.exports = {
    NewsItemScope,
}
