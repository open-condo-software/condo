/**
 * Generated by `createschema news.NewsItemScope 'newsItem:Relationship:NewsItem:CASCADE; property:Relationship:Property:CASCADE; unitType:Select:get,from,constant,unit_types; unitName:Text'`
 */
const get = require('lodash/get')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/news/access/NewsItemScope')
const { EDIT_DENIED_ALREADY_SENT, EDIT_DENIED_PUBLISHED } = require('@condo/domains/news/constants/errors')
const {
    NEWS_ITEMS_SCOPES_TYPES,
    NEWS_ITEM_SCOPE_TYPE_ORGANIZATION,
    NEWS_ITEM_SCOPE_TYPE_PROPERTY,
    NEWS_ITEM_SCOPE_TYPE_PROPERTY_UNIT_TYPE,
    NEWS_ITEM_SCOPE_TYPE_PROPERTY_UNIT_TYPE_UNIT_NAME,
} = require('@condo/domains/news/constants/scopesTypes')
const { UNIT_TYPES } = require('@condo/domains/property/constants/common')

const ERRORS = {
    EDIT_DENIED_PUBLISHED: {
        code: BAD_USER_INPUT,
        type: EDIT_DENIED_PUBLISHED,
        message: 'The published news item is restricted from editing',
        messageForUser: 'api.newsItem.EDIT_DENIED_PUBLISHED',
    },
    EDIT_DENIED_ALREADY_SENT: {
        code: BAD_USER_INPUT,
        type: EDIT_DENIED_ALREADY_SENT,
        message: 'The sent news item is restricted from editing',
        messageForUser: 'api.newsItem.EDIT_DENIED_ALREADY_SENT',
    },
}

const NewsItemScope = new GQLListSchema('NewsItemScope', {
    schemaDoc: 'Which residents can see the particular news item',
    fields: {

        type: {
            schemaDoc: 'The scope type. This is an auto-calculated field. Used to find news items by scopes filled with some set of attributes.',
            type: 'Select',
            options: NEWS_ITEMS_SCOPES_TYPES,
            isRequired: true,
            access: {
                read: true,
                create: false,
                update: false,
            },
            hooks: {
                resolveInput: async ({ operation, resolvedData, fieldPath }) => {
                    if (operation === 'create') {
                        let type
                        const { property, unitType, unitName } = resolvedData

                        if (!property && !unitType && !unitName) {
                            type = NEWS_ITEM_SCOPE_TYPE_ORGANIZATION
                        } else if (!!property && !unitType && !unitName) {
                            type = NEWS_ITEM_SCOPE_TYPE_PROPERTY
                        } else if (!!property && !!unitType && !unitName) {
                            type = NEWS_ITEM_SCOPE_TYPE_PROPERTY_UNIT_TYPE
                        } else if (!!property && !!unitType && !!unitName) {
                            type = NEWS_ITEM_SCOPE_TYPE_PROPERTY_UNIT_TYPE_UNIT_NAME
                        }

                        if (type) {
                            return type
                        }

                        return null
                    }

                    return resolvedData[fieldPath]
                },
            },
        },

        newsItem: {
            schemaDoc: 'The news item to control access for',
            type: 'Relationship',
            ref: 'NewsItem.scopes',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },

        property: {
            schemaDoc: 'Filter on Resident by property, who can read news',
            type: 'Relationship',
            ref: 'Property',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },

        unitType: {
            schemaDoc: 'Filter on Resident by unit type, who can read news',
            type: 'Select',
            options: UNIT_TYPES,
        },

        unitName: {
            schemaDoc: 'Filter on Resident by unit name, who can read news. Because in case when a Property will have several units of different types, NewsItem can go to wrong recipients. In practice, when an organization needs to address specific residents it is usually assumed, that they are from units of some specific type, for example, a flat. Without this restriction, a NewsItem, targeted only to unitName 1 can potentially be received by residents of flat 1, parking 1 etc.',
            type: 'Text',
        },

    },
    hooks: {
        validateInput: async (args) => {
            const { resolvedData, existingItem, context, operation } = args

            let newsItemId
            if (operation === 'create') {
                newsItemId = get(resolvedData, 'newsItem')
            } else if (operation === 'update') {
                newsItemId = get(existingItem, 'id')
            }

            /** @type {null|NewsItem} */
            const newsItem = await getById('NewsItem', newsItemId)

            if (!!newsItem && newsItem.sentAt) {
                throw new GQLError(ERRORS.EDIT_DENIED_ALREADY_SENT, context)
            }

            if (!!newsItem && newsItem.isPublished) {
                throw new GQLError(ERRORS.EDIT_DENIED_PUBLISHED, context)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadNewsItemScopes,
        create: access.canManageNewsItemScopes,
        update: access.canManageNewsItemScopes,
        delete: false,
        auth: true,
    },
})

module.exports = {
    NewsItemScope,
}
