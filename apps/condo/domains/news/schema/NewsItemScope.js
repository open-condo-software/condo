/**
 * Generated by `createschema news.NewsItemScope 'newsItem:Relationship:NewsItem:CASCADE; property:Relationship:Property:CASCADE; unitType:Select:get,from,constant,unit_types; unitName:Text'`
 */
const get = require('lodash/get')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById, getByCondition } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/news/access/NewsItemScope')
const { EDIT_DENIED_ALREADY_SENT, EDIT_DENIED_PUBLISHED, NEWS_ITEM_NOT_FOUND } = require('@condo/domains/news/constants/errors')
const {
    NEWS_ITEMS_SCOPES_TYPES,
    NEWS_ITEM_SCOPE_TYPE_ORGANIZATION,
    NEWS_ITEM_SCOPE_TYPE_PROPERTY,
    NEWS_ITEM_SCOPE_TYPE_PROPERTY_UNIT_TYPE,
    NEWS_ITEM_SCOPE_TYPE_PROPERTY_UNIT_TYPE_UNIT_NAME,
} = require('@condo/domains/news/constants/scopesTypes')
const { ORGANIZATION_OWNED_FIELD } = require('@condo/domains/organization/schema/fields')
const { UNIT_TYPES } = require('@condo/domains/property/constants/common')


const ERRORS = {
    EDIT_DENIED_PUBLISHED: {
        code: BAD_USER_INPUT,
        type: EDIT_DENIED_PUBLISHED,
        message: 'The published news item is restricted from editing',
        messageForUser: 'api.newsItem.EDIT_DENIED_PUBLISHED',
    },
    EDIT_DENIED_ALREADY_SENT: {
        code: BAD_USER_INPUT,
        type: EDIT_DENIED_ALREADY_SENT,
        message: 'The sent news item is restricted from editing',
        messageForUser: 'api.newsItem.EDIT_DENIED_ALREADY_SENT',
    },
    NEWS_ITEM_NOT_FOUND: {
        code: BAD_USER_INPUT,
        variable: ['data', 'newsItem'],
        type: NEWS_ITEM_NOT_FOUND,
        message: 'There is no such newsItem in the specified organization',
        messageForUser: 'api.newsItem.NEWS_ITEM_NOT_FOUND',
    },
}

const NewsItemScope = new GQLListSchema('NewsItemScope', {
    schemaDoc: 'Which residents can see the particular news item',
    fields: {

        organization: ORGANIZATION_OWNED_FIELD,

        type: {
            schemaDoc: 'The scope type. This is an auto-calculated field. Used to find news items by scopes filled with some set of attributes.',
            type: 'Select',
            options: NEWS_ITEMS_SCOPES_TYPES,
            isRequired: true,
            access: {
                read: true,
                create: false,
                update: false,
            },
            hooks: {
                resolveInput: async ({ operation, resolvedData, fieldPath }) => {
                    if (operation === 'create') {
                        let type
                        const { property, unitType, unitName } = resolvedData

                        if (!property && !unitType && !unitName) {
                            type = NEWS_ITEM_SCOPE_TYPE_ORGANIZATION
                        } else if (!!property && !unitType && !unitName) {
                            type = NEWS_ITEM_SCOPE_TYPE_PROPERTY
                        } else if (!!property && !!unitType && !unitName) {
                            type = NEWS_ITEM_SCOPE_TYPE_PROPERTY_UNIT_TYPE
                        } else if (!!property && !!unitType && !!unitName) {
                            type = NEWS_ITEM_SCOPE_TYPE_PROPERTY_UNIT_TYPE_UNIT_NAME
                        }

                        if (type) {
                            return type
                        }

                        return null
                    }

                    return resolvedData[fieldPath]
                },
            },
        },

        newsItem: {
            schemaDoc: 'The news item to control access for',
            type: 'Relationship',
            ref: 'NewsItem.scopes',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            hooks: {
                validateInput: async ({ resolvedData, fieldPath, existingItem, context }) => {
                    const newItem = { ...existingItem, ...resolvedData }
                    const newsItemId = newItem[fieldPath]
                    const organizationId = newItem.organization

                    if (newsItemId) {
                        const newsItem = await getByCondition('NewsItem', {
                            id: newsItemId,
                            deletedAt: null,
                        })

                        if (organizationId !== newsItem.organization) {
                            throw new GQLError(ERRORS.NEWS_ITEM_NOT_FOUND, context)
                        }
                    }
                },
            },
        },

        property: {
            schemaDoc: 'Filter on Resident by property, who can read news',
            type: 'Relationship',
            ref: 'Property',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },

        unitType: {
            schemaDoc: 'Filter on Resident by unit type, who can read news',
            type: 'Select',
            options: UNIT_TYPES,
        },

        unitName: {
            schemaDoc: 'Filter on Resident by unit name, who can read news. Because in case when a Property will have several units of different types, NewsItem can go to wrong recipients. In practice, when an organization needs to address specific residents it is usually assumed, that they are from units of some specific type, for example, a flat. Without this restriction, a NewsItem, targeted only to unitName 1 can potentially be received by residents of flat 1, parking 1 etc.',
            type: 'Text',
        },

    },
    hooks: {
        validateInput: async (args) => {
            const { resolvedData, existingItem, context, operation } = args

            let newsItemId
            if (operation === 'create') {
                newsItemId = get(resolvedData, 'newsItem')
            } else if (operation === 'update') {
                newsItemId = get(existingItem, 'id')
            }

            /** @type {null|NewsItem} */
            const newsItem = await getById('NewsItem', newsItemId)

            if (!!newsItem && newsItem.sentAt) {
                throw new GQLError(ERRORS.EDIT_DENIED_ALREADY_SENT, context)
            }

            if (!!newsItem && newsItem.isPublished) {
                throw new GQLError(ERRORS.EDIT_DENIED_PUBLISHED, context)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadNewsItemScopes,
        create: access.canManageNewsItemScopes,
        update: access.canManageNewsItemScopes,
        delete: false,
        auth: true,
    },
})

module.exports = {
    NewsItemScope,
}
