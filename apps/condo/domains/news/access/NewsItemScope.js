/**
 * Generated by `createschema news.NewsItemScope 'newsItem:Relationship:NewsItem:CASCADE; property:Relationship:Property:CASCADE; unitType:Select:get,from,constant,unit_types; unitName:Text'`
 */

const { uniq, get } = require('lodash')

const { isSoftDelete } = require('@open-condo/keystone/access')
const { throwAuthenticationError } = require('@open-condo/keystone/apolloErrorFormatter')
const { find } = require('@open-condo/keystone/schema')

const {
    getEmployedOrRelatedOrganizationsByPermissions,
    checkPermissionsInEmployedOrRelatedOrganizations,
} = require('@condo/domains/organization/utils/accessSchema')
const { STAFF, RESIDENT } = require('@condo/domains/user/constants/common')

async function canReadNewsItemScopes (attrs) {
    const { authentication: { item: user }, context } = attrs
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false
    if (user.isAdmin || user.isSupport) return {}
    if (user.type === RESIDENT) return false

    const permittedOrganizations = await getEmployedOrRelatedOrganizationsByPermissions(context, user, 'canReadNewsItems')

    // access for stuff
    return {
        newsItem: {
            organization: {
                id_in: permittedOrganizations,
            },
        },
    }
}

async function canManageNewsItemScopes ({ authentication: { item: user }, context, originalInput, operation, itemId, itemIds }) {
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false

    const isBulkRequest = Array.isArray(originalInput)
    const isSoftDeleteOperation = operation === 'update'
        && (
            isBulkRequest
                ? (Array.isArray(itemIds) && originalInput.every(item => isSoftDelete(get(item, 'data'))))
                : (itemId && isSoftDelete(originalInput))
        )

    if (operation !== 'create' && !isSoftDeleteOperation) return false
    if (user.isAdmin) return true

    if (user.type === STAFF) {
        let organizationIds

        if (operation === 'create') {
            let newsItemIds = []
            if (isBulkRequest) {
                newsItemIds = originalInput.map(item => get(item, 'data.newsItem.connect.id')).filter(Boolean)
                if (newsItemIds.length !== originalInput.length) return false
                newsItemIds = uniq(newsItemIds)
            } else {
                const newsItemId = get(originalInput, 'newsItem.connect.id')
                if (!newsItemId) return false
                newsItemIds = [newsItemId]
            }

            const newsItems = await find('NewsItem', {
                id_in: newsItemIds,
                deletedAt: null,
                organization_is_null: false,
            })
            if (newsItemIds.length !== newsItems.length) return false
            organizationIds = newsItems.map(item => item.organization)

        } else if (isSoftDeleteOperation) {
            const ids = itemIds || [itemId]
            if (ids.length !== uniq(ids).length) return false

            const newsItems = await find('NewsItem', {
                scopes_some: {
                    id_in: ids,
                    deletedAt: null,
                },
                deletedAt: null,
            })

            if (newsItems.length !== ids.length) return false

            if (newsItems.some(item => !item.organization)) return false
            organizationIds = uniq(newsItems.map(newsItem => newsItem.organization))
        }

        return await checkPermissionsInEmployedOrRelatedOrganizations(context, user, organizationIds, 'canManageNewsItems')
    }

    return false
}

/*
  Rules are logical functions that used for list access, and may return a boolean (meaning
  all or no items are available) or a set of filters that limit the available items.
*/
module.exports = {
    canReadNewsItemScopes,
    canManageNewsItemScopes,
}
