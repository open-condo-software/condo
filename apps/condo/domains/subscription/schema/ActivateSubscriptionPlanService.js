/**
 * Generated by `createservice subscription.ActivateSubscriptionPlanService --type mutations`
 */

const dayjs = require('dayjs')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find, getById } = require('@open-condo/keystone/schema')


const { ACTIVATE_SUBSCRIPTION_TYPE } = require('@condo/domains/onboarding/constants/userHelpRequest')
const { UserHelpRequest } = require('@condo/domains/onboarding/utils/serverSchema')
const { Organization } = require('@condo/domains/organization/utils/serverSchema')
const access = require('@condo/domains/subscription/access/ActivateSubscriptionPlanService')
const { PERIOD_TO_MONTHS } = require('@condo/domains/subscription/constants')
const { SubscriptionContext } = require('@condo/domains/subscription/utils/serverSchema')
const { canDirectlyExecuteService } = require('@condo/domains/user/utils/directAccess')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    ORGANIZATION_NOT_FOUND: {
        mutation: 'activateSubscriptionPlan',
        variable: ['data', 'organization'],
        code: BAD_USER_INPUT,
        type: 'ORGANIZATION_NOT_FOUND',
        message: 'Organization not found',
    },
    PRICING_RULE_NOT_FOUND: {
        mutation: 'activateSubscriptionPlan',
        variable: ['data', 'pricingRule'],
        code: BAD_USER_INPUT,
        type: 'PRICING_RULE_NOT_FOUND',
        message: 'Pricing rule not found or inactive',
    },
    INVALID_ORGANIZATION_TYPE: {
        mutation: 'activateSubscriptionPlan',
        variable: ['data', 'organization'],
        code: BAD_USER_INPUT,
        type: 'INVALID_ORGANIZATION_TYPE',
        message: 'Plan is not available for this organization type',
    },
    TRIAL_ALREADY_USED: {
        mutation: 'activateSubscriptionPlan',
        variable: ['data', 'pricingRule'],
        code: BAD_USER_INPUT,
        type: 'TRIAL_ALREADY_USED',
        message: 'Trial subscription for this plan has already been used',
    },
    TRIAL_NOT_AVAILABLE: {
        mutation: 'activateSubscriptionPlan',
        variable: ['data', 'pricingRule'],
        code: BAD_USER_INPUT,
        type: 'TRIAL_NOT_AVAILABLE',
        message: 'Trial is not available for this subscription plan',
    },
}

const ActivateSubscriptionPlanService = new GQLCustomSchema('ActivateSubscriptionPlanService', {
    types: [
        {
            access: true,
            type: 'input PaymentMethodInput { id: String!, type: String!, cardMask: String, cardType: String, title: String, cardIssuerCountry: String, cardIssuerName: String }',
        },
        {
            access: true,
            type: 'input ActivateSubscriptionPlanInput { dv: Int!, sender: SenderFieldInput!, organization: OrganizationWhereUniqueInput!, pricingRule: SubscriptionPlanPricingRuleWhereUniqueInput!, isTrial: Boolean, paymentMethod: PaymentMethodInput, paymentId: String }',
        },
        {
            access: true,
            type: 'type ActivateSubscriptionPlanOutput { subscriptionContext: SubscriptionContext, userHelpRequest: UserHelpRequest }',
        },
    ],

    mutations: [
        {
            access: access.canActivateSubscriptionPlan,
            schema: 'activateSubscriptionPlan(data: ActivateSubscriptionPlanInput!): ActivateSubscriptionPlanOutput',
            doc: {
                summary: 'Activates a subscription plan for an organization. For trial subscriptions (isTrial=true), creates SubscriptionContext. For paid subscriptions (isTrial=false), creates UserHelpRequest for manual processing.',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { dv, sender, organization: organizationInput, pricingRule: pricingRuleInput, isTrial, paymentMethod, paymentId } = data

                const [organization] = await find('Organization', {
                    id: organizationInput.id,
                    deletedAt: null,
                })
                if (!organization) {
                    throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)
                }

                const [pricingRule] = await find('SubscriptionPlanPricingRule', {
                    id: pricingRuleInput.id,
                    isHidden: false,
                    deletedAt: null,
                })
                if (!pricingRule) {
                    throw new GQLError(ERRORS.PRICING_RULE_NOT_FOUND, context)
                }

                const plan = await getById('SubscriptionPlan', pricingRule.subscriptionPlan)
                if (!plan || plan.isHidden || plan.deletedAt) {
                    throw new GQLError(ERRORS.PRICING_RULE_NOT_FOUND, context)
                }

                if (plan.organizationType && plan.organizationType !== organization.type) {
                    throw new GQLError(ERRORS.INVALID_ORGANIZATION_TYPE, context)
                }

                const user = await getById('User', context.authedItem.id)
                const hasDirectAccess = await canDirectlyExecuteService(user, 'activateSubscriptionPlan')
                
                if (!isTrial) {
                    if (hasDirectAccess) {
                        const months = PERIOD_TO_MONTHS[pricingRule.period]
                        if (!months) {
                            throw new GQLError(ERRORS.PRICING_RULE_NOT_FOUND, context)
                        }
                        
                        const startAt = dayjs()
                        const endAt = startAt.add(months, 'month')
                        const createdSubscriptionContext = await SubscriptionContext.create(context, {
                            dv,
                            sender,
                            organization: { connect: { id: organization.id } },
                            subscriptionPlan: { connect: { id: plan.id } },
                            startAt: startAt.format('YYYY-MM-DD'),
                            endAt: endAt.format('YYYY-MM-DD'),
                            basePrice: pricingRule.price,
                            isTrial: false,
                            meta: {
                                price: pricingRule.price,
                                pricingRuleId: pricingRule.id,
                                paymentMethod,
                                paymentId,
                            },
                        })

                        // TODO(DOMA-12895): Move payment methods from Organization.meta to separate model
                        if (paymentMethod) {
                            const existingPaymentMethods = organization.meta?.paymentMethods || []
                            const paymentMethodExists = existingPaymentMethods.some(
                                pm => pm.id === paymentMethod.id
                            )
                            
                            if (!paymentMethodExists) {
                                await Organization.update(context, organization.id, {
                                    dv,
                                    sender,
                                    meta: {
                                        ...organization.meta,
                                        paymentMethods: [
                                            ...existingPaymentMethods,
                                            paymentMethod,
                                        ],
                                    },
                                })
                            }
                        }
                        
                        const subscriptionContext = await getById('SubscriptionContext', createdSubscriptionContext.id)
                        return { subscriptionContext, userHelpRequest: null }
                    }
                    
                    const createdHelpRequest = await UserHelpRequest.create(context, {
                        dv,
                        sender,
                        type: ACTIVATE_SUBSCRIPTION_TYPE,
                        organization: { connect: { id: organization.id } },
                        subscriptionPlanPricingRule: { connect: { id: pricingRule.id } },
                        phone: user.phone,
                    })
                    const userHelpRequest = await getById('UserHelpRequest', createdHelpRequest.id)
                    return { subscriptionContext: null, userHelpRequest }
                }

                if (plan.trialDays <= 0) {
                    throw new GQLError(ERRORS.TRIAL_NOT_AVAILABLE, context)
                }

                const [existingTrial] = await find('SubscriptionContext', {
                    organization: { id: organization.id },
                    subscriptionPlan: { id: plan.id },
                    isTrial: true,
                    deletedAt: null,
                })
                if (existingTrial) {
                    throw new GQLError(ERRORS.TRIAL_ALREADY_USED, context)
                }

                const startAt = dayjs()
                const endAt = startAt.add(plan.trialDays, 'day')
                const createdSubscriptionContext = await SubscriptionContext.create(context, {
                    dv,
                    sender,
                    organization: { connect: { id: organization.id } },
                    subscriptionPlan: { connect: { id: plan.id } },
                    startAt: startAt.format('YYYY-MM-DD'),
                    endAt: endAt.format('YYYY-MM-DD'),
                    isTrial: true,
                })
                const subscriptionContext = await getById('SubscriptionContext', createdSubscriptionContext.id)

                return { subscriptionContext, userHelpRequest: null }
            },
        },
    ],
})

module.exports = {
    ActivateSubscriptionPlanService,
    ERRORS,
}
