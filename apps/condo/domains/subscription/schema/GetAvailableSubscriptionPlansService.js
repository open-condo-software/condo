/**
 * Generated by `createservice subscription.GetAvailableSubscriptionPlansService --type queries`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/subscription/access/GetAvailableSubscriptionPlansService')
const { SUBSCRIPTION_PERIODS } = require('@condo/domains/subscription/constants')
const { findMatchingPricingRule } = require('@condo/domains/subscription/utils/findMatchingPricingRule')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    ORGANIZATION_NOT_FOUND: {
        query: 'getAvailableSubscriptionPlans',
        variable: ['organization'],
        code: BAD_USER_INPUT,
        type: 'ORGANIZATION_NOT_FOUND',
        message: 'Organization not found',
    },
}

const GetAvailableSubscriptionPlansService = new GQLCustomSchema('GetAvailableSubscriptionPlansService', {
    types: [
        {
            access: true,
            type: 'type SubscriptionPlanPrice { id: ID!, period: String!, price: String, currencyCode: String }',
        },
        {
            access: true,
            type: 'type AvailableSubscriptionPlan { plan: SubscriptionPlan!, prices: [SubscriptionPlanPrice!]! }',
        },
        {
            access: true,
            type: 'type GetAvailableSubscriptionPlansOutput { plans: [AvailableSubscriptionPlan]! }',
        },
    ],

    queries: [
        {
            access: access.canGetAvailableSubscriptionPlans,
            schema: 'getAvailableSubscriptionPlans(organization: OrganizationWhereUniqueInput!): GetAvailableSubscriptionPlansOutput',
            doc: {
                summary: 'Returns available subscription plans with calculated prices for the organization based on pricing rules and conditions.',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { organization: organizationInput } = args

                const [organization] = await find('Organization', {
                    id: organizationInput.id,
                    deletedAt: null,
                })
                if (!organization) {
                    throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)
                }

                const plans = await find('SubscriptionPlan', {
                    isHidden: false,
                    organizationType: organization.type,
                    deletedAt: null,
                })

                const result = []

                for (const plan of plans) {
                    const prices = []
                    for (const period of SUBSCRIPTION_PERIODS) {
                        const priceData = await findMatchingPricingRule(plan.id, period, organization)
                        if (priceData) {
                            prices.push({
                                id: priceData.ruleId,
                                period,
                                price: priceData.finalPrice,
                                currencyCode: priceData.currencyCode,
                            })
                        }
                    }

                    result.push({ plan, prices })
                }

                return { plans: result }
            },
        },
    ],
})

module.exports = {
    GetAvailableSubscriptionPlansService,
    ERRORS,
}
