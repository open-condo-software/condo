/**
 * Generated by `createschema subscription.SubscriptionContext 'organization:Relationship:Organization:CASCADE; subscriptionPlan:Relationship:SubscriptionPlan:PROTECT; startAt:DateTimeUtc; endAt:DateTimeUtc; basePrice:Decimal; calculatedPrice:Decimal; appliedRules:Json; isTrial:Checkbox;'`
 */

const dayjs = require('dayjs')

const { makeLoggedInAdminClient, makeClient, UUID_RE, expectToThrowGQLError, catchErrorFrom } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { HOLDING_TYPE } = require('@condo/domains/organization/constants/common')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema')
const {
    SubscriptionContext,
    SubscriptionPlan,
    createTestSubscriptionContext,
    updateTestSubscriptionContext,
    createTestSubscriptionPlan,
    updateTestSubscriptionPlan,
} = require('@condo/domains/subscription/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

describe('SubscriptionContext', () => {
    let admin, support
    let organization, subscriptionPlan

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()

        const plans = await SubscriptionPlan.getAll(admin, {
            isHidden: false,
            deletedAt: null,
        })
        for (const plan of plans) {
            await updateTestSubscriptionPlan(admin, plan.id, { deletedAt: new Date() })
        }

        const [plan] = await createTestSubscriptionPlan(admin, {
            name: 'Test Plan for SubscriptionContext',
            organizationType: HOLDING_TYPE,
            isHidden: false,
        })
        subscriptionPlan = plan
    })

    afterAll(async () => {
        const plans = await SubscriptionPlan.getAll(admin, {
            isHidden: false,
            deletedAt: null,
        })
        for (const plan of plans) {
            await updateTestSubscriptionPlan(admin, plan.id, { deletedAt: new Date() })
        }
    })

    beforeEach(async () => {
        const user = await makeClientWithNewRegisteredAndLoggedInUser()
        const [org] = await registerNewOrganization(user, { type: HOLDING_TYPE })
        organization = org
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can create trial subscription without prices', async () => {
                const startAt = dayjs().toISOString()
                const endAt = dayjs().add(14, 'day').toISOString()

                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: true,
                })

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.isTrial).toBe(true)
                expect(obj.basePrice).toBeNull()
                expect(obj.calculatedPrice).toBeNull()
            })

            test('admin can create non-trial subscription without prices', async () => {
                const startAt = dayjs().toISOString()
                const endAt = dayjs().add(30, 'day').toISOString()

                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: false,
                })

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.isTrial).toBe(false)
            })

            test('support can create subscription without prices', async () => {
                const startAt = dayjs().toISOString()
                const endAt = dayjs().add(30, 'day').toISOString()

                const [obj] = await createTestSubscriptionContext(support, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: false,
                })

                expect(obj.id).toMatch(UUID_RE)
            })

            test('anonymous cannot create', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestSubscriptionContext(client, organization, subscriptionPlan, {
                        startAt: dayjs().toISOString(),
                        endAt: dayjs().add(14, 'day').toISOString(),
                        isTrial: true,
                    })
                })
            })
        })

        describe('update', () => {
            test('admin can update endAt', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const newEndAt = dayjs().add(30, 'day').toISOString()
                const [obj] = await updateTestSubscriptionContext(admin, objCreated.id, { endAt: newEndAt })

                expect(obj.endAt).toBe(newEndAt)
            })

            test('support can update endAt', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const newEndAt = dayjs().add(30, 'day').toISOString()
                const [obj] = await updateTestSubscriptionContext(support, objCreated.id, { endAt: newEndAt })

                expect(obj.endAt).toBe(newEndAt)
            })

            test('anonymous cannot update', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestSubscriptionContext(client, objCreated.id, {
                        endAt: dayjs().add(30, 'day').toISOString(),
                    })
                })
            })
        })

        describe('hard delete', () => {
            test('admin cannot delete', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await SubscriptionContext.delete(admin, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can read', async () => {
                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const objs = await SubscriptionContext.getAll(admin, { id: obj.id })

                expect(objs).toHaveLength(1)
                expect(objs[0].id).toBe(obj.id)
            })

            test('anonymous cannot read', async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await SubscriptionContext.getAll(client, {})
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('endAt must be after startAt', async () => {
            const startAt = dayjs().toISOString()
            const endAt = dayjs().subtract(1, 'day').toISOString()

            await expectToThrowGQLError(async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: true,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'END_DATE_MUST_BE_AFTER_START_DATE',
            }, 'obj')
        })

        test('daysRemaining is calculated correctly', async () => {
            const startAt = dayjs().toISOString()
            const endAt = dayjs().add(10, 'day').toISOString()

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt,
                isTrial: true,
            })

            expect(obj.daysRemaining).toBeGreaterThanOrEqual(9)
            expect(obj.daysRemaining).toBeLessThanOrEqual(10)
        })

        test('daysRemaining returns 0 for expired subscription', async () => {
            const startAt = dayjs().subtract(20, 'day').toISOString()
            const endAt = dayjs().subtract(5, 'day').toISOString()

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt,
                isTrial: true,
            })

            expect(obj.daysRemaining).toBe(0)
        })
    })

    describe('Field access restrictions', () => {
        test('cannot update subscriptionPlan', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    subscriptionPlan: { connect: { id: subscriptionPlan.id } },
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "subscriptionPlan" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update startAt', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    startAt: dayjs().add(5, 'day').toISOString(),
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "startAt" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update isTrial', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    isTrial: false,
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "isTrial" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })
    })
})
