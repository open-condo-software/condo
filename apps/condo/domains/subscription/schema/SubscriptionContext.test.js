/**
 * Generated by `createschema subscription.SubscriptionContext 'organization:Relationship:Organization:CASCADE; subscriptionPlan:Relationship:SubscriptionPlan:PROTECT; startAt:DateTimeUtc; endAt:DateTimeUtc; basePrice:Decimal; calculatedPrice:Decimal; appliedRules:Json; isTrial:Checkbox;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { makeLoggedInAdminClient, makeClient, UUID_RE, expectToThrowGQLError, catchErrorFrom } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { HOLDING_TYPE } = require('@condo/domains/organization/constants/common')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema')
const {
    SubscriptionContext,
    createTestSubscriptionContext,
    updateTestSubscriptionContext,
    createTestSubscriptionPlan,
} = require('@condo/domains/subscription/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

describe('SubscriptionContext', () => {
    let admin, support, employee
    let organization, subscriptionPlan

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()

        const [plan] = await createTestSubscriptionPlan(admin, {
            name: faker.commerce.productName(),
            organizationType: HOLDING_TYPE,
            isHidden: false,
        })
        subscriptionPlan = plan
    })

    beforeEach(async () => {
        employee = await makeClientWithNewRegisteredAndLoggedInUser()
        const [org] = await registerNewOrganization(employee, { type: HOLDING_TYPE })
        organization = org
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can create subscription without prices', async () => {
                const startAt = dayjs().toISOString()
                const endAt = dayjs().add(30, 'day').toISOString()

                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: false,
                })

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.isTrial).toBe(false)
            })

            test('support can create subscription without prices', async () => {
                const startAt = dayjs().toISOString()
                const endAt = dayjs().add(30, 'day').toISOString()

                const [obj] = await createTestSubscriptionContext(support, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: false,
                })

                expect(obj.id).toMatch(UUID_RE)
            })

            test('employee cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestSubscriptionContext(employee, organization, subscriptionPlan, {
                        startAt: dayjs().toISOString(),
                        endAt: dayjs().add(14, 'day').toISOString(),
                        isTrial: true,
                    })
                })
            })

            test('anonymous cannot create', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestSubscriptionContext(client, organization, subscriptionPlan, {
                        startAt: dayjs().toISOString(),
                        endAt: dayjs().add(14, 'day').toISOString(),
                        isTrial: true,
                    })
                })
            })
        })

        describe('update', () => {
            test('support can soft delete', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const deletedAt = dayjs().toISOString()
                const [obj] = await updateTestSubscriptionContext(support, objCreated.id, { deletedAt })

                expect(obj.deletedAt).toBeTruthy()
            })

            test('employee cannot update (soft delete)', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestSubscriptionContext(employee, objCreated.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                })
            })

            test('anonymous cannot update (soft delete)', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestSubscriptionContext(client, objCreated.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                })
            })
        })

        describe('read', () => {
            test('admin can read', async () => {
                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const objs = await SubscriptionContext.getAll(admin, { id: obj.id })

                expect(objs).toHaveLength(1)
                expect(objs[0].id).toBe(obj.id)
            })

            test('employee can read own organization subscription', async () => {
                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const objs = await SubscriptionContext.getAll(employee, { id: obj.id })

                expect(objs).toHaveLength(1)
                expect(objs[0].id).toBe(obj.id)
            })

            test('employee cannot read other organization subscription', async () => {
                const otherUser = await makeClientWithNewRegisteredAndLoggedInUser()
                const [otherOrg] = await registerNewOrganization(otherUser, { type: HOLDING_TYPE })

                const [obj] = await createTestSubscriptionContext(admin, otherOrg, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const objs = await SubscriptionContext.getAll(employee, { id: obj.id })

                expect(objs).toHaveLength(0)
            })

            test('anonymous cannot read', async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await SubscriptionContext.getAll(client, {})
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('endAt must be after startAt', async () => {
            const startAt = dayjs().toISOString()
            const endAt = dayjs().subtract(1, 'day').toISOString()

            await expectToThrowGQLError(async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: true,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'END_DATE_MUST_BE_AFTER_START_DATE',
            }, 'obj')
        })

        test('daysRemaining is calculated correctly', async () => {
            const startAt = dayjs().toISOString()
            const endAt = dayjs().add(10, 'day').toISOString()

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt,
                isTrial: true,
            })

            expect(obj.daysRemaining).toBeGreaterThanOrEqual(9)
            expect(obj.daysRemaining).toBeLessThanOrEqual(10)
        })

        test('daysRemaining returns 0 for expired subscription', async () => {
            const startAt = dayjs().subtract(20, 'day').toISOString()
            const endAt = dayjs().subtract(5, 'day').toISOString()

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt,
                isTrial: true,
            })

            expect(obj.daysRemaining).toBe(0)
        })

        test('daysRemaining returns null for unlimited subscription', async () => {
            const startAt = dayjs().toISOString()

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt: null,
                isTrial: false,
            })

            expect(obj.daysRemaining).toBeNull()
        })
    })

    describe('Field access restrictions', () => {
        test('cannot update subscriptionPlan', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    subscriptionPlan: { connect: { id: subscriptionPlan.id } },
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "subscriptionPlan" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update startAt', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    startAt: dayjs().add(5, 'day').toISOString(),
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "startAt" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update isTrial', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    isTrial: false,
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "isTrial" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update endAt', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    endAt: dayjs().add(30, 'day').toISOString(),
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "endAt" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })
    })
})
