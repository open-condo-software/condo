/**
 * Generated by `createschema subscription.SubscriptionContext 'organization:Relationship:Organization:CASCADE; subscriptionPlan:Relationship:SubscriptionPlan:PROTECT; startAt:DateTimeUtc; endAt:DateTimeUtc; basePrice:Decimal; calculatedPrice:Decimal; appliedRules:Json; isTrial:Checkbox;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { makeLoggedInAdminClient, makeClient, UUID_RE, expectToThrowGQLError, catchErrorFrom } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { ACTIVATE_SUBSCRIPTION_TYPE } = require('@condo/domains/onboarding/constants/userHelpRequest')
const { UserHelpRequest, createTestUserHelpRequest } = require('@condo/domains/onboarding/utils/testSchema')
const { HOLDING_TYPE, MANAGING_COMPANY_TYPE, SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema')
const {
    SubscriptionContext,
    createTestSubscriptionContext,
    updateTestSubscriptionContext,
    createTestSubscriptionPlan,
    createTestSubscriptionPlanPricingRule,
} = require('@condo/domains/subscription/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

describe('SubscriptionContext', () => {
    let admin, support, employee
    let organization, subscriptionPlan, pricingRule

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()

        const [plan] = await createTestSubscriptionPlan(admin, {
            name: faker.commerce.productName(),
            organizationType: HOLDING_TYPE,
            isHidden: false,
        })
        subscriptionPlan = plan

        const [rule] = await createTestSubscriptionPlanPricingRule(admin, subscriptionPlan, {
            name: 'Default pricing',
            period: 'month',
            price: '1000.00',
            currencyCode: 'RUB',
        })
        pricingRule = rule
    })

    beforeEach(async () => {
        employee = await makeClientWithNewRegisteredAndLoggedInUser()
        const [org] = await registerNewOrganization(employee, { type: HOLDING_TYPE })
        organization = org
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can create paid subscription', async () => {
                const startAt = dayjs().format('YYYY-MM-DD')
                const endAt = dayjs().add(30, 'day').format('YYYY-MM-DD')

                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: false,
                })

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.organization.id).toBe(organization.id)
                expect(obj.subscriptionPlan.id).toBe(subscriptionPlan.id)
                expect(obj.startAt).toBe(startAt)
                expect(obj.endAt).toBe(endAt)
                expect(obj.isTrial).toBe(false)
            })

            test('admin can create trial subscription', async () => {
                const startAt = dayjs().format('YYYY-MM-DD')
                const endAt = dayjs().add(14, 'day').format('YYYY-MM-DD')

                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: true,
                })

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.isTrial).toBe(true)
            })

            test('support can create subscription', async () => {
                const startAt = dayjs().format('YYYY-MM-DD')
                const endAt = dayjs().add(30, 'day').format('YYYY-MM-DD')

                const [obj] = await createTestSubscriptionContext(support, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: false,
                })

                expect(obj.id).toMatch(UUID_RE)
            })

            test('employee cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestSubscriptionContext(employee, organization, subscriptionPlan, {
                        startAt: dayjs().format('YYYY-MM-DD'),
                        endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                        isTrial: true,
                    })
                })
            })

            test('anonymous cannot create', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestSubscriptionContext(client, organization, subscriptionPlan, {
                        startAt: dayjs().format('YYYY-MM-DD'),
                        endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                        isTrial: true,
                    })
                })
            })
        })

        describe('update', () => {
            test('support can soft delete', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().format('YYYY-MM-DD'),
                    endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                    isTrial: true,
                })

                const deletedAt = dayjs().toISOString()
                const [obj] = await updateTestSubscriptionContext(support, objCreated.id, { deletedAt })

                expect(obj.deletedAt).toBeTruthy()
            })

            test('employee cannot update (soft delete)', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().format('YYYY-MM-DD'),
                    endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                    isTrial: true,
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestSubscriptionContext(employee, objCreated.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                })
            })

            test('anonymous cannot update (soft delete)', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().format('YYYY-MM-DD'),
                    endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                    isTrial: true,
                })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestSubscriptionContext(client, objCreated.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                })
            })
        })

        describe('read', () => {
            test('admin can read subscription context', async () => {
                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().format('YYYY-MM-DD'),
                    endAt: dayjs().add(30, 'day').format('YYYY-MM-DD'),
                    isTrial: false,
                })

                const objs = await SubscriptionContext.getAll(admin, { id: obj.id })

                expect(objs).toHaveLength(1)
                expect(objs[0].id).toBe(obj.id)
            })

            test('employee can read own organization subscription', async () => {
                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().format('YYYY-MM-DD'),
                    endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                    isTrial: true,
                })

                const objs = await SubscriptionContext.getAll(employee, { id: obj.id })

                expect(objs).toHaveLength(1)
                expect(objs[0].id).toBe(obj.id)
            })

            test('employee cannot read other organization subscription', async () => {
                const otherUser = await makeClientWithNewRegisteredAndLoggedInUser()
                const [otherOrg] = await registerNewOrganization(otherUser, { type: HOLDING_TYPE })

                const [obj] = await createTestSubscriptionContext(admin, otherOrg, subscriptionPlan, {
                    startAt: dayjs().format('YYYY-MM-DD'),
                    endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                    isTrial: true,
                })

                const objs = await SubscriptionContext.getAll(employee, { id: obj.id })

                expect(objs).toHaveLength(0)
            })

            test('anonymous cannot read', async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().format('YYYY-MM-DD'),
                    endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                    isTrial: true,
                })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await SubscriptionContext.getAll(client, {})
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('endAt must be after startAt', async () => {
            const startAt = dayjs().format('YYYY-MM-DD')
            const endAt = dayjs().subtract(1, 'day').format('YYYY-MM-DD')

            await expectToThrowGQLError(async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: true,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'END_DATE_MUST_BE_AFTER_START_DATE',
            }, 'obj')
        })

        test('organization type must match subscriptionPlan organizationType', async () => {
            const [managingCompanyOrg] = await registerNewOrganization(employee, { type: MANAGING_COMPANY_TYPE })
            const [holdingPlan] = await createTestSubscriptionPlan(admin, { organizationType: HOLDING_TYPE })

            await expectToThrowGQLError(async () => {
                await createTestSubscriptionContext(admin, managingCompanyOrg, holdingPlan, {
                    startAt: dayjs().format('YYYY-MM-DD'),
                    endAt: dayjs().add(30, 'day').format('YYYY-MM-DD'),
                    isTrial: false,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'ORGANIZATION_TYPE_MISMATCH',
            }, 'obj')
        })

        test('can create subscription when organization type matches subscriptionPlan organizationType', async () => {
            const [serviceProviderOrg] = await registerNewOrganization(employee, { type: SERVICE_PROVIDER_TYPE })
            const [serviceProviderPlan] = await createTestSubscriptionPlan(admin, { organizationType: SERVICE_PROVIDER_TYPE })

            const [obj] = await createTestSubscriptionContext(admin, serviceProviderOrg, serviceProviderPlan, {
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: dayjs().add(30, 'day').format('YYYY-MM-DD'),
                isTrial: false,
            })

            expect(obj.id).toMatch(UUID_RE)
            expect(obj.organization.id).toBe(serviceProviderOrg.id)
            expect(obj.subscriptionPlan.id).toBe(serviceProviderPlan.id)
        })


        test('daysRemaining is calculated correctly', async () => {
            const startAt = dayjs().format('YYYY-MM-DD')
            const endAt = dayjs().add(10, 'day').format('YYYY-MM-DD')

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt,
                isTrial: true,
            })

            expect(obj.daysRemaining).toBeGreaterThanOrEqual(9)
            expect(obj.daysRemaining).toBeLessThanOrEqual(10)
        })

        test('daysRemaining returns 0 for expired subscription', async () => {
            const startAt = dayjs().subtract(20, 'day').format('YYYY-MM-DD')
            const endAt = dayjs().subtract(5, 'day').format('YYYY-MM-DD')

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt,
                isTrial: true,
            })

            expect(obj.daysRemaining).toBe(0)
        })

        test('daysRemaining returns null for unlimited subscription', async () => {
            const startAt = dayjs().format('YYYY-MM-DD')

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt: null,
                isTrial: false,
            })

            expect(obj.daysRemaining).toBeNull()
        })
    })

    describe('Field access restrictions', () => {
        test('cannot update subscriptionPlan', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    subscriptionPlan: { connect: { id: subscriptionPlan.id } },
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "subscriptionPlan" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })


        test('cannot update startAt', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    startAt: dayjs().add(5, 'day').format('YYYY-MM-DD'),
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "startAt" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update isTrial', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    isTrial: false,
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "isTrial" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update endAt', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    endAt: dayjs().add(30, 'day').format('YYYY-MM-DD'),
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "endAt" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })
    })

    describe('UserHelpRequest cleanup', () => {
        test('creating non-trial SubscriptionContext soft deletes pending UserHelpRequests for the organization', async () => {
            // Create a pending UserHelpRequest
            const [helpRequest] = await createTestUserHelpRequest(admin, organization, {
                type: ACTIVATE_SUBSCRIPTION_TYPE,
                subscriptionPlanPricingRule: { connect: { id: pricingRule.id } },
            })

            expect(helpRequest.deletedAt).toBeNull()

            // Create a non-trial SubscriptionContext
            await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: dayjs().add(30, 'day').format('YYYY-MM-DD'),
                isTrial: false,
            })

            // Check that the UserHelpRequest is now soft deleted
            const [updatedHelpRequest] = await UserHelpRequest.getAll(admin, { id: helpRequest.id, deletedAt_not: null })
            expect(updatedHelpRequest).toBeDefined()
            expect(updatedHelpRequest.deletedAt).not.toBeNull()
        })

        test('creating trial SubscriptionContext does NOT delete pending UserHelpRequests', async () => {
            // Create a pending UserHelpRequest
            const [helpRequest] = await createTestUserHelpRequest(admin, organization, {
                type: ACTIVATE_SUBSCRIPTION_TYPE,
                subscriptionPlanPricingRule: { connect: { id: pricingRule.id } },
            })

            expect(helpRequest.deletedAt).toBeNull()

            // Create a trial SubscriptionContext
            await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: dayjs().add(14, 'day').format('YYYY-MM-DD'),
                isTrial: true,
            })

            // Check that the UserHelpRequest is NOT deleted
            const updatedHelpRequest = await UserHelpRequest.getOne(admin, { id: helpRequest.id })
            expect(updatedHelpRequest.deletedAt).toBeNull()
        })

        test('creating non-trial SubscriptionContext soft deletes multiple pending UserHelpRequests', async () => {
            // Create multiple pending UserHelpRequests
            const [helpRequest1] = await createTestUserHelpRequest(admin, organization, {
                type: ACTIVATE_SUBSCRIPTION_TYPE,
                subscriptionPlanPricingRule: { connect: { id: pricingRule.id } },
            })
            const [helpRequest2] = await createTestUserHelpRequest(admin, organization, {
                type: ACTIVATE_SUBSCRIPTION_TYPE,
            })

            // Create a non-trial SubscriptionContext
            await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: dayjs().add(30, 'day').format('YYYY-MM-DD'),
                isTrial: false,
            })

            // Check that both UserHelpRequests are soft deleted
            const [updated1] = await UserHelpRequest.getAll(admin, { id: helpRequest1.id, deletedAt_not: null })
            const [updated2] = await UserHelpRequest.getAll(admin, { id: helpRequest2.id, deletedAt_not: null })
            expect(updated1).toBeDefined()
            expect(updated1.deletedAt).not.toBeNull()
            expect(updated2).toBeDefined()
            expect(updated2.deletedAt).not.toBeNull()
        })

        test('creating non-trial SubscriptionContext does not affect UserHelpRequests from other organizations', async () => {
            const otherUser = await makeClientWithNewRegisteredAndLoggedInUser()
            const [otherOrg] = await registerNewOrganization(otherUser, { type: HOLDING_TYPE })

            // Create UserHelpRequest for other organization
            const [otherHelpRequest] = await createTestUserHelpRequest(admin, otherOrg, {
                type: ACTIVATE_SUBSCRIPTION_TYPE,
            })

            // Create non-trial SubscriptionContext for original organization
            await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: dayjs().add(30, 'day').format('YYYY-MM-DD'),
                isTrial: false,
            })

            // Check that the other organization's UserHelpRequest is not affected
            const otherUpdated = await UserHelpRequest.getOne(admin, { id: otherHelpRequest.id })
            expect(otherUpdated.deletedAt).toBeNull()
        })
    })
})
