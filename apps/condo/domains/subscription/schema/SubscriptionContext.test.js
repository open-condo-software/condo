/**
 * Generated by `createschema subscription.SubscriptionContext 'organization:Relationship:Organization:CASCADE; subscriptionPlan:Relationship:SubscriptionPlan:PROTECT; startAt:DateTimeUtc; endAt:DateTimeUtc; basePrice:Decimal; calculatedPrice:Decimal; appliedRules:Json; isTrial:Checkbox;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { makeLoggedInAdminClient, makeClient, UUID_RE, expectToThrowGQLError, catchErrorFrom } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { HOLDING_TYPE } = require('@condo/domains/organization/constants/common')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema')
const {
    SubscriptionContext,
    createTestSubscriptionContext,
    updateTestSubscriptionContext,
    createTestSubscriptionPlan,
    createTestSubscriptionPlanPricingRule,
} = require('@condo/domains/subscription/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

describe('SubscriptionContext', () => {
    let admin, support, employee
    let organization, subscriptionPlan, pricingRule

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()

        const [plan] = await createTestSubscriptionPlan(admin, {
            name: faker.commerce.productName(),
            organizationType: HOLDING_TYPE,
            isHidden: false,
        })
        subscriptionPlan = plan

        const [rule] = await createTestSubscriptionPlanPricingRule(admin, subscriptionPlan, {
            name: 'Default pricing',
            period: 'month',
            price: '1000.00',
            currencyCode: 'RUB',
        })
        pricingRule = rule
    })

    beforeEach(async () => {
        employee = await makeClientWithNewRegisteredAndLoggedInUser()
        const [org] = await registerNewOrganization(employee, { type: HOLDING_TYPE })
        organization = org
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can create paid subscription with pricingRule', async () => {
                const startAt = dayjs().toISOString()
                const endAt = dayjs().add(30, 'day').toISOString()

                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: false,
                    pricingRule: { connect: { id: pricingRule.id } },
                })

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.isTrial).toBe(false)
                expect(obj.pricingRule.id).toBe(pricingRule.id)
                expect(obj.frozenPricingRule).toBeDefined()
                expect(obj.frozenPricingRule.dv).toBe(1)
                expect(obj.frozenPricingRule.data.id).toBe(pricingRule.id)
                expect(obj.frozenPricingRule.data.price).toBe('1000.00')
                expect(obj.frozenPricingRule.data.currencyCode).toBe('RUB')
                expect(obj.frozenPricingRule.data.subscriptionPlan.id).toBe(subscriptionPlan.id)
            })

            test('admin can create trial subscription without pricingRule', async () => {
                const startAt = dayjs().toISOString()
                const endAt = dayjs().add(14, 'day').toISOString()

                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: true,
                })

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.isTrial).toBe(true)
                expect(obj.pricingRule).toBeNull()
                expect(obj.frozenPricingRule).toBeNull()
            })

            test('support can create subscription with pricingRule', async () => {
                const startAt = dayjs().toISOString()
                const endAt = dayjs().add(30, 'day').toISOString()

                const [obj] = await createTestSubscriptionContext(support, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: false,
                    pricingRule: { connect: { id: pricingRule.id } },
                })

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.pricingRule.id).toBe(pricingRule.id)
            })

            test('employee cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestSubscriptionContext(employee, organization, subscriptionPlan, {
                        startAt: dayjs().toISOString(),
                        endAt: dayjs().add(14, 'day').toISOString(),
                        isTrial: true,
                    })
                })
            })

            test('anonymous cannot create', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestSubscriptionContext(client, organization, subscriptionPlan, {
                        startAt: dayjs().toISOString(),
                        endAt: dayjs().add(14, 'day').toISOString(),
                        isTrial: true,
                    })
                })
            })
        })

        describe('update', () => {
            test('support can soft delete', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const deletedAt = dayjs().toISOString()
                const [obj] = await updateTestSubscriptionContext(support, objCreated.id, { deletedAt })

                expect(obj.deletedAt).toBeTruthy()
            })

            test('employee cannot update (soft delete)', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestSubscriptionContext(employee, objCreated.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                })
            })

            test('anonymous cannot update (soft delete)', async () => {
                const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestSubscriptionContext(client, objCreated.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                })
            })
        })

        describe('read', () => {
            test('admin can read with pricingRule', async () => {
                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(30, 'day').toISOString(),
                    isTrial: false,
                    pricingRule: { connect: { id: pricingRule.id } },
                })

                const objs = await SubscriptionContext.getAll(admin, { id: obj.id })

                expect(objs).toHaveLength(1)
                expect(objs[0].id).toBe(obj.id)
                expect(objs[0].pricingRule.id).toBe(pricingRule.id)
            })

            test('employee can read own organization subscription', async () => {
                const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const objs = await SubscriptionContext.getAll(employee, { id: obj.id })

                expect(objs).toHaveLength(1)
                expect(objs[0].id).toBe(obj.id)
            })

            test('employee cannot read other organization subscription', async () => {
                const otherUser = await makeClientWithNewRegisteredAndLoggedInUser()
                const [otherOrg] = await registerNewOrganization(otherUser, { type: HOLDING_TYPE })

                const [obj] = await createTestSubscriptionContext(admin, otherOrg, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const objs = await SubscriptionContext.getAll(employee, { id: obj.id })

                expect(objs).toHaveLength(0)
            })

            test('anonymous cannot read', async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await SubscriptionContext.getAll(client, {})
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('endAt must be after startAt', async () => {
            const startAt = dayjs().toISOString()
            const endAt = dayjs().subtract(1, 'day').toISOString()

            await expectToThrowGQLError(async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt,
                    endAt,
                    isTrial: true,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'END_DATE_MUST_BE_AFTER_START_DATE',
            }, 'obj')
        })

        test('pricingRule is required for non-trial subscription', async () => {
            await expectToThrowGQLError(async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(30, 'day').toISOString(),
                    isTrial: false,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'PRICING_RULE_REQUIRED_FOR_NON_TRIAL',
            }, 'obj')
        })

        test('pricingRule is not allowed for trial subscription', async () => {
            await expectToThrowGQLError(async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(14, 'day').toISOString(),
                    isTrial: true,
                    pricingRule: { connect: { id: pricingRule.id } },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'PRICING_RULE_NOT_ALLOWED_FOR_TRIAL',
            }, 'obj')
        })

        test('pricingRule must belong to the same subscriptionPlan', async () => {
            const [otherPlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: HOLDING_TYPE,
            })
            const [otherRule] = await createTestSubscriptionPlanPricingRule(admin, otherPlan, {
                name: 'Other pricing',
                period: 'month',
                price: '2000.00',
                currencyCode: 'RUB',
            })

            await expectToThrowGQLError(async () => {
                await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                    startAt: dayjs().toISOString(),
                    endAt: dayjs().add(30, 'day').toISOString(),
                    isTrial: false,
                    pricingRule: { connect: { id: otherRule.id } },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'PRICING_RULE_PLAN_MISMATCH',
            }, 'obj')
        })

        test('daysRemaining is calculated correctly', async () => {
            const startAt = dayjs().toISOString()
            const endAt = dayjs().add(10, 'day').toISOString()

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt,
                isTrial: true,
            })

            expect(obj.daysRemaining).toBeGreaterThanOrEqual(9)
            expect(obj.daysRemaining).toBeLessThanOrEqual(10)
        })

        test('daysRemaining returns 0 for expired subscription', async () => {
            const startAt = dayjs().subtract(20, 'day').toISOString()
            const endAt = dayjs().subtract(5, 'day').toISOString()

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt,
                isTrial: true,
            })

            expect(obj.daysRemaining).toBe(0)
        })

        test('daysRemaining returns null for unlimited subscription with pricingRule', async () => {
            const startAt = dayjs().toISOString()

            const [obj] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt,
                endAt: null,
                isTrial: false,
                pricingRule: { connect: { id: pricingRule.id } },
            })

            expect(obj.daysRemaining).toBeNull()
        })
    })

    describe('Field access restrictions', () => {
        test('cannot update subscriptionPlan', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    subscriptionPlan: { connect: { id: subscriptionPlan.id } },
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "subscriptionPlan" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update pricingRule', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(30, 'day').toISOString(),
                isTrial: false,
                pricingRule: { connect: { id: pricingRule.id } },
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    pricingRule: { connect: { id: pricingRule.id } },
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "pricingRule" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update startAt', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    startAt: dayjs().add(5, 'day').toISOString(),
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "startAt" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update isTrial', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    isTrial: false,
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "isTrial" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })

        test('cannot update endAt', async () => {
            const [objCreated] = await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().toISOString(),
                endAt: dayjs().add(14, 'day').toISOString(),
                isTrial: true,
            })

            await catchErrorFrom(async () => {
                await updateTestSubscriptionContext(admin, objCreated.id, {
                    endAt: dayjs().add(30, 'day').toISOString(),
                })
            }, ({ errors }) => {
                expect(errors[0].message).toContain('Field "endAt" is not defined by type "SubscriptionContextUpdateInput"')
            })
        })
    })
})
