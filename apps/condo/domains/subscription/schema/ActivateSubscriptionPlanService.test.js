/**
 * Generated by `createservice subscription.ActivateSubscriptionPlanService --type mutations`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { makeLoggedInAdminClient, makeClient, expectToThrowGQLError } = require('@open-condo/keystone/test.utils')
const { expectToThrowAccessDeniedErrorToResult, expectToThrowAuthenticationErrorToResult } = require('@open-condo/keystone/test.utils')

const { ACTIVATE_SUBSCRIPTION_TYPE } = require('@condo/domains/onboarding/constants/userHelpRequest')
const { UserHelpRequest } = require('@condo/domains/onboarding/utils/testSchema')
const { MANAGING_COMPANY_TYPE, HOLDING_TYPE } = require('@condo/domains/organization/constants/common')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema')
const { SUBSCRIPTION_PERIOD } = require('@condo/domains/subscription/constants')
const {
    activateSubscriptionPlanByTestClient,
    createTestSubscriptionPlan,
    createTestSubscriptionPlanPricingRule,
    SubscriptionContext,
} = require('@condo/domains/subscription/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser, makeClientWithServiceUser, createTestUserRightsSet, updateTestUser } = require('@condo/domains/user/utils/testSchema')

const { ERRORS } = require('./ActivateSubscriptionPlanService')

describe('ActivateSubscriptionPlanService', () => {
    let admin, support, user, anonymous
    let organization, subscriptionPlan, pricingRule

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()

        const [plan] = await createTestSubscriptionPlan(admin, {
            name: faker.commerce.productName(),
            organizationType: MANAGING_COMPANY_TYPE,
            isHidden: false,
            trialDays: 14,
        })
        subscriptionPlan = plan

        const [rule] = await createTestSubscriptionPlanPricingRule(admin, subscriptionPlan, {
            period: SUBSCRIPTION_PERIOD.MONTH,
            price: '1000.00',
            currencyCode: 'RUB',
        })
        pricingRule = rule
    })

    beforeEach(async () => {
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        const [org] = await registerNewOrganization(user, { type: MANAGING_COMPANY_TYPE })
        organization = org
    })

    describe('Access', () => {
        test('admin can activate trial', async () => {
            const [result] = await activateSubscriptionPlanByTestClient(admin, organization, pricingRule, { isTrial: true })

            expect(result.subscriptionContext).toBeDefined()
            expect(result.subscriptionContext.isTrial).toBe(true)
        })

        test('support can activate trial', async () => {
            const [result] = await activateSubscriptionPlanByTestClient(support, organization, pricingRule, { isTrial: true })

            expect(result.subscriptionContext).toBeDefined()
            expect(result.subscriptionContext.isTrial).toBe(true)
        })

        test('organization admin can activate trial for own organization', async () => {
            const [result] = await activateSubscriptionPlanByTestClient(user, organization, pricingRule, { isTrial: true })

            expect(result.subscriptionContext).toBeDefined()
            expect(result.subscriptionContext.isTrial).toBe(true)
        })

        test('user cannot activate for other organization', async () => {
            const otherUser = await makeClientWithNewRegisteredAndLoggedInUser()
            const [otherOrg] = await registerNewOrganization(otherUser, { type: MANAGING_COMPANY_TYPE })

            await expectToThrowAccessDeniedErrorToResult(async () => {
                await activateSubscriptionPlanByTestClient(user, otherOrg, pricingRule, { isTrial: true })
            })
        })

        test('anonymous cannot activate', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await activateSubscriptionPlanByTestClient(anonymous, organization, pricingRule, { isTrial: true })
            })
        })
    })

    describe('Trial Logic', () => {
        test('creates trial subscription context with correct dates based on trialDays', async () => {
            const [result] = await activateSubscriptionPlanByTestClient(user, organization, pricingRule, { isTrial: true })

            const context = result.subscriptionContext
            expect(context.isTrial).toBe(true)
            expect(context.organization.id).toBe(organization.id)
            expect(context.subscriptionPlan.id).toBe(subscriptionPlan.id)

            const startAt = dayjs(context.startAt)
            const endAt = dayjs(context.endAt)
            expect(endAt.diff(startAt, 'day')).toBe(subscriptionPlan.trialDays)
        })

        test('throws access denied if organization not found', async () => {
            const fakeOrg = { id: '00000000-0000-0000-0000-000000000000' }

            await expectToThrowAccessDeniedErrorToResult(async () => {
                await activateSubscriptionPlanByTestClient(user, fakeOrg, pricingRule, { isTrial: true })
            })
        })

        test('throws error if pricing rule not found', async () => {
            const fakeRule = { id: '00000000-0000-0000-0000-000000000000' }

            await expectToThrowGQLError(async () => {
                await activateSubscriptionPlanByTestClient(user, organization, fakeRule, { isTrial: true })
            }, ERRORS.PRICING_RULE_NOT_FOUND, 'result')
        })

        test('throws error if plan is hidden', async () => {
            const [hiddenPlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                isHidden: true,
                trialDays: 14,
            })
            const [hiddenPlanRule] = await createTestSubscriptionPlanPricingRule(admin, hiddenPlan, {
                period: SUBSCRIPTION_PERIOD.MONTH,
                price: '1000.00',
                currencyCode: 'RUB',
            })

            await expectToThrowGQLError(async () => {
                await activateSubscriptionPlanByTestClient(user, organization, hiddenPlanRule, { isTrial: true })
            }, ERRORS.PRICING_RULE_NOT_FOUND, 'result')
        })

        test('throws error if trial is not available for plan (trialDays = 0)', async () => {
            const [noTrialPlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                isHidden: false,
                trialDays: 0,
            })
            const [noTrialPlanRule] = await createTestSubscriptionPlanPricingRule(admin, noTrialPlan, {
                period: SUBSCRIPTION_PERIOD.MONTH,
                price: '1000.00',
                currencyCode: 'RUB',
            })

            await expectToThrowGQLError(async () => {
                await activateSubscriptionPlanByTestClient(user, organization, noTrialPlanRule, { isTrial: true })
            }, ERRORS.TRIAL_NOT_AVAILABLE, 'result')
        })

        test('throws error if organization type does not match plan', async () => {
            const [differentTypePlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: HOLDING_TYPE,
                isHidden: false,
                trialDays: 14,
            })
            const [differentTypePlanRule] = await createTestSubscriptionPlanPricingRule(admin, differentTypePlan, {
                period: SUBSCRIPTION_PERIOD.MONTH,
                price: '1000.00',
                currencyCode: 'RUB',
            })

            await expectToThrowGQLError(async () => {
                await activateSubscriptionPlanByTestClient(user, organization, differentTypePlanRule, { isTrial: true })
            }, ERRORS.INVALID_ORGANIZATION_TYPE, 'result')
        })

        test('throws error if trial already used for this plan', async () => {
            await activateSubscriptionPlanByTestClient(user, organization, pricingRule, { isTrial: true })

            await expectToThrowGQLError(async () => {
                await activateSubscriptionPlanByTestClient(user, organization, pricingRule, { isTrial: true })
            }, ERRORS.TRIAL_ALREADY_USED, 'result')
        })

        test('can activate trial for different plans', async () => {
            const [result1] = await activateSubscriptionPlanByTestClient(user, organization, pricingRule, { isTrial: true })
            expect(result1.subscriptionContext.isTrial).toBe(true)

            const [anotherPlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                isHidden: false,
                trialDays: 14,
            })
            const [anotherPlanRule] = await createTestSubscriptionPlanPricingRule(admin, anotherPlan, {
                period: SUBSCRIPTION_PERIOD.MONTH,
                price: '1000.00',
                currencyCode: 'RUB',
            })

            const [result2] = await activateSubscriptionPlanByTestClient(user, organization, anotherPlanRule, { isTrial: true })
            expect(result2.subscriptionContext.isTrial).toBe(true)
        })
    })

    describe('Service User Access', () => {
        test('service user with canExecuteActivateSubscriptionPlan right can activate subscription', async () => {
            const serviceUser = await makeClientWithServiceUser()
            const [rightsSet] = await createTestUserRightsSet(admin, {
                canExecuteActivateSubscriptionPlan: true,
            })
            await updateTestUser(admin, serviceUser.user.id, {
                rightsSet: { connect: { id: rightsSet.id } },
            })

            const [result] = await activateSubscriptionPlanByTestClient(serviceUser, organization, pricingRule, { isTrial: false })

            expect(result.subscriptionContext).toBeDefined()
            expect(result.subscriptionContext.id).toBeDefined()
            expect(result.userHelpRequest).toBeNull()

            const [subscriptionContext] = await SubscriptionContext.getAll(admin, { id: result.subscriptionContext.id })
            expect(subscriptionContext).toBeDefined()
            expect(subscriptionContext.isTrial).toBe(false)
            expect(subscriptionContext.organization.id).toBe(organization.id)
            expect(subscriptionContext.subscriptionPlan.id).toBe(subscriptionPlan.id)
            expect(subscriptionContext.basePrice).toBe(pricingRule.price)

            const startAt = dayjs(subscriptionContext.startAt)
            const endAt = dayjs(subscriptionContext.endAt)
            expect(endAt.diff(startAt, 'month')).toBe(1)
        })

        test('service user without canExecuteActivateSubscriptionPlan right cannot activate subscription', async () => {
            const serviceUser = await makeClientWithServiceUser()

            await expectToThrowAccessDeniedErrorToResult(async () => {
                await activateSubscriptionPlanByTestClient(serviceUser, organization, pricingRule, { isTrial: false })
            })
        })
    })

    describe('Paid Subscription Logic', () => {
        test('creates UserHelpRequest with pricingRule when isTrial is false for regular users', async () => {
            const [result] = await activateSubscriptionPlanByTestClient(user, organization, pricingRule, { isTrial: false })

            expect(result.subscriptionContext).toBeNull()
            expect(result.userHelpRequest).toBeDefined()
            expect(result.userHelpRequest.type).toBe(ACTIVATE_SUBSCRIPTION_TYPE)
            expect(result.userHelpRequest.organization.id).toBe(organization.id)
            expect(result.userHelpRequest.subscriptionPlanPricingRule.id).toBe(pricingRule.id)
        })

        test('employees can read UserHelpRequest with ACTIVATE_SUBSCRIPTION_TYPE', async () => {
            const [result] = await activateSubscriptionPlanByTestClient(user, organization, pricingRule, { isTrial: false })

            const helpRequests = await UserHelpRequest.getAll(user, {
                id: result.userHelpRequest.id,
            })

            expect(helpRequests).toHaveLength(1)
            expect(helpRequests[0].id).toBe(result.userHelpRequest.id)
        })
    })

    describe('Subscription Renewal Without Gaps', () => {
        let serviceUser

        beforeEach(async () => {
            serviceUser = await makeClientWithServiceUser()
            const [rightsSet] = await createTestUserRightsSet(admin, {
                canExecuteActivateSubscriptionPlan: true,
            })
            await updateTestUser(admin, serviceUser.user.id, {
                rightsSet: { connect: { id: rightsSet.id } },
            })
        })

        test('creates subscription starting from today when no existing contexts', async () => {
            const [result] = await activateSubscriptionPlanByTestClient(serviceUser, organization, pricingRule, { isTrial: false })

            expect(result.subscriptionContext).toBeDefined()
            const context = result.subscriptionContext
            
            const today = dayjs().format('YYYY-MM-DD')
            expect(context.startAt).toBe(today)
            
            const expectedEndAt = dayjs().add(1, 'month').format('YYYY-MM-DD')
            expect(context.endAt).toBe(expectedEndAt)
        })

        test('extends subscription from last context endAt when it is in the future', async () => {
            const firstEndAt = dayjs().add(15, 'days').format('YYYY-MM-DD')
            await SubscriptionContext.create(admin, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'test-fingerprint' },
                organization: { connect: { id: organization.id } },
                subscriptionPlan: { connect: { id: subscriptionPlan.id } },
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: firstEndAt,
                isTrial: false,
            })

            const [result] = await activateSubscriptionPlanByTestClient(serviceUser, organization, pricingRule, { isTrial: false })

            expect(result.subscriptionContext).toBeDefined()
            const context = result.subscriptionContext
            
            expect(context.startAt).toBe(firstEndAt)
            
            const expectedEndAt = dayjs(firstEndAt).add(1, 'month').format('YYYY-MM-DD')
            expect(context.endAt).toBe(expectedEndAt)
        })

        test('starts from today when last context has already expired', async () => {
            const expiredEndAt = dayjs().subtract(5, 'days').format('YYYY-MM-DD')
            await SubscriptionContext.create(admin, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'test-fingerprint' },
                organization: { connect: { id: organization.id } },
                subscriptionPlan: { connect: { id: subscriptionPlan.id } },
                startAt: dayjs().subtract(35, 'days').format('YYYY-MM-DD'),
                endAt: expiredEndAt,
                isTrial: false,
            })

            const [result] = await activateSubscriptionPlanByTestClient(serviceUser, organization, pricingRule, { isTrial: false })

            expect(result.subscriptionContext).toBeDefined()
            const context = result.subscriptionContext
            
            const today = dayjs().format('YYYY-MM-DD')
            expect(context.startAt).toBe(today)
            
            const expectedEndAt = dayjs().add(1, 'month').format('YYYY-MM-DD')
            expect(context.endAt).toBe(expectedEndAt)
        })

        test('only considers contexts with the same plan for renewal', async () => {
            const [anotherPlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                isHidden: false,
            })

            const anotherPlanEndAt = dayjs().add(60, 'days').format('YYYY-MM-DD')
            await SubscriptionContext.create(admin, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'test-fingerprint' },
                organization: { connect: { id: organization.id } },
                subscriptionPlan: { connect: { id: anotherPlan.id } },
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: anotherPlanEndAt,
                isTrial: false,
            })

            const currentPlanEndAt = dayjs().add(20, 'days').format('YYYY-MM-DD')
            await SubscriptionContext.create(admin, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'test-fingerprint' },
                organization: { connect: { id: organization.id } },
                subscriptionPlan: { connect: { id: subscriptionPlan.id } },
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: currentPlanEndAt,
                isTrial: false,
            })

            const [result] = await activateSubscriptionPlanByTestClient(serviceUser, organization, pricingRule, { isTrial: false })

            expect(result.subscriptionContext).toBeDefined()
            const context = result.subscriptionContext
            
            expect(context.startAt).toBe(currentPlanEndAt)
            
            const expectedEndAt = dayjs(currentPlanEndAt).add(1, 'month').format('YYYY-MM-DD')
            expect(context.endAt).toBe(expectedEndAt)
        })

        test('creates continuous subscription chain without gaps', async () => {
            const firstEndAt = dayjs().add(10, 'days').format('YYYY-MM-DD')
            await SubscriptionContext.create(admin, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'test-fingerprint' },
                organization: { connect: { id: organization.id } },
                subscriptionPlan: { connect: { id: subscriptionPlan.id } },
                startAt: dayjs().format('YYYY-MM-DD'),
                endAt: firstEndAt,
                isTrial: false,
            })

            const [result1] = await activateSubscriptionPlanByTestClient(serviceUser, organization, pricingRule, { isTrial: false })
            expect(result1.subscriptionContext.startAt).toBe(firstEndAt)
            const secondEndAt = result1.subscriptionContext.endAt

            const [result2] = await activateSubscriptionPlanByTestClient(serviceUser, organization, pricingRule, { isTrial: false })
            expect(result2.subscriptionContext.startAt).toBe(secondEndAt)
            const thirdEndAt = result2.subscriptionContext.endAt

            expect(dayjs(secondEndAt).diff(dayjs(firstEndAt), 'month')).toBe(1)
            expect(dayjs(thirdEndAt).diff(dayjs(secondEndAt), 'month')).toBe(1)
        })
    })
})