/**
 * Generated by `createschema document.Document 'organization:Relationship:Organization:CASCADE; property?:Relationship:Property:CASCADE; category:Relationship:DocumentCategory:CASCADE; file:File;'`
 */
const get = require('lodash/get')

const { GQLError } = require('@open-condo/keystone/errors')
const FileAdapter = require('@open-condo/keystone/fileAdapter/fileAdapter')
const { getFileMetaAfterChange } = require('@open-condo/keystone/fileAdapter/fileAdapter')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById } = require('@open-condo/keystone/schema')

const { META_FIELD } = require('@condo/domains/common/schema/fields')
const access = require('@condo/domains/document/access/Document')
const { ERRORS } = require('@condo/domains/document/constants')
const { ORGANIZATION_OWNED_FIELD } = require('@condo/domains/organization/schema/fields')

const DOCUMENT_FOLDER_NAME = 'document'
const Adapter = new FileAdapter(DOCUMENT_FOLDER_NAME, false)
const fileMetaAfterChange = getFileMetaAfterChange(Adapter)

const createAndReadOnlyFieldAccess = {
    read: true,
    create: true,
    update: false,
    delete: false,
}

const Document = new GQLListSchema('Document', {
    schemaDoc: 'Document with file attached to organization or property. It could be some kind of property documentation, inspection reports or other documents',
    fields: {
        organization: ORGANIZATION_OWNED_FIELD,
        property: {
            schemaDoc: 'Property to which the document is attached',
            type: 'Relationship',
            ref: 'Property',
            kmigratorOptions: { null: true, on_delete: 'models.CASCADE' },
            access: createAndReadOnlyFieldAccess,
        },
        category: {
            schemaDoc: 'Document type',
            type: 'Relationship',
            ref: 'DocumentCategory',
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },
        name: {
            schemaDoc: 'Name of the document. By default it\'s file name',
            type: 'Text',
            isRequired: true,
        },
        file: {
            schemaDoc: 'File attached to document',
            type: 'File',
            adapter: Adapter,
            isRequired: true,
            access: createAndReadOnlyFieldAccess,
        },
        canReadByResident: {
            schemaDoc: 'If set to true, this means document will be accessible by residents',
            type: 'Checkbox',
            isRequired: true,
            defaultValue: false,
        },
        meta: META_FIELD,
    },
    hooks: {
        validateInput: async ({ resolvedData, existingItem, context }) => {
            const newItem = { ...existingItem, ...resolvedData }

            const resolvedPropertyId = resolvedData['property']
            if (resolvedPropertyId) {
                const property = await getById('Property', resolvedPropertyId)

                if (get(property, 'organization') !== newItem.organization) {
                    throw new GQLError(ERRORS.WRONG_PROPERTY_ORGANIZATION, context)
                }
            }
        },
        resolveInput: ({ resolvedData, operation, context, listKey }) => {
            if (operation === 'create' && !resolvedData['name']) {
                resolvedData['name'] = get(resolvedData, 'file.originalFilename') || get(context, ['_fileNewFlow', `${listKey}.file`, 'originalFilename'])
            }

            return resolvedData
        },
        afterChange: fileMetaAfterChange,
        afterDelete: async ({ existingItem }) => {
            if (existingItem.file) {
                await Adapter.delete(existingItem.file)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadDocuments,
        create: access.canManageDocuments,
        update: access.canManageDocuments,
        delete: false,
        auth: true,
    },
})

module.exports = {
    Document,
}
