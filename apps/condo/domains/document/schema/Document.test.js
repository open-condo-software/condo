/**
 * Generated by `createschema document.Document 'organization:Relationship:Organization:CASCADE; property?:Relationship:Property:CASCADE; category:Relationship:DocumentCategory:CASCADE; file:File;'`
 */

const path = require('path')

const { faker } = require('@faker-js/faker')

const conf = require('@open-condo/config')
const { makeLoggedInAdminClient, makeClient, UUID_RE, expectToThrowGQLError, catchErrorFrom, UploadingFile } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { ERRORS } = require('@condo/domains/document/constants')
const { Document, createTestDocument, updateTestDocument, createTestDocumentCategory, softDeleteTestDocument } = require('@condo/domains/document/utils/testSchema')
const { createTestOrganization,  createTestOrganizationEmployeeRole, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')


const TEST_FILE = path.resolve(conf.PROJECT_ROOT, 'apps/condo/domains/common/test-assets/dino.png')

describe('Document', () => {
    let admin, support, anonymous, employeeUserWithDocumentPermissions, employeeUserWithoutDocumentPermissions, employeeUserInOtherOrganization, notEmployeeUser,
        organization, documentCategory, document

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
        employeeUserWithDocumentPermissions = await makeClientWithNewRegisteredAndLoggedInUser()
        employeeUserWithoutDocumentPermissions = await makeClientWithNewRegisteredAndLoggedInUser()
        employeeUserInOtherOrganization = await makeClientWithNewRegisteredAndLoggedInUser()
        notEmployeeUser = await makeClientWithNewRegisteredAndLoggedInUser()

        const [testOrganization] = await createTestOrganization(admin)
        const [testOtherOrganization] = await createTestOrganization(admin)
        const [roleWithAccess] = await createTestOrganizationEmployeeRole(admin, testOrganization, { canManageDocuments: true, canReadDocuments: true })
        const [roleWithoutAccess] = await createTestOrganizationEmployeeRole(admin, testOrganization, { canManageDocuments: false, canReadDocuments: false })
        const [roleWithCanAccessInOtherOrganization] = await createTestOrganizationEmployeeRole(admin, testOtherOrganization, { canManageDocuments: true, canReadDocuments: true })
        await createTestOrganizationEmployee(admin, testOrganization, employeeUserWithDocumentPermissions.user, roleWithAccess)
        await createTestOrganizationEmployee(admin, testOrganization, employeeUserWithoutDocumentPermissions.user, roleWithoutAccess)
        await createTestOrganizationEmployee(admin, testOtherOrganization, employeeUserInOtherOrganization.user, roleWithCanAccessInOtherOrganization)
        const [testDocumentCategory] = await createTestDocumentCategory(admin)
        const [testDocument] = await createTestDocument(admin, testOrganization, testDocumentCategory)

        organization = testOrganization
        documentCategory = testDocumentCategory
        document = testDocument
    })

    describe('Access', () => {
        describe('Create', () => {
            it('anonymous can not', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestDocument(anonymous, organization, documentCategory)
                })
            })

            it('admin can', async () => {
                const [createdDocument] = await createTestDocument(admin, organization, documentCategory)

                expect(createdDocument.id).toMatch(UUID_RE)
                expect(createdDocument.organization.id).toEqual(organization.id)
                expect(createdDocument.category.id).toEqual(documentCategory.id)
            })

            it('support can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestDocument(support, organization, documentCategory)
                })
            })

            it('employee with canManageDocuments can', async () => {
                const [createdDocument] = await createTestDocument(employeeUserWithDocumentPermissions, organization, documentCategory)

                expect(createdDocument.id).toMatch(UUID_RE)
                expect(createdDocument.organization.id).toEqual(organization.id)
                expect(createdDocument.category.id).toEqual(documentCategory.id)
            })

            it('employee with canManageDocuments in several organizations can', async () => {
                const [otherOrganization] = await createTestOrganization(admin)
                const [otherRole] = await createTestOrganizationEmployeeRole(admin, otherOrganization, {
                    canManageDocuments: true,
                    canReadDocuments: true,
                })
                await createTestOrganizationEmployee(admin, otherOrganization, employeeUserWithDocumentPermissions.user, otherRole)
                const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

                const documents = await Document.createMany(employeeUserWithDocumentPermissions, [
                    {
                        data: {
                            dv: 1,
                            sender,
                            organization: { connect: { id: organization.id } },
                            category: { connect: { id: documentCategory.id } },
                            file: new UploadingFile(TEST_FILE),
                        },
                    },
                    {
                        data: {
                            dv: 1,
                            sender,
                            organization: { connect: { id: otherOrganization.id } },
                            category: { connect: { id: documentCategory.id } },
                            file: new UploadingFile(TEST_FILE),
                        },
                    },
                ])

                expect(documents).toHaveLength(2)
                expect(documents).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({
                            organization: expect.objectContaining({ id: organization.id }),
                        }),
                        expect.objectContaining({
                            organization: expect.objectContaining({ id: otherOrganization.id }),
                        }),
                    ])
                )
            })

            it('employee without canManageDocuments can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestDocument(employeeUserWithoutDocumentPermissions, organization, documentCategory)
                })
            })

            it('user without employee can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestDocument(notEmployeeUser, organization, documentCategory)
                })
            })

            it('employee can not create Document to property in other organization', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestDocument(employeeUserInOtherOrganization, organization, documentCategory)
                })
            })
        })

        describe('Read', () => {
            it('anonymous can not', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Document.getOne(anonymous, { id: document.id })
                })
            })

            it('admin can', async () => {
                const readDocument = await Document.getOne(admin, { id: document.id })

                expect(readDocument.id).toMatch(document.id)
            })

            it('support can not', async () => {
                const readDocument = await Document.getOne(support, { id: document.id })

                expect(readDocument).toBeUndefined()
            })

            it('employee with canReadDocuments can', async () => {
                const readDocument = await Document.getOne(employeeUserWithDocumentPermissions, { id: document.id })

                expect(readDocument.id).toMatch(document.id)
            })

            it('employee without canReadDocuments can not', async () => {
                const readDocument = await Document.getOne(employeeUserWithoutDocumentPermissions, { id: document.id })

                expect(readDocument).toBeUndefined()
            })

            it('user without employee can not', async () => {
                const readDocument = await Document.getOne(notEmployeeUser, { id: document.id })

                expect(readDocument).toBeUndefined()
            })

            it('employee with canReadDocuments can not read Document to property in other organization', async () => {
                const readDocument = await Document.getOne(employeeUserInOtherOrganization, { id: document.id })

                expect(readDocument).toBeUndefined()
            })
        })

        describe('Update', () => {
            it('anonymous can not', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestDocument(anonymous, document.id, {})
                })
            })

            it('admin can', async () => {
                const [createdDocument] = await createTestDocument(admin, organization, documentCategory)
                const [otherCategory] = await createTestDocumentCategory(admin)

                const [updatedDocument] = await updateTestDocument(admin, createdDocument.id, {
                    category: { connect: { id: otherCategory.id } },
                })

                expect(updatedDocument.category.id).toEqual(otherCategory.id)
            })

            it('support can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestDocument(support, document.id, {})
                })
            })

            it('employee with canManageDocuments can not update property', async () => {
                const [createdDocument] = await createTestDocument(admin, organization, documentCategory)
                const [otherProperty] = await createTestProperty(admin, organization)
                const [otherCategory] = await createTestDocumentCategory(admin)

                const [updatedDocument] = await updateTestDocument(employeeUserWithDocumentPermissions, createdDocument.id, {
                    category: { connect: { id: otherCategory.id } },
                })

                expect(updatedDocument.category.id).toEqual(otherCategory.id)
                await catchErrorFrom(async () => {
                    await updateTestDocument(employeeUserWithDocumentPermissions, document.id, {
                        property: { connect: { id: otherProperty.id } },
                    })
                }, (e) => {
                    expect(e.errors[0].message).toContain('Field "property" is not defined by type "DocumentUpdateInput"')
                })
            })

            it('employee with canManageDocuments in several organizations can', async () => {
                const [otherOrganization] = await createTestOrganization(admin)
                const [otherRole] = await createTestOrganizationEmployeeRole(admin, otherOrganization, {
                    canManageDocuments: true,
                    canReadDocuments: true,
                })
                await createTestOrganizationEmployee(admin, otherOrganization, employeeUserWithDocumentPermissions.user, otherRole)
                const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

                const [firstDocument] = await createTestDocument(employeeUserWithDocumentPermissions, organization, documentCategory)
                const [secondDocument] = await createTestDocument(employeeUserWithDocumentPermissions, otherOrganization, documentCategory)

                const [otherCategory] = await createTestDocumentCategory(admin)

                const updatedDocuments = await Document.updateMany(employeeUserWithDocumentPermissions, [
                    {
                        id: firstDocument.id,
                        data: {
                            dv: 1,
                            sender,
                            category: { connect: { id: otherCategory.id } },
                        },
                    },
                    {
                        id: secondDocument.id,
                        data: {
                            dv: 1,
                            sender,
                            category: { connect: { id: otherCategory.id } },
                        },
                    },
                ])

                expect(updatedDocuments).toHaveLength(2)
                expect(updatedDocuments).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({
                            id: firstDocument.id,
                            category: expect.objectContaining({ id: otherCategory.id }),
                        }),
                        expect.objectContaining({
                            id: secondDocument.id,
                            category: expect.objectContaining({ id: otherCategory.id }),
                        }),
                    ])
                )
            })

            it('employee without canManageDocuments can not', async () => {
                const [otherCategory] = await createTestDocumentCategory(admin)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestDocument(employeeUserWithoutDocumentPermissions, document.id, {
                        category: { connect: { id: otherCategory.id } },
                    })
                })
            })

            it('user without employee can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestDocument(notEmployeeUser, document.id, {})
                })
            })

            it('employee can not update Document to property in other organization', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestDocument(employeeUserInOtherOrganization, document.id, {})
                })
            })
        })

        describe('Soft delete', () => {
            it('anonymous can not', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await softDeleteTestDocument(anonymous, document.id)
                })
            })

            it('admin can', async () => {
                const [createdDocument] = await createTestDocument(admin, organization, documentCategory)
                const [deletedDocument] = await softDeleteTestDocument(admin, createdDocument.id)

                expect(deletedDocument.deletedAt).toBeDefined()
            })

            it('support can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await softDeleteTestDocument(support, document.id)
                })
            })

            it('employee with canManageDocuments can', async () => {
                const [createdDocument] = await createTestDocument(employeeUserWithDocumentPermissions, organization, documentCategory)
                const [deletedDocument] = await softDeleteTestDocument(employeeUserWithDocumentPermissions, createdDocument.id)

                expect(deletedDocument.deletedAt).toBeDefined()
            })

            it('employee without canManageDocuments can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await softDeleteTestDocument(employeeUserWithoutDocumentPermissions, document.id)
                })
            })

            it('user without employee can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await softDeleteTestDocument(notEmployeeUser, document.id)
                })
            })

            it('employee can not soft delete Document to property in other organization', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await softDeleteTestDocument(employeeUserInOtherOrganization, document.id)
                })
            })
        })
    })

    describe('Validations', () => {
        it('Can not create document with property organization different to document organization', async () => {
            const [otherOrganization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, otherOrganization)

            await expectToThrowGQLError(async () => {
                await createTestDocument(admin, organization, documentCategory, {
                    property: { connect: { id: property.id } },
                })

            }, ERRORS.WRONG_PROPERTY_ORGANIZATION)
        })
    })
})
