/**
 * Generated by `createschema document.Document 'organization:Relationship:Organization:CASCADE; property?:Relationship:Property:CASCADE; category:Relationship:DocumentCategory:CASCADE; file:File;'`
 */

const path = require('path')

const { faker } = require('@faker-js/faker')

const conf = require('@open-condo/config')
const { FileRecord } = require('@open-condo/files/schema/utils/testSchema')
const {
    makeLoggedInAdminClient,
    makeClient,
    UUID_RE,
    expectToThrowGQLError,
    catchErrorFrom,
    getUploadingFile,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { ERRORS } = require('@condo/domains/document/constants')
const {
    Document,
    createTestDocument,
    updateTestDocument,
    createTestDocumentCategory,
    softDeleteTestDocument,
} = require('@condo/domains/document/utils/testSchema')
const { createTestOrganization,  createTestOrganizationEmployeeRole, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { createTestResident } = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
} = require('@condo/domains/user/utils/testSchema')


const TEST_FILE = path.resolve(conf.PROJECT_ROOT, 'apps/condo/domains/common/test-assets/dino.png')

describe('Document', () => {
    let admin, support, anonymous, employeeUserWithDocumentPermissions, employeeUserWithoutDocumentPermissions, employeeUserInOtherOrganization, notEmployeeUser,
        organization, documentCategory, document

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
        employeeUserWithDocumentPermissions = await makeClientWithNewRegisteredAndLoggedInUser()
        employeeUserWithoutDocumentPermissions = await makeClientWithNewRegisteredAndLoggedInUser()
        employeeUserInOtherOrganization = await makeClientWithNewRegisteredAndLoggedInUser()
        notEmployeeUser = await makeClientWithNewRegisteredAndLoggedInUser()

        const [testOrganization] = await createTestOrganization(admin)
        const [testOtherOrganization] = await createTestOrganization(admin)
        const [roleWithAccess] = await createTestOrganizationEmployeeRole(admin, testOrganization, { canManageDocuments: true, canReadDocuments: true })
        const [roleWithoutAccess] = await createTestOrganizationEmployeeRole(admin, testOrganization, { canManageDocuments: false, canReadDocuments: false })
        const [roleWithCanAccessInOtherOrganization] = await createTestOrganizationEmployeeRole(admin, testOtherOrganization, { canManageDocuments: true, canReadDocuments: true })
        await createTestOrganizationEmployee(admin, testOrganization, employeeUserWithDocumentPermissions.user, roleWithAccess)
        await createTestOrganizationEmployee(admin, testOrganization, employeeUserWithoutDocumentPermissions.user, roleWithoutAccess)
        await createTestOrganizationEmployee(admin, testOtherOrganization, employeeUserInOtherOrganization.user, roleWithCanAccessInOtherOrganization)
        const [testDocumentCategory] = await createTestDocumentCategory(admin)
        const [testDocument] = await createTestDocument(admin, testOrganization, testDocumentCategory)

        organization = testOrganization
        documentCategory = testDocumentCategory
        document = testDocument
    })

    describe('Access', () => {
        describe('Create', () => {
            it('anonymous can not', async () => {
                const fileMeta = {
                    user: { id: admin.user.id },
                    fileClientId: 'condo',
                    modelNames: ['Document'],
                    dv: 1, sender: { dv: 1, fingerprint: 'test-utils' },
                }
                const file = await getUploadingFile(TEST_FILE, fileMeta, admin)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestDocument(anonymous, organization, documentCategory, { file })
                })
            })

            it('admin can', async () => {
                const [createdDocument] = await createTestDocument(admin, organization, documentCategory)

                expect(createdDocument.id).toMatch(UUID_RE)
                expect(createdDocument.organization.id).toEqual(organization.id)
                expect(createdDocument.category.id).toEqual(documentCategory.id)
                expect(createdDocument.canReadByResident).toEqual(false)
            })

            it('support can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestDocument(support, organization, documentCategory)
                })
            })

            it('employee with canManageDocuments can', async () => {
                const [createdDocument] = await createTestDocument(employeeUserWithDocumentPermissions, organization, documentCategory, {
                    canReadByResident: true,
                })

                expect(createdDocument.id).toMatch(UUID_RE)
                expect(createdDocument.organization.id).toEqual(organization.id)
                expect(createdDocument.category.id).toEqual(documentCategory.id)
                expect(createdDocument.canReadByResident).toEqual(true)
            })

            it('employee with canManageDocuments in several organizations can', async () => {
                const [otherOrganization] = await createTestOrganization(admin)
                const [otherRole] = await createTestOrganizationEmployeeRole(admin, otherOrganization, {
                    canManageDocuments: true,
                    canReadDocuments: true,
                })
                await createTestOrganizationEmployee(admin, otherOrganization, employeeUserWithDocumentPermissions.user, otherRole)
                const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

                const fileMeta = {
                    organization: { id: organization.id },
                    user: { id: employeeUserWithDocumentPermissions.user.id },
                    fileClientId: 'condo',
                    modelNames: ['Document'],
                    dv: 1, sender,
                }
                const file = await getUploadingFile(TEST_FILE, fileMeta, employeeUserWithDocumentPermissions)

                expect(file).toHaveProperty('id')
                expect(file).toHaveProperty('signature')
                expect(file).toHaveProperty('originalFilename')

                const fileRecord = await FileRecord.getOne(admin, { id: file.id })
                expect(fileRecord).toHaveProperty(['user', 'id'], employeeUserWithDocumentPermissions.user.id)
                expect(fileRecord).toHaveProperty(['organization', 'id'], organization.id)
                expect(fileRecord.attachments).toBeNull()

                const documents = await Document.createMany(employeeUserWithDocumentPermissions, [
                    {
                        data: {
                            dv: 1,
                            sender,
                            organization: { connect: { id: organization.id } },
                            category: { connect: { id: documentCategory.id } },
                            file,
                        },
                    },
                    {
                        data: {
                            dv: 1,
                            sender,
                            organization: { connect: { id: otherOrganization.id } },
                            category: { connect: { id: documentCategory.id } },
                            file,
                        },
                    },
                ])

                expect(documents).toHaveLength(2)
                expect(documents).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({
                            organization: expect.objectContaining({ id: organization.id }),
                        }),
                        expect.objectContaining({
                            organization: expect.objectContaining({ id: otherOrganization.id }),
                        }),
                    ])
                )

                const attachedFileRecords = await FileRecord.getOne(admin, { id: file.id })

                expect(attachedFileRecords.attachments.attachments).not.toHaveLength(0)
            })

            it('employee without canManageDocuments can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestDocument(employeeUserWithoutDocumentPermissions, organization, documentCategory)
                })
            })

            it('user without employee can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestDocument(notEmployeeUser, organization, documentCategory)
                })
            })

            it('employee can not create Document to property in other organization', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestDocument(employeeUserInOtherOrganization, organization, documentCategory)
                })
            })
        })

        describe('Read', () => {
            it('anonymous can not', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Document.getOne(anonymous, { id: document.id })
                })
            })

            it('admin can', async () => {
                const readDocument = await Document.getOne(admin, { id: document.id })

                expect(readDocument.id).toMatch(document.id)
            })

            it('support can not', async () => {
                const readDocument = await Document.getOne(support, { id: document.id })

                expect(readDocument).toBeUndefined()
            })

            it('employee with canReadDocuments can', async () => {
                const readDocument = await Document.getOne(employeeUserWithDocumentPermissions, { id: document.id })

                expect(readDocument.id).toMatch(document.id)
            })

            it('employee without canReadDocuments can not', async () => {
                const readDocument = await Document.getOne(employeeUserWithoutDocumentPermissions, { id: document.id })

                expect(readDocument).toBeUndefined()
            })

            it('user without employee can not', async () => {
                const readDocument = await Document.getOne(notEmployeeUser, { id: document.id })

                expect(readDocument).toBeUndefined()
            })

            it('employee with canReadDocuments can not read Document to property in other organization', async () => {
                const readDocument = await Document.getOne(employeeUserInOtherOrganization, { id: document.id })

                expect(readDocument).toBeUndefined()
            })

            describe('resident', () => {
                let organizationWithAccess, organizationWithoutAccess
                let residentClientWithAccess, residentClientWithoutAccess
                beforeAll(async () => {
                    [organizationWithAccess] = await createTestOrganization(admin);
                    [organizationWithoutAccess] = await createTestOrganization(admin)

                    const unitName1 = faker.random.alphaNumeric(4)
                    const unitName2 = unitName1 + faker.random.alphaNumeric(4)

                    const [propertyWithAccess] = await createTestProperty(admin, organizationWithAccess)
                    const [propertyWithoutAccess] = await createTestProperty(admin, organizationWithoutAccess)

                    residentClientWithAccess = await makeClientWithResidentUser()
                    residentClientWithoutAccess = await makeClientWithResidentUser()

                    await createTestResident(admin, residentClientWithAccess.user, propertyWithAccess, { unitName: unitName1 })
                    await createTestResident(admin, residentClientWithoutAccess.user, propertyWithoutAccess, { unitName: unitName2 })
                })

                it('can read documents in his organization with a flag with canReadByResident document flag', async () => {
                    const [testDocument] = await createTestDocument(admin, organizationWithAccess, documentCategory, {
                        canReadByResident: true,
                    })
                    const readDocument = await Document.getOne(residentClientWithAccess, { id: testDocument.id })

                    expect(readDocument.id).toMatch(testDocument.id)
                    expect(readDocument.canReadByResident).toBeTruthy()
                    expect(readDocument.organization.id).toEqual(testDocument.organization.id)
                })

                it('can not read documents in his organization without canReadByResident document flag', async () => {
                    const [testDocument] = await createTestDocument(admin, organizationWithAccess, documentCategory, {
                        canReadByResident: false,
                    })
                    const readDocument = await Document.getOne(residentClientWithAccess, { id: testDocument.id })

                    expect(readDocument).toBeUndefined()
                    expect(testDocument.canReadByResident).toBeFalsy()
                })

                it('can not read documents in an organization other than his own with canReadByResident document flag', async () => {
                    const [testDocument] = await createTestDocument(admin, organizationWithAccess, documentCategory, {
                        canReadByResident: true,
                    })
                    const readDocument = await Document.getOne(residentClientWithoutAccess, { id: testDocument.id })

                    expect(readDocument).toBeUndefined()
                })
            })
        })

        describe('Update', () => {
            it('anonymous can not', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestDocument(anonymous, document.id, {})
                })
            })

            it('admin can', async () => {
                const [createdDocument] = await createTestDocument(admin, organization, documentCategory)
                const [otherCategory] = await createTestDocumentCategory(admin)

                const [updatedDocument] = await updateTestDocument(admin, createdDocument.id, {
                    category: { connect: { id: otherCategory.id } },
                })

                expect(updatedDocument.category.id).toEqual(otherCategory.id)
            })

            it('support can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestDocument(support, document.id, {})
                })
            })

            it('employee with canManageDocuments can not update property', async () => {
                const [createdDocument] = await createTestDocument(admin, organization, documentCategory)
                const [otherProperty] = await createTestProperty(admin, organization)
                const [otherCategory] = await createTestDocumentCategory(admin)

                const [updatedDocument] = await updateTestDocument(employeeUserWithDocumentPermissions, createdDocument.id, {
                    category: { connect: { id: otherCategory.id } },
                })

                expect(updatedDocument.category.id).toEqual(otherCategory.id)
                await catchErrorFrom(async () => {
                    await updateTestDocument(employeeUserWithDocumentPermissions, document.id, {
                        property: { connect: { id: otherProperty.id } },
                    })
                }, (e) => {
                    expect(e.errors[0].message).toContain('Field "property" is not defined by type "DocumentUpdateInput"')
                })
            })

            it('employee with canManageDocuments in several organizations can', async () => {
                const [otherOrganization] = await createTestOrganization(admin)
                const [otherRole] = await createTestOrganizationEmployeeRole(admin, otherOrganization, {
                    canManageDocuments: true,
                    canReadDocuments: true,
                })
                await createTestOrganizationEmployee(admin, otherOrganization, employeeUserWithDocumentPermissions.user, otherRole)
                const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

                const [firstDocument] = await createTestDocument(employeeUserWithDocumentPermissions, organization, documentCategory)
                const [secondDocument] = await createTestDocument(employeeUserWithDocumentPermissions, otherOrganization, documentCategory)

                const [otherCategory] = await createTestDocumentCategory(admin)

                const updatedDocuments = await Document.updateMany(employeeUserWithDocumentPermissions, [
                    {
                        id: firstDocument.id,
                        data: {
                            dv: 1,
                            sender,
                            category: { connect: { id: otherCategory.id } },
                        },
                    },
                    {
                        id: secondDocument.id,
                        data: {
                            dv: 1,
                            sender,
                            category: { connect: { id: otherCategory.id } },
                        },
                    },
                ])

                expect(updatedDocuments).toHaveLength(2)
                expect(updatedDocuments).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({
                            id: firstDocument.id,
                            category: expect.objectContaining({ id: otherCategory.id }),
                        }),
                        expect.objectContaining({
                            id: secondDocument.id,
                            category: expect.objectContaining({ id: otherCategory.id }),
                        }),
                    ])
                )
            })

            it('employee without canManageDocuments can not', async () => {
                const [otherCategory] = await createTestDocumentCategory(admin)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestDocument(employeeUserWithoutDocumentPermissions, document.id, {
                        category: { connect: { id: otherCategory.id } },
                    })
                })
            })

            it('user without employee can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestDocument(notEmployeeUser, document.id, {})
                })
            })

            it('employee can not update Document to property in other organization', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestDocument(employeeUserInOtherOrganization, document.id, {})
                })
            })
        })

        describe('Soft delete', () => {
            it('anonymous can not', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await softDeleteTestDocument(anonymous, document.id)
                })
            })

            it('admin can', async () => {
                const [createdDocument] = await createTestDocument(admin, organization, documentCategory)
                const [deletedDocument] = await softDeleteTestDocument(admin, createdDocument.id)

                expect(deletedDocument.deletedAt).toBeDefined()
            })

            it('support can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await softDeleteTestDocument(support, document.id)
                })
            })

            it('employee with canManageDocuments can', async () => {
                const [createdDocument] = await createTestDocument(employeeUserWithDocumentPermissions, organization, documentCategory)
                const [deletedDocument] = await softDeleteTestDocument(employeeUserWithDocumentPermissions, createdDocument.id)

                expect(deletedDocument.deletedAt).toBeDefined()
            })

            it('employee without canManageDocuments can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await softDeleteTestDocument(employeeUserWithoutDocumentPermissions, document.id)
                })
            })

            it('user without employee can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await softDeleteTestDocument(notEmployeeUser, document.id)
                })
            })

            it('employee can not soft delete Document to property in other organization', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await softDeleteTestDocument(employeeUserInOtherOrganization, document.id)
                })
            })
        })
    })

    describe('Validations', () => {
        it('Can not create document with property organization different to document organization', async () => {
            const [otherOrganization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, otherOrganization)

            await expectToThrowGQLError(async () => {
                await createTestDocument(admin, organization, documentCategory, {
                    property: { connect: { id: property.id } },
                })

            }, ERRORS.WRONG_PROPERTY_ORGANIZATION)
        })
    })
})
