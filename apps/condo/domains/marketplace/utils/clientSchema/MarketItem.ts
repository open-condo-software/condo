/**
 * Generated by `createschema marketplace.MarketItem 'name:Text; marketCategory:Relationship:MarketCategory:SET_NULL; sku:Text; description:Text; organization:Relationship:Organization:CASCADE;'`
 */

import {
    InvoiceContext,
    MarketItem,
    MarketItemCreateInput, MarketItemFile, MarketItemPrice, MarketItemPriceCreateInput,
    MarketItemUpdateInput, MarketPriceScope, MarketPriceScopeCreateInput,
    QueryAllMarketItemsArgs,
} from '@app/condo/schema'
import { get } from 'lodash'
import isUndefined from 'lodash/isUndefined'

import { generateReactHooks } from '@open-condo/codegen/generate.hooks'

import { UploadFileType } from '@condo/domains/common/components/ImagesUploadList'
import { MarketItem as MarketItemGQL } from '@condo/domains/marketplace/gql'


const RELATIONS = ['marketCategory']
const DISCONNECT_ON_NULL = []
const IGNORE_FORM_FIELDS = ['parentCategory']

export enum PriceType {
    Exact = 'exact',
    Min = 'min',
    Contract = 'contract',
}

export type PriceFormValuesType = {
    properties?: string[]
    priceType?: PriceType
    price?: string
    hasAllProperties?: boolean
    id?: string
}

export type MarketItemFormValuesType = {
    name?: string
    sku?: string
    parentCategory?: string
    marketCategory?: string
    description?: string
    files?: UploadFileType[]
    prices?: PriceFormValuesType[]
    selectedProperties?: string[]
}

type ConvertToFormStateArgsType = {
    marketItem: MarketItem,
    marketItemPrices: MarketItemPrice[]
    marketPriceScopes: MarketPriceScope[]
    marketItemFiles: MarketItemFile[]
}

export function convertToFormState ({ marketItem, marketItemPrices, marketPriceScopes, marketItemFiles }: ConvertToFormStateArgsType): MarketItemFormValuesType {
    const result: MarketItemFormValuesType = {}

    for (const key of Object.keys(marketItem)) {
        const relationId = get(marketItem[key], 'id')

        result[key] = relationId || marketItem[key]

        if (key === 'marketCategory') {
            result['marketCategoryName'] = get(marketItem, 'marketCategory.name')
            result['parentCategory'] = get(marketItem, 'marketCategory.parentCategory.id')
        }
    }

    const prices = []
    for (const marketItemPrice of marketItemPrices) {
        const id = marketItemPrice.id
        const priceScopes = marketPriceScopes.filter(scope => scope.marketItemPrice.id === marketItemPrice.id)
        const properties = priceScopes.map(priceScope => get(priceScope, 'property.id')).filter(Boolean)
        const hasAllProperties = priceScopes.length === 1 && !priceScopes[0].property

        const [priceObj] = get(marketItemPrice, 'price')
        const priceFromObj = get(priceObj, 'price')
        const isMinPrice = get(priceObj, 'isMin')

        let priceType
        let price
        if (isMinPrice) {
            priceType = priceFromObj === '0' ? PriceType.Contract : PriceType.Min
            price = priceFromObj === '0' ? null : priceFromObj
        } else {
            priceType = PriceType.Exact
            price = priceFromObj
        }

        prices.push({ id, priceType, price, properties, hasAllProperties })
    }

    result['prices'] = prices

    result['files'] = marketItemFiles.map(fileObj => ({
        uid: get(fileObj, 'id'),
        name: get(fileObj, 'file.originalFilename'),
        status: 'done',
        url: get(fileObj, 'file.publicUrl'),
        response: { id: get(fileObj, 'id') },
    }))

    return result
}

type MarketItemMutationType = MarketItemUpdateInput | MarketItemCreateInput

export function formValuesProcessor (formValues: MarketItemFormValuesType): MarketItemMutationType {
    const result: MarketItemMutationType = {}

    for (const key of Object.keys(formValues)) {
        if (IGNORE_FORM_FIELDS.includes(key)) continue
        const isRelation = RELATIONS.includes(key)

        if (isRelation) {
            if (DISCONNECT_ON_NULL.includes(key) && formValues[key] === null) {
                result[key] = { disconnectAll: true }
            } else if (formValues[key]) {
                result[key] = { connect: { id: formValues[key] } }
            }
        } else if (!isUndefined(formValues[key])) {
            result[key] = formValues[key]
        }
    }

    return result
}

export function formatFormPricesField (prices): PriceFormValuesType[] {
    return prices.map(
        priceObj => ({ ...priceObj, price: priceObj.price?.replace(',', '.') })
    )
}

export function getPriceValueFromFormPrice ({ priceType, price }) {
    let resultPrice
    let isMin
    if (priceType === PriceType.Exact) {
        resultPrice = price
        isMin = false
    } else if (priceType === PriceType.Min) {
        resultPrice = price
        isMin = true
    } else if (priceType === PriceType.Contract) {
        resultPrice = '0'
        isMin = true
    }

    return { price: resultPrice, isMin }
}

type CreateNewPricesAndPriceScopesArgType = {
    marketItem: MarketItem
    prices: PriceFormValuesType[]
    invoiceContext: InvoiceContext
    createMarketItemPrice: (data: MarketItemPriceCreateInput) => Promise<MarketItemPrice>
    createMarketPriceScope: (data: MarketPriceScopeCreateInput) => Promise<MarketPriceScope>
}

export async function createNewPricesAndPriceScopes ({
    marketItem,
    prices,
    invoiceContext,
    createMarketItemPrice,
    createMarketPriceScope,
}: CreateNewPricesAndPriceScopesArgType) {
    for (const formPrice of prices) {
        const { properties, hasAllProperties, price, priceType } = formPrice

        const vatPercent = get(invoiceContext, 'vatPercent')
        const salesTaxPercent = get(invoiceContext, 'salesTaxPercent')
        const currencyCode = get(invoiceContext, 'currencyCode')
        const { price: resultPrice, isMin } = getPriceValueFromFormPrice({ priceType, price })

        const createdPrice = await createMarketItemPrice({
            price: [{ type: 'variant', group: '', name: marketItem.name,
                price: resultPrice, isMin, vatPercent, salesTaxPercent, currencyCode }],
            marketItem: { connect: { id: marketItem.id } },
        })

        if (hasAllProperties) {
            await createMarketPriceScope({
                marketItemPrice: { connect: { id: createdPrice.id } },
            })
        } else {
            for (const propertyId of properties ) {
                await createMarketPriceScope({
                    marketItemPrice: { connect: { id: createdPrice.id } },
                    property: { connect: { id: propertyId } },
                })
            }
        }
    }
}

export const INITIAL_PRICE_FORM_VALUE = { properties: [], priceType: PriceType.Exact }

const {
    useObject,
    useObjects,
    useCreate,
    useUpdate,
    useSoftDelete,
    useCount,
} = generateReactHooks<MarketItem, MarketItemCreateInput, MarketItemUpdateInput, QueryAllMarketItemsArgs>(MarketItemGQL)

export {
    useObject,
    useObjects,
    useCreate,
    useUpdate,
    useSoftDelete,
    useCount,
}
