/**
 * Generated by `createschema marketplace.Invoice 'number:Integer; property:Relationship:Property:PROTECT; unitType:Text; unitName:Text; accountNumber:Text; toPay:Decimal; items:Json; contact?:Relationship:Contact:SET_NULL; client?:Relationship:User:SET_NULL; clientName?:Text; clientPhone?:Text; clientEmail?:Text'`
 */

const { get } = require('lodash')

const { throwAuthenticationError } = require('@open-condo/keystone/apolloErrorFormatter')
const { getLogger } = require('@open-condo/keystone/logging')
const { getById, find } = require('@open-condo/keystone/schema')

const { INVOICE_STATUS_PUBLISHED } = require('@condo/domains/marketplace/constants')
const {
    queryOrganizationEmployeeFor,
    queryOrganizationEmployeeFromRelatedOrganizationFor,
    checkPermissionInUserOrganizationOrRelatedOrganization,
} = require('@condo/domains/organization/utils/accessSchema')
const { RESIDENT } = require('@condo/domains/user/constants/common')

const logger = getLogger('invoiceAccess')

async function canReadInvoices ({ authentication: { item: user }, context }) {
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false

    if (user.isAdmin || user.isSupport) return {}

    if (user.type === RESIDENT) {
        const residents = await find('Resident', { deletedAt: null, user: { id: user.id } })

        if (residents.length === 0) {
            return false
        }

        if (residents.length > 50) {
            logger.warn({
                msg: `user ${user.id} has ${residents.length} residents`,
                reqId: context.req.id,
                userId: user.id,
            })
        }

        const serviceConsumers = await find('ServiceConsumer', {
            deletedAt: null,
            resident: { id_in: residents.map(({ id }) => id) },
        })

        if (serviceConsumers.length > 50) {
            logger.warn({
                msg: `user ${user.id} has ${serviceConsumers.length} service consumers`,
                reqId: context.req.id,
                userId: user.id,
            })
        }

        return {
            deletedAt: null,
            status: INVOICE_STATUS_PUBLISHED,
            OR: [
                ...residents.map((resident) => ({ AND: [{ property: { addressKey: resident.addressKey } }, { unitType: resident.unitType }, { unitName: resident.unitName }] })),
                ...serviceConsumers.map((serviceConsumer) => ({ AND: [{ context: { organization: { id: serviceConsumer.organization } } }, { accountNumber: serviceConsumer.accountNumber }] })),
            ],
        }

    }

    return {
        context: {
            organization: {
                OR: [
                    queryOrganizationEmployeeFor(user.id, 'canReadInvoices'),
                    queryOrganizationEmployeeFromRelatedOrganizationFor(user.id, 'canReadInvoices'),
                ],
                deletedAt: null,
            },
        },
        deletedAt: null,
    }
}

async function canManageInvoices ({ authentication: { item: user }, originalInput, operation, itemId }) {
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false
    if (user.isAdmin || user.isSupport) return true
    if (user.type === RESIDENT) return false

    let contextId

    if (operation === 'create') {
        contextId = get(originalInput, ['context', 'connect', 'id'])
    } else if (operation === 'update') {
        if (!itemId) return false
        const item = await getById('Invoice', itemId)
        contextId = get(item, 'context')
    }

    const context = await getById('InvoiceContext', contextId)
    const organizationId = get(context, 'organization')

    if (!organizationId) return false

    return await checkPermissionInUserOrganizationOrRelatedOrganization(user.id, organizationId, 'canManageInvoices')
}

/*
  Rules are logical functions that used for list access, and may return a boolean (meaning
  all or no items are available) or a set of filters that limit the available items.
*/
module.exports = {
    canReadInvoices,
    canManageInvoices,
}
