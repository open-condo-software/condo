/**
 * Generated by `createschema marketplace.InvoiceWebhookDelivery 'invoice:Relationship:Invoice:CASCADE; ...'`
 */

const dayjs = require('dayjs')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectValuesOfCommonFields,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    createTestAcquiringIntegration,
    createTestAcquiringIntegrationContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBillingIntegration } = require('@condo/domains/billing/utils/testSchema')
const {
    INVOICE_STATUS_DRAFT,
    INVOICE_STATUS_PUBLISHED,
    INVOICE_STATUS_PAID,
    INVOICE_STATUS_CANCELED,
    INVOICE_WEBHOOK_DELIVERY_STATUS_PENDING,
    INVOICE_WEBHOOK_DELIVERY_STATUS_SUCCESS,
    INVOICE_WEBHOOK_DELIVERY_STATUS_FAILED,
    INVOICE_WEBHOOK_DELIVERY_TTL_DAYS,
} = require('@condo/domains/marketplace/constants')
const {
    createTestInvoice,
    updateTestInvoice,
    createTestInvoiceWebhookDelivery,
    updateTestInvoiceWebhookDelivery,
    InvoiceWebhookDelivery,
} = require('@condo/domains/marketplace/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
} = require('@condo/domains/user/utils/testSchema')

let adminClient, supportClient, anonymousClient
let dummyOrganization, dummyAcquiringIntegration

describe('InvoiceWebhookDelivery', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        anonymousClient = await makeClient();

        [dummyOrganization] = await createTestOrganization(adminClient)
        await createTestBillingIntegration(adminClient);
        [dummyAcquiringIntegration] = await createTestAcquiringIntegration(adminClient)
        await createTestAcquiringIntegrationContext(adminClient, dummyOrganization, dummyAcquiringIntegration, {
            invoiceStatus: CONTEXT_FINISHED_STATUS,
        })
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [obj, attrs] = await createTestInvoiceWebhookDelivery(adminClient, invoice, {
                    previousStatus: null,
                    newStatus: INVOICE_STATUS_PUBLISHED,
                })

                expectValuesOfCommonFields(obj, attrs, adminClient)
                expect(obj.status).toBe(INVOICE_WEBHOOK_DELIVERY_STATUS_PENDING)
                expect(obj.attempt).toBe(0)
                expect(obj.invoice.id).toBe(invoice.id)
            })

            test('support can', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [obj, attrs] = await createTestInvoiceWebhookDelivery(supportClient, invoice)

                expectValuesOfCommonFields(obj, attrs, supportClient)
            })

            test('staff with canManageInvoices permission can', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [obj, attrs] = await createTestInvoiceWebhookDelivery(client, invoice)

                expectValuesOfCommonFields(obj, attrs, client)
            })

            test('staff without permission can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestInvoiceWebhookDelivery(client, invoice)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestInvoiceWebhookDelivery(anonymousClient, { id: 'does-not-matter' })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [objCreated] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                const [obj, attrs] = await updateTestInvoiceWebhookDelivery(adminClient, objCreated.id, {
                    status: INVOICE_WEBHOOK_DELIVERY_STATUS_SUCCESS,
                    attempt: 1,
                    httpStatusCode: 200,
                    responseBody: '{"received": true}',
                })

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
                expect(obj.status).toBe(INVOICE_WEBHOOK_DELIVERY_STATUS_SUCCESS)
                expect(obj.httpStatusCode).toBe(200)
            })

            test('support can', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [objCreated] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                const [obj, attrs] = await updateTestInvoiceWebhookDelivery(supportClient, objCreated.id, {
                    status: INVOICE_WEBHOOK_DELIVERY_STATUS_FAILED,
                    errorMessage: 'Connection refused',
                })

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: supportClient.user.id }))
            })

            test('staff with permission can', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [objCreated] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                const [obj, attrs] = await updateTestInvoiceWebhookDelivery(client, objCreated.id, {
                    attempt: 2,
                })

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            })

            test('staff without permission can\'t', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, o10n, client.user, role)

                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [objCreated] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestInvoiceWebhookDelivery(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [objCreated] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestInvoiceWebhookDelivery(anonymousClient, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [objCreated] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await InvoiceWebhookDelivery.delete(adminClient, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [objCreated] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await InvoiceWebhookDelivery.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [objCreated] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await InvoiceWebhookDelivery.delete(anonymousClient, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [obj] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                const objs = await InvoiceWebhookDelivery.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('support can', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [obj] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                const objs = await InvoiceWebhookDelivery.getAll(supportClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('staff with canReadInvoices permission can', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canReadInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                const [objCreated] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

                const objs = await InvoiceWebhookDelivery.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: objCreated.id,
                    }),
                ]))
            })

            test('staff without permission can\'t read', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
                await createTestInvoiceWebhookDelivery(adminClient, invoice)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canReadInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                const objs = await InvoiceWebhookDelivery.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs).toHaveLength(0)
            })

            test('each staff user can read only deliveries for his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                await createTestAcquiringIntegrationContext(adminClient, o10n1, dummyAcquiringIntegration, {
                    invoiceStatus: CONTEXT_FINISHED_STATUS,
                })
                await createTestAcquiringIntegrationContext(adminClient, o10n2, dummyAcquiringIntegration, {
                    invoiceStatus: CONTEXT_FINISHED_STATUS,
                })

                const [invoice1] = await createTestInvoice(adminClient, o10n1, { status: INVOICE_STATUS_PUBLISHED })
                const [invoice2] = await createTestInvoice(adminClient, o10n2, { status: INVOICE_STATUS_PUBLISHED })

                const [delivery1] = await createTestInvoiceWebhookDelivery(adminClient, invoice1)
                const [delivery2] = await createTestInvoiceWebhookDelivery(adminClient, invoice2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                const objs1 = await InvoiceWebhookDelivery.getAll(client1, {}, { sortBy: ['updatedAt_DESC'] })
                const objs2 = await InvoiceWebhookDelivery.getAll(client2, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs1).toEqual([expect.objectContaining({ id: delivery1.id })])
                expect(objs2).toEqual([expect.objectContaining({ id: delivery2.id })])
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await InvoiceWebhookDelivery.getAll(anonymousClient, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('Schema fields', () => {
        test('should set default expiresAt based on TTL_DAYS', async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
            const [delivery] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

            const expiresAt = dayjs(delivery.expiresAt)
            const expectedExpiry = dayjs().add(INVOICE_WEBHOOK_DELIVERY_TTL_DAYS, 'day')

            // Check expiresAt is approximately TTL_DAYS from now (within 5 minutes)
            expect(Math.abs(expiresAt.diff(expectedExpiry, 'minute'))).toBeLessThan(5)
        })

        test('should set default nextRetryAt to now', async () => {
            const beforeCreate = dayjs()
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
            const [delivery] = await createTestInvoiceWebhookDelivery(adminClient, invoice)
            const afterCreate = dayjs()

            const nextRetryAt = dayjs(delivery.nextRetryAt)

            expect(nextRetryAt.isAfter(beforeCreate.subtract(1, 'second'))).toBe(true)
            expect(nextRetryAt.isBefore(afterCreate.add(1, 'second'))).toBe(true)
        })

        test('should store previousStatus and newStatus', async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
            const [delivery] = await createTestInvoiceWebhookDelivery(adminClient, invoice, {
                previousStatus: INVOICE_STATUS_PUBLISHED,
                newStatus: INVOICE_STATUS_PAID,
            })

            expect(delivery.previousStatus).toBe(INVOICE_STATUS_PUBLISHED)
            expect(delivery.newStatus).toBe(INVOICE_STATUS_PAID)
        })

        test('should allow storing error information', async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
            const [delivery] = await createTestInvoiceWebhookDelivery(adminClient, invoice)

            const [updatedDelivery] = await updateTestInvoiceWebhookDelivery(adminClient, delivery.id, {
                status: INVOICE_WEBHOOK_DELIVERY_STATUS_FAILED,
                attempt: 5,
                httpStatusCode: 500,
                errorMessage: 'Server error after 5 attempts',
            })

            expect(updatedDelivery.status).toBe(INVOICE_WEBHOOK_DELIVERY_STATUS_FAILED)
            expect(updatedDelivery.errorMessage).toBe('Server error after 5 attempts')
            expect(updatedDelivery.httpStatusCode).toBe(500)
        })
    })

    describe('Querying', () => {
        test('should filter by status', async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
            const [pendingDelivery] = await createTestInvoiceWebhookDelivery(adminClient, invoice, {
                status: INVOICE_WEBHOOK_DELIVERY_STATUS_PENDING,
            })
            const [successDelivery] = await createTestInvoiceWebhookDelivery(adminClient, invoice, {
                status: INVOICE_WEBHOOK_DELIVERY_STATUS_SUCCESS,
            })

            const pendingResults = await InvoiceWebhookDelivery.getAll(adminClient, {
                status: INVOICE_WEBHOOK_DELIVERY_STATUS_PENDING,
                invoice: { id: invoice.id },
            })
            const successResults = await InvoiceWebhookDelivery.getAll(adminClient, {
                status: INVOICE_WEBHOOK_DELIVERY_STATUS_SUCCESS,
                invoice: { id: invoice.id },
            })

            expect(pendingResults.some(d => d.id === pendingDelivery.id)).toBe(true)
            expect(successResults.some(d => d.id === successDelivery.id)).toBe(true)
        })

        test('should filter by invoice', async () => {
            const [invoice1] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
            const [invoice2] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })

            const [delivery1] = await createTestInvoiceWebhookDelivery(adminClient, invoice1)
            const [delivery2] = await createTestInvoiceWebhookDelivery(adminClient, invoice2)

            const results = await InvoiceWebhookDelivery.getAll(adminClient, {
                invoice: { id: invoice1.id },
            })

            expect(results.some(d => d.id === delivery1.id)).toBe(true)
            expect(results.some(d => d.id === delivery2.id)).toBe(false)
        })

        test('should filter by nextRetryAt for cron task', async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })

            // Create delivery due for retry
            const [dueDelivery] = await createTestInvoiceWebhookDelivery(adminClient, invoice, {
                nextRetryAt: dayjs().subtract(1, 'minute').toISOString(),
            })

            // Create delivery not yet due
            const [futureDelivery] = await createTestInvoiceWebhookDelivery(adminClient, invoice, {
                nextRetryAt: dayjs().add(1, 'hour').toISOString(),
            })

            const now = dayjs().toISOString()
            const results = await InvoiceWebhookDelivery.getAll(adminClient, {
                status: INVOICE_WEBHOOK_DELIVERY_STATUS_PENDING,
                nextRetryAt_lte: now,
                invoice: { id: invoice.id },
            })

            expect(results.some(d => d.id === dueDelivery.id)).toBe(true)
            expect(results.some(d => d.id === futureDelivery.id)).toBe(false)
        })
    })

    describe('Webhook trigger on Invoice status change', () => {
        describe('on invoice create', () => {
            test('should not create delivery for draft invoice without callback URL', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    status: INVOICE_STATUS_DRAFT,
                })

                const deliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                })

                expect(deliveries).toHaveLength(0)
            })

            test('should not create delivery for draft invoice with callback URL', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    status: INVOICE_STATUS_DRAFT,
                    statusChangeCallbackUrl: 'https://example.com/webhook',
                })

                const deliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                })

                // Draft status on create should not trigger webhook
                expect(deliveries).toHaveLength(0)
            })

            test('should create delivery for published invoice with callback URL', async () => {
                const callbackUrl = 'https://example.com/webhook/published'
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    status: INVOICE_STATUS_PUBLISHED,
                    statusChangeCallbackUrl: callbackUrl,
                })

                const deliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                })

                expect(deliveries).toHaveLength(1)
                expect(deliveries[0].previousStatus).toBeNull()
                expect(deliveries[0].newStatus).toBe(INVOICE_STATUS_PUBLISHED)
                expect(deliveries[0].callbackUrl).toBe(callbackUrl)
                expect(deliveries[0].status).toBe(INVOICE_WEBHOOK_DELIVERY_STATUS_PENDING)
            })
        })

        describe('on invoice update', () => {
            test('should not create delivery when status does not change', async () => {
                const callbackUrl = 'https://example.com/webhook/no-change'
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    status: INVOICE_STATUS_DRAFT,
                    statusChangeCallbackUrl: callbackUrl,
                })

                // Update something other than status
                await updateTestInvoice(adminClient, invoice.id, {
                    accountNumber: 'NEW-ACCOUNT-123',
                })

                const deliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                })

                expect(deliveries).toHaveLength(0)
            })

            test('should create delivery when status changes from draft to published', async () => {
                const callbackUrl = 'https://example.com/webhook/draft-to-published'
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    status: INVOICE_STATUS_DRAFT,
                    statusChangeCallbackUrl: callbackUrl,
                })

                await updateTestInvoice(adminClient, invoice.id, {
                    status: INVOICE_STATUS_PUBLISHED,
                })

                const deliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                })

                expect(deliveries).toHaveLength(1)
                expect(deliveries[0].previousStatus).toBe(INVOICE_STATUS_DRAFT)
                expect(deliveries[0].newStatus).toBe(INVOICE_STATUS_PUBLISHED)
            })

            test('should create delivery when status changes from published to paid', async () => {
                const callbackUrl = 'https://example.com/webhook/published-to-paid'
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    status: INVOICE_STATUS_PUBLISHED,
                    statusChangeCallbackUrl: callbackUrl,
                })

                const initialDeliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                })

                await updateTestInvoice(adminClient, invoice.id, {
                    status: INVOICE_STATUS_PAID,
                })

                const deliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                })

                expect(deliveries.length).toBeGreaterThan(initialDeliveries.length)

                const paidDelivery = deliveries.find(d => d.newStatus === INVOICE_STATUS_PAID)
                expect(paidDelivery).toBeDefined()
                expect(paidDelivery.previousStatus).toBe(INVOICE_STATUS_PUBLISHED)
            })

            test('should create delivery when status changes from published to canceled', async () => {
                const callbackUrl = 'https://example.com/webhook/published-to-canceled'
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    status: INVOICE_STATUS_PUBLISHED,
                    statusChangeCallbackUrl: callbackUrl,
                })

                await updateTestInvoice(adminClient, invoice.id, {
                    status: INVOICE_STATUS_CANCELED,
                })

                const deliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                })

                const canceledDelivery = deliveries.find(d => d.newStatus === INVOICE_STATUS_CANCELED)
                expect(canceledDelivery).toBeDefined()
                expect(canceledDelivery.previousStatus).toBe(INVOICE_STATUS_PUBLISHED)
            })

            test('should not create delivery when callback URL is not set', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    status: INVOICE_STATUS_DRAFT,
                })

                await updateTestInvoice(adminClient, invoice.id, {
                    status: INVOICE_STATUS_PUBLISHED,
                })

                const deliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                })

                expect(deliveries).toHaveLength(0)
            })
        })

        describe('multiple status changes', () => {
            test('should create separate deliveries for each status change', async () => {
                const callbackUrl = 'https://example.com/webhook/multiple'
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    status: INVOICE_STATUS_DRAFT,
                    statusChangeCallbackUrl: callbackUrl,
                })

                await updateTestInvoice(adminClient, invoice.id, {
                    status: INVOICE_STATUS_PUBLISHED,
                })

                await updateTestInvoice(adminClient, invoice.id, {
                    status: INVOICE_STATUS_PAID,
                })

                const deliveries = await InvoiceWebhookDelivery.getAll(adminClient, {
                    invoice: { id: invoice.id },
                }, { sortBy: 'createdAt_ASC' })

                expect(deliveries).toHaveLength(2)

                expect(deliveries[0].previousStatus).toBe(INVOICE_STATUS_DRAFT)
                expect(deliveries[0].newStatus).toBe(INVOICE_STATUS_PUBLISHED)

                expect(deliveries[1].previousStatus).toBe(INVOICE_STATUS_PUBLISHED)
                expect(deliveries[1].newStatus).toBe(INVOICE_STATUS_PAID)
            })
        })
    })
})
