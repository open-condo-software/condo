/**
 * Generated by `createschema marketplace.Invoice 'number:Integer; property:Relationship:Property:PROTECT; unitType:Text; unitName:Text; accountNumber:Text; toPay:Decimal; items:Json; contact?:Relationship:Contact:SET_NULL; client?:Relationship:User:SET_NULL; clientName?:Text; clientPhone?:Text; clientEmail?:Text'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectValuesOfCommonFields,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { addAcquiringIntegrationAndContext } = require('@condo/domains/acquiring/utils/testSchema')
const {
    addBillingIntegrationAndContext, createTestBillingProperty,
    createRegisterBillingReceiptsPayload,
    registerBillingReceiptsByTestClient,
} = require('@condo/domains/billing/utils/testSchema')
const {
    INVOICE_STATUS_DRAFT,
    INVOICE_STATUS_PUBLISHED,
    INVOICE_STATUS_PAID,
} = require('@condo/domains/marketplace/constants')
const {
    Invoice,
    createTestInvoice,
    updateTestInvoice,
    createTestInvoiceContext,
} = require('@condo/domains/marketplace/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    makeClientWithRegisteredOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { makeClientWithProperty, createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
} = require('@condo/domains/user/utils/testSchema')

let adminClient, supportClient, anonymousClient
let dummyO10n, dummyInvoiceContext

describe('Invoice', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        anonymousClient = await makeClient()

        ;[dummyO10n] = await createTestOrganization(adminClient)
        ;[dummyInvoiceContext] = await createTestInvoiceContext(adminClient, dummyO10n)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestInvoice(adminClient, dummyInvoiceContext)
                expectValuesOfCommonFields(obj, attrs, adminClient)
                expect(obj.status).toBe(INVOICE_STATUS_DRAFT)
            })

            test('support can', async () => {
                const [obj, attrs] = await createTestInvoice(supportClient, dummyInvoiceContext)
                expectValuesOfCommonFields(obj, attrs, supportClient)
            })

            test('staff with permission can', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const [obj, attrs] = await createTestInvoice(client, dummyInvoiceContext)

                expectValuesOfCommonFields(obj, attrs, client)
            })

            test('staff without permission can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestInvoice(client, dummyInvoiceContext)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestInvoice(anonymousClient, { id: 'does-not-matter' })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)
                const [obj, attrs] = await updateTestInvoice(adminClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            })

            test('support can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const [obj, attrs] = await updateTestInvoice(supportClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: supportClient.user.id }))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const [obj, attrs] = await updateTestInvoice(client, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            })

            test('staff without permission can\'t', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, o10n, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestInvoice(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestInvoice(anonymousClient, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(adminClient, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const objs = await Invoice.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('support can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const objs = await Invoice.getAll(supportClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: objCreated.id,
                    }),
                ]))
            })

            test('staff without permission can\'t', async () => {
                await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, { canReadInvoices: false })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs).toHaveLength(0)
            })

            test('each staff user can read only his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                const [invoiceContext1] = await createTestInvoiceContext(adminClient, o10n1)
                const [invoiceContext2] = await createTestInvoiceContext(adminClient, o10n2)

                const [objCreated1] = await createTestInvoice(adminClient, invoiceContext1)
                const [objCreated2] = await createTestInvoice(adminClient, invoiceContext2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                const objs1 = await Invoice.getAll(client1, {}, { sortBy: ['updatedAt_DESC'] })
                const objs2 = await Invoice.getAll(client2, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs1).toEqual([expect.objectContaining({ id: objCreated1.id })])
                expect(objs2).toEqual([expect.objectContaining({ id: objCreated2.id })])
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('resident side', () => {
        test('resident can\'t see drafts', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                // status=draft by default
            })

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(0)
        })

        test('resident can\'t see paid invoices', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PAID,
            })

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(0)
        })

        test('resident can see invoices by address, resident from neighbor flat not', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()
            const unitName2 = faker.lorem.word()

            // client.user has the Administrator role by default after he had registered an organization

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            const [invoice] = await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName: unitName1,
                status: INVOICE_STATUS_PUBLISHED,
            })

            const residentClient1 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient1,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName: unitName1,
                })

            const residentClient2 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient2,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName: unitName2,
                })

            const invoices1 = await Invoice.getAll(residentClient1, {})
            const invoices2 = await Invoice.getAll(residentClient2, {})

            expect(invoices1).toEqual([expect.objectContaining({ id: invoice.id })])
            expect(invoices2).toHaveLength(0)
        })

        test('resident can see invoices by accountNumber', async () => {
            const client = await makeClientWithProperty()

            const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, client.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, client.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(adminClient, billingIntegrationContext, { address: client.property.address })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const accountNumber = faker.random.alphaNumeric(13)

            const now = dayjs()
            const receiptsPayload1 = {
                context: { id: billingIntegrationContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: billingProperty.address,
                        unitType,
                        unitName,
                        accountNumber,
                        year: Number(now.format('YYYY')),
                        month: Number(now.format('MM')),
                    }),
                ],
            }
            await registerBillingReceiptsByTestClient(adminClient, receiptsPayload1)

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            const [invoice] = await createTestInvoice(client, invoiceContext, {
                accountNumber,
                status: INVOICE_STATUS_PUBLISHED,
            })

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toEqual([expect.objectContaining({ id: invoice.id })])
        })

        test('resident can see both invoices: by address and by account number', async () => {
            const client = await makeClientWithProperty()

            const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, client.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, client.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(adminClient, billingIntegrationContext, { address: client.property.address })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const accountNumber = faker.random.alphaNumeric(13)

            const now = dayjs()
            const receiptsPayload1 = {
                context: { id: billingIntegrationContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: billingProperty.address,
                        unitType,
                        unitName,
                        accountNumber,
                        year: Number(now.format('YYYY')),
                        month: Number(now.format('MM')),
                    }),
                ],
            }
            await registerBillingReceiptsByTestClient(adminClient, receiptsPayload1)

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            // add invoice by account number
            const [invoice1] = await createTestInvoice(client, invoiceContext, {
                accountNumber,
                status: INVOICE_STATUS_PUBLISHED,
            })
            // add invoice by address
            const [invoice2] = await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(2)
            expect(invoices).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: invoice1.id }),
                expect.objectContaining({ id: invoice2.id }),
            ]))
        })

        test('resident can see invoices from two organizations', async () => {
            const client1 = await makeClientWithProperty()
            const client2 = await makeClientWithRegisteredOrganization()

            ;[client2.property] = await createTestProperty(client2, client2.organization, { address: client1.property.address }, false, client1.property.addressMeta)

            const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, client1.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, client1.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(adminClient, billingIntegrationContext, { address: client1.property.address })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const accountNumber = faker.random.alphaNumeric(13)

            const now = dayjs()
            const receiptsPayload = {
                context: { id: billingIntegrationContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: billingProperty.address,
                        unitType,
                        unitName,
                        accountNumber,
                        year: Number(now.format('YYYY')),
                        month: Number(now.format('MM')),
                    }),
                ],
            }
            await registerBillingReceiptsByTestClient(adminClient, receiptsPayload)

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client1.property.address,
                    addressMeta: client1.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoiceContext1] = await createTestInvoiceContext(client1, client1.organization)
            const [invoiceContext2] = await createTestInvoiceContext(client2, client2.organization)

            // add invoice by account number from 1st organization
            const [invoice1] = await createTestInvoice(client1, invoiceContext1, {
                accountNumber,
                status: INVOICE_STATUS_PUBLISHED,
            })

            // add invoice by address from 2nd organization
            const [invoice2] = await createTestInvoice(client2, invoiceContext2, {
                property: { connect: { id: client2.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(2)
            expect(invoices).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: invoice1.id }),
                expect.objectContaining({ id: invoice2.id }),
            ]))
        })
    })

    describe('validation', () => {
        test('invoice must contain address or account number', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(adminClient, dummyInvoiceContext, {
                    accountNumber: null,
                    property: null,
                    unitType: null,
                    unitName: null,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'NO_INVOICE_RECEIVERS',
                message: 'Nobody sees this invoice. You must set property+unitType+unitName or accountNumber',
                messageForUser: 'api.marketplace.invoice.error.noReceivers',
            })
        })

        test('can\'t change paid invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext, { status: INVOICE_STATUS_PAID })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id)
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INVOICE_ALREADY_PAID',
                message: 'Changing of paid invoice is forbidden',
                messageForUser: 'api.marketplace.invoice.error.alreadyPaid',
            })
        })

        test('can\'t publish invoice without rows', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext, { rows: [] })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id, { status: INVOICE_STATUS_PUBLISHED })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'EMPTY_ROWS',
                message: 'The invoice contains no rows',
                messageForUser: 'api.marketplace.invoice.error.emptyRows',
            })
        })
    })
})
