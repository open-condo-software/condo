/**
 * Generated by `createschema marketplace.Invoice 'number:Integer; property:Relationship:Property:PROTECT; unitType:Text; unitName:Text; accountNumber:Text; toPay:Decimal; items:Json; contact?:Relationship:Contact:SET_NULL; client?:Relationship:User:SET_NULL; clientName?:Text; clientPhone?:Text; clientEmail?:Text'`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const dayjs = require('dayjs')
const isSameOrAfter = require('dayjs/plugin/isSameOrAfter')
const { omit } = require('lodash')

const conf = require('@open-condo/config')
const {
    makeLoggedInAdminClient,
    makeClient,
    expectValuesOfCommonFields,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowGQLError,
    expectToThrowGraphQLRequestError, waitFor,
} = require('@open-condo/keystone/test.utils')

const { createTestAcquiringIntegration } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBillingIntegration } = require('@condo/domains/billing/utils/testSchema')
const { createTestContact } = require('@condo/domains/contact/utils/testSchema')
const {
    INVOICE_STATUS_DRAFT,
    INVOICE_STATUS_PUBLISHED,
    INVOICE_STATUS_PAID,
    INVOICE_PAYMENT_TYPE_CASH,
    INVOICE_PAYMENT_TYPE_ONLINE,
    INVOICE_STATUS_CANCELED, CLIENT_DATA_FIELDS,
} = require('@condo/domains/marketplace/constants')
const {
    Invoice,
    createTestInvoice,
    updateTestInvoice,
    generateInvoiceRow, generateInvoiceRows,
} = require('@condo/domains/marketplace/utils/testSchema')
const {
    MARKETPLACE_INVOICE_PUBLISHED_MESSAGE_TYPE,
    MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
} = require('@condo/domains/notification/constants/constants')
const { Message } = require('@condo/domains/notification/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    makeClientWithRegisteredOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { makeClientWithProperty, createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const { STATUS_IDS } = require('@condo/domains/ticket/constants/statusTransitions')
const { createTestTicket, updateTestTicket } = require('@condo/domains/ticket/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithStaffUser, createTestPhone,
} = require('@condo/domains/user/utils/testSchema')

dayjs.extend(isSameOrAfter)

let adminClient, supportClient, anonymousClient
let dummyO10n

describe('Invoice', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        anonymousClient = await makeClient()

        ;[dummyO10n] = await createTestOrganization(adminClient)
        await createTestBillingIntegration(adminClient)
        await createTestAcquiringIntegration(supportClient)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestInvoice(adminClient, dummyO10n)
                expectValuesOfCommonFields(obj, attrs, adminClient)
                expect(obj.status).toBe(INVOICE_STATUS_DRAFT)
                expect(obj.paymentType).toBe(INVOICE_PAYMENT_TYPE_ONLINE)
            })

            test('support can', async () => {
                const [obj, attrs] = await createTestInvoice(supportClient, dummyO10n)
                expectValuesOfCommonFields(obj, attrs, supportClient)
            })

            test('staff with permission can', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const [obj, attrs] = await createTestInvoice(client, dummyO10n)

                expectValuesOfCommonFields(obj, attrs, client)
            })

            test('staff without permission can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestInvoice(client, dummyO10n)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestInvoice(anonymousClient, { id: 'does-not-matter' })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyO10n)
                const [obj, attrs] = await updateTestInvoice(adminClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            })

            test('support can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyO10n)

                const [obj, attrs] = await updateTestInvoice(supportClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: supportClient.user.id }))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyO10n)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const [obj, attrs] = await updateTestInvoice(client, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            })

            test('staff without permission can\'t', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [objCreated] = await createTestInvoice(adminClient, dummyO10n)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, o10n, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestInvoice(client, objCreated.id)
                })
            })

            test('each staff user can update only his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                const [objCreated1] = await createTestInvoice(adminClient, o10n1)
                const [objCreated2] = await createTestInvoice(adminClient, o10n2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                await updateTestInvoice(client1, objCreated1.id)
                await expectToThrowAccessDeniedErrorToObj(async () => await updateTestInvoice(client1, objCreated2.id))

                await updateTestInvoice(client2, objCreated2.id)
                await expectToThrowAccessDeniedErrorToObj(async () => await updateTestInvoice(client2, objCreated1.id))
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyO10n)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestInvoice(anonymousClient, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyO10n)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(adminClient, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyO10n)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyO10n)

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyO10n)

                const objs = await Invoice.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('support can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyO10n)

                const objs = await Invoice.getAll(supportClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyO10n)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: objCreated.id,
                    }),
                ]))
            })

            test('staff without permission can\'t', async () => {
                await createTestInvoice(adminClient, dummyO10n)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, { canReadInvoices: false })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs).toHaveLength(0)
            })

            test('each staff user can read only his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                const [objCreated1] = await createTestInvoice(adminClient, o10n1)
                const [objCreated2] = await createTestInvoice(adminClient, o10n2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                const objs1 = await Invoice.getAll(client1, {}, { sortBy: ['updatedAt_DESC'] })
                const objs2 = await Invoice.getAll(client2, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs1).toEqual([expect.objectContaining({ id: objCreated1.id })])
                expect(objs2).toEqual([expect.objectContaining({ id: objCreated2.id })])
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('resident side', () => {
        test('resident can\'t see drafts and canceled invoices', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                // status=draft by default
            })

            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_CANCELED,
            })

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(0)
        })

        test('resident can see paid invoices', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PAID,
                client: { connect: { id: residentClient.user.id } },
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(1)
        })

        test('two residents in one flat: only one can see the invoice by phone', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient1 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient1,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const residentClient2 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient2,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName: unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient1.user.id } },
            })

            const invoices1 = await Invoice.getAll(residentClient1, {})
            const invoices2 = await Invoice.getAll(residentClient2, {})

            expect(invoices1).toEqual([expect.objectContaining({ id: invoice.id })])
            expect(invoices2).toHaveLength(0)
        })

        test('resident can see invoices from two organizations', async () => {
            const client1 = await makeClientWithProperty()
            const client2 = await makeClientWithRegisteredOrganization()

            ;[client2.property] = await createTestProperty(client2, client2.organization, { address: client1.property.address }, false, client1.property.addressMeta)

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client1.property.address,
                    addressMeta: client1.property.addressMeta,
                    unitType,
                    unitName,
                })

            // add invoice from 1st organization
            const [invoice1] = await createTestInvoice(client1, client1.organization, {
                property: { connect: { id: client1.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
            })

            // add invoice from 2nd organization
            const [invoice2] = await createTestInvoice(client2, client2.organization, {
                property: { connect: { id: client2.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(2)
            expect(invoices).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: invoice1.id }),
                expect.objectContaining({ id: invoice2.id }),
            ]))
        })

        test('resident can see the invoice created by staff', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const staffClient = await makeClientWithStaffUser()
            const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                canManageInvoices: true,
                canManageContacts: true,
                canReadInvoiceContexts: true,
            })
            await createTestOrganizationEmployee(adminClient, o10n, staffClient.user, role)

            const [contact] = await createTestContact(staffClient, o10n, property, {
                phone: residentClient.userAttrs.phone,
                unitType,
                unitName,
            })

            const [invoice] = await createTestInvoice(staffClient, o10n, {
                property: { connect: { id: property.id } },
                unitType,
                unitName,
                contact: { connect: { id: contact.id } },
                status: INVOICE_STATUS_PUBLISHED,
            })

            const invoices = await Invoice.getAll(residentClient, {}, { sortBy: ['updatedAt_DESC'] })

            expect(invoices).toEqual([
                expect.objectContaining({
                    id: invoice.id,
                    client: expect.objectContaining({ id: resident.user.id, name: resident.user.name }),
                }),
            ])
        })
    })

    describe('resolve hook', () => {
        describe('connect contact to Invoice', () => {
            it('create and connect contact if client data passed, but contact not passed', async () => {
                const [property] = await createTestProperty(adminClient, dummyO10n)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const clientPhone = createTestPhone()
                const clientName = faker.random.alphaNumeric(5)

                const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                    clientName, clientPhone, unitName, unitType,
                    property: { connect: { id: property.id } },
                })

                expect(invoice.contact).toBeDefined()

                const contact = invoice.contact
                expect(contact.name).toEqual(clientName)
                expect(contact.phone).toEqual(clientPhone)
                expect(contact.property.id).toEqual(property.id)
                expect(contact.unitName).toEqual(unitName)
                expect(contact.unitType).toEqual(unitType)
            })

            it('connect existed contact if contact founded by passed client data', async () => {
                const [property] = await createTestProperty(adminClient, dummyO10n)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const clientPhone = createTestPhone()
                const clientName = faker.random.alphaNumeric(5)

                const [contact] = await createTestContact(adminClient, dummyO10n, property, {
                    unitType, unitName, phone: clientPhone, name: clientName,
                })

                const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                    clientName, clientPhone, unitName, unitType,
                    property: { connect: { id: property.id } },
                })

                expect(invoice.contact).toBeDefined()
                expect(invoice.contact.id).toEqual(contact.id)
            })

            it('does not connect contact if no client data passed', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyO10n)

                expect(invoice.contact).toBeNull()
            })

            it('invoice.toPay must be a sum of rows.*.toPay', async () => {
                const [invoice, invoiceAttrs] = await createTestInvoice(adminClient, dummyO10n)
                const expectedSum = invoiceAttrs.rows.reduce((sum, {
                    toPay,
                    count,
                }) => sum.plus(Big(toPay).mul(count)), Big(0)).toFixed(8)
                expect(invoice).toHaveProperty('toPay', expectedSum)
            })
        })

        describe('The time when some status set', () => {

            test('publishedAt', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyO10n)
                expect(invoice.publishedAt).toBeNull()
                const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, { status: INVOICE_STATUS_PUBLISHED })
                expect(dayjs(updatedInvoice.publishedAt).isSameOrAfter(dayjs(invoice.createdAt))).toBe(true)
            })

            test('paidAt', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyO10n)
                expect(invoice.paidAt).toBe(null)
                const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, { status: INVOICE_STATUS_PAID })
                expect(dayjs(updatedInvoice.paidAt).isSameOrAfter(dayjs(invoice.createdAt))).toBe(true)
            })

            test('canceledAt', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyO10n)
                expect(invoice.canceledAt).toBe(null)
                const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, { status: INVOICE_STATUS_CANCELED })
                expect(dayjs(updatedInvoice.canceledAt).isSameOrAfter(dayjs(invoice.createdAt))).toBe(true)
            })
        })
    })

    describe('sending push', () => {
        test('send push after create invoice with published status', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/invoice/${invoice.id}`)
        })

        test('send push after publish invoice', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [createdInvoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_DRAFT,
                client: { connect: { id: residentClient.user.id } },
            })

            const invoice = await Invoice.update(adminClient, createdInvoice.id, {
                status: INVOICE_STATUS_PUBLISHED,
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/invoice/${invoice.id}`)
        })

        test('not send push after create invoice with no published status', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PAID,
                client: { connect: { id: residentClient.user.id } },
            })

            const messages = await Message.getAll(adminClient, {
                user: { id: residentClient.user.id },
                type: MARKETPLACE_INVOICE_PUBLISHED_MESSAGE_TYPE,
            })

            expect(messages).toHaveLength(0)
        })

        test('send push after create invoice with ticket and published status', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                isPayable: true,
                unitType,
                unitName,
                clientName: null,
                clientPhone: null,
                contact: null,
                client: { connect: { id: residentClient.user.id } },
            })
            const [invoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
                ticket: { connect: { id: ticket.id } },
                clientName: null,
                clientPhone: null,
                contact: null,
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.ticketId).toEqual(ticket.id)
            expect(messages[0].meta.data.ticketNumber).toEqual(ticket.number)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/ticket/${ticket.id}`)
        })

        test('send push after publish invoice with ticket', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                isPayable: true,
                unitType,
                unitName,
                clientName: null,
                clientPhone: null,
                contact: null,
                client: { connect: { id: residentClient.user.id } },
            })
            const [createdInvoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_DRAFT,
                client: { connect: { id: residentClient.user.id } },
                ticket: { connect: { id: ticket.id } },
                clientName: null,
                clientPhone: null,
                contact: null,
            })

            const invoice = await Invoice.update(adminClient, createdInvoice.id, {
                status: INVOICE_STATUS_PUBLISHED,
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.ticketId).toEqual(ticket.id)
            expect(messages[0].meta.data.ticketNumber).toEqual(ticket.number)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/ticket/${ticket.id}`)
        })

    })

    describe('validation', () => {

        test('can\'t change online-paid invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyO10n, {
                paymentType: INVOICE_PAYMENT_TYPE_ONLINE,
                status: INVOICE_STATUS_PAID,
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id)
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INVOICE_ALREADY_PAID',
                message: 'Changing of paid invoice is forbidden',
                messageForUser: 'api.marketplace.invoice.error.alreadyPaid',
            })
        })

        test('can change cash-paid invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyO10n, {
                paymentType: INVOICE_PAYMENT_TYPE_CASH,
                status: INVOICE_STATUS_PAID,
            })
            const [updatedObj, updatedAttrs] = await updateTestInvoice(adminClient, obj.id, { status: INVOICE_STATUS_PUBLISHED })

            expect(updatedObj.sender).toEqual(updatedAttrs.sender)
        })

        test('can\'t change canceled invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyO10n, {
                status: INVOICE_STATUS_CANCELED,
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id)
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INVOICE_ALREADY_CANCELED',
                message: 'Changing of canceled invoice is forbidden',
                messageForUser: 'api.marketplace.invoice.error.alreadyCanceled',
            })
        })

        test('can\'t publish invoice without rows', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyO10n, { rows: [] })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id, { status: INVOICE_STATUS_PUBLISHED })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'EMPTY_ROWS',
                message: 'The invoice contains no rows',
                messageForUser: 'api.marketplace.invoice.error.emptyRows',
            })
        })

        describe('invoice rows must contain necessary fields', () => {
            const necessaryFields = [
                ['name', 'String!'],
                ['toPay', 'String!'],
                ['count', 'Int!'],
                ['currencyCode', 'String!'],
                ['isMin', 'Boolean!'],
            ]

            test.each(necessaryFields)('%s', async (fieldToOmit, omittedFieldType) => {
                await expectToThrowGraphQLRequestError(async () => {
                    await createTestInvoice(adminClient, dummyO10n, {
                        rows: [omit(generateInvoiceRow(), fieldToOmit)],
                    })
                }, `Field "${fieldToOmit}" of required type "${omittedFieldType}" was not provided.`)
            })
        })

        test('invoice.rows.*.count must be 1+', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(
                    adminClient,
                    dummyO10n,
                    {
                        rows: [
                            generateInvoiceRow(),
                            generateInvoiceRow({ count: -4 }),
                        ],
                    },
                )
            }, {
                code: 'BAD_USER_INPUT',
                type: 'WRONG_COUNT',
                message: 'Count at line 2 can\'t be less than 1',
                messageForUser: 'api.marketplace.invoice.error.rows.count',
                messageInterpolation: { rowNumber: 2 },
            })
        })

        test('invoice.rows.*.toPay must be positive', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(adminClient, dummyO10n, { rows: [generateInvoiceRow({ toPay: '-4' })] })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'WRONG_PRICE',
                message: 'Price at line 1 can\'t be less than 0',
                messageForUser: 'api.marketplace.invoice.error.rows.toPay',
                messageInterpolation: { rowNumber: 1 },
            })
        })

        test(`can update status to ${INVOICE_STATUS_CANCELED} of published invoice`, async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyO10n, { status: INVOICE_STATUS_PUBLISHED })
            const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                status: INVOICE_STATUS_CANCELED,
            })

            expect(updatedInvoice.status).toEqual(INVOICE_STATUS_CANCELED)
        })

        test('can\'t edit published invoice', async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyO10n, { status: INVOICE_STATUS_PUBLISHED })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, invoice.id, { rows: generateInvoiceRows() })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'FORBID_EDIT_PUBLISHED',
                message: `Only the status ${INVOICE_STATUS_CANCELED} and ${INVOICE_STATUS_PAID} can be updated by the published invoice`,
                messageForUser: 'api.marketplace.invoice.error.editPublishedForbidden',
            })
        })

        test('can create invoice with ticket', async () => {
            const [property] = await createTestProperty(adminClient, dummyO10n)
            const unitName = faker.random.alphaNumeric(5)
            const unitType = FLAT_UNIT_TYPE
            const clientPhone = createTestPhone()
            const clientName = faker.random.alphaNumeric(5)
            const [ticket] = await createTestTicket(adminClient, dummyO10n, property, {
                unitName, unitType, clientPhone, clientName, isResidentTicket: true,
            })
            const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                ticket: { connect: { id: ticket.id } },
            })

            expect(invoice).toBeDefined()
            expect(invoice.ticket.id).toEqual(ticket.id)
            expect(invoice.property.id).toEqual(ticket.property.id)
            expect(invoice.unitName).toEqual(ticket.unitName)
            expect(invoice.unitType).toEqual(ticket.unitType)
            expect(invoice.clientPhone).toEqual(ticket.clientPhone)
            expect(invoice.clientName).toEqual(ticket.clientName)
        })

        test('can connect ticket to invoice', async () => {
            const [property] = await createTestProperty(adminClient, dummyO10n)
            const unitName = faker.random.alphaNumeric(5)
            const unitType = FLAT_UNIT_TYPE
            const clientPhone = createTestPhone()
            const clientName = faker.random.alphaNumeric(5)
            const [ticket] = await createTestTicket(adminClient, dummyO10n, property, {
                unitName, unitType, clientPhone, clientName, isResidentTicket: true,
            })

            const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                status: INVOICE_STATUS_PUBLISHED,
            })

            expect(invoice).toBeDefined()
            expect(invoice.ticket).toBeNull()
            expect(invoice.property).toBeNull()
            expect(invoice.unitName).toBeNull()
            expect(invoice.unitType).toBeNull()
            expect(invoice.clientPhone).toBeNull()
            expect(invoice.clientName).toBeNull()

            const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                ticket: { connect: { id: ticket.id } },
            })

            expect(updatedInvoice).toBeDefined()
            expect(updatedInvoice.ticket.id).toEqual(ticket.id)
            expect(updatedInvoice.property.id).toEqual(ticket.property.id)
            expect(updatedInvoice.unitName).toEqual(ticket.unitName)
            expect(updatedInvoice.unitType).toEqual(ticket.unitType)
            expect(updatedInvoice.clientPhone).toEqual(ticket.clientPhone)
            expect(updatedInvoice.clientName).toEqual(ticket.clientName)
        })

        test('can\'t update ticket for invoice with ticket', async () => {
            const [property] = await createTestProperty(adminClient, dummyO10n)
            const [ticket] = await createTestTicket(adminClient, dummyO10n, property)
            const [ticket1] = await createTestTicket(adminClient, dummyO10n, property)

            const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                ticket: { connect: { id: ticket.id } },
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, invoice.id, {
                    ticket: { connect: { id: ticket1.id } },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'FORBID_UPDATE_TICKET',
                message: 'You cannot update ticket in invoice that is already linked to the ticket',
                messageForUser: 'api.marketplace.invoice.error.forbidUpdateTicket',
            })
        })

        test('can\'t update invoice client data to other than ticket client data', async () => {
            const [property] = await createTestProperty(adminClient, dummyO10n)
            const [ticket] = await createTestTicket(adminClient, dummyO10n, property)
            const [property1] = await createTestProperty(adminClient, dummyO10n)

            const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                ticket: { connect: { id: ticket.id } },
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, invoice.id, {
                    property: { connect: { id: property1.id } },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'CLIENT_DATA_DOES_NOT_MATCH_TICKET',
                message: `Fields ${CLIENT_DATA_FIELDS.join(', ')} must match same fields in connected ticket`,
                messageForUser: 'api.marketplace.invoice.error.clientDataDoesNotMatchTicket',
            })
        })

        test('can update status and rows in invoice with ticket', async () => {
            const [property] = await createTestProperty(adminClient, dummyO10n)
            const [ticket] = await createTestTicket(adminClient, dummyO10n, property)

            const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                ticket: { connect: { id: ticket.id } },
                rows: generateInvoiceRows(),
                status: INVOICE_STATUS_DRAFT,
            })

            const newRows = generateInvoiceRows()
            const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                rows: newRows,
                status: INVOICE_STATUS_PUBLISHED,
            })

            expect(updatedInvoice.rows).toEqual(newRows)
            expect(updatedInvoice.status).toEqual(INVOICE_STATUS_PUBLISHED)
        })

        test('client data auto update when ticket updates client data', async () => {
            const [property] = await createTestProperty(adminClient, dummyO10n)
            const unitName = faker.random.alphaNumeric(5)
            const unitType = FLAT_UNIT_TYPE
            const clientPhone = createTestPhone()
            const clientName = faker.random.alphaNumeric(5)
            const [ticket] = await createTestTicket(adminClient, dummyO10n, property, {
                unitName: null,
                unitType: null,
            })
            const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                ticket: { connect: { id: ticket.id } },
            })

            expect(invoice).toBeDefined()
            expect(invoice.ticket.id).toEqual(ticket.id)
            expect(invoice.property.id).toEqual(ticket.property.id)
            expect(invoice.unitName).toBeNull()
            expect(invoice.unitType).toBeNull()
            expect(invoice.clientPhone).toBeNull()
            expect(invoice.clientName).toBeNull()

            const [updatedTicket] = await updateTestTicket(adminClient, ticket.id, {
                isResidentTicket: true,
                unitName, unitType, clientPhone, clientName,
            })

            const updatedInvoice = await Invoice.getOne(adminClient, { id: invoice.id })

            expect(updatedInvoice.property.id).toEqual(updatedTicket.property.id)
            expect(updatedInvoice.unitName).toEqual(updatedTicket.unitName)
            expect(updatedInvoice.unitType).toEqual(updatedTicket.unitType)
            expect(updatedInvoice.clientPhone).toEqual(updatedTicket.clientPhone)
            expect(updatedInvoice.clientName).toEqual(updatedTicket.clientName)
        })

        test(`invoices status sets to ${INVOICE_STATUS_CANCELED} when ticket status sets canceled`, async () => {
            const [property] = await createTestProperty(adminClient, dummyO10n)
            const [ticket] = await createTestTicket(adminClient, dummyO10n, property)
            const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                status: INVOICE_STATUS_PUBLISHED,
                ticket: { connect: { id: ticket.id } },
            })

            await updateTestTicket(adminClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.DECLINED } },
            })

            const updatedInvoice = await Invoice.getOne(adminClient, { id: invoice.id })

            expect(updatedInvoice.status).toEqual(INVOICE_STATUS_CANCELED)
        })

        test('can\'t publish invoice with isMin-price', async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyO10n, {
                rows: [generateInvoiceRow({ isMin: true })],
                status: INVOICE_STATUS_DRAFT,
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, invoice.id, { status: INVOICE_STATUS_PUBLISHED })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'PUBLISHING_WITHOUT_DEFINED_PRICES_FORBIDDEN',
                message: 'Can\'t publish invoice without defined prices',
                messageForUser: 'api.marketplace.invoice.error.PublishingWithoutDefinedPricesForbidden',
            })
        })
    })
})
