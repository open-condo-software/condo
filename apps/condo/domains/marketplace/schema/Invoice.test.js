/**
 * Generated by `createschema marketplace.Invoice 'number:Integer; property:Relationship:Property:PROTECT; unitType:Text; unitName:Text; accountNumber:Text; toPay:Decimal; items:Json; contact?:Relationship:Contact:SET_NULL; client?:Relationship:User:SET_NULL; clientName?:Text; clientPhone?:Text; clientEmail?:Text'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { omit } = require('lodash')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectValuesOfCommonFields,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowGQLError,
    expectToThrowGraphQLRequestError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    PAYMENT_WITHDRAWN_STATUS,
    PAYMENT_PROCESSING_STATUS,
    PAYMENT_DONE_STATUS,
} = require('@condo/domains/acquiring/constants/payment')
const { addAcquiringIntegrationAndContext, createTestPayment } = require('@condo/domains/acquiring/utils/testSchema')
const {
    addBillingIntegrationAndContext, createTestBillingProperty,
    createRegisterBillingReceiptsPayload,
    registerBillingReceiptsByTestClient,
} = require('@condo/domains/billing/utils/testSchema')
const {
    INVOICE_STATUS_DRAFT,
    INVOICE_STATUS_PUBLISHED,
    INVOICE_STATUS_PAID,
} = require('@condo/domains/marketplace/constants')
const {
    Invoice,
    createTestInvoice,
    updateTestInvoice,
    createTestInvoiceContext,
    generateInvoiceRow,
} = require('@condo/domains/marketplace/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    makeClientWithRegisteredOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { makeClientWithProperty, createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
} = require('@condo/domains/user/utils/testSchema')

let adminClient, supportClient, anonymousClient
let dummyO10n, dummyInvoiceContext

describe('Invoice', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        anonymousClient = await makeClient()

        ;[dummyO10n] = await createTestOrganization(adminClient)
        ;[dummyInvoiceContext] = await createTestInvoiceContext(adminClient, dummyO10n)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestInvoice(adminClient, dummyInvoiceContext)
                expectValuesOfCommonFields(obj, attrs, adminClient)
                expect(obj.status).toBe(INVOICE_STATUS_DRAFT)
            })

            test('support can', async () => {
                const [obj, attrs] = await createTestInvoice(supportClient, dummyInvoiceContext)
                expectValuesOfCommonFields(obj, attrs, supportClient)
            })

            test('staff with permission can', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const [obj, attrs] = await createTestInvoice(client, dummyInvoiceContext)

                expectValuesOfCommonFields(obj, attrs, client)
            })

            test('staff without permission can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestInvoice(client, dummyInvoiceContext)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestInvoice(anonymousClient, { id: 'does-not-matter' })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)
                const [obj, attrs] = await updateTestInvoice(adminClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            })

            test('support can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const [obj, attrs] = await updateTestInvoice(supportClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: supportClient.user.id }))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const [obj, attrs] = await updateTestInvoice(client, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            })

            test('staff without permission can\'t', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, o10n, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestInvoice(client, objCreated.id)
                })
            })

            test('each staff user can update only his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                const [invoiceContext1] = await createTestInvoiceContext(adminClient, o10n1)
                const [invoiceContext2] = await createTestInvoiceContext(adminClient, o10n2)

                const [objCreated1] = await createTestInvoice(adminClient, invoiceContext1)
                const [objCreated2] = await createTestInvoice(adminClient, invoiceContext2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                await updateTestInvoice(client1, objCreated1.id)
                await expectToThrowAccessDeniedErrorToObj(async () => await updateTestInvoice(client1, objCreated2.id))

                await updateTestInvoice(client2, objCreated2.id)
                await expectToThrowAccessDeniedErrorToObj(async () => await updateTestInvoice(client2, objCreated1.id))
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestInvoice(anonymousClient, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(adminClient, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const objs = await Invoice.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('support can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const objs = await Invoice.getAll(supportClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: objCreated.id,
                    }),
                ]))
            })

            test('staff without permission can\'t', async () => {
                await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, { canReadInvoices: false })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs).toHaveLength(0)
            })

            test('each staff user can read only his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                const [invoiceContext1] = await createTestInvoiceContext(adminClient, o10n1)
                const [invoiceContext2] = await createTestInvoiceContext(adminClient, o10n2)

                const [objCreated1] = await createTestInvoice(adminClient, invoiceContext1)
                const [objCreated2] = await createTestInvoice(adminClient, invoiceContext2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                const objs1 = await Invoice.getAll(client1, {}, { sortBy: ['updatedAt_DESC'] })
                const objs2 = await Invoice.getAll(client2, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs1).toEqual([expect.objectContaining({ id: objCreated1.id })])
                expect(objs2).toEqual([expect.objectContaining({ id: objCreated2.id })])
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('resident side', () => {
        test('resident can\'t see drafts', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                // status=draft by default
            })

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(0)
        })

        test('resident can\'t see paid invoices', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PAID,
            })

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(0)
        })

        test('resident can see invoices by address, resident from neighbor flat not', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()
            const unitName2 = faker.lorem.word()

            // client.user has the Administrator role by default after he had registered an organization

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            const [invoice] = await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName: unitName1,
                status: INVOICE_STATUS_PUBLISHED,
            })

            const residentClient1 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient1,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName: unitName1,
                })

            const residentClient2 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient2,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName: unitName2,
                })

            const invoices1 = await Invoice.getAll(residentClient1, {})
            const invoices2 = await Invoice.getAll(residentClient2, {})

            expect(invoices1).toEqual([expect.objectContaining({ id: invoice.id })])
            expect(invoices2).toHaveLength(0)
        })

        test('resident can see invoices by accountNumber', async () => {
            const client = await makeClientWithProperty()

            const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, client.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, client.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(adminClient, billingIntegrationContext, { address: client.property.address })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const accountNumber = faker.random.alphaNumeric(13)

            const now = dayjs()
            const receiptsPayload1 = {
                context: { id: billingIntegrationContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: billingProperty.address,
                        unitType,
                        unitName,
                        accountNumber,
                        year: Number(now.format('YYYY')),
                        month: Number(now.format('MM')),
                    }),
                ],
            }
            await registerBillingReceiptsByTestClient(adminClient, receiptsPayload1)

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            const [invoice] = await createTestInvoice(client, invoiceContext, {
                accountNumber,
                status: INVOICE_STATUS_PUBLISHED,
            })

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toEqual([expect.objectContaining({ id: invoice.id })])
        })

        test('resident can see both invoices: by address and by account number', async () => {
            const client = await makeClientWithProperty()

            const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, client.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, client.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(adminClient, billingIntegrationContext, { address: client.property.address })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const accountNumber = faker.random.alphaNumeric(13)

            const now = dayjs()
            const receiptsPayload1 = {
                context: { id: billingIntegrationContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: billingProperty.address,
                        unitType,
                        unitName,
                        accountNumber,
                        year: Number(now.format('YYYY')),
                        month: Number(now.format('MM')),
                    }),
                ],
            }
            await registerBillingReceiptsByTestClient(adminClient, receiptsPayload1)

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            // add invoice by account number
            const [invoice1] = await createTestInvoice(client, invoiceContext, {
                accountNumber,
                status: INVOICE_STATUS_PUBLISHED,
            })
            // add invoice by address
            const [invoice2] = await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(2)
            expect(invoices).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: invoice1.id }),
                expect.objectContaining({ id: invoice2.id }),
            ]))
        })

        test('resident can see invoices from two organizations', async () => {
            const client1 = await makeClientWithProperty()
            const client2 = await makeClientWithRegisteredOrganization()

            ;[client2.property] = await createTestProperty(client2, client2.organization, { address: client1.property.address }, false, client1.property.addressMeta)

            const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, client1.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, client1.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(adminClient, billingIntegrationContext, { address: client1.property.address })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const accountNumber = faker.random.alphaNumeric(13)

            const now = dayjs()
            const receiptsPayload = {
                context: { id: billingIntegrationContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: billingProperty.address,
                        unitType,
                        unitName,
                        accountNumber,
                        year: Number(now.format('YYYY')),
                        month: Number(now.format('MM')),
                    }),
                ],
            }
            await registerBillingReceiptsByTestClient(adminClient, receiptsPayload)

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client1.property.address,
                    addressMeta: client1.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoiceContext1] = await createTestInvoiceContext(client1, client1.organization)
            const [invoiceContext2] = await createTestInvoiceContext(client2, client2.organization)

            // add invoice by account number from 1st organization
            const [invoice1] = await createTestInvoice(client1, invoiceContext1, {
                accountNumber,
                status: INVOICE_STATUS_PUBLISHED,
            })

            // add invoice by address from 2nd organization
            const [invoice2] = await createTestInvoice(client2, invoiceContext2, {
                property: { connect: { id: client2.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(2)
            expect(invoices).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: invoice1.id }),
                expect.objectContaining({ id: invoice2.id }),
            ]))
        })
    })

    describe('validation', () => {
        test('invoice must contain address or account number', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(adminClient, dummyInvoiceContext, {
                    accountNumber: null,
                    property: null,
                    unitType: null,
                    unitName: null,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'NO_INVOICE_RECEIVERS',
                message: 'Nobody sees this invoice. You must set property+unitType+unitName or accountNumber',
                messageForUser: 'api.marketplace.invoice.error.noReceivers',
            })
        })

        describe('can\'t change online-paid invoice', () => {
            const paymentStatuses = [
                PAYMENT_PROCESSING_STATUS,
                PAYMENT_DONE_STATUS,
                PAYMENT_WITHDRAWN_STATUS,
            ]

            test.each(paymentStatuses)('payment status: %s', async (paymentStatus) => {
                const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext, { status: INVOICE_STATUS_PAID })

                await createTestPayment(adminClient, dummyO10n, null, null, {
                    invoice: obj,
                    status: paymentStatus,
                })

                await expectToThrowGQLError(async () => {
                    await updateTestInvoice(adminClient, obj.id)
                }, {
                    code: 'BAD_USER_INPUT',
                    type: 'INVOICE_ALREADY_PAID',
                    message: 'Changing of paid invoice is forbidden',
                    messageForUser: 'api.marketplace.invoice.error.alreadyPaid',
                })
            })
        })

        test('can change cash-paid invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext, { status: INVOICE_STATUS_PAID })
            const [updatedObj, updatedAttrs] = await updateTestInvoice(adminClient, obj.id, { status: INVOICE_STATUS_PUBLISHED })

            expect(updatedObj.sender).toEqual(updatedAttrs.sender)
        })

        test('can\'t publish invoice without rows', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext, { rows: [] })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id, { status: INVOICE_STATUS_PUBLISHED })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'EMPTY_ROWS',
                message: 'The invoice contains no rows',
                messageForUser: 'api.marketplace.invoice.error.emptyRows',
            })
        })

        describe('invoice rows must contain necessary fields', () => {
            const necessaryFields = [
                ['name', 'String!'],
                ['toPay', 'String!'],
                ['count', 'Int!'],
                ['currencyCode', 'String!'],
            ]

            test.each(necessaryFields)('%s', async (fieldToOmit, omittedFieldType) => {
                await expectToThrowGraphQLRequestError(async () => {
                    await createTestInvoice(adminClient, dummyInvoiceContext, {
                        rows: [omit(generateInvoiceRow(), fieldToOmit)],
                    })
                }, `Field "${fieldToOmit}" of required type "${omittedFieldType}" was not provided.`)
            })
        })

        test('invoice.rows.*.count must be 1+', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(
                    adminClient,
                    dummyInvoiceContext,
                    {
                        rows: [
                            generateInvoiceRow(),
                            generateInvoiceRow({ count: -4 }),
                        ],
                    },
                )
            }, {
                code: 'BAD_USER_INPUT',
                type: 'WRONG_COUNT',
                message: 'Count at line 2 can\'t be less than 1',
                messageForUser: 'api.marketplace.invoice.error.rows.count',
                messageInterpolation: { rowNumber: 2 },
            })
        })

        test('invoice.rows.*.toPay must be positive', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(adminClient, dummyInvoiceContext, { rows: [generateInvoiceRow({ toPay: '-4' })] })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'WRONG_PRICE',
                message: 'Price at line 1 can\'t be less than 0',
                messageForUser: 'api.marketplace.invoice.error.rows.toPay',
                messageInterpolation: { rowNumber: 1 },
            })
        })
    })
})
