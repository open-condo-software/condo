/**
 * Generated by `createschema marketplace.Invoice 'number:Integer; property:Relationship:Property:PROTECT; unitType:Text; unitName:Text; accountNumber:Text; toPay:Decimal; items:Json; contact?:Relationship:Contact:SET_NULL; client?:Relationship:User:SET_NULL; clientName?:Text; clientPhone?:Text; clientEmail?:Text'`
 */

const { faker } = require('@faker-js/faker')
const { omit } = require('lodash')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectValuesOfCommonFields,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowGQLError,
    expectToThrowGraphQLRequestError,
} = require('@open-condo/keystone/test.utils')

const { createTestContact } = require('@condo/domains/contact/utils/testSchema')
const {
    INVOICE_STATUS_DRAFT,
    INVOICE_STATUS_PUBLISHED,
    INVOICE_STATUS_PAID,
    INVOICE_CONTEXT_STATUS_FINISHED,
    INVOICE_PAYMENT_TYPE_CASH,
    INVOICE_PAYMENT_TYPE_ONLINE,
    INVOICE_STATUS_CANCELED,
} = require('@condo/domains/marketplace/constants')
const {
    Invoice,
    createTestInvoice,
    updateTestInvoice,
    createTestInvoiceContext,
    generateInvoiceRow,
} = require('@condo/domains/marketplace/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    makeClientWithRegisteredOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { makeClientWithProperty, createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithStaffUser,
} = require('@condo/domains/user/utils/testSchema')

let adminClient, supportClient, anonymousClient
let dummyO10n, dummyInvoiceContext

describe('Invoice', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        anonymousClient = await makeClient()

        ;[dummyO10n] = await createTestOrganization(adminClient)
        ;[dummyInvoiceContext] = await createTestInvoiceContext(adminClient, dummyO10n)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestInvoice(adminClient, dummyInvoiceContext)
                expectValuesOfCommonFields(obj, attrs, adminClient)
                expect(obj.status).toBe(INVOICE_STATUS_DRAFT)
                expect(obj.paymentType).toBe(INVOICE_PAYMENT_TYPE_ONLINE)
            })

            test('support can', async () => {
                const [obj, attrs] = await createTestInvoice(supportClient, dummyInvoiceContext)
                expectValuesOfCommonFields(obj, attrs, supportClient)
            })

            test('staff with permission can', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const [obj, attrs] = await createTestInvoice(client, dummyInvoiceContext)

                expectValuesOfCommonFields(obj, attrs, client)
            })

            test('staff without permission can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestInvoice(client, dummyInvoiceContext)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestInvoice(anonymousClient, { id: 'does-not-matter' })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)
                const [obj, attrs] = await updateTestInvoice(adminClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            })

            test('support can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const [obj, attrs] = await updateTestInvoice(supportClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: supportClient.user.id }))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const [obj, attrs] = await updateTestInvoice(client, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            })

            test('staff without permission can\'t', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                    canReadInvoiceContexts: true,
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, o10n, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestInvoice(client, objCreated.id)
                })
            })

            test('each staff user can update only his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                const [invoiceContext1] = await createTestInvoiceContext(adminClient, o10n1)
                const [invoiceContext2] = await createTestInvoiceContext(adminClient, o10n2)

                const [objCreated1] = await createTestInvoice(adminClient, invoiceContext1)
                const [objCreated2] = await createTestInvoice(adminClient, invoiceContext2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                await updateTestInvoice(client1, objCreated1.id)
                await expectToThrowAccessDeniedErrorToObj(async () => await updateTestInvoice(client1, objCreated2.id))

                await updateTestInvoice(client2, objCreated2.id)
                await expectToThrowAccessDeniedErrorToObj(async () => await updateTestInvoice(client2, objCreated1.id))
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestInvoice(anonymousClient, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(adminClient, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const objs = await Invoice.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('support can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const objs = await Invoice.getAll(supportClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: objCreated.id,
                    }),
                ]))
            })

            test('staff without permission can\'t', async () => {
                await createTestInvoice(adminClient, dummyInvoiceContext)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyO10n, { canReadInvoices: false })
                await createTestOrganizationEmployee(adminClient, dummyO10n, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs).toHaveLength(0)
            })

            test('each staff user can read only his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                const [invoiceContext1] = await createTestInvoiceContext(adminClient, o10n1)
                const [invoiceContext2] = await createTestInvoiceContext(adminClient, o10n2)

                const [objCreated1] = await createTestInvoice(adminClient, invoiceContext1)
                const [objCreated2] = await createTestInvoice(adminClient, invoiceContext2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                const objs1 = await Invoice.getAll(client1, {}, { sortBy: ['updatedAt_DESC'] })
                const objs2 = await Invoice.getAll(client2, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs1).toEqual([expect.objectContaining({ id: objCreated1.id })])
                expect(objs2).toEqual([expect.objectContaining({ id: objCreated2.id })])
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('resident side', () => {
        test('resident can\'t see drafts and canceled invoices', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                // status=draft by default
            })

            await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_CANCELED,
            })

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(0)
        })

        test('resident can see paid invoices', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PAID,
                client: { connect: { id: residentClient.user.id } },
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(1)
        })

        test('two residents in one flat: only one can see the invoice by phone', async () => {
            const client = await makeClientWithProperty()

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient1 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient1,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const residentClient2 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient2,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoiceContext] = await createTestInvoiceContext(client, client.organization)
            const [invoice] = await createTestInvoice(client, invoiceContext, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName: unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient1.user.id } },
            })

            const invoices1 = await Invoice.getAll(residentClient1, {})
            const invoices2 = await Invoice.getAll(residentClient2, {})

            expect(invoices1).toEqual([expect.objectContaining({ id: invoice.id })])
            expect(invoices2).toHaveLength(0)
        })

        test('resident can see invoices from two organizations', async () => {
            const client1 = await makeClientWithProperty()
            const client2 = await makeClientWithRegisteredOrganization()

            ;[client2.property] = await createTestProperty(client2, client2.organization, { address: client1.property.address }, false, client1.property.addressMeta)

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client1.property.address,
                    addressMeta: client1.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoiceContext1] = await createTestInvoiceContext(client1, client1.organization)
            const [invoiceContext2] = await createTestInvoiceContext(client2, client2.organization)

            // add invoice from 1st organization
            const [invoice1] = await createTestInvoice(client1, invoiceContext1, {
                property: { connect: { id: client1.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
            })

            // add invoice from 2nd organization
            const [invoice2] = await createTestInvoice(client2, invoiceContext2, {
                property: { connect: { id: client2.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(2)
            expect(invoices).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: invoice1.id }),
                expect.objectContaining({ id: invoice2.id }),
            ]))
        })

        test('resident can see the invoice created by staff', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const staffClient = await makeClientWithStaffUser()
            const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                canManageInvoices: true,
                canManageContacts: true,
                canReadInvoiceContexts: true,
            })
            await createTestOrganizationEmployee(adminClient, o10n, staffClient.user, role)

            const [contact] = await createTestContact(staffClient, o10n, property, {
                phone: residentClient.userAttrs.phone,
                unitType,
                unitName,
            })

            const [invoiceContext] = await createTestInvoiceContext(adminClient, o10n, { status: INVOICE_CONTEXT_STATUS_FINISHED })
            const [invoice] = await createTestInvoice(staffClient, invoiceContext, {
                property: { connect: { id: property.id } },
                unitType,
                unitName,
                contact: { connect: { id: contact.id } },
                status: INVOICE_STATUS_PUBLISHED,
            })

            const invoices = await Invoice.getAll(residentClient, {}, { sortBy: ['updatedAt_DESC'] })

            expect(invoices).toEqual([
                expect.objectContaining({
                    id: invoice.id,
                    client: expect.objectContaining({ id: resident.user.id, name: resident.user.name }),
                }),
            ])
        })
    })

    describe('validation', () => {

        test('can\'t change online-paid invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext, {
                paymentType: INVOICE_PAYMENT_TYPE_ONLINE,
                status: INVOICE_STATUS_PAID,
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id)
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INVOICE_ALREADY_PAID',
                message: 'Changing of paid invoice is forbidden',
                messageForUser: 'api.marketplace.invoice.error.alreadyPaid',
            })
        })

        test('can change cash-paid invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext, {
                paymentType: INVOICE_PAYMENT_TYPE_CASH,
                status: INVOICE_STATUS_PAID,
            })
            const [updatedObj, updatedAttrs] = await updateTestInvoice(adminClient, obj.id, { status: INVOICE_STATUS_PUBLISHED })

            expect(updatedObj.sender).toEqual(updatedAttrs.sender)
        })

        test('can\'t change canceled invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext, {
                status: INVOICE_STATUS_CANCELED,
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id)
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INVOICE_ALREADY_CANCELED',
                message: 'Changing of canceled invoice is forbidden',
                messageForUser: 'api.marketplace.invoice.error.alreadyCanceled',
            })
        })

        test('can\'t publish invoice without rows', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyInvoiceContext, { rows: [] })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id, { status: INVOICE_STATUS_PUBLISHED })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'EMPTY_ROWS',
                message: 'The invoice contains no rows',
                messageForUser: 'api.marketplace.invoice.error.emptyRows',
            })
        })

        describe('invoice rows must contain necessary fields', () => {
            const necessaryFields = [
                ['name', 'String!'],
                ['toPay', 'String!'],
                ['count', 'Int!'],
                ['currencyCode', 'String!'],
            ]

            test.each(necessaryFields)('%s', async (fieldToOmit, omittedFieldType) => {
                await expectToThrowGraphQLRequestError(async () => {
                    await createTestInvoice(adminClient, dummyInvoiceContext, {
                        rows: [omit(generateInvoiceRow(), fieldToOmit)],
                    })
                }, `Field "${fieldToOmit}" of required type "${omittedFieldType}" was not provided.`)
            })
        })

        test('invoice.rows.*.count must be 1+', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(
                    adminClient,
                    dummyInvoiceContext,
                    {
                        rows: [
                            generateInvoiceRow(),
                            generateInvoiceRow({ count: -4 }),
                        ],
                    },
                )
            }, {
                code: 'BAD_USER_INPUT',
                type: 'WRONG_COUNT',
                message: 'Count at line 2 can\'t be less than 1',
                messageForUser: 'api.marketplace.invoice.error.rows.count',
                messageInterpolation: { rowNumber: 2 },
            })
        })

        test('invoice.rows.*.toPay must be positive', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(adminClient, dummyInvoiceContext, { rows: [generateInvoiceRow({ toPay: '-4' })] })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'WRONG_PRICE',
                message: 'Price at line 1 can\'t be less than 0',
                messageForUser: 'api.marketplace.invoice.error.rows.toPay',
                messageInterpolation: { rowNumber: 1 },
            })
        })
    })
})
