/**
 * Generated by `createschema marketplace.Invoice 'number:Integer; property:Relationship:Property:PROTECT; unitType:Text; unitName:Text; accountNumber:Text; toPay:Decimal; items:Json; contact?:Relationship:Contact:SET_NULL; client?:Relationship:User:SET_NULL; clientName?:Text; clientPhone?:Text; clientEmail?:Text'`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const dayjs = require('dayjs')
const isSameOrAfter = require('dayjs/plugin/isSameOrAfter')
const { omit, pick, get } = require('lodash')

const { generateGqlQueries } = require('@open-condo/codegen/generate.gql')
const { generateGQLTestUtils } = require('@open-condo/codegen/generate.test.utils')
const conf = require('@open-condo/config')
const {
    makeLoggedInAdminClient,
    makeClient,
    expectValuesOfCommonFields,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowGQLError,
    expectToThrowGraphQLRequestError, waitFor,
    expectToThrowAccessDeniedToFieldError,
    expectToThrowAccessDeniedToManageFieldError,
    expectToThrowAccessDeniedErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    createTestAcquiringIntegration,
    createTestAcquiringIntegrationContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBankAccount } = require('@condo/domains/banking/utils/testSchema')
const { AMOUNT_DISTRIBUTION_SUBFIELDS } = require('@condo/domains/billing/gql')
const { createTestBillingIntegration, createTestRecipient } = require('@condo/domains/billing/utils/testSchema')
const { createTestContact } = require('@condo/domains/contact/utils/testSchema')
const {
    INVOICE_STATUS_DRAFT,
    INVOICE_STATUS_PUBLISHED,
    INVOICE_STATUS_PAID,
    INVOICE_PAYMENT_TYPE_CASH,
    INVOICE_PAYMENT_TYPE_ONLINE,
    INVOICE_STATUS_CANCELED, CLIENT_DATA_FIELDS, DEFAULT_INVOICE_CURRENCY_CODE,
} = require('@condo/domains/marketplace/constants')
const {
    Invoice,
    createTestInvoice,
    updateTestInvoice,
    generateInvoiceRow,
    generateInvoiceRows,
    createTestMarketCategory,
    createTestMarketItem,
    createTestMarketItemPrice,
    createTestMarketPriceScope,
} = require('@condo/domains/marketplace/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRightSet,
    createTestB2BAppAccessRight,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    MARKETPLACE_INVOICE_PUBLISHED_MESSAGE_TYPE,
    MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
    MARKETPLACE_INVOICE_CASH_PUBLISHED_MESSAGE_TYPE,
    MARKETPLACE_INVOICE_CASH_WITH_TICKET_PUBLISHED_MESSAGE_TYPE, MESSAGE_THROTTLED_STATUS,
} = require('@condo/domains/notification/constants/constants')
const { Message } = require('@condo/domains/notification/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    makeClientWithRegisteredOrganization,
    registerNewOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE, COMMERCIAL_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { makeClientWithProperty, createTestProperty } = require('@condo/domains/property/utils/testSchema')
const {
    registerResidentByTestClient,
    registerResidentInvoiceByTestClient,
    updateTestResident,
} = require('@condo/domains/resident/utils/testSchema')
const { STATUS_IDS } = require('@condo/domains/ticket/constants/statusTransitions')
const { createTestTicket, updateTestTicket, TicketStatus } = require('@condo/domains/ticket/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithStaffUser, createTestPhone,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

const { PRICE_MEASURES } = require('./fields/price')

dayjs.extend(isSameOrAfter)

let adminClient, supportClient, anonymousClient
let dummyOrganization, dummyAcquiringIntegration

describe('Invoice', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        anonymousClient = await makeClient();

        [dummyOrganization] = await createTestOrganization(adminClient)
        await createTestBillingIntegration(adminClient);
        [dummyAcquiringIntegration] = await createTestAcquiringIntegration(supportClient, { canGroupReceipts: true })
        await createTestAcquiringIntegrationContext(adminClient, dummyOrganization, dummyAcquiringIntegration, {
            invoiceStatus: CONTEXT_FINISHED_STATUS,
            invoiceRecipient: createTestRecipient(),
        })
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestInvoice(adminClient, dummyOrganization)
                expectValuesOfCommonFields(obj, attrs, adminClient)
                expect(obj.status).toBe(INVOICE_STATUS_DRAFT)
                expect(obj.paymentType).toBe(INVOICE_PAYMENT_TYPE_ONLINE)
            })

            test('support can', async () => {
                const [obj, attrs] = await createTestInvoice(supportClient, dummyOrganization)
                expectValuesOfCommonFields(obj, attrs, supportClient)
            })

            test('staff with permission can', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                const [obj, attrs] = await createTestInvoice(client, dummyOrganization)

                expectValuesOfCommonFields(obj, attrs, client)
            })

            test('staff without permission can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestInvoice(client, dummyOrganization)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestInvoice(anonymousClient, { id: 'does-not-matter' })
                })
            })

            describe('service user', () => {
                test('with access rights can', async () => {
                    const serviceClient = await makeClientWithServiceUser()
                    const [organization] = await createTestOrganization(adminClient)

                    const [acquiringIntegration] = await createTestAcquiringIntegration(supportClient, { canGroupReceipts: true })
                    await createTestAcquiringIntegrationContext(supportClient, organization, acquiringIntegration, {
                        invoiceStatus: CONTEXT_FINISHED_STATUS,
                        invoiceRecipient: createTestRecipient(),
                    })

                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(supportClient, app, organization, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(supportClient, app, {
                        canReadOrganizations: true,
                        canReadInvoices: true,
                        canManageInvoices: true,
                    })
                    await createTestB2BAppAccessRight(supportClient, serviceClient.user, app, accessRightSet)

                    const [invoice, attrs] = await createTestInvoice(serviceClient, organization)

                    expectValuesOfCommonFields(invoice, attrs, serviceClient)
                })

                test('without access rights can\'t', async () => {
                    const serviceClient = await makeClientWithServiceUser()
                    const [organization] = await createTestOrganization(adminClient)

                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(adminClient, app, organization, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(adminClient, app)
                    await createTestB2BAppAccessRight(adminClient, serviceClient.user, app, accessRightSet)

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestInvoice(serviceClient, organization)
                    })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyOrganization)
                const [obj, attrs] = await updateTestInvoice(adminClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            })

            test('support can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyOrganization)

                const [obj, attrs] = await updateTestInvoice(supportClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: supportClient.user.id }))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyOrganization)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                const [obj, attrs] = await updateTestInvoice(client, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            })

            test('staff without permission can\'t', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [objCreated] = await createTestInvoice(adminClient, dummyOrganization)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, o10n, client.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestInvoice(client, objCreated.id)
                })
            })

            test('each staff user can update only his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                await createTestAcquiringIntegrationContext(adminClient, o10n1, dummyAcquiringIntegration, {
                    invoiceStatus: CONTEXT_FINISHED_STATUS,
                    invoiceRecipient: createTestRecipient(),
                })
                await createTestAcquiringIntegrationContext(adminClient, o10n2, dummyAcquiringIntegration, {
                    invoiceStatus: CONTEXT_FINISHED_STATUS,
                    invoiceRecipient: createTestRecipient(),
                })

                const [objCreated1] = await createTestInvoice(adminClient, o10n1)
                const [objCreated2] = await createTestInvoice(adminClient, o10n2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                await updateTestInvoice(client1, objCreated1.id)
                await expectToThrowAccessDeniedErrorToObj(async () => await updateTestInvoice(client1, objCreated2.id))

                await updateTestInvoice(client2, objCreated2.id)
                await expectToThrowAccessDeniedErrorToObj(async () => await updateTestInvoice(client2, objCreated1.id))
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyOrganization)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestInvoice(anonymousClient, objCreated.id)
                })
            })

            describe('service user', () => {
                test('with access rights can', async () => {
                    const serviceClient = await makeClientWithServiceUser()
                    const [organization] = await createTestOrganization(adminClient)

                    const [acquiringIntegration] = await createTestAcquiringIntegration(supportClient, { canGroupReceipts: true })
                    await createTestAcquiringIntegrationContext(supportClient, organization, acquiringIntegration, {
                        invoiceStatus: CONTEXT_FINISHED_STATUS,
                        invoiceRecipient: createTestRecipient(),
                    })

                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(supportClient, app, organization, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(supportClient, app, {
                        canReadOrganizations: true,
                        canReadInvoices: true,
                        canManageInvoices: true,
                    })
                    await createTestB2BAppAccessRight(supportClient, serviceClient.user, app, accessRightSet)

                    const [invoice] = await createTestInvoice(serviceClient, organization)
                    const [updatedInvoice] = await updateTestInvoice(serviceClient, invoice.id)

                    expect(updatedInvoice).toEqual(expect.objectContaining({
                        id: invoice.id,
                        v: 2,
                    }))
                })

                test('without access rights can\'t', async () => {
                    const serviceClient = await makeClientWithServiceUser()
                    const [organization] = await createTestOrganization(adminClient)

                    const [acquiringIntegration] = await createTestAcquiringIntegration(supportClient, { canGroupReceipts: true })
                    await createTestAcquiringIntegrationContext(supportClient, organization, acquiringIntegration, {
                        invoiceStatus: CONTEXT_FINISHED_STATUS,
                        invoiceRecipient: createTestRecipient(),
                    })

                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(adminClient, app, organization, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(adminClient, app)
                    await createTestB2BAppAccessRight(adminClient, serviceClient.user, app, accessRightSet)

                    const [invoice] = await createTestInvoice(adminClient, organization)

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestInvoice(serviceClient, invoice.id)
                    })
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyOrganization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(adminClient, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyOrganization)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyOrganization)

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Invoice.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyOrganization)

                const objs = await Invoice.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('support can', async () => {
                const [obj] = await createTestInvoice(adminClient, dummyOrganization)

                const objs = await Invoice.getAll(supportClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('staff with permission can', async () => {
                const [objCreated] = await createTestInvoice(adminClient, dummyOrganization)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: objCreated.id,
                    }),
                ]))
            })

            test('staff without permission can\'t', async () => {
                await createTestInvoice(adminClient, dummyOrganization)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, { canReadInvoices: false })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, client.user, role)

                const objs = await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs).toHaveLength(0)
            })

            test('each staff user can read only his organization\'s invoices', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                await createTestAcquiringIntegrationContext(adminClient, o10n1, dummyAcquiringIntegration, {
                    invoiceStatus: CONTEXT_FINISHED_STATUS,
                    invoiceRecipient: createTestRecipient(),
                })
                await createTestAcquiringIntegrationContext(adminClient, o10n2, dummyAcquiringIntegration, {
                    invoiceStatus: CONTEXT_FINISHED_STATUS,
                    invoiceRecipient: createTestRecipient(),
                })

                const [objCreated1] = await createTestInvoice(adminClient, o10n1)
                const [objCreated2] = await createTestInvoice(adminClient, o10n2)

                const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const [role1] = await createTestOrganizationEmployeeRole(adminClient, o10n1, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n1, client1.user, role1)

                const [role2] = await createTestOrganizationEmployeeRole(adminClient, o10n2, { canReadInvoices: true })
                await createTestOrganizationEmployee(adminClient, o10n2, client2.user, role2)

                const objs1 = await Invoice.getAll(client1, {}, { sortBy: ['updatedAt_DESC'] })
                const objs2 = await Invoice.getAll(client2, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs1).toEqual([expect.objectContaining({ id: objCreated1.id })])
                expect(objs2).toEqual([expect.objectContaining({ id: objCreated2.id })])
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Invoice.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })

            describe('service user', () => {
                test('with access rights can', async () => {
                    const serviceClient = await makeClientWithServiceUser()
                    const [organization] = await createTestOrganization(adminClient)

                    const [acquiringIntegration] = await createTestAcquiringIntegration(supportClient, { canGroupReceipts: true })
                    await createTestAcquiringIntegrationContext(supportClient, organization, acquiringIntegration, {
                        invoiceStatus: CONTEXT_FINISHED_STATUS,
                        invoiceRecipient: createTestRecipient(),
                    })

                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(supportClient, app, organization, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(supportClient, app, {
                        canReadOrganizations: true,
                        canReadInvoices: true,
                        canManageInvoices: true,
                    })
                    await createTestB2BAppAccessRight(supportClient, serviceClient.user, app, accessRightSet)

                    const [invoice, attrs] = await createTestInvoice(serviceClient, organization)
                    const readInvoices = await Invoice.getAll(serviceClient, { id: invoice.id })

                    expect(readInvoices).toHaveLength(1)
                    expectValuesOfCommonFields(readInvoices[0], attrs, serviceClient)
                })

                test('without access rights can\'t', async () => {
                    const serviceClient = await makeClientWithServiceUser()
                    const [organization] = await createTestOrganization(adminClient)

                    const [acquiringIntegration] = await createTestAcquiringIntegration(supportClient, { canGroupReceipts: true })
                    await createTestAcquiringIntegrationContext(supportClient, organization, acquiringIntegration, {
                        invoiceStatus: CONTEXT_FINISHED_STATUS,
                        invoiceRecipient: createTestRecipient(),
                    })

                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(adminClient, app, organization, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(adminClient, app)
                    await createTestB2BAppAccessRight(adminClient, serviceClient.user, app, accessRightSet)

                    await createTestInvoice(adminClient, organization)

                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await Invoice.getAll(serviceClient, {})
                    })
                })
            })
        })
    })

    describe('resident side', () => {
        test('resident can\'t see drafts and can see canceled invoices', async () => {
            const client = await makeClientWithProperty()

            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [contact] = await createTestContact(adminClient, client.organization, client.property, {
                phone: residentClient.userAttrs.phone,
                unitType,
                unitName,
            })

            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                // status=draft by default
                contact: { connect: { id: contact.id } },
            })

            const [canceledInvoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_CANCELED,
                contact: { connect: { id: contact.id } },
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toEqual([
                expect.objectContaining({
                    id: canceledInvoice.id,
                }),
            ])
        })

        test('resident can see paid invoices', async () => {
            const client = await makeClientWithProperty()

            const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PAID,
                client: { connect: { id: residentClient.user.id } },
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toEqual([
                expect.objectContaining({
                    id: invoice.id,
                    recipient: expect.objectContaining(pick(acquiringContext.invoiceRecipient, ['tin', 'bic', 'bankAccount'])),
                }),
            ])
        })

        test('two residents in one flat: only one can see the invoice by phone', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient1 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient1,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const residentClient2 = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient2,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName: unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient1.user.id } },
            })

            const invoices1 = await Invoice.getAll(residentClient1, {})
            const invoices2 = await Invoice.getAll(residentClient2, {})

            expect(invoices1).toEqual([expect.objectContaining({ id: invoice.id })])
            expect(invoices2).toHaveLength(0)
        })

        test('resident can see invoices from two organizations', async () => {
            const client1 = await makeClientWithProperty()
            const client2 = await makeClientWithRegisteredOrganization()

            await createTestAcquiringIntegrationContext(adminClient, client1.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            await createTestAcquiringIntegrationContext(adminClient, client2.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            ;[client2.property] = await createTestProperty(client2, client2.organization, { address: client1.property.address }, false, client1.property.addressMeta)

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client1.property.address,
                    addressMeta: client1.property.addressMeta,
                    unitType,
                    unitName,
                })

            // add invoice from 1st organization
            const [invoice1] = await createTestInvoice(client1, client1.organization, {
                property: { connect: { id: client1.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
            })

            // add invoice from 2nd organization
            const [invoice2] = await createTestInvoice(client2, client2.organization, {
                property: { connect: { id: client2.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
            })

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(2)
            expect(invoices).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: invoice1.id }),
                expect.objectContaining({ id: invoice2.id }),
            ]))
        })

        test('resident can see the invoice created by staff', async () => {
            const [o10n] = await createTestOrganization(adminClient)

            await createTestAcquiringIntegrationContext(adminClient, o10n, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const [property] = await createTestProperty(adminClient, o10n)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const staffClient = await makeClientWithStaffUser()
            const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                canManageInvoices: true,
                canManageContacts: true,
            })
            await createTestOrganizationEmployee(adminClient, o10n, staffClient.user, role)

            const [contact] = await createTestContact(staffClient, o10n, property, {
                phone: residentClient.userAttrs.phone,
                unitType,
                unitName,
            })

            const [invoice] = await createTestInvoice(staffClient, o10n, {
                property: { connect: { id: property.id } },
                unitType,
                unitName,
                contact: { connect: { id: contact.id } },
                status: INVOICE_STATUS_PUBLISHED,
            })

            const invoices = await Invoice.getAll(residentClient, {}, { sortBy: ['updatedAt_DESC'] })

            expect(invoices).toEqual([
                expect.objectContaining({
                    id: invoice.id,
                    client: expect.objectContaining({ id: resident.user.id, name: resident.user.name }),
                }),
            ])
        })
    })

    describe('resolve hook', () => {
        describe('connect contact to Invoice', () => {
            it('create and connect contact if client data passed, but contact not passed', async () => {
                const [property] = await createTestProperty(adminClient, dummyOrganization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const clientPhone = createTestPhone()
                const clientName = faker.random.alphaNumeric(5)

                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    clientName, clientPhone, unitName, unitType,
                    property: { connect: { id: property.id } },
                })

                expect(invoice.contact).toBeDefined()

                const contact = invoice.contact
                expect(contact.name).toEqual(clientName)
                expect(contact.phone).toEqual(clientPhone)
                expect(contact.property.id).toEqual(property.id)
                expect(contact.unitName).toEqual(unitName)
                expect(contact.unitType).toEqual(unitType)
            })

            it('connect existed contact if contact founded by passed client data', async () => {
                const [property] = await createTestProperty(adminClient, dummyOrganization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const clientPhone = createTestPhone()
                const clientName = faker.random.alphaNumeric(5)

                const [contact] = await createTestContact(adminClient, dummyOrganization, property, {
                    unitType, unitName, phone: clientPhone, name: clientName,
                })

                const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                    clientName, clientPhone, unitName, unitType,
                    property: { connect: { id: property.id } },
                })

                expect(invoice.contact).toBeDefined()
                expect(invoice.contact.id).toEqual(contact.id)
            })

            it('does not connect contact if no client data passed', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization)

                expect(invoice.contact).toBeNull()
            })

            it('invoice.toPay must be a sum of rows.*.toPay', async () => {
                const [invoice, invoiceAttrs] = await createTestInvoice(adminClient, dummyOrganization)
                const expectedSum = invoiceAttrs.rows.reduce((sum, {
                    toPay,
                    count,
                }) => sum.plus(Big(toPay).mul(count)), Big(0)).toFixed(8)
                expect(invoice).toHaveProperty('toPay', expectedSum)
            })
        })

        describe('The time when some status set', () => {

            describe('who can update timestamp', () => {
                const timestampFields = ['publishedAt', 'paidAt', 'canceledAt']
                let invoice
                const publishedAt = dayjs().toISOString()
                const paidAt = dayjs().toISOString()
                const canceledAt = dayjs().toISOString()

                beforeAll(async () => {
                    [invoice] = await createTestInvoice(adminClient, dummyOrganization)
                })
                describe.each(timestampFields)('%p', () => {
                    test('admin can', async () => {
                        const [updated1] = await updateTestInvoice(adminClient, invoice.id, { publishedAt })
                        expect(updated1.publishedAt).toBe(publishedAt)

                        const [updated2] = await updateTestInvoice(adminClient, invoice.id, { paidAt })
                        expect(updated2.paidAt).toBe(paidAt)

                        const [updated3] = await updateTestInvoice(adminClient, invoice.id, { canceledAt })
                        expect(updated3.canceledAt).toBe(canceledAt)
                    })

                    test('support can\'t', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => updateTestInvoice(supportClient, invoice.id, { publishedAt }))
                        await expectToThrowAccessDeniedErrorToObj(async () => updateTestInvoice(supportClient, invoice.id, { paidAt }))
                        await expectToThrowAccessDeniedErrorToObj(async () => updateTestInvoice(supportClient, invoice.id, { canceledAt }))
                    })

                    test('resident can\'t', async () => {
                        const residentClient = await makeClientWithResidentUser()
                        await expectToThrowAccessDeniedErrorToObj(async () => updateTestInvoice(residentClient, invoice.id, { publishedAt }))
                        await expectToThrowAccessDeniedErrorToObj(async () => updateTestInvoice(residentClient, invoice.id, { paidAt }))
                        await expectToThrowAccessDeniedErrorToObj(async () => updateTestInvoice(residentClient, invoice.id, { canceledAt }))
                    })
                })
            })

            test('publishedAt', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization)
                expect(invoice.publishedAt).toBeNull()
                const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, { status: INVOICE_STATUS_PUBLISHED })
                expect(dayjs(updatedInvoice.publishedAt).isSameOrAfter(dayjs(invoice.createdAt))).toBe(true)
            })

            test('paidAt', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization)
                expect(invoice.paidAt).toBe(null)
                const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, { status: INVOICE_STATUS_PAID })
                expect(dayjs(updatedInvoice.paidAt).isSameOrAfter(dayjs(invoice.createdAt))).toBe(true)
            })

            test('canceledAt', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyOrganization)
                expect(invoice.canceledAt).toBe(null)
                const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, { status: INVOICE_STATUS_CANCELED })
                expect(dayjs(updatedInvoice.canceledAt).isSameOrAfter(dayjs(invoice.createdAt))).toBe(true)
            })
        })

        it('must get invoice row meta from item category', async () => {
            const [o10n] = await createTestOrganization(adminClient)

            await createTestAcquiringIntegrationContext(adminClient, o10n, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const [property] = await createTestProperty(adminClient, o10n)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const [parentCategory] = await createTestMarketCategory(adminClient)
            const [marketCategory] = await createTestMarketCategory(adminClient, {
                parentCategory: { connect: { id: parentCategory.id } },
            })
            const [marketItem] = await createTestMarketItem(adminClient, marketCategory, o10n)
            const [itemPrice] = await createTestMarketItemPrice(adminClient, marketItem)
            const [priceScope] = await createTestMarketPriceScope(adminClient, itemPrice, property)

            await registerResidentInvoiceByTestClient(
                residentClient,
                pick(resident, 'id'),
                [{
                    priceScope: pick(priceScope, 'id'),
                    count: 1,
                }],
            )

            const invoices = await Invoice.getAll(residentClient, {})
            expect(invoices).toHaveLength(1)

            const [invoice] = invoices
            expect(invoice.rows).toEqual([
                expect.objectContaining({
                    meta: {
                        imageUrl: get(parentCategory, ['image', 'publicUrl'], null),
                        categoryBgColor: get(parentCategory, ['mobileSettings', 'bgColor'], null),
                    },
                }),
            ])
        })

        describe('fields', () => {
            describe('unitType and unitName', () => {
                describe('create', () => {
                    test('unitType must be reset if not pass unitName', async () => {
                        const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                            unitType: COMMERCIAL_UNIT_TYPE,
                            unitName: null,
                        })
                        expect(invoice).toHaveProperty('unitType', null)
                        expect(invoice).toHaveProperty('unitName', null)
                    })

                    test('unitType must be set to default values if pass unitName and not pass unitType', async () => {
                        const [invoice, attrs] = await createTestInvoice(adminClient, dummyOrganization, {
                            unitType: null,
                            unitName: faker.random.alphaNumeric(5),
                        })
                        expect(invoice).toHaveProperty('unitType', FLAT_UNIT_TYPE)
                        expect(invoice).toHaveProperty('unitName', attrs.unitName)
                    })

                    test('unitType and unitName must be empty if they were not passed', async () => {
                        const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                            unitType: null,
                            unitName: null,
                        })
                        expect(invoice).toHaveProperty('unitType', null)
                        expect(invoice).toHaveProperty('unitName', null)
                    })

                    test('unitType and unitName must not be empty if they were passed', async () => {
                        const [invoice, attrs] = await createTestInvoice(adminClient, dummyOrganization, {
                            unitType: COMMERCIAL_UNIT_TYPE,
                            unitName: faker.random.alphaNumeric(5),
                        })
                        expect(invoice).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                        expect(invoice).toHaveProperty('unitName', attrs.unitName)
                    })
                })

                describe('update', () => {
                    test('unitType must not be update if unitName is not null and unitType try update to null', async () => {
                        const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                            unitType: COMMERCIAL_UNIT_TYPE,
                            unitName: faker.random.alphaNumeric(5),
                        })
                        expect(invoice).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                        const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                            unitType: null,
                        })
                        expect(updatedInvoice).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                        expect(updatedInvoice).toHaveProperty('unitName', invoice.unitName)
                    })

                    test('unitType must be set null if unitType is not null and unitName update to null', async () => {
                        const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                            unitType: COMMERCIAL_UNIT_TYPE,
                            unitName: faker.random.alphaNumeric(5),
                        })
                        const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                            unitName: null,
                        })
                        expect(updatedInvoice).toHaveProperty('unitType', null)
                        expect(updatedInvoice).toHaveProperty('unitName', null)
                    })

                    test('unitType and unitName must be set null if unitType and unitName update to null', async () => {
                        const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                            unitType: COMMERCIAL_UNIT_TYPE,
                            unitName: faker.random.alphaNumeric(5),
                        })
                        const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                            unitType: null,
                            unitName: null,
                        })
                        expect(updatedInvoice).toHaveProperty('unitType', null)
                        expect(updatedInvoice).toHaveProperty('unitName', null)
                    })

                    test('unitType must be updatable', async () => {
                        const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                            unitType: FLAT_UNIT_TYPE,
                            unitName: faker.random.alphaNumeric(5),
                        })
                        const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                            unitType: COMMERCIAL_UNIT_TYPE,
                        })
                        expect(updatedInvoice).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                        expect(updatedInvoice).toHaveProperty('unitName', invoice.unitName)
                    })

                    test('unitName must be updatable', async () => {
                        const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                            unitType: COMMERCIAL_UNIT_TYPE,
                            unitName: faker.random.alphaNumeric(5),
                        })
                        const [updatedInvoice, attrs] = await updateTestInvoice(adminClient, invoice.id, {
                            unitName: faker.random.alphaNumeric(5),
                        })
                        expect(updatedInvoice).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                        expect(updatedInvoice).toHaveProperty('unitName', attrs.unitName)
                    })
                })
            })

            describe('rows.*.measure', () => {
                test('invoice.rows.*.measure is inferred from MarketItemPrice when set as resident', async () => {
                    const [o10n] = await createTestOrganization(adminClient)

                    await createTestAcquiringIntegrationContext(adminClient, o10n, dummyAcquiringIntegration, {
                        invoiceStatus: CONTEXT_FINISHED_STATUS,
                        invoiceRecipient: createTestRecipient(),
                    })

                    const [property] = await createTestProperty(adminClient, o10n)

                    const residentClient = await makeClientWithResidentUser()
                    const unitType = FLAT_UNIT_TYPE
                    const unitName = faker.lorem.word()
                    const [resident] = await registerResidentByTestClient(
                        residentClient,
                        {
                            address: property.address,
                            addressMeta: property.addressMeta,
                            unitType,
                            unitName,
                        })

                    const [parentCategory] = await createTestMarketCategory(adminClient)
                    const [marketCategory] = await createTestMarketCategory(adminClient, {
                        parentCategory: { connect: { id: parentCategory.id } },
                    })
                    const [marketItem] = await createTestMarketItem(adminClient, marketCategory, o10n)
                    const [itemPrice] = await createTestMarketItemPrice(adminClient, marketItem, { price: { type: 'variant', name: 'Installation of AC unit', price: '80', isMin: false, vatPercent: '11', currencyCode: 'USD', measure: PRICE_MEASURES.PER_ITEM } })
                    const [priceScope] = await createTestMarketPriceScope(adminClient, itemPrice, property)

                    await registerResidentInvoiceByTestClient(
                        residentClient,
                        pick(resident, 'id'),
                        [{
                            priceScope: pick(priceScope, 'id'),
                            count: 3,
                        }],
                    )

                    const invoices = await Invoice.getAll(residentClient, {})
                    expect(invoices).toHaveLength(1)

                    const [invoice] = invoices
                    expect(invoice.rows).toEqual([
                        expect.objectContaining({
                            measure: PRICE_MEASURES.PER_ITEM,
                        }),
                    ])
                })
            })
        })

        test('reset client during update if resident was deleted', async () => {
            const [o10n] = await createTestOrganization(adminClient)

            await createTestAcquiringIntegrationContext(adminClient, o10n, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const [property] = await createTestProperty(adminClient, o10n)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const staffClient = await makeClientWithStaffUser()
            const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                canManageInvoices: true,
                canManageContacts: true,
            })
            await createTestOrganizationEmployee(adminClient, o10n, staffClient.user, role)

            const [contact] = await createTestContact(staffClient, o10n, property, {
                phone: residentClient.userAttrs.phone,
                unitType,
                unitName,
            })

            const [invoice] = await createTestInvoice(staffClient, o10n, {
                property: { connect: { id: property.id } },
                unitType,
                unitName,
                contact: { connect: { id: contact.id } },
                status: INVOICE_STATUS_PUBLISHED,
            })

            const invoices = await Invoice.getAll(residentClient, {}, { sortBy: ['updatedAt_DESC'] })

            expect(invoices).toEqual([
                expect.objectContaining({
                    id: invoice.id,
                    client: expect.objectContaining({ id: resident.user.id, name: resident.user.name }),
                }),
            ])

            await updateTestResident(adminClient, resident.id, { deletedAt: faker.date.recent() })
            const [updatedInvoice] = await updateTestInvoice(staffClient, invoice.id, { status: INVOICE_STATUS_CANCELED })

            expect(updatedInvoice.client).toBe(null)
            expect(updatedInvoice.status).toBe(INVOICE_STATUS_CANCELED)
        })
    })

    describe('virtual fields check', () => {
        it('checking the completion of virtual fields: canGroupReceipts, hostUrl, acquiringIntegrationId, currencyCode', async () => {
            const [property] = await createTestProperty(adminClient, dummyOrganization)
            const unitName = faker.random.alphaNumeric(5)
            const unitType = FLAT_UNIT_TYPE
            const clientPhone = createTestPhone()
            const clientName = faker.random.alphaNumeric(5)

            await createTestContact(adminClient, dummyOrganization, property, {
                unitType, unitName, phone: clientPhone, name: clientName,
            })

            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                clientName, clientPhone, unitName, unitType,
                property: { connect: { id: property.id } },
            })

            expect(invoice.canGroupReceipts).toBeTruthy()
            expect(invoice.acquiringHostUrl).toEqual(dummyAcquiringIntegration.hostUrl)
            expect(invoice.acquiringIntegrationId).toEqual(dummyAcquiringIntegration.id)
            expect(invoice.currencyCode).toEqual(DEFAULT_INVOICE_CURRENCY_CODE)
        })
    })

    describe('sending push', () => {
        test('send push after create invoice with published status', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/payments/`)
        })

        test('send push after publish invoice', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [createdInvoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_DRAFT,
                client: { connect: { id: residentClient.user.id } },
            })

            const invoice = await Invoice.update(adminClient, createdInvoice.id, {
                status: INVOICE_STATUS_PUBLISHED,
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/payments/`)
        })

        test('not send push after create invoice with no published status', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PAID,
                client: { connect: { id: residentClient.user.id } },
            })

            const messages = await Message.getAll(adminClient, {
                user: { id: residentClient.user.id },
                type: MARKETPLACE_INVOICE_PUBLISHED_MESSAGE_TYPE,
            })

            expect(messages).toHaveLength(0)
        })

        test('not send push after create invoice with ticket with source mobile_app_resident', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })
            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                isPayable: true,
                unitType,
                unitName,
                clientName: null,
                clientPhone: null,
                contact: null,
                source: { connect: { id: '830d1d89-2d17-4c5b-96d1-21b5cd01a6d3' } },
                client: { connect: { id: residentClient.user.id } },
            })
            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                ticket: { connect: { id: ticket.id } },
                client: { connect: { id: residentClient.user.id } },
            })

            const messages = await Message.getAll(adminClient, {
                user: { id: residentClient.user.id },
                type: MARKETPLACE_INVOICE_PUBLISHED_MESSAGE_TYPE,
            })

            expect(messages).toHaveLength(0)
        })

        test('send push after create invoice with ticket and published status', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                isPayable: true,
                unitType,
                unitName,
                clientName: null,
                clientPhone: null,
                contact: null,
                client: { connect: { id: residentClient.user.id } },
            })
            const [invoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
                ticket: { connect: { id: ticket.id } },
                clientName: null,
                clientPhone: null,
                contact: null,
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.ticketId).toEqual(ticket.id)
            expect(messages[0].meta.data.ticketNumber).toEqual(ticket.number)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/ticket/${ticket.id}/`)
        })

        test('send push after publish invoice with ticket', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                isPayable: true,
                unitType,
                unitName,
                clientName: null,
                clientPhone: null,
                contact: null,
                client: { connect: { id: residentClient.user.id } },
            })
            const [createdInvoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_DRAFT,
                client: { connect: { id: residentClient.user.id } },
                ticket: { connect: { id: ticket.id } },
                clientName: null,
                clientPhone: null,
                contact: null,
            })

            const invoice = await Invoice.update(adminClient, createdInvoice.id, {
                status: INVOICE_STATUS_PUBLISHED,
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.ticketId).toEqual(ticket.id)
            expect(messages[0].meta.data.ticketNumber).toEqual(ticket.number)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/ticket/${ticket.id}/`)
        })

        test('send only 1 push when publish several invoice with same ticket', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                isPayable: true,
                unitType,
                unitName,
                clientName: null,
                clientPhone: null,
                contact: null,
                client: { connect: { id: residentClient.user.id } },
            })
            const [createdInvoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_DRAFT,
                client: { connect: { id: residentClient.user.id } },
                ticket: { connect: { id: ticket.id } },
                clientName: null,
                clientPhone: null,
                contact: null,
            })

            await Invoice.update(adminClient, createdInvoice.id, {
                status: INVOICE_STATUS_PUBLISHED,
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
            })

            let messages1, messages2
            await waitFor(async () => {
                messages1 = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages1).toHaveLength(1)
            })

            // createdInvoice2
            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
                ticket: { connect: { id: ticket.id } },
                clientName: null,
                clientPhone: null,
                contact: null,
            })
            await waitFor(async () => {
                messages2 = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
                }, { sortBy: 'createdAt_ASC' })
                expect(messages2).toHaveLength(2)
                expect(messages2).toEqual(expect.arrayContaining([
                    expect.objectContaining({ status: MESSAGE_THROTTLED_STATUS }),
                ]))
            })

            expect(messages1[0].id).toEqual(messages2.filter(({ status }) => status !== MESSAGE_THROTTLED_STATUS)[0].id)
        })


        test('send only one push for published invoices related to one ticket', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                isPayable: true,
                unitType,
                unitName,
                clientName: null,
                clientPhone: null,
                contact: null,
                client: { connect: { id: residentClient.user.id } },
            })
            // createdInvoice1
            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
                ticket: { connect: { id: ticket.id } },
                clientName: null,
                clientPhone: null,
                contact: null,
            })
            let messagesFirstResult
            await waitFor(async () => {
                messagesFirstResult = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messagesFirstResult).toHaveLength(1)
            })

            // createdInvoice2
            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                client: { connect: { id: residentClient.user.id } },
                ticket: { connect: { id: ticket.id } },
                clientName: null,
                clientPhone: null,
                contact: null,
            })

            let messagesSecondResult
            await waitFor(async () => {
                messagesSecondResult = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
                }, { sortBy: 'createdAt_ASC' })
                expect(messagesSecondResult).toHaveLength(2)
            })

            expect(messagesSecondResult[0].id).toEqual(messagesFirstResult[0].id)
            expect(messagesSecondResult[1].status).toEqual(MESSAGE_THROTTLED_STATUS)
        })

        test('send push after create invoice with published status and paymentType cash', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [invoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                paymentType: INVOICE_PAYMENT_TYPE_CASH,
                client: { connect: { id: residentClient.user.id } },
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_CASH_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/payments/`)
        })

        test('send push after create invoice with ticket and published status and paymentType cash', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })

            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                isPayable: true,
                unitType,
                unitName,
                clientName: null,
                clientPhone: null,
                contact: null,
                client: { connect: { id: residentClient.user.id } },
            })
            const [invoice] = await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                paymentType: INVOICE_PAYMENT_TYPE_CASH,
                client: { connect: { id: residentClient.user.id } },
                ticket: { connect: { id: ticket.id } },
                clientName: null,
                clientPhone: null,
                contact: null,
            })

            let messages
            await waitFor(async () => {
                messages = await Message.getAll(adminClient, {
                    user: { id: residentClient.user.id },
                    type: MARKETPLACE_INVOICE_CASH_WITH_TICKET_PUBLISHED_MESSAGE_TYPE,
                })
                expect(messages).toHaveLength(1)
            })

            expect(messages[0].meta.data.invoiceId).toEqual(invoice.id)
            expect(messages[0].meta.data.ticketId).toEqual(ticket.id)
            expect(messages[0].meta.data.ticketNumber).toEqual(ticket.number)
            expect(messages[0].meta.data.residentId).toEqual(resident.id)
            expect(messages[0].meta.data.url).toEqual(`${conf.SERVER_URL}/ticket/${ticket.id}/`)
        })

    })

    describe('validation', () => {

        test('can\'t change online-paid invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyOrganization, {
                paymentType: INVOICE_PAYMENT_TYPE_ONLINE,
                status: INVOICE_STATUS_PAID,
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id)
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INVOICE_ALREADY_PAID',
                message: 'Changing of paid invoice is forbidden',
                messageForUser: 'api.marketplace.invoice.ALREADY_PAID',
            })
        })

        test('can change cash-paid invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyOrganization, {
                paymentType: INVOICE_PAYMENT_TYPE_CASH,
                status: INVOICE_STATUS_PAID,
            })
            const [updatedObj, updatedAttrs] = await updateTestInvoice(adminClient, obj.id, { status: INVOICE_STATUS_PUBLISHED })

            expect(updatedObj.sender).toEqual(updatedAttrs.sender)
        })

        test('can\'t change canceled invoice', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyOrganization, {
                status: INVOICE_STATUS_CANCELED,
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id)
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INVOICE_ALREADY_CANCELED',
                message: 'Changing of canceled invoice is forbidden',
                messageForUser: 'api.marketplace.invoice.ALREADY_CANCELED',
            })
        })

        test('can\'t publish invoice without rows', async () => {
            const [obj] = await createTestInvoice(adminClient, dummyOrganization, { rows: [] })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, obj.id, { status: INVOICE_STATUS_PUBLISHED })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'EMPTY_ROWS',
                message: 'The invoice contains no rows',
                messageForUser: 'api.marketplace.invoice.EMPTY_ROWS',
            })
        })

        describe('invoice rows must contain necessary fields', () => {
            const necessaryFields = [
                ['name', 'String!'],
                ['toPay', 'String!'],
                ['count', 'Int!'],
                ['isMin', 'Boolean!'],
            ]

            test.each(necessaryFields)('%s', async (fieldToOmit, omittedFieldType) => {
                await expectToThrowGraphQLRequestError(async () => {
                    await createTestInvoice(adminClient, dummyOrganization, {
                        rows: [omit(generateInvoiceRow(), fieldToOmit)],
                    })
                }, `Field "${fieldToOmit}" of required type "${omittedFieldType}" was not provided.`)
            })
        })

        test('invoice.rows.*.count must be 1+', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(
                    adminClient,
                    dummyOrganization,
                    {
                        rows: [
                            generateInvoiceRow(),
                            generateInvoiceRow({ count: -4 }),
                        ],
                    },
                )
            }, {
                code: 'BAD_USER_INPUT',
                type: 'WRONG_COUNT',
                message: 'Count at line {rowNumber} can\'t be less than 1',
                messageForUser: 'api.marketplace.invoice.WRONG_COUNT',
                messageInterpolation: { rowNumber: 2 },
            })
        })

        test('invoice.rows.*.toPay must be positive', async () => {
            await expectToThrowGQLError(async () => {
                await createTestInvoice(adminClient, dummyOrganization, { rows: [generateInvoiceRow({ toPay: '-4' })] })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'WRONG_PRICE',
                message: 'Price at line {rowNumber} can\'t be less than 0',
                messageForUser: 'api.marketplace.invoice.WRONG_PRICE',
                messageInterpolation: { rowNumber: 1 },
            })
        })

        test('can\'t create invoice if no finished acquiring context', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            await createTestBillingIntegration(adminClient)
            await createTestAcquiringIntegration(adminClient)

            await expectToThrowGQLError(async () => {
                await createTestInvoice(adminClient, o10n)
            }, {
                code: 'BAD_USER_INPUT',
                type: 'NO_FINISHED_ACQUIRING_CONTEXT',
                message: 'The organization has no AcquiringIntegrationContext in finished status for invoices',
                messageForUser: 'api.marketplace.invoice.NO_FINISHED_ACQUIRING_CONTEXT',
            })
        })

        test(`can update status to ${INVOICE_STATUS_CANCELED} of published invoice`, async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })
            const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                status: INVOICE_STATUS_CANCELED,
            })

            expect(updatedInvoice.status).toEqual(INVOICE_STATUS_CANCELED)
        })

        test(`can update status to ${INVOICE_STATUS_CANCELED} of published invoice if user&resident were created after invoice`, async () => {
            const [o10n] = await createTestOrganization(adminClient)

            await createTestAcquiringIntegrationContext(adminClient, o10n, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const [property] = await createTestProperty(adminClient, o10n)

            const phone = createTestPhone()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const staffClient = await makeClientWithStaffUser()
            const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                canManageInvoices: true,
                canManageContacts: true,
            })
            await createTestOrganizationEmployee(adminClient, o10n, staffClient.user, role)

            const [contact] = await createTestContact(staffClient, o10n, property, {
                phone,
                unitType,
                unitName,
            })

            const [invoice] = await createTestInvoice(staffClient, o10n, {
                property: { connect: { id: property.id } },
                unitType,
                unitName,
                contact: { connect: { id: contact.id } },
                status: INVOICE_STATUS_PUBLISHED,
            })

            expect(invoice).toEqual(expect.objectContaining({
                id: invoice.id,
                client: null,
            }))

            const residentClient = await makeClientWithResidentUser({}, { phone })
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const [updatedInvoice] = await updateTestInvoice(staffClient, invoice.id, { status: INVOICE_STATUS_CANCELED })

            expect(updatedInvoice.client.id).toBe(resident.user.id)
            expect(updatedInvoice.status).toBe(INVOICE_STATUS_CANCELED)
        })

        test('can\'t edit published invoice', async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, { status: INVOICE_STATUS_PUBLISHED })

            const newRows = generateInvoiceRows()
            const newToPay = newRows.reduce((sum, {
                toPay,
                count,
            }) => sum.plus(Big(toPay).mul(count)), Big(0)).toString()

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, invoice.id, { rows: newRows })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'FORBID_EDIT_PUBLISHED',
                message: `Only the status ${INVOICE_STATUS_CANCELED} and ${INVOICE_STATUS_PAID} can be updated by the published invoice`,
                messageForUser: 'api.marketplace.invoice.FORBID_EDIT_PUBLISHED',
                changedFields: expect.objectContaining({
                    rows: expect.arrayContaining(newRows.map((r) => expect.objectContaining(r))),
                }),
            })
        })

        test('can create invoice with ticket', async () => {
            const [property] = await createTestProperty(adminClient, dummyOrganization)
            const unitName = faker.random.alphaNumeric(5)
            const unitType = FLAT_UNIT_TYPE
            const clientPhone = createTestPhone()
            const clientName = faker.random.alphaNumeric(5)
            const [ticket] = await createTestTicket(adminClient, dummyOrganization, property, {
                unitName, unitType, clientPhone, clientName, isResidentTicket: true,
            })
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                ticket: { connect: { id: ticket.id } },
            })

            expect(invoice).toBeDefined()
            expect(invoice.ticket.id).toEqual(ticket.id)
            expect(invoice.property.id).toEqual(ticket.property.id)
            expect(invoice.unitName).toEqual(ticket.unitName)
            expect(invoice.unitType).toEqual(ticket.unitType)
            expect(invoice.clientPhone).toEqual(ticket.clientPhone)
            expect(invoice.clientName).toEqual(ticket.clientName)
        })

        test('can connect ticket to invoice', async () => {
            const [property] = await createTestProperty(adminClient, dummyOrganization)
            const unitName = faker.random.alphaNumeric(5)
            const unitType = FLAT_UNIT_TYPE
            const clientPhone = createTestPhone()
            const clientName = faker.random.alphaNumeric(5)
            const [ticket] = await createTestTicket(adminClient, dummyOrganization, property, {
                unitName, unitType, clientPhone, clientName, isResidentTicket: true,
            })

            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                status: INVOICE_STATUS_PUBLISHED,
            })

            expect(invoice).toBeDefined()
            expect(invoice.ticket).toBeNull()
            expect(invoice.property).toBeNull()
            expect(invoice.unitName).toBeNull()
            expect(invoice.unitType).toBeNull()
            expect(invoice.clientPhone).toBeNull()
            expect(invoice.clientName).toBeNull()

            const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                ticket: { connect: { id: ticket.id } },
            })

            expect(updatedInvoice).toBeDefined()
            expect(updatedInvoice.ticket.id).toEqual(ticket.id)
            expect(updatedInvoice.property.id).toEqual(ticket.property.id)
            expect(updatedInvoice.unitName).toEqual(ticket.unitName)
            expect(updatedInvoice.unitType).toEqual(ticket.unitType)
            expect(updatedInvoice.clientPhone).toEqual(ticket.clientPhone)
            expect(updatedInvoice.clientName).toEqual(ticket.clientName)
        })

        test('can\'t update ticket for invoice with ticket', async () => {
            const [property] = await createTestProperty(adminClient, dummyOrganization)
            const [ticket] = await createTestTicket(adminClient, dummyOrganization, property)
            const [ticket1] = await createTestTicket(adminClient, dummyOrganization, property)

            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                ticket: { connect: { id: ticket.id } },
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, invoice.id, {
                    ticket: { connect: { id: ticket1.id } },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'FORBID_UPDATE_TICKET',
                message: 'You cannot update ticket in invoice that is already linked to the ticket',
                messageForUser: 'api.marketplace.invoice.FORBID_UPDATE_TICKET',
            })
        })

        test('can\'t update invoice client data to other than ticket client data', async () => {
            const [property] = await createTestProperty(adminClient, dummyOrganization)
            const [ticket] = await createTestTicket(adminClient, dummyOrganization, property)
            const [property1] = await createTestProperty(adminClient, dummyOrganization)

            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                ticket: { connect: { id: ticket.id } },
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, invoice.id, {
                    property: { connect: { id: property1.id } },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'CLIENT_DATA_DOES_NOT_MATCH_TICKET',
                message: `Fields ${CLIENT_DATA_FIELDS.join(', ')} must match same fields in connected ticket`,
                messageForUser: 'api.marketplace.invoice.CLIENT_DATA_DOES_NOT_MATCH_TICKET',
            })
        })

        test('can update status and rows in invoice with ticket', async () => {
            const [property] = await createTestProperty(adminClient, dummyOrganization)
            const [ticket] = await createTestTicket(adminClient, dummyOrganization, property)

            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                ticket: { connect: { id: ticket.id } },
                rows: generateInvoiceRows(),
                status: INVOICE_STATUS_DRAFT,
            })

            const newRows = generateInvoiceRows()
            const [updatedInvoice] = await updateTestInvoice(adminClient, invoice.id, {
                rows: newRows,
                status: INVOICE_STATUS_PUBLISHED,
            })

            expect(updatedInvoice.rows.map((row) => pick(row, ['name', 'toPay', 'isMin', 'count']))).toEqual(newRows)
            expect(updatedInvoice.status).toEqual(INVOICE_STATUS_PUBLISHED)
        })

        test('client data auto update when ticket updates client data', async () => {
            const [property] = await createTestProperty(adminClient, dummyOrganization)
            const unitName = faker.random.alphaNumeric(5)
            const unitType = FLAT_UNIT_TYPE
            const clientPhone = createTestPhone()
            const clientName = faker.random.alphaNumeric(5)
            const [ticket] = await createTestTicket(adminClient, dummyOrganization, property, {
                unitName: null,
                unitType: null,
            })
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                ticket: { connect: { id: ticket.id } },
            })

            expect(invoice).toBeDefined()
            expect(invoice.ticket.id).toEqual(ticket.id)
            expect(invoice.property.id).toEqual(ticket.property.id)
            expect(invoice.unitName).toBeNull()
            expect(invoice.unitType).toBeNull()
            expect(invoice.clientPhone).toBeNull()
            expect(invoice.clientName).toBeNull()

            const [updatedTicket] = await updateTestTicket(adminClient, ticket.id, {
                isResidentTicket: true,
                unitName, unitType, clientPhone, clientName,
            })

            const updatedInvoice = await Invoice.getOne(adminClient, { id: invoice.id })

            expect(updatedInvoice.property.id).toEqual(updatedTicket.property.id)
            expect(updatedInvoice.unitName).toEqual(updatedTicket.unitName)
            expect(updatedInvoice.unitType).toEqual(updatedTicket.unitType)
            expect(updatedInvoice.clientPhone).toEqual(updatedTicket.clientPhone)
            expect(updatedInvoice.clientName).toEqual(updatedTicket.clientName)
        })

        test(`invoices status sets to ${INVOICE_STATUS_CANCELED} when ticket status sets canceled`, async () => {
            const [property] = await createTestProperty(adminClient, dummyOrganization)
            const [ticket] = await createTestTicket(adminClient, dummyOrganization, property)
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                status: INVOICE_STATUS_PUBLISHED,
                ticket: { connect: { id: ticket.id } },
            })

            await updateTestTicket(adminClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.DECLINED } },
            })

            const updatedInvoice = await Invoice.getOne(adminClient, { id: invoice.id })

            expect(updatedInvoice.status).toEqual(INVOICE_STATUS_CANCELED)
        })

        test('can\'t publish invoice with isMin-price', async () => {
            const [invoice] = await createTestInvoice(adminClient, dummyOrganization, {
                rows: [generateInvoiceRow({ isMin: true })],
                status: INVOICE_STATUS_DRAFT,
            })

            await expectToThrowGQLError(async () => {
                await updateTestInvoice(adminClient, invoice.id, { status: INVOICE_STATUS_PUBLISHED })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'PUBLISHING_WITHOUT_DEFINED_PRICES_FORBIDDEN',
                message: 'Can\'t publish invoice without defined prices',
                messageForUser: 'api.marketplace.invoice.PUBLISHING_WITHOUT_DEFINED_PRICES_FORBIDDEN',
            })
        })

        test('can create more then 2 invoice with different ticket', async () => {
            const createInvoiceWithTicket = async () => {
                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    isPayable: true,
                    unitType,
                    unitName,
                    clientName: null,
                    clientPhone: null,
                    contact: null,
                    source: { connect: { id: '830d1d89-2d17-4c5b-96d1-21b5cd01a6d3' } },
                    client: { connect: { id: residentClient.user.id } },
                })
                await createTestInvoice(client, client.organization, {
                    property: { connect: { id: client.property.id } },
                    unitType,
                    unitName,
                    status: INVOICE_STATUS_PUBLISHED,
                    ticket: { connect: { id: ticket.id } },
                    client: { connect: { id: residentClient.user.id } },
                })
            }
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })
            await createInvoiceWithTicket()
            await createInvoiceWithTicket()
            await createInvoiceWithTicket()
            const invoicesWithTicket = await Invoice.getAll(client, {})
            expect(invoicesWithTicket).toHaveLength(3)
        })

        test('can cancel ticket with several invoice when one invoice in paid status and other in published or draft', async () => {
            const client = await makeClientWithProperty()
            await createTestAcquiringIntegrationContext(adminClient, client.organization, dummyAcquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: createTestRecipient(),
            })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: client.property.address,
                    addressMeta: client.property.addressMeta,
                    unitType,
                    unitName,
                })
            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                isPayable: true,
                unitType,
                unitName,
                clientName: null,
                clientPhone: null,
                contact: null,
                source: { connect: { id: '830d1d89-2d17-4c5b-96d1-21b5cd01a6d3' } },
                client: { connect: { id: residentClient.user.id } },
            })
            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PAID,
                ticket: { connect: { id: ticket.id } },
                client: { connect: { id: residentClient.user.id } },
            })
            await createTestInvoice(client, client.organization, {
                property: { connect: { id: client.property.id } },
                unitType,
                unitName,
                status: INVOICE_STATUS_PUBLISHED,
                ticket: { connect: { id: ticket.id } },
                client: { connect: { id: residentClient.user.id } },
            })
            const [status] = await TicketStatus.getAll(client, {
                type: 'canceled',
            })
            await updateTestTicket(client, ticket.id, { status: { connect: { id: status.id } } })
        })

        describe('validate distribution', () => {
            describe('must throw an error if', () => {
                let o10n
                let bankAccount1, bankAccount2, bankAccount3
                let recipient1, recipient2, recipient3
                let rows
                let serviceClient

                beforeAll(async () => {
                    [o10n] = await createTestOrganization(adminClient);
                    [bankAccount1] = await createTestBankAccount(supportClient, o10n);
                    [bankAccount2] = await createTestBankAccount(supportClient, o10n);
                    [bankAccount3] = await createTestBankAccount(supportClient, o10n)

                    recipient1 = createTestRecipient({
                        tin: bankAccount1.tin,
                        bic: bankAccount1.routingNumber,
                        bankAccount: bankAccount1.number,
                    })
                    recipient2 = createTestRecipient({
                        tin: bankAccount2.tin,
                        bic: bankAccount2.routingNumber,
                        bankAccount: bankAccount2.number,
                    })
                    recipient3 = createTestRecipient({
                        tin: bankAccount3.tin,
                        bic: bankAccount3.routingNumber,
                        bankAccount: bankAccount3.number,
                    })

                    serviceClient = await makeClientWithServiceUser()
                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(supportClient, app, o10n, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(supportClient, app, {
                        canReadOrganizations: true,
                        canReadInvoices: true,
                        canManageInvoices: true,
                    })
                    await createTestB2BAppAccessRight(supportClient, serviceClient.user, app, accessRightSet)
                    const [acquiringIntegration] = await createTestAcquiringIntegration(supportClient, { canGroupReceipts: true })
                    await createTestAcquiringIntegrationContext(adminClient, o10n, acquiringIntegration, {
                        invoiceStatus: CONTEXT_FINISHED_STATUS,
                        invoiceRecipient: createTestRecipient(),
                    })

                    rows = [
                        generateInvoiceRow({ toPay: '100', count: 2 }),
                        generateInvoiceRow({ toPay: '300', count: 1 }),
                    ]
                })

                test('no approved bank account for recipient', async () => {
                    const unapprovedRecipient = createTestRecipient()
                    await expectToThrowGQLError(async () => {
                        await createTestInvoice(serviceClient, o10n, {
                            rows,
                            amountDistribution: [
                                { recipient: unapprovedRecipient, amount: '200' },
                                {
                                    recipient: recipient2,
                                    amount: '300',
                                    vor: true,
                                    overpaymentPart: 1,
                                    isFeePayer: true,
                                },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'NO_APPROVED_BANK_ACCOUNT',
                        message: 'Some recipients not approved. Please connect to support.',
                        notApprovedRecipients: [unapprovedRecipient],
                    })
                })

                test('sums not match', async () => {
                    await expectToThrowGQLError(async () => {
                        await createTestInvoice(serviceClient, o10n, {
                            rows,
                            amountDistribution: [
                                { recipient: recipient1, amount: '100' },
                                {
                                    recipient: recipient2,
                                    amount: '300',
                                    vor: true,
                                    overpaymentPart: 1,
                                    isFeePayer: true,
                                },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'SUMS_NOT_MATCH',
                        message: 'Total sum (toPay={toPay}) is not match to sum of distributions ({distributionsSum})',
                        messageInterpolation: { toPay: '500', distributionsSum: '400' },
                    })
                })

                describe('no single victim of rounding in each group', () => {
                    test('when no such item', async () => {
                        await expectToThrowGQLError(async () => {
                            await createTestInvoice(serviceClient, o10n, {
                                rows,
                                amountDistribution: [
                                    { recipient: recipient1, amount: '200' },
                                    { recipient: recipient2, amount: '300', overpaymentPart: 1, isFeePayer: true },
                                ],
                            })
                        }, {
                            code: 'BAD_USER_INPUT',
                            type: 'NO_VOR_IN_GROUP',
                            message: 'Group {order} does not contains a SINGLE element with vor=true',
                            messageInterpolation: { order: 0 },
                        })
                    })

                    test('when 2 such items', async () => {
                        await expectToThrowGQLError(async () => {
                            await createTestInvoice(serviceClient, o10n, {
                                rows,
                                amountDistribution: [
                                    {
                                        recipient: recipient1,
                                        amount: '100',
                                        order: 0,
                                        vor: true,
                                        isFeePayer: true,
                                        overpaymentPart: 1,
                                    },
                                    {
                                        recipient: recipient2,
                                        amount: '300',
                                        order: 1,
                                        vor: true,
                                        overpaymentPart: 1,
                                        isFeePayer: true,
                                    },
                                    {
                                        recipient: recipient3,
                                        amount: '100',
                                        order: 1,
                                        vor: true,
                                        isFeePayer: true,
                                        overpaymentPart: 1,
                                    },
                                ],
                            })
                        }, {
                            code: 'BAD_USER_INPUT',
                            type: 'NO_VOR_IN_GROUP',
                            message: 'Group {order} does not contains a SINGLE element with vor=true',
                            messageInterpolation: { order: 1 },
                        })
                    })
                })

                test('vor-item is not fee payer', async () => {
                    await expectToThrowGQLError(async () => {
                        await createTestInvoice(serviceClient, o10n, {
                            rows,
                            amountDistribution: [
                                { recipient: recipient1, amount: '200' },
                                { recipient: recipient2, amount: '300', vor: true, overpaymentPart: 1 },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'VOR_MUST_BE_FEE_PAYER',
                        message: 'The victim of rounding (vor) must have isFeePayer=true',
                    })
                })

                test('vor-item is not overpayment receiver', async () => {
                    await expectToThrowGQLError(async () => {
                        await createTestInvoice(serviceClient, o10n, {
                            rows,
                            amountDistribution: [
                                { recipient: recipient1, amount: '200' },
                                { recipient: recipient2, amount: '300', vor: true, isFeePayer: true },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'VOR_MUST_BE_OVERPAYMENT_RECEIVER',
                        message: 'The victim of rounding (vor) must have overpaymentPart value',
                    })
                })

                test('not unique recipients', async () => {
                    await expectToThrowGQLError(async () => {
                        await createTestInvoice(serviceClient, o10n, {
                            rows,
                            amountDistribution: [
                                { recipient: recipient1, amount: '200', vor: true },
                                { recipient: recipient1, amount: '300', isFeePayer: true },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'NOT_UNIQUE_RECIPIENTS',
                        message: 'Distribution contains not unique recipients',
                    })
                })

                test('no recipients set', async () => {
                    await expectToThrowGQLError(async () => {
                        await createTestInvoice(serviceClient, o10n, {
                            rows,
                            amountDistribution: [],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'WRONG_AMOUNT_DISTRIBUTION',
                        message: '"amountDistribution" field validation error. JSON was not in the correct format',
                        errors: [expect.objectContaining({ message: 'must NOT have fewer than 1 items' })],
                    })
                })

                test('5+ recipients set', async () => {
                    await expectToThrowGQLError(async () => {
                        await createTestInvoice(serviceClient, o10n, {
                            rows,
                            amountDistribution: [
                                { recipient: createTestRecipient(), amount: '100', vor: true },
                                { recipient: createTestRecipient(), amount: '100', isFeePayer: true },
                                { recipient: createTestRecipient(), amount: '100' },
                                { recipient: createTestRecipient(), amount: '100' },
                                { recipient: createTestRecipient(), amount: '50' },
                                { recipient: createTestRecipient(), amount: '50' },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'WRONG_AMOUNT_DISTRIBUTION',
                        message: '"amountDistribution" field validation error. JSON was not in the correct format',
                        errors: [expect.objectContaining({ message: 'must NOT have more than 5 items' })],
                    })
                })
            })
        })
    })

    describe('access to fields', () => {
        describe('amountDistribution', () => {
            let bankAccount1, bankAccount2, recipient1, recipient2
            let staffWithPermissionsClient, staffWithoutPermissionsClient, residentClient
            let CustomInvoiceTestUtils

            const rows = [
                generateInvoiceRow({ toPay: '100', count: 2 }),
                generateInvoiceRow({ toPay: '300', count: 1 }),
            ]
            const rowsAmount = rows.reduce((acc, { toPay, count }) => acc.plus(Big(toPay).times(count)), Big(0)).toString()

            beforeAll(async () => {
                residentClient = await makeClientWithResidentUser()
                // Generate utils containing the `amountDistribution` field
                CustomInvoiceTestUtils = generateGQLTestUtils(generateGqlQueries(
                    'Invoice',
                    `{ id organization { id } number amountDistribution { ${AMOUNT_DISTRIBUTION_SUBFIELDS} } }`
                ));
                [bankAccount1] = await createTestBankAccount(supportClient, dummyOrganization);
                [bankAccount2] = await createTestBankAccount(supportClient, dummyOrganization)

                recipient1 = createTestRecipient({
                    tin: bankAccount1.tin,
                    bic: bankAccount1.routingNumber,
                    bankAccount: bankAccount1.number,
                })

                recipient2 = createTestRecipient({
                    tin: bankAccount2.tin,
                    bic: bankAccount2.routingNumber,
                    bankAccount: bankAccount2.number,
                })

                staffWithPermissionsClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [roleWithPermissions] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canReadInvoices: true,
                    canManageInvoices: true,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, staffWithPermissionsClient.user, roleWithPermissions)

                staffWithoutPermissionsClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [roleWithoutPermissions] = await createTestOrganizationEmployeeRole(adminClient, dummyOrganization, {
                    canReadInvoices: false,
                    canManageInvoices: false,
                })
                await createTestOrganizationEmployee(adminClient, dummyOrganization, staffWithoutPermissionsClient.user, roleWithoutPermissions)
            })

            describe('can create, read and update', () => {
                const testFunc = async (testingClient) => {
                    const [createdObj, createAttrs] = await createTestInvoice(testingClient, dummyOrganization, {
                        rows,
                        amountDistribution: [
                            { recipient: recipient1, amount: rowsAmount, vor: true, isFeePayer: true, overpaymentPart: 1 },
                        ],
                    })

                    const readObj = await CustomInvoiceTestUtils.getOne(testingClient, { id: createdObj.id })
                    expect(readObj.amountDistribution).toEqual([expect.objectContaining({
                        ...createAttrs.amountDistribution[0],
                        recipient: expect.objectContaining(recipient1),
                    })])

                    const [, updateAttrs] = await updateTestInvoice(testingClient, createdObj.id, {
                        rows,
                        amountDistribution: [
                            {
                                recipient: recipient2,
                                amount: rowsAmount,
                                vor: true,
                                isFeePayer: true,
                                overpaymentPart: 1,
                            },
                        ],
                    })
                    const updatedObj = await CustomInvoiceTestUtils.getOne(adminClient, { id: createdObj.id })
                    expect(updatedObj.amountDistribution).toEqual([expect.objectContaining({
                        ...updateAttrs.amountDistribution[0],
                        recipient: expect.objectContaining(recipient2),
                        amount: rowsAmount,
                    })])
                }

                test('admin can create, read and update', async () => {
                    await testFunc(adminClient)
                })

                test('support can create, read and update', async () => {
                    await testFunc(supportClient)
                })

                test('service client with rights', async () => {
                    const serviceClient = await makeClientWithServiceUser()
                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(supportClient, app, dummyOrganization, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(supportClient, app, {
                        canReadOrganizations: true,
                        canReadInvoices: true,
                        canManageInvoices: true,
                    })
                    await createTestB2BAppAccessRight(supportClient, serviceClient.user, app, accessRightSet)

                    await testFunc(serviceClient)
                })
            })

            describe('can not create, read and update', () => {
                const testFunc = async (testingClient, { throwErrorOnRead = true } = {}) => {

                    // cant create
                    await expectToThrowAccessDeniedToManageFieldError(
                        async () => await createTestInvoice(testingClient, dummyOrganization, {
                            rows,
                            amountDistribution: [
                                {
                                    recipient: recipient1,
                                    amount: rowsAmount,
                                    vor: true,
                                    isFeePayer: true,
                                    overpaymentPart: 1,
                                },
                            ],
                        }),
                        'obj',
                        'amountDistribution',
                    )

                    // create by admin to try to read and update
                    const [createdObj] = await createTestInvoice(adminClient, dummyOrganization, {
                        rows,
                        amountDistribution: [
                            { recipient: recipient1, amount: rowsAmount, vor: true, isFeePayer: true, overpaymentPart: 1 },
                        ],
                    })

                    // cant read
                    if (throwErrorOnRead) {
                        await expectToThrowAccessDeniedToFieldError(async () => {
                            await CustomInvoiceTestUtils.getAll(testingClient, { id: createdObj.id })
                        }, 'objs', 'amountDistribution')
                    } else {
                        const invoices = await CustomInvoiceTestUtils.getAll(testingClient, { id: createdObj.id })
                        expect(invoices).toHaveLength(0)
                    }

                    // cant update
                    await expectToThrowAccessDeniedToManageFieldError(
                        async () => await updateTestInvoice(testingClient, createdObj.id, {
                            amountDistribution: [
                                {
                                    recipient: recipient1,
                                    amount: rowsAmount,
                                    vor: true,
                                    isFeePayer: true,
                                    overpaymentPart: 2,
                                },
                            ],
                        }),
                        'obj',
                        'amountDistribution',
                    )
                }

                test('staff with permission', async () => {
                    await testFunc(staffWithPermissionsClient)
                })

                test('staff without permission', async () => {
                    await testFunc(staffWithoutPermissionsClient, { throwErrorOnRead: false })
                })

                test('resident', async () => {
                    await testFunc(residentClient, { throwErrorOnRead: false })
                })
            })
        })
    })

    describe('real-life cases', () => {
        test('B2B app can add an invoice for organization and it\'s resident', async () => {
            // Some staff registers new organization and add property
            const staffClient = await makeClientWithStaffUser()
            const [o10n] = await registerNewOrganization(staffClient)
            const [property] = await createTestProperty(staffClient, o10n)

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            // New resident registers in property
            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            // Some b2b-app decided to have an ability to create invoices
            const serviceClient = await makeClientWithServiceUser()
            const [app] = await createTestB2BApp(supportClient)
            const [accessRightSet] = await createTestB2BAppAccessRightSet(supportClient, app, {
                canReadOrganizations: true,
                canReadInvoices: true,
                canManageInvoices: true,
            })
            await createTestB2BAppAccessRight(supportClient, serviceClient.user, app, accessRightSet)
            const [acquiringIntegration] = await createTestAcquiringIntegration(supportClient, { canGroupReceipts: true })

            const [bankAccount1] = await createTestBankAccount(supportClient, o10n)
            const [bankAccount2] = await createTestBankAccount(supportClient, o10n)

            const recipient1 = createTestRecipient({
                tin: bankAccount1.tin,
                bic: bankAccount1.routingNumber,
                bankAccount: bankAccount1.number,
            })
            const recipient2 = createTestRecipient({
                tin: bankAccount2.tin,
                bic: bankAccount2.routingNumber,
                bankAccount: bankAccount2.number,
            })

            // The organization connects marketplace
            await createTestAcquiringIntegrationContext(staffClient, o10n, acquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: recipient1,
            })

            // The organization connects b2b-app
            await createTestB2BAppContext(staffClient, app, o10n, { status: 'Finished' })

            // b2b-app creates invoice for organization's resident
            const [invoice] = await createTestInvoice(serviceClient, o10n, {
                rows: [
                    generateInvoiceRow({ toPay: '1000', count: 1 }),
                ],
                amountDistribution: [
                    { recipient: recipient1, amount: '200', vor: true, overpaymentPart: 1, isFeePayer: true },
                    { recipient: recipient2, amount: '800' },
                ],
                client: { connect: { id: residentClient.user.id } },
                status: INVOICE_STATUS_PUBLISHED,
            })

            // organization can see the invoice in marketplace
            const o10nInvoices = await Invoice.getAll(staffClient, {})
            expect(o10nInvoices).toEqual([expect.objectContaining({ id: invoice.id })])

            // resident can see invoice in mobile application
            const residentInvoices = await Invoice.getAll(residentClient, {})
            expect(residentInvoices).toEqual([expect.objectContaining({ id: invoice.id })])
        })

        test('B2B app can add an invoice for b2b\'s organization and for some organization\'s resident', async () => {
            // Some staff registers new organization and add property
            const staffClient = await makeClientWithStaffUser()
            const b2bStaffClient = await makeClientWithStaffUser()
            const [o10n] = await registerNewOrganization(staffClient)
            const [b2bO10n] = await registerNewOrganization(b2bStaffClient)
            const [property] = await createTestProperty(staffClient, o10n)

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            // New resident registers in property
            const residentClient = await makeClientWithResidentUser()
            await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            // Some b2b-app decided to have an ability to create invoices
            const serviceClient = await makeClientWithServiceUser()
            const [app] = await createTestB2BApp(supportClient)
            const [accessRightSet] = await createTestB2BAppAccessRightSet(supportClient, app, {
                canReadOrganizations: true,
                canReadInvoices: true,
                canManageInvoices: true,
            })
            await createTestB2BAppAccessRight(supportClient, serviceClient.user, app, accessRightSet)

            const [bankAccount1] = await createTestBankAccount(supportClient, b2bO10n)
            const [bankAccount2] = await createTestBankAccount(supportClient, b2bO10n)

            const recipient1 = createTestRecipient({
                tin: bankAccount1.tin,
                bic: bankAccount1.routingNumber,
                bankAccount: bankAccount1.number,
            })
            const recipient2 = createTestRecipient({
                tin: bankAccount2.tin,
                bic: bankAccount2.routingNumber,
                bankAccount: bankAccount2.number,
            })

            // The organization connects marketplace
            const [acquiringIntegration] = await createTestAcquiringIntegration(supportClient, { canGroupReceipts: true })
            await createTestAcquiringIntegrationContext(b2bStaffClient, b2bO10n, acquiringIntegration, {
                invoiceStatus: CONTEXT_FINISHED_STATUS,
                invoiceRecipient: recipient1,
            })

            // The organization connects b2b-app
            await createTestB2BAppContext(b2bStaffClient, app, b2bO10n, { status: 'Finished' })

            // b2b-app creates invoice for organization's resident
            const [invoice] = await createTestInvoice(serviceClient, b2bO10n, {
                rows: [
                    generateInvoiceRow({ toPay: '1000', count: 1 }),
                ],
                amountDistribution: [
                    { recipient: recipient1, amount: '200', vor: true, overpaymentPart: 1, isFeePayer: true },
                    { recipient: recipient2, amount: '800' },
                ],
                client: { connect: { id: residentClient.user.id } },
                status: INVOICE_STATUS_PUBLISHED,
            })

            // organization can't see the invoice in marketplace
            const o10nInvoices = await Invoice.getAll(staffClient, {})
            expect(o10nInvoices).toHaveLength(0)

            // b2b organization can see the invoice in marketplace
            const b2bO10nInvoices = await Invoice.getAll(b2bStaffClient, {})
            expect(b2bO10nInvoices).toEqual([expect.objectContaining({ id: invoice.id })])

            // resident or organization can see invoice in mobile application
            const residentInvoices = await Invoice.getAll(residentClient, {})
            expect(residentInvoices).toEqual([expect.objectContaining({ id: invoice.id })])
        })
    })
})
