/**
 * Generated by `createschema marketplace.MarketPriceScope 'itemPrice:Relationship:MarketItemPrice:CASCADE; property:Relationship:Property:CASCADE; organization:Relationship:Organization:CASCADE;'`
 */

const get = require('lodash/get')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema  } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/marketplace/access/MarketPriceScope')
const {
    MARKETPLACE_PRICE_SCOPES_TYPES,
    MARKETPLACE_PRICE_SCOPE_TYPE_ORGANIZATION,
    MARKETPLACE_PRICE_SCOPE_TYPE_PROPERTY,
} = require('@condo/domains/marketplace/constants')
const { MarketItemPrice, MarketItem } = require('@condo/domains/marketplace/utils/serverSchema')
const { Property } = require('@condo/domains/property/utils/serverSchema')

const ERRORS = {
    ORGANIZATION_IN_PROPERTY_AND_MARKET_ITEM_PRICE_NOT_MATCHED: {
        code: BAD_USER_INPUT,
        type: 'ORGANIZATION_IN_PROPERTY_AND_MARKET_ITEM_PRICE_NOT_MATCHED',
        messageForUser: 'api.marketplace.marketItemPrice.ORGANIZATION_IN_PROPERTY_AND_MARKET_ITEM_PRICE_NOT_MATCHED',
        message: 'Cannot create scope with property from one organization and market item from another organization.',
    },
}

const MarketPriceScope = new GQLListSchema('MarketPriceScope', {
    schemaDoc: 'Which residents can see the particular market item price instance',
    fields: {
        marketItemPrice: {
            schemaDoc: 'Link to market item price',
            type: 'Relationship',
            ref: 'MarketItemPrice',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },
        property: {
            schemaDoc: 'Link to property',
            type: 'Relationship',
            ref: 'Property',
            kmigratorOptions: { null: true, on_delete: 'models.CASCADE' },
        },
        type: {
            schemaDoc: 'The scope type. This is an auto-calculated field. Used to find items by scopes filled with some set of attributes.',
            type: 'Select',
            options: MARKETPLACE_PRICE_SCOPES_TYPES,
            isRequired: true,
            access: {
                read: true,
                create: false,
                update: false,
            },
            hooks: {
                resolveInput: async ({ operation, resolvedData, fieldPath }) => {
                    if (operation === 'create') {
                        return resolvedData.property ? MARKETPLACE_PRICE_SCOPE_TYPE_PROPERTY : MARKETPLACE_PRICE_SCOPE_TYPE_ORGANIZATION
                    }

                    return resolvedData[fieldPath]
                },
            },
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['property', 'marketItemPrice'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'MarketPriceScope_unique_property_marketItemPrice',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['marketItemPrice'],
                condition: 'Q(deletedAt__isnull=True)&' +
                    'Q(property__isnull=True)',
                name: 'MarketPriceScope_unique_marketItemPrice',
            },
        ],
    },
    hooks: {
        validateInput: async ({ resolvedData, existingItem, context }) => {
            const nextData = { ...existingItem, ...resolvedData }
            // Check rows
            const propertyId = get(nextData, 'property', null)
            if (propertyId) {
                const marketItemPriceId = get(nextData, 'marketItemPrice', null)
                const marketItemPrice = await MarketItemPrice.getOne(context, {
                    id: marketItemPriceId,
                }, 'marketItem { id }')
                const marketItem = await MarketItem.getOne(context, {
                    id: get(marketItemPrice, 'marketItem.id', null),
                }, 'organization { id }')

                const property = await Property.getOne(context, {
                    id: propertyId,
                }, 'id organization { id }')

                if (get(marketItem, 'organization.id') !== get(property, 'organization.id')) throw new GQLError(ERRORS.ORGANIZATION_IN_PROPERTY_AND_MARKET_ITEM_PRICE_NOT_MATCHED, context)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), analytical()],
    access: {
        read: access.canReadMarketPriceScopes,
        create: access.canManageMarketPriceScopes,
        update: access.canManageMarketPriceScopes,
        delete: false,
        auth: true,
    },
})

module.exports = {
    MarketPriceScope,
}
