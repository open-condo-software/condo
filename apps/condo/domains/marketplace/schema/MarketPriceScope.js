/**
 * Generated by `createschema marketplace.MarketPriceScope 'itemPrice:Relationship:MarketItemPrice:CASCADE; property:Relationship:Property:CASCADE; organization:Relationship:Organization:CASCADE;'`
 */

const get = require('lodash/get')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema  } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/marketplace/access/MarketPriceScope')
const { MarketItemPrice, MarketItem } = require('@condo/domains/marketplace/utils/serverSchema')
const { Property } = require('@condo/domains/property/utils/serverSchema')


const ERRORS = {
    ORGANIZATION_IN_PROPERTY_AND_MARKET_ITEM_PRICE_NOT_MATCHED: {
        code: BAD_USER_INPUT,
        type: 'ORGANIZATION_IN_PROPERTY_AND_MARKET_ITEM_PRICE_NOT_MATCHED',
        messageForUser: 'api.marketplace.MarketItemPrice.error.ORGANIZATION_IN_PROPERTY_AND_MARKET_ITEM_PRICE_NOT_MATCHED',
        message: 'Cannot create scope with property from one organization and market item from another organization.',
    },
}


const MarketPriceScope = new GQLListSchema('MarketPriceScope', {
    schemaDoc: 'Which residents can see the particular market item price instance',
    fields: {

        marketItemPrice: {
            schemaDoc: 'Link to market item price',
            type: 'Relationship',
            ref: 'MarketItemPrice',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },

        property: {
            schemaDoc: 'Link to property',
            type: 'Relationship',
            ref: 'Property',
            kmigratorOptions: { null: true, on_delete: 'models.CASCADE' },
        },

    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['property', 'marketItemPrice'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'MarketPriceScope_unique_property_marketItemPrice',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['marketItemPrice'],
                condition: 'Q(deletedAt__isnull=True)&' +
                    'Q(property__isnull=True)',
                name: 'MarketPriceScope_unique_marketItemPrice',
            },
        ],
    },
    hooks: {
        validateInput: async ({ resolvedData, existingItem, context }) => {
            const nextData = { ...existingItem, ...resolvedData }
            // Check rows
            const propertyId = get(nextData, 'property', null)
            if (propertyId) {
                const marketItemPriceId = get(nextData, 'marketItemPrice', null)
                const marketItemPrice = await MarketItemPrice.getOne(context, {
                    id: marketItemPriceId,
                })
                const marketItem = await MarketItem.getOne(context, {
                    id: get(marketItemPrice, 'marketItem.id', null),
                })

                const property = await Property.getOne(context, {
                    id: propertyId,
                })

                if (get(marketItem, 'organization.id') !== get(property, 'organization.id')) throw new GQLError(ERRORS.ORGANIZATION_IN_PROPERTY_AND_MARKET_ITEM_PRICE_NOT_MATCHED, context)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadMarketPriceScopes,
        create: access.canManageMarketPriceScopes,
        update: access.canManageMarketPriceScopes,
        delete: false,
        auth: true,
    },
})

module.exports = {
    MarketPriceScope,
}
