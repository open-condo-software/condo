/**
 * Generated by `createschema notification.MessageBlackList 'organization?:Relationship:Organization:SET_NULL; user?:Relationship:User:CASCADE; phone?:Text; email?:Text;'`
 */

const faker = require('faker')

const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, waitFor } = require('@core/keystone/test.utils')

const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects,
} = require('@condo/domains/common/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser, createTestEmail, createTestPhone } = require('@condo/domains/user/utils/testSchema')
const { MessageBlackList, createTestMessageBlackList, updateTestMessageBlackList, Message } = require('@condo/domains/notification/utils/testSchema')
const { createTestBillingIntegrationLog } = require('@condo/domains/billing/utils/testSchema')
const { makeClientWithRegisteredOrganization, inviteNewOrganizationEmployee, reInviteNewOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema/Organization')
const { DIRTY_INVITE_NEW_EMPLOYEE_MESSAGE_TYPE, MESSAGE_SENT_STATUS, EMAIL_TRANSPORT, MESSAGE_ERROR_STATUS } = require('@condo/domains/notification/constants/constants')

describe('MessageBlackList', () => {
    describe('accesses', () => {
        describe('create', () => {
            it('support can create MessageBlackList', async () => {
                const supportClient = await makeClientWithSupportUser()

                const [blackList] = await createTestMessageBlackList(supportClient)

                expect(blackList.id).toMatch(UUID_RE)
            })

            it('user cannot create MessageBlackList', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMessageBlackList(userClient)
                })
            })

            it('anonymous cannot create MessageBlackList', async () => {
                const anonymousClient = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestMessageBlackList(anonymousClient)
                })
            })
        })

        describe('update', () => {
            it('support can update MessageBlackList', async () => {
                const supportClient = await makeClientWithSupportUser()

                const [blackList] = await createTestMessageBlackList(supportClient)
                const description = faker.random.alphaNumeric(8)

                const [updatedBlackList] = await updateTestMessageBlackList(supportClient, blackList.id, {
                    description,
                })

                expect(updatedBlackList.description).toEqual(description)
            })

            it('user cannot update MessageBlackList', async () => {
                const supportClient = await makeClientWithSupportUser()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [blackList] = await createTestMessageBlackList(supportClient)
                const description = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMessageBlackList(userClient, blackList.id, {
                        description,
                    })
                })
            })

            it('anonymous cannot update MessageBlackList', async () => {
                const supportClient = await makeClientWithSupportUser()
                const anonymousClient = await makeClient()

                const [blackList] = await createTestMessageBlackList(supportClient)
                const description = faker.random.alphaNumeric(8)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestMessageBlackList(anonymousClient, blackList.id, {
                        description,
                    })
                })
            })
        })

        describe('read', () => {
            it('user cannot read MessageBlackList', async () => {
                const supportClient = await makeClientWithSupportUser()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                await createTestMessageBlackList(supportClient)

                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await MessageBlackList.getAll(userClient)
                })
            })

            it('anonymous cannot read MessageBlackList', async () => {
                const supportClient = await makeClientWithSupportUser()
                const anonymousClient = await makeClient()

                await createTestMessageBlackList(supportClient)

                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await MessageBlackList.getAll(anonymousClient)
                })
            })
        })
    })

    describe('logic', () => {
        it('dont send invite notification if message type and email added in MessageBlackList', async () => {
            const admin = await makeLoggedInAdminClient()
            const userAttrs = {
                name: faker.name.firstName(),
                email: createTestEmail(),
                phone: createTestPhone(),
            }
            const client = await makeClientWithRegisteredOrganization()

            await createTestMessageBlackList(admin, {
                type: DIRTY_INVITE_NEW_EMPLOYEE_MESSAGE_TYPE,
                email: userAttrs.email,
            })

            const [employee] = await inviteNewOrganizationEmployee(client, client.organization, userAttrs)

            await waitFor(async () => {
                const messageWhere = { user: { id: employee.user.id }, type: DIRTY_INVITE_NEW_EMPLOYEE_MESSAGE_TYPE }
                const messages = await Message.getAll(admin, messageWhere)

                expect(messages[0].status).toEqual(MESSAGE_ERROR_STATUS)
                expect(messages[0].processingMeta).toBeNull()
            })
        })

        it('dont send any notifications to phone if MessageBlackList rule type is empty', async () => {
            const admin = await makeLoggedInAdminClient()
            const userAttrs = {
                name: faker.name.firstName(),
                email: createTestEmail(),
                phone: createTestPhone(),
            }
            const client = await makeClientWithRegisteredOrganization()

            await createTestMessageBlackList(admin, {
                email: userAttrs.email,
            })

            const [employee] = await inviteNewOrganizationEmployee(client, client.organization, userAttrs)

            await waitFor(async () => {
                const messageWhere = { user: { id: employee.user.id }, type: DIRTY_INVITE_NEW_EMPLOYEE_MESSAGE_TYPE }
                const messages = await Message.getAll(admin, messageWhere)

                expect(messages[0].status).toEqual(MESSAGE_ERROR_STATUS)
                expect(messages[0].processingMeta).toBeNull()
            })
        })
    })
})
