/**
 * Generated by `createschema notification.MessageBatch 'messageType:Text; title:Text; message:Text; deepLink?:Text; targets:Json; status:Select:created,processing,failed,done; processingMeta?:Json;'`
 */
const faker = require('faker')
const { sample } = require('lodash')
const dayjs = require('dayjs')

const {
    makeLoggedInAdminClient,
    makeClient,
    UUID_RE,
    DATETIME_RE, waitFor,
} = require('@condo/keystone/test.utils')

const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects,
    expectToThrowValidationFailureError,
} = require('@condo/domains/common/utils/testSchema')
const {
    JSON_EXPECT_ARRAY_ERROR,
    JSON_EXPECT_OBJECT_ERROR,
    OPERATION_FORBIDDEN,
} = require('@condo/domains/common/constants/errors')

const {
    MessageBatch,
    createTestMessageBatch,
    updateTestMessageBatch, Message,
} = require('@condo/domains/notification/utils/testSchema')

const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
} = require('@condo/domains/user/utils/testSchema')

const {
    MESSAGE_BATCH_CREATED_STATUS,
    MESSAGE_BATCH_PROCESSING_STATUS,
    MESSAGE_BATCH_FAILED_STATUS,
    MESSAGE_BATCH_DONE_STATUS,
    CUSTOM_CONTENT_MESSAGE_TYPE,
    MESSAGE_BATCH_TYPE_OPTIONS,
} = require('../constants/constants')

const { DATE_FORMAT, getUniqKey } = require('../tasks/sendMessageBatch.helpers')


describe('MessageBatch', () => {
    let admin
    let anonymous
    let support
    let userClient
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        anonymous = await makeClient()
        support = await makeClientWithSupportUser()
        userClient = await makeClientWithNewRegisteredAndLoggedInUser()
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestMessageBatch(admin)

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(1)
                expect(obj.newId).toEqual(null)
                expect(obj.deletedAt).toEqual(null)
                expect(obj.createdBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(obj.createdAt).toMatch(DATETIME_RE)
                expect(obj.updatedAt).toMatch(DATETIME_RE)
                expect(obj.title).toMatch(attrs.title)
                expect(obj.message).toMatch(attrs.message)
                expect(obj.messageType).toMatch(attrs.messageType)
                expect(obj.deepLink).toMatch(attrs.deepLink)
                expect(obj.targets).toEqual(attrs.targets)
                expect(obj.status).toMatch(MESSAGE_BATCH_CREATED_STATUS)
            })

            test('support can', async () => {
                const [obj, attrs] = await createTestMessageBatch(support)

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(1)
                expect(obj.newId).toEqual(null)
                expect(obj.deletedAt).toEqual(null)
                expect(obj.createdBy).toEqual(expect.objectContaining({ id: support.user.id }))
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: support.user.id }))
                expect(obj.createdAt).toMatch(DATETIME_RE)
                expect(obj.updatedAt).toMatch(DATETIME_RE)
                expect(obj.title).toMatch(attrs.title)
                expect(obj.message).toMatch(attrs.message)
                expect(obj.messageType).toMatch(attrs.messageType)
                expect(obj.deepLink).toMatch(attrs.deepLink)
                expect(obj.targets).toEqual(attrs.targets)
                expect(obj.status).toMatch(MESSAGE_BATCH_CREATED_STATUS)
            })

            test('user can not', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMessageBatch(userClient)
                })
            })

            test('anonymous can not', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestMessageBatch(anonymous)
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestMessageBatch(admin)
                const [obj, attrs] = await updateTestMessageBatch(admin, objCreated.id)

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            })

            test('support can', async () => {
                const [objCreated] = await createTestMessageBatch(support)
                const [obj, attrs] = await updateTestMessageBatch(support, objCreated.id)

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: support.user.id }))
            })

            test('user can not', async () => {
                const [objCreated] = await createTestMessageBatch(admin)
                const client = await makeClientWithNewRegisteredAndLoggedInUser()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMessageBatch(client, objCreated.id)
                })
            })

            test('anonymous can not', async () => {
                const [objCreated] = await createTestMessageBatch(admin)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestMessageBatch(anonymous, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can not', async () => {
                const [objCreated] = await createTestMessageBatch(admin)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MessageBatch.delete(admin, objCreated.id)
                })
            })

            test('user can not', async () => {
                const [objCreated] = await createTestMessageBatch(admin)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MessageBatch.delete(userClient, objCreated.id)
                })
            })

            test('anonymous can not', async () => {
                const [objCreated] = await createTestMessageBatch(admin)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MessageBatch.delete(anonymous, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestMessageBatch(admin)
                const obj1 = await MessageBatch.getOne(admin, { id: obj.id })

                expect(obj1).not.toBeUndefined()
                expect(obj1).toEqual(
                    expect.objectContaining({
                        id: obj.id,
                        messageType: attrs.messageType,
                        title: attrs.title,
                        message: attrs.message,
                        deepLink: attrs.deepLink,
                        targets: attrs.targets,
                    }),
                )
            })

            test('support can', async () => {
                const [obj, attrs] = await createTestMessageBatch(support)
                const obj1 = await MessageBatch.getOne(support, { id: obj.id })

                expect(obj1).not.toBeUndefined()
                expect(obj1).toEqual(
                    expect.objectContaining({
                        id: obj.id,
                        messageType: attrs.messageType,
                        title: attrs.title,
                        message: attrs.message,
                        deepLink: attrs.deepLink,
                        targets: attrs.targets,
                    }),
                )
            })

            test('user can not', async () => {
                const [obj] = await createTestMessageBatch(admin)

                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await MessageBatch.getOne(userClient, { id: obj.id })
                })
            })

            test('anonymous can not', async () => {
                const [obj] = await createTestMessageBatch(admin)

                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await MessageBatch.getOne(anonymous, { id: obj.id })
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('Non-object value in processingMeta fails', async () => {
            await expectToThrowValidationFailureError(
                async () => { await createTestMessageBatch(admin, { processingMeta: faker.random.alphaNumeric(8) }) },
                `${JSON_EXPECT_OBJECT_ERROR}processingMeta] Expect JSON Object`
            )
        })


        test('Non-array value in targets fails', async () => {
            await expectToThrowValidationFailureError(
                async () => { await createTestMessageBatch(admin, { targets: {} }) },
                `${JSON_EXPECT_ARRAY_ERROR}targets] Expect non-empty JSON Array`
            )
            await expectToThrowValidationFailureError(
                async () => { await createTestMessageBatch(admin, { targets: null }) },
                'Required field "targets" is null or undefined.'
            )
            await expectToThrowValidationFailureError(
                async () => { await createTestMessageBatch(admin, { targets: undefined }) },
                'Required field "targets" is null or undefined.'
            )
            await expectToThrowValidationFailureError(
                async () => { await createTestMessageBatch(admin, { targets: 17 }) },
                `${JSON_EXPECT_ARRAY_ERROR}targets] Expect non-empty JSON Array`
            )
            await expectToThrowValidationFailureError(
                async () => { await createTestMessageBatch(admin, { targets: 'some string value' }) },
                `${JSON_EXPECT_ARRAY_ERROR}targets] Expect non-empty JSON Array`
            )
        })

        test('Empty array in targets fails', async () => {
            await expectToThrowValidationFailureError(
                async () => { await createTestMessageBatch(admin, { targets: [] }) },
                `${JSON_EXPECT_ARRAY_ERROR}targets] Expect non-empty JSON Array`
            )
        })

        test('admin can not update messageType', async () => {
            const [objCreated] = await createTestMessageBatch(admin)

            await expectToThrowValidationFailureError(async () => {
                await updateTestMessageBatch(admin, objCreated.id, { messageType: sample(MESSAGE_BATCH_TYPE_OPTIONS) })
            }, `${OPERATION_FORBIDDEN}] Updating messageType is forbidden.`)
        })

        test('admin can not update title', async () => {
            const [objCreated] = await createTestMessageBatch(admin)

            await expectToThrowValidationFailureError(async () => {
                await updateTestMessageBatch(admin, objCreated.id, { title: faker.random.alphaNumeric(8) })
            }, `${OPERATION_FORBIDDEN}] Updating title is forbidden.`)
        })

        test('admin can not update message', async () => {
            const [objCreated] = await createTestMessageBatch(admin)

            await expectToThrowValidationFailureError(async () => {
                await updateTestMessageBatch(admin, objCreated.id, { message: faker.random.alphaNumeric(8) })
            }, `${OPERATION_FORBIDDEN}] Updating message is forbidden.`)
        })

        test('admin can not update deepLink', async () => {
            const [objCreated] = await createTestMessageBatch(admin)

            await expectToThrowValidationFailureError(async () => {
                await updateTestMessageBatch(admin, objCreated.id, { deepLink: faker.random.alphaNumeric(8) })
            }, `${OPERATION_FORBIDDEN}] Updating deepLink is forbidden.`)
        })

        test('admin can not update targets', async () => {
            const [objCreated] = await createTestMessageBatch(admin)

            await expectToThrowValidationFailureError(async () => {
                await updateTestMessageBatch(admin, objCreated.id, { targets: [faker.random.alphaNumeric(8)] })
            }, `${OPERATION_FORBIDDEN}] Updating targets is forbidden.`)
        })

    })

    describe('task', () => {
        it('handles messageBatch and creates push notification of CUSTOM_CONTENT_MESSAGE_TYPE for user', async () => {
            const [marketingMessage] = await createTestMessageBatch(admin)
            const date = dayjs().format(DATE_FORMAT)
            const messagesWhere = {
                type: CUSTOM_CONTENT_MESSAGE_TYPE,
                user: { id: admin.user.id },
                uniqKey: getUniqKey(date, marketingMessage.title, admin.user.id),
            }
            const messagesSort = { sortBy: ['createdAt_DESC'] }

            await waitFor(async () => {
                const marketingMessage1 = await MessageBatch.getOne(admin, { id: marketingMessage.id })

                expect(marketingMessage1.processingMeta.successCnt).toEqual(1)
                expect(marketingMessage1.status).toEqual(MESSAGE_BATCH_DONE_STATUS)
            })

            await waitFor(async () => {
                const message = await Message.getOne(admin, messagesWhere, messagesSort)

                expect(message).not.toBeUndefined()
                expect(message.type).toEqual(CUSTOM_CONTENT_MESSAGE_TYPE)
                expect(message.user.id).toEqual(admin.user.id)
            })
        })

        it('handles messageBatch and creates sms notification of CUSTOM_CONTENT_MESSAGE_TYPE for phone', async () => {
            const phone = faker.phone.phoneNumber('+79#########')
            const [marketingMessage] = await createTestMessageBatch(admin, { targets: [phone] })
            const date = dayjs().format(DATE_FORMAT)
            const messagesWhere = {
                type: CUSTOM_CONTENT_MESSAGE_TYPE,
                uniqKey: getUniqKey(date, marketingMessage.title, phone),
            }
            const messagesSort = { sortBy: ['createdAt_DESC'] }

            await waitFor(async () => {
                const marketingMessage1 = await MessageBatch.getOne(admin, { id: marketingMessage.id })

                expect(marketingMessage1.processingMeta.successCnt).toEqual(1)
                expect(marketingMessage1.status).toEqual(MESSAGE_BATCH_DONE_STATUS)
            })

            await waitFor(async () => {
                const message = await Message.getOne(admin, messagesWhere, messagesSort)

                expect(message).not.toBeUndefined()
                expect(message.type).toEqual(CUSTOM_CONTENT_MESSAGE_TYPE)
                expect(message.phone).toEqual(phone)
            })
        })

        it('handles messageBatch and creates email notification of CUSTOM_CONTENT_MESSAGE_TYPE for email', async () => {
            const email = `${faker.random.alphaNumeric(8)}@${faker.random.alphaNumeric(8)}.com`
            const [marketingMessage] = await createTestMessageBatch(admin, { targets: [email] })
            const date = dayjs().format(DATE_FORMAT)
            const messagesWhere = {
                type: CUSTOM_CONTENT_MESSAGE_TYPE,
                uniqKey: getUniqKey(date, marketingMessage.title, email),
            }
            const messagesSort = { sortBy: ['createdAt_DESC'] }

            await waitFor(async () => {
                const marketingMessage1 = await MessageBatch.getOne(admin, { id: marketingMessage.id })

                expect(marketingMessage1.processingMeta.successCnt).toEqual(1)
                expect(marketingMessage1.status).toEqual(MESSAGE_BATCH_DONE_STATUS)
            })

            await waitFor(async () => {
                const message = await Message.getOne(admin, messagesWhere, messagesSort)

                expect(message).not.toBeUndefined()
                expect(message.type).toEqual(CUSTOM_CONTENT_MESSAGE_TYPE)
                expect(message.email).toEqual(email)
            })
        })

        it('sends nothing for nonexistent user, broken email or phone, and other invalid targets ', async () => {
            const date = dayjs().format(DATE_FORMAT)
            // invalid targets
            const targets = [
                faker.datatype.uuid(), // non existent user
                faker.random.alphaNumeric(8), // some random string
                faker.phone.phoneNumber('+79########'), //broken phone number
                faker.phone.phoneNumber('+73#########'), //landline phone number
                `${faker.random.alphaNumeric(8)}@${faker.random.alphaNumeric(8)}`, // broken email
                '',
                null,
                17,
                new Date(),
            ]
            const [marketingMessage] = await createTestMessageBatch(admin, { targets })
            const uniqKeys = targets.map(target => getUniqKey(date, marketingMessage.title, target))
            const messagesWhere = {
                type: CUSTOM_CONTENT_MESSAGE_TYPE,
                uniqKey_in: uniqKeys,
            }
            const messagesSort = { sortBy: ['createdAt_DESC'] }

            await waitFor(async () => {
                const marketingMessage1 = await MessageBatch.getOne(admin, { id: marketingMessage.id })

                expect(marketingMessage1.status).toEqual(MESSAGE_BATCH_FAILED_STATUS)
                expect(marketingMessage1.processingMeta.successCnt).toEqual(0)
                expect(marketingMessage1.processingMeta.failCnt).toEqual(targets.length)
            }, { delay: 2000 })

            await waitFor(async () => {
                const messages = await Message.getAll(admin, messagesWhere, messagesSort)

                expect(messages.length).toEqual(0)
            })
        })

        it('handles messageBatch, creates notifications of CUSTOM_CONTENT_MESSAGE_TYPE, skips duplicate targets', async () => {
            const email = `${faker.random.alphaNumeric(8)}@${faker.random.alphaNumeric(8)}.com`
            const phone = faker.phone.phoneNumber('+79#########')
            const targets = [email, email, email, phone, phone, phone, admin.user.id, admin.user.id, admin.user.id]
            const [marketingMessage] = await createTestMessageBatch(admin, { targets })

            await waitFor(async () => {
                const marketingMessage1 = await MessageBatch.getOne(admin, { id: marketingMessage.id })

                expect(marketingMessage1.status).toEqual(MESSAGE_BATCH_DONE_STATUS)
                expect(marketingMessage1.processingMeta.successCnt).toEqual(3)
                expect(marketingMessage1.processingMeta.duplicates).toEqual(6)
            })
        })
    })
})