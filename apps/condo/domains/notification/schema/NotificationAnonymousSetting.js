/**
 * Generated by `createschema notification.NotificationAnonymousSetting 'email:Text; phone:Text; messageType:Text; messageTransport:Text; isEnabled:Checkbox'`
 */
const { Text, Checkbox, Select } = require('@keystonejs/fields')
const { get, isEmpty, isUndefined, isNull } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { normalizePhone } = require('@condo/domains/common/utils/phone')
const access = require('@condo/domains/notification/access/NotificationAnonymousSetting')
const { EMAIL_TRANSPORT, SMS_TRANSPORT, MESSAGE_TYPES } = require('@condo/domains/notification/constants/constants')
const {
    NO_NEED_TO_ENABLE_NOTIFICATIONS,
    EMPTY_NOTIFICATION_ANONYMOUS_SETTING_FIELDS_ERROR,
} = require('@condo/domains/notification/constants/errors')

const ERRORS = {
    NO_NEED_TO_ENABLE_NOTIFICATIONS: {
        code: BAD_USER_INPUT,
        type: NO_NEED_TO_ENABLE_NOTIFICATIONS,
        message: 'No need to enable notifications. All notifications enabled by default. You may just delete this setting instead.',
    },
    EMPTY_NOTIFICATION_ANONYMOUS_SETTING_FIELDS_ERROR: {
        code: BAD_USER_INPUT,
        type: EMPTY_NOTIFICATION_ANONYMOUS_SETTING_FIELDS_ERROR,
        message: 'One of the "phone" or "email" fields should be provided.',
    },
}

const NotificationAnonymousSetting = new GQLListSchema('NotificationAnonymousSetting', {
    schemaDoc: 'Anonymous contact notifications settings',
    fields: {
        email: {
            schemaDoc: 'The settings will applied for',
            type: Text,
            isRequired: false,
            hooks: {
                resolveInput: ({ resolvedData }) => {
                    if (isUndefined(resolvedData.email)) return undefined
                    if (isNull(resolvedData.email) || isEmpty(resolvedData.email)) return null
                    return normalizeEmail(resolvedData['email']) || resolvedData['email']
                },
            },
        },
        phone: {
            schemaDoc: 'Phone. In international E.164 format without spaces',
            type: Text,
            isRequired: false,
            hooks: {
                resolveInput: async ({ resolvedData }) => {
                    if (isUndefined(resolvedData.phone)) return undefined
                    if (isNull(resolvedData.phone) || isEmpty(resolvedData.phone)) return null
                    return normalizePhone(resolvedData['phone']) || resolvedData['phone']
                },
            },
        },
        messageType: {
            schemaDoc: `Affected message type. Possible values are: ${MESSAGE_TYPES.join(',')}`,
            type: Select,
            options: MESSAGE_TYPES,
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, max_length: 100 },
        },
        messageTransport: {
            schemaDoc: `Affected message transport. Possible values are: ${EMAIL_TRANSPORT}, ${SMS_TRANSPORT}`,
            type: Select,
            options: [EMAIL_TRANSPORT, SMS_TRANSPORT],
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true },
        },
        isEnabled: {
            schemaDoc: 'Is notification enabled',
            type: Checkbox,
            isRequired: false,
            defaultValue: true,
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.CheckConstraint',
                check: 'Q(messageType__isnull=False) | Q(messageTransport__isnull=False)',
                name: 'nas_has_messageType_or_messageTransport',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['email', 'messageType', 'messageTransport'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'nas_unique_email_messageType_messageTransport',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['email', 'messageType'],
                condition: 'Q(deletedAt__isnull=True) & Q(messageTransport__isnull=True)',
                name: 'nas_unique_email_messageType',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['email', 'messageTransport'],
                condition: 'Q(deletedAt__isnull=True) & Q(messageType__isnull=True)',
                name: 'nas_unique_email_messageTransport',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['phone', 'messageType', 'messageTransport'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'nas_unique_phone_messageType_messageTransport',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['phone', 'messageType'],
                condition: 'Q(deletedAt__isnull=True) & Q(messageTransport__isnull=True)',
                name: 'nas_unique_phone_messageType',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['phone', 'messageTransport'],
                condition: 'Q(deletedAt__isnull=True) & Q(messageType__isnull=True)',
                name: 'nas_unique_phone_messageTransport',
            },
        ],
        indexes: [
            {
                type: 'BTreeIndex',
                fields: ['email', 'messageType'],
                name: 'nas_email_messageType_idx',
            },
            {
                type: 'BTreeIndex',
                fields: ['phone', 'messageType'],
                name: 'nas_phone_messageType_idx',
            },
        ],
    },
    hooks: {
        validateInput: async (args) => {
            const { resolvedData, context } = args

            const isEnabled = get(resolvedData, 'isEnabled')
            const email = get(resolvedData, 'email')
            const phone = get(resolvedData, 'phone')

            // This is a temporary check.
            // It is actual as long we only control if the message enabled
            // All messages are enabled by default, so there is no needed to create model with isEnabled=true
            if (isEnabled) {
                throw new GQLError(ERRORS.NO_NEED_TO_ENABLE_NOTIFICATIONS, context)
            }

            if (isEmpty(phone) && isEmpty(email)) {
                throw new GQLError(ERRORS.EMPTY_NOTIFICATION_ANONYMOUS_SETTING_FIELDS_ERROR, context)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadNotificationAnonymousSettings,
        create: access.canManageNotificationAnonymousSettings,
        update: access.canManageNotificationAnonymousSettings,
        delete: false,
        auth: true,
    },
})

module.exports = {
    NotificationAnonymousSetting,
}
