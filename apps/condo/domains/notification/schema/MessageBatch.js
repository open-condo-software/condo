/**
 * Generated by `createschema notification.MessageBatch 'messageType:Text; title:Text; message:Text; deepLink?:Text; targets:Json; status:Select:created,processing,failed,done; processingMeta?:Json;'`
 */

const { isArray, isEmpty } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const { JSON_EXPECT_ARRAY_ERROR, OPERATION_FORBIDDEN } = require('@condo/domains/common/constants/errors')
const { hasValidJsonStructure } = require('@condo/domains/common/utils/validation.utils')
const access = require('@condo/domains/notification/access/MessageBatch')
const {
    CUSTOM_CONTENT_MESSAGE_TYPE,
    MESSAGE_BATCH_STATUSES,
    MESSAGE_BATCH_CREATED_STATUS,
    MESSAGE_BATCH_TYPE_OPTIONS,
    BODY_IS_REQUIRED_FOR_CUSTOM_CONTENT_MESSAGE_TYPE,
    TITLE_IS_REQUIRED_FOR_CUSTOM_CONTENT_MESSAGE_TYPE,
} = require('@condo/domains/notification/constants/constants')
const { sendMessageBatch } = require('@condo/domains/notification/tasks/sendMessageBatch')

const operationForbiddenValidator = ({ fieldPath, addFieldValidationError, operation }) => {
    if (operation === 'update') addFieldValidationError(`${OPERATION_FORBIDDEN}] Updating ${fieldPath} is forbidden.`)
}

const ERRORS = {
    TITLE_IS_REQUIRED_FOR_CUSTOM_CONTENT_MESSAGE_TYPE: {
        code: BAD_USER_INPUT,
        type: TITLE_IS_REQUIRED_FOR_CUSTOM_CONTENT_MESSAGE_TYPE,
        message: 'Field "title" required for create MessageBatch with CUSTOM_CONTENT_MESSAGE type',
        mutation: 'createMessageBatch',
    },
    MESSAGE_IS_REQUIRED_FOR_CUSTOM_CONTENT_MESSAGE_TYPE: {
        code: BAD_USER_INPUT,
        type: BODY_IS_REQUIRED_FOR_CUSTOM_CONTENT_MESSAGE_TYPE,
        message: 'Field "body" required for create MessageBatch with CUSTOM_CONTENT_MESSAGE type',
        mutation: 'createMessageBatch',
    },
}

const MessageBatch = new GQLListSchema('MessageBatch', {
    schemaDoc: 'Batch of notifications. Creating a record sends the message to every target (user, phone, or email) using the transport that matches the target type.',
    fields: {
        messageType: {
            schemaDoc: 'Notification template or message type used to deliver the batch.',
            type: 'Select',
            options: MESSAGE_BATCH_TYPE_OPTIONS,
            defaultValue: CUSTOM_CONTENT_MESSAGE_TYPE,
            isRequired: false,
            hooks: {
                validateInput: operationForbiddenValidator,
            },
        },

        title: {
            schemaDoc: 'Shared title for all messages in the batch. Should be short and single-line.',
            type: 'Text',
            hooks: {
                validateInput: operationForbiddenValidator,
            },
        },

        message: {
            schemaDoc: 'Shared body for all messages in the batch. Can be multiline, but keep it brief for SMS or push notifications.',
            type: 'Text',
            hooks: {
                validateInput: operationForbiddenValidator,
            },
        },

        deepLink: {
            schemaDoc: 'Deep link that opens a specific screen in the mobile app. Used only for push notifications.',
            type: 'Text',
            hooks: {
                validateInput: operationForbiddenValidator,
            },
        },

        targets: {
            schemaDoc: 'List of recipients. Provide user IDs for push/email/SMS templates, email addresses for email messages, and phone numbers for SMS messages. Different target types can be mixed.',
            type: 'Json',
            isRequired: true,
            hooks: {
                validateInput: (args) => {
                    const { resolvedData, fieldPath, addFieldValidationError } = args
                    const targets = resolvedData[fieldPath]

                    if (!isArray(targets) || isEmpty(targets)) addFieldValidationError(`${JSON_EXPECT_ARRAY_ERROR}${fieldPath}] Expect non-empty JSON Array`)

                    operationForbiddenValidator(args)
                },
            },
        },

        status: {
            schemaDoc: 'Processing status of the batch.',
            type: 'Select',
            options: MESSAGE_BATCH_STATUSES,
            defaultValue: MESSAGE_BATCH_CREATED_STATUS,
            isRequired: true,
        },

        processingMeta: {
            schemaDoc: 'Processing results or metadata for the batch.',
            type: 'Json',
            isRequired: false,
            hooks: {
                validateInput: (args) => {
                    if (!hasValidJsonStructure(args, false, 1, {})) return
                },
            },
        },

    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadMessageBatches,
        create: access.canManageMessageBatches,
        update: access.canManageMessageBatches,
        delete: false,
        auth: true,
    },
    hooks: {
        validateInput: async ({ operation, resolvedData, context }) => {
            if (operation === 'create' && resolvedData.messageType === CUSTOM_CONTENT_MESSAGE_TYPE) {
                if (!resolvedData.title) throw new GQLError(ERRORS.TITLE_IS_REQUIRED_FOR_CUSTOM_CONTENT_MESSAGE_TYPE, context)
                if (!resolvedData.message) throw new GQLError(ERRORS.MESSAGE_IS_REQUIRED_FOR_CUSTOM_CONTENT_MESSAGE_TYPE, context)
            }
        },
        resolveInput: async ({ operation, resolvedData }) => {
            if (operation === 'create') resolvedData.status = MESSAGE_BATCH_CREATED_STATUS

            return resolvedData
        },
        afterChange: async ({ operation, updatedItem }) => {
            if (operation === 'create') await sendMessageBatch.delay(updatedItem.id)
        },
    },
})

module.exports = {
    MessageBatch,
}
