/**
 * Generated by `createschema ai.ExecutionAIFlowTask 'flowType:Text; context:Json; status:Select:processing,completed,error,canceled; result?:Json; errorMessage?:Text; error?:Json; meta?:Json; locale:Text; generationId?:Text; user:Relationship:User:SET_NULL;'`
 */
const Ajv = require('ajv')
const cloneDeep = require('lodash/cloneDeep')

const conf = require('@open-condo/config')
const { canOnlyServerSideWithoutUserRequest, userIsAdminOrIsSupport } = require('@open-condo/keystone/access')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')


const access = require('@condo/domains/ai/access/ExecutionAIFlowTask')
const {
    TASK_STATUSES,
    FLOW_TYPES_LIST,
    FLOW_META_SCHEMAS,
    CUSTOM_FLOW_TYPE,
} = require('@condo/domains/ai/constants')
const { executeAIFlow } = require('@condo/domains/ai/tasks')
const { CUSTOM_FLOW_TYPES_LIST } = require('@condo/domains/ai/utils/flowsConfig')
const { removeSensitiveDataFromObj } = require('@condo/domains/ai/utils/serverSchema/removeSensitiveDataFromObj')
const { WRONG_VALUE } = require('@condo/domains/common/constants/errors')
const { LOCALES } = require('@condo/domains/user/constants/common')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')

const EXECUTION_AI_FLOW_TASK_DEFAULT_RATE_LIMITER = {
    windowSizeInSec: 60 * 60,
    windowLimit: 30,
}
let EXECUTION_AI_FLOW_TASK_CUSTOM_RATE_LIMITER = {}
try {
    if (conf.EXECUTION_AI_FLOW_TASK_RATE_LIMITER) {
        EXECUTION_AI_FLOW_TASK_CUSTOM_RATE_LIMITER = JSON.parse(conf.EXECUTION_AI_FLOW_TASK_RATE_LIMITER)
    }
} catch (error) {
    console.error('EXECUTION_AI_FLOW_TASK_RATE_LIMITER could not be parsed!')
    console.error(error)
    EXECUTION_AI_FLOW_TASK_CUSTOM_RATE_LIMITER = {}
}

const ERRORS = {
    UNKNOWN_FLOW_TYPE: {
        mutation: 'createExecutionAIFlowTask',
        variable: ['data', 'flowType'],
        code: BAD_USER_INPUT,
        type: 'UNKNOWN_FLOW_TYPE',
        message: `Unknown flow type. May be one of list (${FLOW_TYPES_LIST.map(type => `"${type}"`).join(',')}) or some configured custom flow type`,
        messageForUser: 'api.ai.executionAIFlowTask.FAILED_TO_COMPLETE_REQUEST',
    },
    INVALID_FLOW_CONTEXT: {
        mutation: 'createExecutionAIFlowTask',
        variable: ['data', 'context'],
        code: BAD_USER_INPUT,
        type: 'INVALID_FLOW_CONTEXT',
        message: 'Flow context for current flow type has invalid format',
        messageForUser: 'api.ai.executionAIFlowTask.FAILED_TO_COMPLETE_REQUEST',
    },
    STATUS_IS_ALREADY_COMPLETED: {
        mutation: 'updateExecutionAIFlowTask',
        variable: ['data', 'status'],
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: 'Status is already completed',
        messageForUser: 'api.ai.executionAIFlowTask.STATUS_IS_ALREADY_COMPLETED',
    },
    STATUS_IS_ALREADY_ERROR: {
        mutation: 'updateExecutionAIFlowTask',
        variable: ['data', 'status'],
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: 'Status is already error',
        messageForUser: 'api.ai.executionAIFlowTask.STATUS_IS_ALREADY_ERROR',
    },
}

const redisGuard = new RedisGuard()

const ajv = new Ajv()

const ExecutionAIFlowTask = new GQLListSchema('ExecutionAIFlowTask', {
    schemaDoc: 'Allows you to run a deferred task to execute a request to AI. Saves information about the request, as well as about the process of executing the request itself.',
    fields: {

        flowType: {
            schemaDoc: `The type of AI flow to be called.
             \nThe value can be one of the list (${FLOW_TYPES_LIST.map(flowType => `"${flowType}"`).join('.')}), or some allowed custom value.`,
            type: 'Text',
            isRequired: true,
            access: {
                create: true,
                read: true,
                update: false,
            },
            hooks: {
                validateInput: ({ resolvedData, fieldPath, context }) => {
                    const flowType = resolvedData[fieldPath]
                    if (!FLOW_TYPES_LIST.includes(flowType) && !CUSTOM_FLOW_TYPES_LIST.includes(flowType)) {
                        throw new GQLError(ERRORS.UNKNOWN_FLOW_TYPE, context)
                    }
                },
            },
        },

        context: {
            schemaDoc: 'Context for executing a request to AI.',
            type: 'Json',
            isRequired: true,
            access: {
                create: true,
                read: true,
                update: false,
            },
        },

        cleanContext: {
            schemaDoc: 'Cleaned context for executing a request to AI. This field is managed by the system',
            type: 'Json',
            isRequired: true,
            access: {
                create: false,
                read: true,
                update: false,
            },
        },

        status: {
            schemaDoc: 'Status of the job. Used at client side progress information component.',
            type: 'Select',
            options: Object.values(TASK_STATUSES),
            defaultValue: TASK_STATUSES.PROCESSING,
            isRequired: true,
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: true,
                update: true,
            },
        },

        result: {
            schemaDoc: 'Result of query execution to AI.',
            type: 'Json',
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: true,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        errorMessage: {
            schemaDoc: 'User friendly error message.',
            type: 'Text',
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: true,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        error: {
            schemaDoc: 'Full error message for developers.',
            type: 'Json',
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: userIsAdminOrIsSupport,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        meta: {
            schemaDoc: 'Additional arbitrary data about the task.',
            type: 'Json',
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: userIsAdminOrIsSupport,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        locale: {
            schemaDoc: 'The requested locale in which the result will be displayed.',
            type: 'Select',
            options: LOCALES,
            isRequired: true,
            access: {
                create: true,
                read: true,
                update: false,
            },
            hooks: {
                resolveInput: async ({ context, resolvedData, fieldPath, operation }) => {
                    if (operation === 'create') {
                        const resolvedValue = resolvedData[fieldPath]
                        if (resolvedValue && LOCALES.includes(resolvedValue)) return resolvedValue
                        return extractReqLocale(context.req) || conf.DEFAULT_LOCALE
                    }
                },
            },
        },

        user: {
            schemaDoc: 'User that requested this operation.',
            type: 'Relationship',
            ref: 'User',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: {
                create: true,
                read: true,
                update: false,
            },
        },

    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadExecutionAIFlowTasks,
        create: access.canManageExecutionAIFlowTasks,
        update: access.canManageExecutionAIFlowTasks,
        delete: false,
        auth: true,
    },
    hooks: {
        resolveInput: async (args) => {
            const { resolvedData, operation } = args

            if (operation === 'create') {
                const { cleaned: cleanContext } = removeSensitiveDataFromObj(cloneDeep(resolvedData.context))
                resolvedData.cleanContext = cleanContext
            }

            return resolvedData
        },
        validateInput: async (args) => {
            const { resolvedData, existingItem, operation, context } = args

            const newItem = { ...existingItem, ...resolvedData }

            if (operation === 'create') {
                // rate limiter
                const userId =  newItem?.user
                const key = ['executionAIFlowTask', 'userId', userId].join(':')
                await redisGuard.checkCustomLimitCounters(
                    key,
                    EXECUTION_AI_FLOW_TASK_CUSTOM_RATE_LIMITER.windowSizeInSec || EXECUTION_AI_FLOW_TASK_DEFAULT_RATE_LIMITER.windowSizeInSec,
                    EXECUTION_AI_FLOW_TASK_CUSTOM_RATE_LIMITER.windowLimit || EXECUTION_AI_FLOW_TASK_DEFAULT_RATE_LIMITER.windowLimit,
                    context
                )

                // context validation
                const flowType = newItem.flowType
                const flowContext = newItem.context
                const isCustomFlow = CUSTOM_FLOW_TYPES_LIST.includes(flowType)

                const schema = FLOW_META_SCHEMAS[isCustomFlow ? CUSTOM_FLOW_TYPE : flowType]?.input ?? { type: 'object' }
                const validateFlowContext = ajv.compile(schema)
                if (!validateFlowContext(flowContext)) {
                    const flowContextErrors = validateFlowContext.errors.map(error => ({
                        message: error.message,
                        path: error.instancePath,
                    }))
                    throw new GQLError({ ...ERRORS.INVALID_FLOW_CONTEXT, errors: flowContextErrors }, context)
                }
            }

            if (existingItem) {
                if (resolvedData['status'] && existingItem['status'] === TASK_STATUSES.COMPLETED) {
                    throw new GQLError(ERRORS.STATUS_IS_ALREADY_COMPLETED, context)
                }
                if (resolvedData['status'] && existingItem['status'] === TASK_STATUSES.ERROR) {
                    throw new GQLError(ERRORS.STATUS_IS_ALREADY_ERROR, context)
                }
            }
        },
        afterChange: async ({ updatedItem, operation }) => {
            if (operation === 'create') {
                await executeAIFlow.delay(updatedItem.id)
            }
        },
    },
})

module.exports = {
    ExecutionAIFlowTask,
    ERRORS,
}
