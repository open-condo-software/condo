/**
 * Generated by `createschema acquiring.AcquiringIntegration 'name:Text;'`
 * In most cases you should not change it by hands
 * Please, don't remove `AUTOGENERATE MARKER`s
 */
const faker = require('faker')
const get = require('lodash/get')
const {createTestProperty} = require("@condo/domains/property/utils/testSchema");
const {
    createTestBillingIntegration,
    createTestBillingIntegrationOrganizationContext,
    createTestBillingAccount,
    createTestBillingProperty,
    createTestBillingReceipt,
} = require("@condo/domains/billing/utils/testSchema");
const {makeClientWithNewRegisteredAndLoggedInUser} = require("@condo/domains/user/utils/testSchema");
const {createTestOrganizationEmployee, createTestOrganizationEmployeeRole} = require("@condo/domains/organization/utils/testSchema");

const { generateGQLTestUtils } = require('@condo/domains/common/utils/codegeneration/generate.test.utils')
const { MULTIPAYMENT_INIT_STATUS } = require('../../constants')
const { makeLoggedInAdminClient } = require('@core/keystone/test.utils')
const { makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema/Organization')

const { AcquiringIntegration: AcquiringIntegrationGQL } = require('@condo/domains/acquiring/gql')
const { AcquiringIntegrationAccessRight: AcquiringIntegrationAccessRightGQL } = require('@condo/domains/acquiring/gql')
const { AcquiringIntegrationContext: AcquiringIntegrationContextGQL } = require('@condo/domains/acquiring/gql')
const { MultiPayment: MultiPaymentGQL } = require('@condo/domains/acquiring/gql')
const { Payment: PaymentGQL } = require('@condo/domains/acquiring/gql')

const dayjs = require('dayjs')
/* AUTOGENERATE MARKER <IMPORT> */

const AcquiringIntegration = generateGQLTestUtils(AcquiringIntegrationGQL)
const AcquiringIntegrationAccessRight = generateGQLTestUtils(AcquiringIntegrationAccessRightGQL)
const AcquiringIntegrationContext = generateGQLTestUtils(AcquiringIntegrationContextGQL)
const MultiPayment = generateGQLTestUtils(MultiPaymentGQL)
const Payment = generateGQLTestUtils(PaymentGQL)
/* AUTOGENERATE MARKER <CONST> */

function getRandomHiddenCard() {
    const prefix = Math.floor(Math.random() * 9000 + 1000)
    const suffix = Math.floor(Math.random() * 9000 + 1000)
    return `${prefix}********${suffix}`
}

async function createTestAcquiringIntegration (client, billings, extraAttrs = {}) {
    if (!client) throw new Error('no client')
    if (!billings || !billings.length) throw new Error('no billings')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
    const name = faker.company.companyName().replace(/ /, '-').toUpperCase() + ' TEST ACQUIRING'
    const hostUrl = faker.internet.url()
    const billingsIds = billings.map(billing => ({id: billing.id}))
    const attrs = {
        dv: 1,
        sender,
        name,
        hostUrl,
        supportedBillingIntegrations: { connect: billingsIds },
        ...extraAttrs
    }
    const obj = await AcquiringIntegration.create(client, attrs)
    return [obj, attrs]
}

async function updateTestAcquiringIntegration (client, id, extraAttrs = {}) {
    if (!client) throw new Error('no client')
    if (!id) throw new Error('no id')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

    const attrs = {
        dv: 1,
        sender,
        ...extraAttrs,
    }
    const obj = await AcquiringIntegration.update(client, id, attrs)
    return [obj, attrs]
}

async function createTestAcquiringIntegrationAccessRight (client, integration, user, extraAttrs = {}) {
    if (!client) throw new Error('no client')
    if (!integration || !integration.id) throw new Error('no integration')
    if (!user || !user.id) throw new Error('no user')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
    const attrs = {
        dv: 1,
        sender,
        integration: { connect: {id: integration.id } },
        user: { connect: { id: user.id } },
        ...extraAttrs,
    }
    const obj = await AcquiringIntegrationAccessRight.create(client, attrs)
    return [obj, attrs]
}

async function updateTestAcquiringIntegrationAccessRight (client, id, extraAttrs = {}) {
    if (!client) throw new Error('no client')
    if (!id) throw new Error('no id')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

    const attrs = {
        dv: 1,
        sender,
        ...extraAttrs,
    }
    const obj = await AcquiringIntegrationAccessRight.update(client, id, attrs)
    return [obj, attrs]
}

async function createTestAcquiringIntegrationContext (client, organization, integration, extraAttrs = {}) {
    if (!client) throw new Error('no client')
    if (!organization || !organization.id) throw new Error('no organization.id')
    if (!integration || !integration.id) throw new Error('no integration.id')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
    const settings = { dv: 1 }
    const state = { dv: 1 }

    const attrs = {
        dv: 1,
        sender,
        integration: { connect: { id: integration.id } },
        organization: { connect: { id: organization.id } },
        settings,
        state,
        ...extraAttrs,
    }
    const obj = await AcquiringIntegrationContext.create(client, attrs)
    return [obj, attrs]
}

async function updateTestAcquiringIntegrationContext (client, id, extraAttrs = {}) {
    if (!client) throw new Error('no client')
    if (!id) throw new Error('no id')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

    const attrs = {
        dv: 1,
        sender,
        ...extraAttrs,
    }
    const obj = await AcquiringIntegrationContext.update(client, id, attrs)
    return [obj, attrs]
}

async function makeAcquiringContext () {
    const admin = await makeLoggedInAdminClient()
    const [integration] = await createTestAcquiringIntegration(admin)
    const [organization] = await registerNewOrganization(admin)
    const [context] = await createTestAcquiringIntegrationContext(admin, organization, integration)
    return context
}

async function makeAcquiringContextAndIntegrationManager() {
    const admin = await makeLoggedInAdminClient()
    const [integration] = await createTestAcquiringIntegration(admin)
    const [organization] = await registerNewOrganization(admin)
    const [context] = await createTestAcquiringIntegrationContext(admin, organization, integration)
    const client = await makeClientWithNewRegisteredAndLoggedInUser()
    const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
        canManageIntegrations: true,
    })
    await createTestOrganizationEmployee(admin, organization, client.user, role)

    return {
        context,
        client
    }
}

async function makeAcquiringContextAndIntegrationAccount() {
    const admin = await makeLoggedInAdminClient()
    const [integration] = await createTestAcquiringIntegration(admin)
    const [organization] = await registerNewOrganization(admin)
    const [context] = await createTestAcquiringIntegrationContext(admin, organization, integration)
    const client = await makeClientWithNewRegisteredAndLoggedInUser()
    await createTestAcquiringIntegrationAccessRight(admin, integration, client.user)
    return {
        context,
        client
    }
}

async function createTestMultiPayment (client, payments, user, integration, extraAttrs = {}) {
    if (!client) throw new Error('no client')
    if (!payments || !payments.length) throw new Error('no receipts')
    if (!user) throw new Error('no user')
    if (!integration) throw new Error('no integration')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
    const amountWithoutExplicitFee = String(payments.reduce((acc, cur) => acc + parseFloat(cur.amount), 0))
    const explicitFee = String(Math.floor(Math.random() * 100) / 2)

    const attrs = {
        dv: 1,
        sender,
        amountWithoutExplicitFee,
        explicitFee,
        currencyCode: 'RUB',
        serviceCategory: 'TEST DOCUMENT',
        status: MULTIPAYMENT_INIT_STATUS,
        user: { connect: { id: user.id } },
        payments: { connect: payments.map(payment => ({id: payment.id})) },
        integration: { connect: { id: integration.id } },
        ...extraAttrs,
    }
    const obj = await MultiPayment.create(client, attrs)
    return [obj, attrs]
}

// todo @toplenboren (why do we need to use params? maybe add some generic solution?)
async function updateTestMultiPayment (client, id, extraAttrs = {}, params = {}) {
    if (!client) throw new Error('no client')
    if (!id) throw new Error('no id')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

    const attrs = {
        dv: 1,
        sender,
        ...extraAttrs,
    }
    const obj = await MultiPayment.update(client, id, attrs, params)
    return [obj, attrs]
}

async function createTestPayment (client, organization, receipt=null, context=null, extraAttrs = {}) {
    if (!client) throw new Error('no client')
    if (!organization || !organization.id) throw new Error('no organization.id')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
    const amount = get(receipt, 'toPay', '100.00')
    const explicitFee = String(Math.floor(Math.random() * 100) / 2)
    const implicitFee = String(Math.floor(Math.random() * 100) / 2)
    const period = dayjs().format('YYYY-MM-01')
    const contextId = get(context, 'id')
    const receiptId = get(receipt, 'id')

    const attrs = {
        dv: 1,
        sender,
        amount,
        explicitFee,
        implicitFee,
        currencyCode: 'RUB',
        advancedAt: dayjs().toISOString(),
        accountNumber: String(faker.datatype.number()),
        receipt: receiptId ? { connect: { id: receipt.id } } : null,
        frozenReceipt: receiptId ? receipt : null,
        organization: { connect: { id: organization.id } },
        context: contextId ? { connect: {id: contextId} } : null,
        period,
        ...extraAttrs,
    }
    const obj = await Payment.create(client, attrs)
    return [obj, attrs]
}

async function updateTestPayment (client, id, extraAttrs = {}) {
    if (!client) throw new Error('no client')
    if (!id) throw new Error('no id')
    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

    const attrs = {
        dv: 1,
        sender,
        ...extraAttrs,
    }
    const obj = await Payment.update(client, id, attrs)
    return [obj, attrs]
}

/* AUTOGENERATE MARKER <FACTORY> */

// Utils used to generate bunch of entities for working with MultiPayments
async function makePayer (receiptsAmount = 1) {
    const client = await makeClientWithResidentUser()
    const admin = await makeLoggedInAdminClient()

    const [organization] = await registerNewOrganization(admin)
    const [property] = await createTestProperty(admin, organization)

    const [billingIntegration] = await createTestBillingIntegration(admin)
    const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, billingIntegration)
    const [billingProperty] = await createTestBillingProperty(admin, billingContext, {address: property.address})
    const [billingAccount] = await createTestBillingAccount(admin, billingContext, billingProperty)
    const billingReceipts = []
    for (let i = 0; i < receiptsAmount; i++) {
        const [receipt] = await createTestBillingReceipt(admin, billingContext, billingProperty, billingAccount)
        billingReceipts.push(receipt)
    }

    const [acquiringIntegration] = await createTestAcquiringIntegration(admin, [billingIntegration])
    const [acquiringContext] = await createTestAcquiringIntegrationContext(admin, organization, acquiringIntegration)

    return {
        admin,
        client,
        organization,
        property,
        acquiringIntegration,
        acquiringContext,
        billingIntegration,
        billingContext,
        billingProperty,
        billingAccount,
        billingReceipts,
    }
}

async function makePayerAndPayments (receiptsAmount = 1) {
    const data = await makePayer(receiptsAmount)
    const { admin, billingReceipts, acquiringContext } = data
    const payments = []
    for (let i = 0; i < billingReceipts.length; i++) {
        const [payment] = await createTestPayment(admin, billingReceipts[i], acquiringContext)
        payments.push(payment)
    }

    return {
        ...data,
        payments
    }
}

module.exports = {
    AcquiringIntegration, createTestAcquiringIntegration, updateTestAcquiringIntegration,
    AcquiringIntegrationAccessRight, createTestAcquiringIntegrationAccessRight, updateTestAcquiringIntegrationAccessRight,
    AcquiringIntegrationContext, createTestAcquiringIntegrationContext, updateTestAcquiringIntegrationContext,
    MultiPayment, createTestMultiPayment, updateTestMultiPayment,
    makeAcquiringContext,
    makeAcquiringContextAndIntegrationAccount,
    makeAcquiringContextAndIntegrationManager,
    Payment, createTestPayment, updateTestPayment,
    makePayer,
    makePayerAndPayments,
    getRandomHiddenCard,
/* AUTOGENERATE MARKER <EXPORTS> */
}
