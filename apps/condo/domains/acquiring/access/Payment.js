/**
 * Generated by `createschema acquiring.Payment 'amount:Decimal; currencyCode:Text; time:DateTimeUtc; accountNumber:Text; purpose?:Text; receipts:Relationship:BillingReceipt:PROTECT; multiPayment:Relationship:MultiPayment:PROTECT; context:Relationship:AcquiringIntegrationContext:PROTECT;' --force`
 */
const get = require('lodash/get')

const { throwAuthenticationError } = require('@open-condo/keystone/apolloErrorFormatter')
const { find } = require('@open-condo/keystone/schema')

const { checkAcquiringIntegrationAccessRights } = require('@condo/domains/acquiring/utils/accessSchema')
const { canReadObjectsAsB2BAppServiceUser } = require('@condo/domains/miniapp/utils/b2bAppServiceUserAccess/server.utils')
const { checkPermissionsInEmployedOrganizations } = require('@condo/domains/organization/utils/accessSchema')
const { RESIDENT } = require('@condo/domains/user/constants/common')
const { SERVICE, STAFF } = require('@condo/domains/user/constants/common')
const { canDirectlyReadSchemaObjects } = require('@condo/domains/user/utils/directAccess')


async function canReadPayments (args) {
    const { authentication: { item: user }, listKey } = args
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false

    if (user.isSupport || user.isAdmin) return {}

    const hasDirectAccess = await canDirectlyReadSchemaObjects(user, listKey)
    if (hasDirectAccess) return {}

    if (user.type === RESIDENT) {
        return { multiPayment: { user: { id: user.id } } }
    }

    if (user.type === STAFF) {
        return {
            OR: [
                // Employee with `canReadPayments` can see theirs organization payments
                {
                    AND: [
                        {
                            invoice_is_null: true,
                            organization: { employees_some: { user: { id: user.id }, role: { canReadPayments: true }, deletedAt: null, isBlocked: false } },
                        },
                    ],
                },
                // Employee with `canReadPaymentsWithInvoices` can see theirs organization payments with invoices
                {
                    AND: [
                        {
                            invoice_is_null: false,
                            organization: { employees_some: { user: { id: user.id }, role: { canReadPaymentsWithInvoices: true }, deletedAt: null, isBlocked: false } },
                        },
                    ],
                },
            ],
        }
    }

    if (user.type === SERVICE) {
        const filtersByOrganization = await canReadObjectsAsB2BAppServiceUser(args)
        const filters = [
            // Acquiring integration account can see it's payments
            { context: { integration: { accessRights_some: { user: { id: user.id }, deletedAt: null } } } },
        ]
        if (filtersByOrganization !== false) {
            // Allow payments, whose organization connected b2bApp with access rights for this user
            filters.push({ AND: [{ ...filtersByOrganization }] })
        }
        return { OR: filters }
    }

    return false
}

async function canManagePayments ({ authentication: { item: user }, operation, itemId }) {
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false

    if (user.isAdmin) return true
    // Nobody can create Payments manually
    if (operation === 'create') return false
    // Acquiring integration can update its own Payments
    if (operation === 'update' && itemId) {
        return { context: { integration: { accessRights_some: { user: { id: user.id }, deletedAt: null } } } }
    }
    return false
}

async function canReadPaymentsSensitiveData (args) {
    const { authentication: { item: user }, existingItem, context, listKey } = args
    if (!user || user.deletedAt) return false
    if (user.isSupport || user.isAdmin) return true

    const hasDirectAccess = await canDirectlyReadSchemaObjects(user, listKey)
    if (hasDirectAccess) return true

    if (user.type === SERVICE) {
        const [acquiringContext] = await find('AcquiringIntegrationContext', {
            deletedAt: null,
            id: existingItem.context,
        })
        // If context exist => check is it's integration account
        if (acquiringContext) {
            const integrationId = get(acquiringContext, ['integration'])
            if (await checkAcquiringIntegrationAccessRights(user.id, [integrationId])) return true
        }
        if (await canReadObjectsAsB2BAppServiceUser(args)) return true
    }

    if (user.type === STAFF) {
        // Otherwise check if it's employee or not
        const canReadPayments = !!(await checkPermissionsInEmployedOrganizations(context, user, existingItem.organization, 'canReadPayments'))
        if (canReadPayments) {
            return true
        }

        const canReadPaymentsWithInvoices = !!(await checkPermissionsInEmployedOrganizations(context, user, existingItem.organization, 'canReadPaymentsWithInvoices'))
        if (canReadPaymentsWithInvoices) {
            return true
        }
    }

    return false
}


/*
  Rules are logical functions that used for list access, and may return a boolean (meaning
  all or no items are available) or a set of filters that limit the available items.
*/
module.exports = {
    canReadPayments,
    canManagePayments,
    canReadPaymentsSensitiveData,
}
