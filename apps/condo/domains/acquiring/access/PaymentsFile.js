/**
 * Generated by `createschema acquiring.PaymentsFile 'number:Text;file:File;billingIntegrationOrganizationContextId:Text;externalId:Text;account:Text;dateBegin:CalendarDay;dateEnd:CalendarDay;dateLoad:DateTimeUtc;uploadedRecords:Integer;amount:Decimal;amountBring:Decimal;registryName:Text;bankStatus:Text;bankComment:Text;fileName:Text;'`
 */

const get = require('lodash/get')
const uniq = require('lodash/uniq')

const { throwAuthenticationError } = require('@open-condo/keystone/apolloErrorFormatter')
const { find } = require('@open-condo/keystone/schema')

const { checkAcquiringIntegrationAccessRights } = require('@condo/domains/acquiring/utils/accessSchema')
const { getEmployedOrRelatedOrganizationsByPermissions } = require('@condo/domains/organization/utils/accessSchema')
const { SERVICE, STAFF } = require('@condo/domains/user/constants/common')

async function getAndValidateContextsAmount ({ originalInput, operation, itemIds, itemId, listKey })  {
    const isBulkRequest = Array.isArray(originalInput)

    let contextIds
    if (operation === 'create') {
        if (isBulkRequest) {
            contextIds = originalInput.map(element => get(element, ['data', 'context', 'connect', 'id']))
            if (contextIds.filter(Boolean).length !== originalInput.length) return false
            contextIds = uniq(contextIds)
        } else {
            const contextId = get(originalInput, ['context', 'connect', 'id'])
            if (!contextId) return false
            contextIds = [contextId]
        }
    } else if (operation === 'update') {
        const ids = itemIds || [itemId]
        if (!ids) return false
        if (ids.length !== uniq(ids).length) return false
        const items = await find(listKey, {
            id_in: ids,
            deletedAt: null,
        })
        if (items.length !== ids.length) return false
        contextIds = uniq(items.map(item => item.context))
    }

    return contextIds
}

async function canReadPaymentsFiles ({ authentication: { item: user }, context }) {
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false

    if (user.isSupport || user.isAdmin) return {}

    // Acquiring integration account can see its payments files
    if (user.type === SERVICE) {
        return { context: { integration: { accessRights_some: { user: { id: user.id }, deletedAt: null } } } }
    }

    // Employee with `canReadPayments` can see theirs organization payments files
    if (user.type === STAFF) {
        const permittedOrganizations =  await getEmployedOrRelatedOrganizationsByPermissions(context, user, 'canReadPayments')

        return { context: { organization: { id_in: permittedOrganizations } } }
    }

    return false
}


async function canManagePaymentsFiles ({ authentication: { item: user }, originalInput, operation, itemIds, itemId, listKey, context }) {
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false
    if (user.isAdmin) return true

    // STEP 1: Obtain contextIds and match theirs amounts
    const contextIds = await getAndValidateContextsAmount({ originalInput, operation, itemIds, itemId, listKey })
    // STEP 2: Obtain all contexts and check their deletion status
    const contexts = await find('AcquiringIntegrationContext', {
        id_in: contextIds,
        deletedAt: null,
    })

    if (contexts.length !== contextIds.length) return false

    // STEP 3a: Check acquiring integration access rights for service users
    if (user.type === SERVICE) {
        const integrationIds = uniq(contexts.map(context => context.integration))

        return await checkAcquiringIntegrationAccessRights(user.id, integrationIds)
    }

    // STEP 3b: Employee with `canReadPayments` can update theirs organization payments files
    if (user.type === STAFF && operation !== 'create') {
        if (contexts.length !== contextIds.length) return false
        const organizationIds = uniq(contexts.map(context => context.organization))

        const permittedOrganizations =  await getEmployedOrRelatedOrganizationsByPermissions(context, user, 'canReadPayments')

        return organizationIds.every((orgId) => permittedOrganizations.includes(orgId))
    }

    return false
}

/*
  Rules are logical functions that used for list access, and may return a boolean (meaning
  all or no items are available) or a set of filters that limit the available items.
*/
module.exports = {
    canReadPaymentsFiles,
    canManagePaymentsFiles,
}
