/**
 * Generated by `createschema acquiring.Payment 'amount:Decimal; currencyCode:Text; time:DateTimeUtc; accountNumber:Text; purpose?:Text; receipt:Relationship:BillingReceipt:PROTECT; multiPayment:Relationship:MultiPayment:PROTECT; context:Relationship:AcquiringIntegrationContext:PROTECT;' --force`
 */

const Big = require('big.js')
const get = require('lodash/get')

const { split } = require('@open-condo/billing/utils/paymentSplitter')
const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')

const access = require('@condo/domains/acquiring/access/Payment')
const {
    PAYMENT_NO_PAIRED_RECEIPT,
    PAYMENT_NO_PAIRED_FROZEN_RECEIPT,
    PAYMENT_NO_PAIRED_INVOICE,
    PAYMENT_NO_PAIRED_FROZEN_INVOICE,
    PAYMENT_CONTEXT_ORGANIZATION_NOT_MATCH,
    PAYMENT_NOT_ALLOWED_TRANSITION,
    PAYMENT_MISSING_REQUIRED_FIELDS,
    PAYMENT_FROZEN_FIELD_INCLUDED,
    PAYMENT_TOO_BIG_IMPLICIT_FEE,
    PAYMENT_NO_PAIRED_CONTEXT,
    PAYMENT_NO_SUPPORTED_CONTEXT,
    PAYMENT_RECIPIENT_MISMATCH,
    PAYMENT_EXPLICIT_FEE_AND_CHARGE_SAME_TIME,
    PAYMENT_OVERRIDING_EXPLICIT_FEES_MUST_BE_EXPLICIT,
    PAYMENT_RECEIPT_WITHOUT_ACCOUNT_NUMBER,
} = require('@condo/domains/acquiring/constants/errors')
const {
    PAYMENT_STATUSES,
    PAYMENT_INIT_STATUS,
    PAYMENT_TRANSITIONS,
    PAYMENT_REQUIRED_FIELDS,
    PAYMENT_FROZEN_FIELDS,
    PAYMENT_DONE_STATUS,
    PAYMENT_WITHDRAWN_STATUS,
} = require('@condo/domains/acquiring/constants/payment')
const { RECIPIENT_FIELD } = require('@condo/domains/acquiring/schema/fields/Recipient')
const { ACQUIRING_CONTEXT_FIELD } = require('@condo/domains/acquiring/schema/fields/relations')
const { sendPaymentStatusChangeWebhook } = require('@condo/domains/acquiring/tasks')
const { AcquiringIntegrationContext, Payment: PaymentGQL } = require('@condo/domains/acquiring/utils/serverSchema')
const { PERIOD_FIELD } = require('@condo/domains/billing/schema/fields/common')
const { BillingReceipt } = require('@condo/domains/billing/utils/serverSchema')
const {
    CURRENCY_CODE_FIELD,
    POSITIVE_MONEY_AMOUNT_FIELD,
    NON_NEGATIVE_MONEY_FIELD,
    IMPORT_ID_FIELD,
} = require('@condo/domains/common/schema/fields')
const { getCurrencyDecimalPlaces } = require('@condo/domains/common/utils/currencies')
const { INVOICE_STATUS_PUBLISHED, INVOICE_STATUS_PAID } = require('@condo/domains/marketplace/constants')
const { Invoice } = require('@condo/domains/marketplace/utils/serverSchema')

const ERRORS = {
    PAYMENT_NO_PAIRED_FROZEN_INVOICE: {
        code: BAD_USER_INPUT,
        type: PAYMENT_NO_PAIRED_FROZEN_INVOICE,
        message: 'Input is containing "invoice", but "frozenInvoice" is not specified',
    },
    PAYMENT_NO_PAIRED_INVOICE: {
        code: BAD_USER_INPUT,
        type: PAYMENT_NO_PAIRED_INVOICE,
        message: 'Input is containing "frozenInvoice", but "invoice" is not specified',
    },
    RECEIPT_WITHOUT_ACCOUNT_NUMBER: {
        code: BAD_USER_INPUT,
        type: PAYMENT_RECEIPT_WITHOUT_ACCOUNT_NUMBER,
        message: 'Input is containing "receipt", but "accountNumber" is not specified',
    },
}

const Payment = new GQLListSchema('Payment', {
    schemaDoc: 'Information about completed transaction from user to a specific organization',
    fields: {
        amount: {
            ...POSITIVE_MONEY_AMOUNT_FIELD,
            schemaDoc: 'Amount of money from MultiPayment.amountWithOutExplicitFee to pay for billing receipt',
            isRequired: true,
        },

        explicitFee: {
            ...NON_NEGATIVE_MONEY_FIELD,
            schemaDoc: 'Amount of money which payer pays on top of initial "amount", which counts as fee for every service which is not housing and communal services',
            isRequired: false,
        },

        explicitServiceCharge: {
            ...NON_NEGATIVE_MONEY_FIELD,
            schemaDoc: 'Amount of money which payer pays on top of initial "amount", which counts as internal service charge for all payments from housing and communal services category',
            isRequired: false,
        },

        implicitFee: {
            ...NON_NEGATIVE_MONEY_FIELD,
            schemaDoc: 'Amount of money which recipient pays from initial amount for transaction',
            isRequired: false,
            access: { read: access.canReadPaymentsSensitiveData },
            hooks: {
                validateInput: ({ resolvedData, addFieldValidationError, fieldPath, operation, existingItem }) => {
                    if (resolvedData.hasOwnProperty(fieldPath) && resolvedData[fieldPath] !== null) {
                        const amount = Big(operation === 'create' ? resolvedData['amount'] : existingItem['amount'])
                        const fee = Big(resolvedData[fieldPath])
                        if (fee.gt(amount)) {
                            addFieldValidationError(PAYMENT_TOO_BIG_IMPLICIT_FEE)
                        }
                    }
                },
            },
        },

        serviceFee: {
            ...NON_NEGATIVE_MONEY_FIELD,
            schemaDoc: 'The amount of money charged by our service for the provision of service after subtracting from it the shares of all participants in the process. Can be part of explicit fee, implicit fee or explicit service charge',
            isRequired: false,
        },

        currencyCode: CURRENCY_CODE_FIELD,

        advancedAt: {
            schemaDoc: 'Time at which money was advanced to recipient\'s account',
            type: 'DateTimeUtc',
            isRequired: false,
        },

        depositedDate: {
            schemaDoc: 'Time at which the payment was made by client',
            type: 'DateTimeUtc',
            isRequired: false,
        },

        transferDate: {
            schemaDoc: 'Time at which money was transfered to recipient\'s account',
            type: 'DateTimeUtc',
            isRequired: false,
        },

        accountNumber: {
            schemaDoc: 'Payer\'s account number',
            type: 'Text',
            isRequired: false,
            hooks: {
                validateInput: ({ context, resolvedData, fieldPath }) => {
                    if (!!resolvedData['receipt'] && !resolvedData[fieldPath]) {
                        throw new GQLError(ERRORS.RECEIPT_WITHOUT_ACCOUNT_NUMBER, context)
                    }
                },
            },
        },

        period: PERIOD_FIELD,

        purpose: {
            schemaDoc: 'Purpose of payment. Mostly used as title such as "Payment by agreement â„–123"',
            type: 'Text',
            isRequired: false,
        },

        receipt: {
            schemaDoc: 'Link to a billing receipt that the user paid for. Can be null in cases of getting payments out of our system',
            type: 'Relationship',
            ref: 'BillingReceipt',
            isRequired: false,
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
            hooks: {
                validateInput: ({ resolvedData, addFieldValidationError, fieldPath }) => {
                    if (resolvedData[fieldPath] && !resolvedData['frozenReceipt']) {
                        addFieldValidationError(PAYMENT_NO_PAIRED_FROZEN_RECEIPT)
                    }
                },
            },
        },

        frozenReceipt: {
            schemaDoc: 'Frozen billing receipt, used to resolving conflicts',
            type: 'Json',
            sensitive: true,
            isRequired: false,
            access: { read: access.canReadPaymentsSensitiveData },
            hooks: {
                validateInput: ({ resolvedData, addFieldValidationError, fieldPath }) => {
                    if (resolvedData[fieldPath] && !resolvedData['receipt']) {
                        addFieldValidationError(PAYMENT_NO_PAIRED_RECEIPT)
                    }
                },
            },
        },

        invoice: {
            schemaDoc: 'Link to the invoice that user paid for.',
            type: 'Relationship',
            ref: 'Invoice',
            isRequired: false,
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
            hooks: {
                validateInput: ({ context, resolvedData, fieldPath }) => {
                    if (resolvedData[fieldPath] && !resolvedData['frozenInvoice']) {
                        throw new GQLError(ERRORS.PAYMENT_NO_PAIRED_FROZEN_INVOICE, context)
                    }
                },
            },
        },

        frozenInvoice: {
            schemaDoc: 'Frozen invoice, used to resolving conflicts',
            type: 'Json',
            sensitive: true,
            isRequired: false,
            access: { read: access.canReadPaymentsSensitiveData },
            hooks: {
                validateInput: ({ context, resolvedData, fieldPath }) => {
                    if (resolvedData[fieldPath] && !resolvedData['invoice']) {
                        throw new GQLError(ERRORS.PAYMENT_NO_PAIRED_INVOICE, context)
                    }
                },
            },
        },

        multiPayment: {
            schemaDoc: 'Link to a payment related MultiPayment. Required field to update, but initially created unlinked',
            type: 'Relationship',
            ref: 'MultiPayment.payments',
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
        },

        context: {
            ...ACQUIRING_CONTEXT_FIELD,
            isRequired: false,
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            hooks: {
                validateInput: async ({
                    resolvedData,
                    addFieldValidationError,
                    fieldPath,
                    existingItem,
                    operation,
                }) => {
                    if (resolvedData[fieldPath]) {
                        const context = await getById('AcquiringIntegrationContext', resolvedData[fieldPath])
                        // NOTE: CHECKS THAT CONTEXT EXIST AND NOT DELETED ARE DONE AUTOMATICALLY BEFORE
                        const organization = operation === 'create' ? get(resolvedData, 'organization') : existingItem.organization
                        if (context.organization !== organization) {
                            return addFieldValidationError(PAYMENT_CONTEXT_ORGANIZATION_NOT_MATCH)
                        }
                    }
                },
            },
        },

        organization: {
            schemaDoc: 'Direct link to organization, since acquiring context cannot be defined for some payments',
            type: 'Relationship',
            ref: 'Organization',
            knexOptions: { isNotNullable: true }, // Required relationship only!
            access: {
                read: true,
                create: true,
                update: false,
            },
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },

        status: {
            schemaDoc: `Status of payment. Can be: ${PAYMENT_STATUSES.map(status => `"${status}"`).join(', ')}`,
            type: 'Select',
            dataType: 'string',
            isRequired: true,
            options: PAYMENT_STATUSES,
            defaultValue: PAYMENT_INIT_STATUS,
        },

        order: {
            schemaDoc: 'Payment order. A directive to a bank from a bank account holder instructing the bank to make a payment or series of payments to a third party',
            type: 'Text',
            isRequired: false,
        },

        recipientBic: {
            schemaDoc: '@deprecated --use "recipient" Bic of recipient organization, used for matching payments with receipts in case of multiple receipts per account + address',
            type: 'Text',
            isRequired: true,
        },

        recipientBankAccount: {
            schemaDoc: '@deprecated --use "recipient" Bank account number of recipient organization, used for matching payments with receipts in case of multiple receipts per account + address',
            type: 'Text',
            isRequired: true,
        },

        recipient: {
            ...RECIPIENT_FIELD,
            schemaDoc: 'Recipient. Should contain all meta information to identify the organization and bank account',
            isRequired: false,
        },

        rawAddress: {
            schemaDoc: 'Non-normalized address that was imported from the organization',
            type: 'Text',
            isRequired: false,
        },

        importId: IMPORT_ID_FIELD,

        frozenDistribution: {
            schemaDoc: 'Distribution obtained from a paid model (receipt or invoice)',
            type: 'Json',
            sensitive: true,
            isRequired: false,
            access: { read: access.canReadPaymentsSensitiveData },
            hooks: {
                resolveInput: async ({ operation, resolvedData, fieldPath }) => {
                    if (operation === 'create') {
                        const invoiceId = get(resolvedData, 'invoice')
                        const receiptId = get(resolvedData, 'receipt')

                        let frozenDistribution

                        if (invoiceId) {
                            frozenDistribution = get(resolvedData, ['frozenInvoice', 'data', 'amountDistribution'])
                        } else if (receiptId) {
                            frozenDistribution = get(resolvedData, ['frozenReceipt', 'data', 'amountDistribution'])
                        }

                        return frozenDistribution || resolvedData[fieldPath]
                    }

                    return resolvedData[fieldPath]
                },
            },
        },

        frozenSplits: {
            schemaDoc: 'Splits created from distribution. Contains data applicable in external acquiring integration',
            type: 'Json',
            sensitive: true,
            isRequired: false,
            access: { read: access.canReadPaymentsSensitiveData },
        },

        posReceiptUrl: {
            schemaDoc: 'URL of the POS receipt',
            type: 'Text',
            sensitive: true,
            isRequired: false,
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), analytical()],
    access: {
        read: access.canReadPayments,
        create: access.canManagePayments,
        update: access.canManagePayments,
        delete: false,
        auth: true,
    },
    hooks: {
        resolveInput: async ({ operation, context, resolvedData }) => {
            const isCreate = operation === 'create'

            if (resolvedData['explicitFee'] && !resolvedData['explicitServiceCharge']) {
                resolvedData['explicitServiceCharge'] = '0'
            }
            if (resolvedData['explicitServiceCharge'] && !resolvedData['explicitFee']) {
                resolvedData['explicitFee'] = '0'
            }
            if (isCreate) {
                resolvedData['rawAddress'] = get(resolvedData, ['frozenReceipt', 'data', 'raw', 'address'])
            }

            // Calculate splits if distribution was set
            const frozenDistribution = get(resolvedData, ['frozenDistribution'])
            if (isCreate && !!frozenDistribution) {
                // Try to find other payments related to same receipt/invoice
                // It is important for partial payments
                const invoiceId = get(resolvedData, 'invoice')
                const receiptId = get(resolvedData, 'receipt')

                if (invoiceId || receiptId) {
                    const wherePart = {}
                    let currencyCode
                    if (invoiceId) {
                        wherePart.invoice = { id: invoiceId }
                        wherePart.receipt_is_null = true

                        const invoice = await Invoice.getOne(context, { id: invoiceId }, '{ currencyCode }')
                        currencyCode = get(invoice, 'currencyCode')
                    } else if (receiptId) {
                        wherePart.receipt = { id: receiptId }
                        wherePart.invoice_is_null = true

                        const receipt = await BillingReceipt.getOne(context, { id: receiptId }, '{ context { integration { currencyCode } } }')
                        currencyCode = get(receipt, ['context', 'integration', 'currencyCode'])
                    }

                    const relatedPayments = await PaymentGQL.getAll(context, {
                        ...wherePart,
                        frozenDistribution_not: null,
                        frozenSplits_not: null,
                        deletedAt: null,
                    }, 'id frozenSplits')

                    const appliedSplits = relatedPayments.reduce((acc, payment) => [...acc, ...payment.frozenSplits], [])

                    const splitsAmount = Big(resolvedData['amount'] || 0)
                    const splitsFeeAmount = Big(resolvedData['implicitFee'] || 0)

                    const locale = extractReqLocale(context.req) || conf.DEFAULT_LOCALE
                    const decimalPlaces = getCurrencyDecimalPlaces(locale, currencyCode)

                    resolvedData['frozenSplits'] = split(splitsAmount.toString(), frozenDistribution, {
                        feeAmount: splitsFeeAmount.toString(),
                        appliedSplits,
                        decimalPlaces,
                    })
                }
            }

            return resolvedData
        },
        validateInput: async ({
            resolvedData,
            context,
            addValidationError,
            operation,
            existingItem,
            originalInput,
        }) => {
            if (operation === 'create') {
                if (resolvedData['receipt']) {
                    if (!resolvedData['context']) {
                        return addValidationError(PAYMENT_NO_PAIRED_CONTEXT)
                    }
                    const receipt = await getById('BillingReceipt', resolvedData['receipt'])
                    const billingContext = await getById('BillingIntegrationOrganizationContext', receipt.context)
                    const billingIntegration = await getById('BillingIntegration', billingContext.integration)
                    const acquiringContextsCount = await AcquiringIntegrationContext.count(context, {
                        id: resolvedData['context'],
                        integration: {
                            supportedBillingIntegrationsGroup: billingIntegration.group,
                        },
                        organization: { id: resolvedData['organization'] },
                    })
                    if (!acquiringContextsCount) {
                        return addValidationError(PAYMENT_NO_SUPPORTED_CONTEXT)
                    }
                    if (get(receipt, ['recipient', 'bic']) !== resolvedData['recipientBic']
                        || get(receipt, ['recipient', 'bankAccount']) !== resolvedData['recipientBankAccount']) {
                        return addValidationError(PAYMENT_RECIPIENT_MISMATCH)
                    }
                }
            } else if (operation === 'update') {
                const oldStatus = existingItem.status
                const newStatus = get(resolvedData, 'status', oldStatus)
                // we can not use resolvedData.hasOwnProperty('status') check here as adminUi sends status if it is not changed
                if (oldStatus !== newStatus) {
                    if (!PAYMENT_TRANSITIONS[oldStatus].includes(newStatus)) {
                        return addValidationError(`${PAYMENT_NOT_ALLOWED_TRANSITION} Cannot move from "${oldStatus}" status to "${newStatus}"`)
                    }
                }
                const newItem = {
                    ...existingItem,
                    ...resolvedData,
                }
                const requiredFields = PAYMENT_REQUIRED_FIELDS[newStatus]
                let requiredMissing = false
                for (const field of requiredFields) {
                    if (!newItem.hasOwnProperty(field) || newItem[field] === null) {
                        addValidationError(`${PAYMENT_MISSING_REQUIRED_FIELDS} Field ${field} was not provided`)
                        requiredMissing = true
                    }
                }
                if (requiredMissing) return
                if (requiredFields.includes('explicitFee') || requiredFields.includes('explicitServiceCharge')) {
                    // Only 1 should be greater than 0
                    const hasPositiveExplicitFee = resolvedData.explicitFee && Big(resolvedData.explicitFee).gt(0)
                    const hasPositiveExplicitServiceCharge = resolvedData.explicitServiceCharge && Big(resolvedData.explicitServiceCharge).gt(0)
                    if (hasPositiveExplicitFee && hasPositiveExplicitServiceCharge) {
                        return addValidationError(PAYMENT_EXPLICIT_FEE_AND_CHARGE_SAME_TIME)
                    }
                    const restrictedFeeOverride = hasPositiveExplicitFee
                        && !originalInput.explicitServiceCharge
                        && get(existingItem, 'explicitServiceCharge')
                        && !Big(existingItem.explicitServiceCharge).eq('0')
                    const restrictedChargeOverride = hasPositiveExplicitServiceCharge
                        && !originalInput.explicitFee
                        && get(existingItem, 'explicitFee')
                        && !Big(existingItem.explicitFee).eq('0')
                    if (restrictedFeeOverride || restrictedChargeOverride) {
                        return addValidationError(PAYMENT_OVERRIDING_EXPLICIT_FEES_MUST_BE_EXPLICIT)
                    }
                }
                const frozenFields = PAYMENT_FROZEN_FIELDS[oldStatus]
                for (const field of frozenFields) {
                    if (resolvedData.hasOwnProperty(field)) {
                        addValidationError(`${PAYMENT_FROZEN_FIELD_INCLUDED} (${field})`)
                    }
                }
            }
        },
        afterChange: async ({ context, operation, existingItem, updatedItem }) => {
            // Trigger webhook task on status change FIRST - this must always happen
            // regardless of any subsequent operations that might fail
            const previousStatus = get(existingItem, 'status')
            const newStatus = get(updatedItem, 'status')
            const statusChanged = operation === 'update' && previousStatus !== newStatus

            // Use a small closure to cache invoice loading within this hook execution.
            // This avoids multiple getById('Invoice', ...) calls when both webhook enqueueing
            // logic and invoice status update logic need the invoice.
            let invoice = null
            let invoiceFetched = false
            const getInvoice = async () => {
                if (invoiceFetched) return invoice
                const fetchedInvoice = await getById('Invoice', updatedItem.invoice)
                invoice = fetchedInvoice
                invoiceFetched = true
                return fetchedInvoice
            }

            if (statusChanged) {
                // Avoid queueing background tasks for payments that have no webhook configured.
                // We only enqueue the task if invoice/receipt has paymentStatusChangeWebhookUrl.
                let shouldEnqueueWebhookTask = false

                try {
                    if (updatedItem.invoice) {
                        invoice = await getInvoice()
                        shouldEnqueueWebhookTask = !!get(invoice, 'paymentStatusChangeWebhookUrl')
                    }

                    if (!shouldEnqueueWebhookTask && updatedItem.receipt) {
                        const receipt = await getById('BillingReceipt', updatedItem.receipt)
                        shouldEnqueueWebhookTask = !!get(receipt, 'paymentStatusChangeWebhookUrl')
                    }
                } catch {
                    // Fail-open: if we can't read invoice/receipt right now (transient DB error, etc.),
                    // enqueue the task anyway to avoid missing a webhook that *is* configured.
                    shouldEnqueueWebhookTask = true
                }

                if (shouldEnqueueWebhookTask) {
                    // Queue background task to build and send webhook
                    // This minimizes async operations in the hook itself
                    await sendPaymentStatusChangeWebhook.delay(updatedItem.id)
                }
            }

            // Update invoice status when payment is done
            if (
                updatedItem.invoice
                && [PAYMENT_WITHDRAWN_STATUS, PAYMENT_DONE_STATUS].includes(get(updatedItem, 'status'))
            ) {
                invoice = invoiceFetched ? invoice : await getInvoice()
                if (get(invoice, 'status') === INVOICE_STATUS_PUBLISHED) {
                    await Invoice.update(context, invoice.id, {
                        dv: updatedItem.dv,
                        sender: updatedItem.sender,
                        status: INVOICE_STATUS_PAID,
                    })
                }
            }
        },
    },
})

module.exports = {
    Payment,
}
