/**
 * Generated by `createservice acquiring.CalculateFeeForReceiptService --type queries`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')

const { expectToThrowGQLError, expectToThrowGQLErrorToResult } = require('@open-condo/keystone/test.utils')

const { GQL_ERRORS: { PAYMENT_AMOUNT_LESS_THAN_MINIMUM } } = require('@condo/domains/acquiring/constants/errors')
const { calculateFeeForReceiptByTestClient } = require('@condo/domains/acquiring/utils/testSchema')
const { HOUSING_CATEGORY_ID, ELECTRICITY_CATEGORY_ID } = require('@condo/domains/billing/constants/constants')
const { TestUtils, ResidentTestMixin } = require('@condo/domains/billing/utils/testSchema/testUtils')

describe('CalculateFeeForReceiptService', () => {
    let utils

    beforeAll(async () => {
        utils = new TestUtils([ResidentTestMixin])
        await utils.init()
        await utils.updateAcquiringIntegration({
            explicitFeeDistributionSchema: [
                { 'recipient': 'acquiring', 'percent': '1.0' },
                { 'recipient': 'service', 'percent': '0.2' },
            ],
        })
    })

    describe('Check the calculations for fees', () => {
        test('Check the calculations for explicit fees', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result.amountWithoutExplicitFee).toBe(amount)
            expect(result.explicitFee).toBe('0')
            expect(result.explicitServiceCharge).toBe('3.6')
        })

        test('Check calculations for implicit fees', async () => {
            const [[receipt]] = await utils.createReceipts()
            await utils.updateAcquiringContext({
                implicitFeeDistributionSchema: [{ 'recipient': 'organization', 'percent': '1.2' }],
            })
            const amount = '300'
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result.amountWithoutExplicitFee).toBe(amount)
            expect(result.explicitFee).toBe('0')
            expect(result.explicitServiceCharge).toBe('0')
        })

        describe('Implicit fee calculation with categories', () => {
            const AMOUNT = '1000'

            test.each([
                {
                    name: 'uses "commission" recipient for service charge',
                    schema: [
                        { recipient: 'acquiring', percent: '0', category: HOUSING_CATEGORY_ID },
                        { recipient: 'commission', percent: '0.5', category: HOUSING_CATEGORY_ID },
                    ],
                    receiptCategory: HOUSING_CATEGORY_ID,
                    amount: AMOUNT,
                    expectedExplicitFee: '5',
                },
                {
                    name: 'uses "service" recipient for service charge',
                    schema: [
                        { recipient: 'acquiring', percent: '0', category: HOUSING_CATEGORY_ID },
                        { recipient: 'service', percent: '0.5', category: HOUSING_CATEGORY_ID },
                    ],
                    receiptCategory: HOUSING_CATEGORY_ID,
                    amount: AMOUNT,
                    expectedServiceCharge: '5',
                },
                {
                    name: 'falls back to default service charge when no schema matches',
                    schema: null,
                    receiptCategory: HOUSING_CATEGORY_ID,
                    amount: AMOUNT,
                    expectedServiceCharge: '12',
                },
                {
                    name: 'applies category-specific overrides and falls back correctly',
                    schema: [
                        { recipient: 'acquiring', percent: '0.3', category: HOUSING_CATEGORY_ID },
                        { recipient: 'service', percent: '0.2', category: HOUSING_CATEGORY_ID },
                    ],
                    receiptCategory: ELECTRICITY_CATEGORY_ID,
                    amount: AMOUNT,
                    expectedServiceCharge: '12',
                },
                {
                    name: 'applies category-specific overrides',
                    schema: [
                        { recipient: 'acquiring', percent: '0.4', category: ELECTRICITY_CATEGORY_ID },
                        { recipient: 'service', percent: '0.5', category: ELECTRICITY_CATEGORY_ID },
                        { recipient: 'organization', percent: '0.9', category: ELECTRICITY_CATEGORY_ID },
                    ],
                    receiptCategory: ELECTRICITY_CATEGORY_ID,
                    amount: AMOUNT,
                },
            ])('$name', async ({
                schema,
                receiptCategory,
                amount,
                expectedServiceCharge,
                expectedExplicitFee,
            }) => {
                if (schema) {
                    await utils.updateAcquiringContext({ implicitFeeDistributionSchema: schema })
                } else {
                    await utils.updateAcquiringContext({ implicitFeeDistributionSchema: [] })
                }

                const [[receipt]] = await utils.createReceipts([
                    utils.createJSONReceipt({ category: { id: receiptCategory } }),
                ])

                const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, {
                    receipt: { id: receipt.id },
                    amount,
                })

                expect(result.amountWithoutExplicitFee).toBe(amount)
                expect(result.explicitFee).toBe(expectedExplicitFee || '0')
                expect(result.explicitServiceCharge).toBe(expectedServiceCharge || '0')
            })
        })
    })

    describe('Check receipt', () => {
        test('Receipt must exist', async () => {
            const missingReceiptId = faker.datatype.uuid()
            const amount = '300'
            await expectToThrowGQLErrorToResult(async () => {
                await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: missingReceiptId }, amount })
            }, {
                query: 'calculateFeeForReceipt',
                variable: ['data', 'receipt', 'id'],
                code: 'BAD_USER_INPUT',
                type: 'CANNOT_FIND_ALL_BILLING_RECEIPTS',
                message: 'Cannot find specified BillingReceipt with id {missingReceiptId}',
                messageInterpolation: {
                    missingReceiptId,
                },
            })
        })
    })

    describe('Check minimum payment amount from acquiring integration', () => {
        afterEach(async () => {
            await utils.updateAcquiringIntegration({ minimumPaymentAmount: null })
        })

        test('Payment for acquiring with no set the minimum payment amount', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result).toHaveProperty('amountWithoutExplicitFee')
            expect(result).toHaveProperty('explicitFee')
            expect(result).toHaveProperty('explicitServiceCharge')
        })

        test('Payment amount is equal to the minimum payment amount required by the acquiring integration', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            await utils.updateAcquiringIntegration({ minimumPaymentAmount: amount })
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result).toHaveProperty('amountWithoutExplicitFee')
            expect(result).toHaveProperty('explicitFee')
            expect(result).toHaveProperty('explicitServiceCharge')
        })

        test('Payment amount is greater than the minimum payment amount required by the acquiring integration', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            await utils.updateAcquiringIntegration({ minimumPaymentAmount: Big(amount).minus(10) })
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result).toHaveProperty('amountWithoutExplicitFee')
            expect(result).toHaveProperty('explicitFee')
            expect(result).toHaveProperty('explicitServiceCharge')
        })

        test('Payment amount is less than the minimum payment amount required by the acquiring integration', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            const minimumPaymentAmount = Big(amount).add(100).toString()
            await utils.updateAcquiringIntegration({ minimumPaymentAmount })
            await expectToThrowGQLError(async () => {
                await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            }, {
                ...PAYMENT_AMOUNT_LESS_THAN_MINIMUM,
                messageInterpolation: { minimumPaymentAmount },
            }, 'result')
        })
    })
})