/**
 * Generated by `createservice acquiring.CalculateFeeForReceiptService --type queries`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')

const { expectToThrowGQLError, catchErrorFrom } = require('@open-condo/keystone/test.utils')

const { GQL_ERRORS: { PAYMENT_AMOUNT_LESS_THAN_MINIMUM } } = require('@condo/domains/acquiring/constants/errors')
const { calculateFeeForReceiptByTestClient } = require('@condo/domains/acquiring/utils/testSchema')
const { TestUtils, ResidentTestMixin } = require('@condo/domains/billing/utils/testSchema/testUtils')

describe('CalculateFeeForReceiptService', () => {
    let utils

    beforeAll(async () => {
        utils = new TestUtils([ResidentTestMixin])
        await utils.init()
        await utils.updateAcquiringIntegration({
            explicitFeeDistributionSchema: [
                { 'recipient':'acquiring', 'percent':'1.0' },
                { 'recipient':'service', 'percent':'0.2' },
            ],
        })
    })

    describe('Check the calculations for fees', () => {
        test('Check the calculations for explicit fees', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result.amountWithoutExplicitFee).toBe(amount)
            expect(result.explicitFee).toBe('0')
            expect(result.explicitServiceCharge).toBe('3.6')
        })

        test('Check calculations for implicit fees', async () => {
            const [[receipt]] = await utils.createReceipts()
            await utils.updateAcquiringContext({
                implicitFeeDistributionSchema: [{ 'recipient':'organization', 'percent':'1.2' }],
            })
            const amount = '300'
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result.amountWithoutExplicitFee).toBe(amount)
            expect(result.explicitFee).toBe('0')
            expect(result.explicitServiceCharge).toBe('0')
        })
    })
    describe('Check receipt', () => {
        test('Receipt must exist', async () => {
            const missingReceiptId = faker.datatype.uuid()
            const amount = '300'
            await catchErrorFrom(async () => {
                await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: missingReceiptId }, amount })
            }, ({ errors }) => {
                expect(errors).toMatchObject([{
                    message: `Cannot find specified BillingReceipt with id ${missingReceiptId}`,
                    path: ['result'],
                    extensions: {
                        query: 'calculateFeeForReceipt',
                        variable: ['data', 'receipt', 'id'],
                        code: 'BAD_USER_INPUT',
                        type: 'CANNOT_FIND_ALL_BILLING_RECEIPTS',
                        message: 'Cannot find specified BillingReceipt with id {missingReceiptId}',
                    },
                }])
            })
        })
    })

    describe('Check minimum payment amount from acquiring integration', () => {
        afterEach(async () => {
            await utils.updateAcquiringIntegration({ minimumPaymentAmount: null })
        })

        test('Payment for acquiring with no set the minimum payment amount', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result).toHaveProperty('amountWithoutExplicitFee')
            expect(result).toHaveProperty('explicitFee')
            expect(result).toHaveProperty('explicitServiceCharge')
        })

        test('Payment amount is equal to the minimum payment amount required by the acquiring integration', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            await utils.updateAcquiringIntegration({ minimumPaymentAmount: amount })
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result).toHaveProperty('amountWithoutExplicitFee')
            expect(result).toHaveProperty('explicitFee')
            expect(result).toHaveProperty('explicitServiceCharge')
        })

        test('Payment amount is greater than the minimum payment amount required by the acquiring integration', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            await utils.updateAcquiringIntegration({ minimumPaymentAmount: Big(amount).minus(10) })
            const [result] = await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            expect(result).toHaveProperty('amountWithoutExplicitFee')
            expect(result).toHaveProperty('explicitFee')
            expect(result).toHaveProperty('explicitServiceCharge')
        })

        test('Payment amount is less than the minimum payment amount required by the acquiring integration', async () => {
            const [[receipt]] = await utils.createReceipts()
            const amount = '300'
            const minimumPaymentAmount = Big(amount).add(100).toString()
            await utils.updateAcquiringIntegration({ minimumPaymentAmount })
            await expectToThrowGQLError(async () => {
                await calculateFeeForReceiptByTestClient(utils.clients.resident, { receipt: { id: receipt.id }, amount })
            }, {
                ...PAYMENT_AMOUNT_LESS_THAN_MINIMUM,
                messageInterpolation: { minimumPaymentAmount },
            }, 'result')
        })
    })
})