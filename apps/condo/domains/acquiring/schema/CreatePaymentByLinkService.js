/**
 * Generated by `createservice acquiring.CreatePaymentByLinkService`
 */

const Big = require('big.js')
const { get } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { find, GQLCustomSchema, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/acquiring/access/CreatePaymentByLinkService')
const { CONTEXT_FINISHED_STATUS: ACQUIRING_CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    registerMultiPaymentForOneReceipt,
    registerMultiPaymentForVirtualReceipt,
    MultiPayment,
} = require('@condo/domains/acquiring/utils/serverSchema')
const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const { isReceiptPaid, compareQRCodeWithLastReceipt, formatPeriodFromQRCode, findAuxiliaryData } = require('@condo/domains/billing/utils/receiptQRCodeUtils')
const {
    validateQRCode,
} = require('@condo/domains/billing/utils/serverSchema')
const { ALREADY_EXISTS_ERROR, WRONG_FORMAT } = require('@condo/domains/common/constants/errors')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    ADDRESS_IS_INVALID: {
        mutation: 'createPaymentByLink',
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'The provided address is invalid',
    },
    BANK_ACCOUNT_IS_INVALID: {
        mutation: 'createPaymentByLink',
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Provided bank account is not in the system',
    },
    RECEIPT_ALREADY_PAID: {
        mutation: 'createPaymentByLink',
        code: BAD_USER_INPUT,
        type: ALREADY_EXISTS_ERROR,
        message: 'Provided receipt already paid',
        messageForUser: 'api.billing.error.alreadyPaid',
    },
}

const CreatePaymentByLinkService = new GQLCustomSchema('CreatePaymentByLinkService', {
    types: [
        {
            access: true,
            type: 'input CreatePaymentByLinkInput { dv: Int!, sender: SenderFieldInput!, qrCode: String! }',
        },
        {
            access: true,
            type: 'type CreatePaymentByLinkOutput { multiPaymentId: ID!, amount: String!, explicitFee: String!, totalAmount: String!, acquiringIntegrationHostUrl: String!, currencyCode: String!, address: String!, addressMeta: AddressMetaField!, unitType: String!, unitName: String!, accountNumber: String!, period: String! }',
        },
    ],

    mutations: [
        {
            access: access.canCreatePaymentByLink,
            schema: 'createPaymentByLink(data: CreatePaymentByLinkInput!): CreatePaymentByLinkOutput',
            resolver: async (parent, args, context) => {
                const { data: { dv, sender, qrCode } } = args

                const validationResult = await validateQRCode(context, { dv, sender, qrCode })

                const { qrCodeFields, acquiringIntegrationHostUrl, currencyCode } = validationResult
                const {
                    PersonalAcc, // organization's bank account
                    BIC,
                    PaymPeriod, // mm.yyyy
                    Sum,
                    PersAcc, // resident's account within organization
                } = qrCodeFields
                const period = formatPeriodFromQRCode(PaymPeriod)
                const amount = String(Big(Sum).div(100))

                const auxiliaryData = await findAuxiliaryData(qrCodeFields, { address: ERRORS.ADDRESS_IS_INVALID })
                const { normalizedAddress } = auxiliaryData

                const [organizationId] = Object.keys(auxiliaryData.contexts)
                const { billingContext, acquiringContext } = auxiliaryData.contexts[organizationId]

                // make sure PersonalAccount is in our system
                /** @type {BillingRecipient[]} */
                const billingRecipients = await find('BillingRecipient', {
                    context: { id: billingContext.id, deletedAt: null },
                    bankAccount: PersonalAcc,
                    deletedAt: null,
                })

                if (billingRecipients.length === 0) throw new GQLError(ERRORS.BANK_ACCOUNT_IS_INVALID, context)

                let multiPaymentId

                const payForLastBillingReceipt = async (lastBillingReceipt) => {
                    if (await isReceiptPaid(context, PersAcc, lastBillingReceipt.period, [organizationId], PersonalAcc)) {
                        throw new GQLError(ERRORS.RECEIPT_ALREADY_PAID, context)
                    }
                    const { multiPaymentId: id } = await registerMultiPaymentForOneReceipt(context, {
                        dv, sender,
                        receipt: { id: lastBillingReceipt.id },
                        acquiringIntegrationContext: { id: acquiringContext.id },
                    })
                    multiPaymentId = id
                }

                /** @type {TCompareQRResolvers} */
                const resolvers = {
                    onNoReceipt: async () => {
                        if (await isReceiptPaid(context, PersAcc, period, [organizationId], PersonalAcc)) {
                            throw new GQLError(ERRORS.RECEIPT_ALREADY_PAID, context)
                        }
                        const { multiPaymentId: id } = await registerMultiPaymentForVirtualReceipt(context, {
                            dv, sender,
                            receipt: {
                                currencyCode,
                                amount,
                                period,
                                recipient: {
                                    routingNumber: BIC,
                                    bankAccount: PersonalAcc,
                                    accountNumber: PersAcc,
                                },
                            },
                            acquiringIntegrationContext: {
                                id: acquiringContext.id,
                            },
                        })

                        multiPaymentId = id
                    },
                    onReceiptPeriodEqualsQrCodePeriod: payForLastBillingReceipt,
                    onReceiptPeriodNewerThanQrCodePeriod: payForLastBillingReceipt,
                    onReceiptPeriodOlderThanQrCodePeriod: async (lastBillingReceipt) => {
                        if (await isReceiptPaid(context, PersAcc, period, [organizationId], PersonalAcc)) {
                            throw new GQLError(ERRORS.RECEIPT_ALREADY_PAID, context)
                        }

                        // find acquiring context and routing number from older receipt
                        const billingIntegrationContext = await getById('BillingIntegrationOrganizationContext', lastBillingReceipt.context)
                        /** @type {AcquiringIntegrationContext[]} */
                        const acquiringContexts = await AcquiringIntegrationContext.getAll(context, {
                            organization: { id: billingIntegrationContext.organization, deletedAt: null },
                            status: ACQUIRING_CONTEXT_FINISHED_STATUS,
                            deletedAt: null,
                        })

                        const { multiPaymentId: id } = await registerMultiPaymentForVirtualReceipt(context, {
                            dv, sender,
                            receipt: {
                                currencyCode,
                                amount,
                                period,
                                recipient: {
                                    routingNumber: billingRecipients[0].bic,
                                    bankAccount: PersonalAcc,
                                    accountNumber: PersAcc,
                                },
                            },
                            acquiringIntegrationContext: {
                                id: acquiringContexts[0].id,
                            },
                        })

                        multiPaymentId = id
                    },
                }

                await compareQRCodeWithLastReceipt(qrCodeFields, resolvers)

                const multiPayment = await MultiPayment.getOne(context, { id: multiPaymentId })

                return {
                    multiPaymentId,
                    amount: multiPayment.amountWithoutExplicitFee,
                    explicitFee: multiPayment.explicitServiceCharge,
                    totalAmount: multiPayment.amount,
                    acquiringIntegrationHostUrl,
                    currencyCode: multiPayment.currencyCode,
                    address: normalizedAddress.address,
                    addressMeta: {
                        dv: 1,
                        value: get(normalizedAddress, ['addressMeta', 'value'], ''),
                        unrestricted_value: get(normalizedAddress, ['addressMeta', 'unrestricted_value'], ''),
                        data: get(normalizedAddress, ['addressMeta', 'data'], null),
                    },
                    unitType: get(normalizedAddress, 'unitType'),
                    unitName: get(normalizedAddress, 'unitName'),
                    accountNumber: PersAcc,
                    period,
                }
            },
        },
    ],
})

module.exports = {
    CreatePaymentByLinkService,
}
