/**
 * Generated by `createservice acquiring.RegisterMultiPaymentService`
 */

const {
    makeClient,
    makeLoggedInAdminClient,
    prepareKeystoneExpressApp,
    setFakeClientMode,
} = require('@core/keystone/test.utils')
const {
    registerMultiPaymentByTestClient,
    createTestAcquiringIntegration,
    updateTestAcquiringIntegrationContext,
    makePayerWithMultipleConsumers,
    makePayer,
    updateTestAcquiringIntegration,
} = require('@condo/domains/acquiring/utils/testSchema')
const { updateTestServiceConsumer } = require('@condo/domains/resident/utils/testSchema')
const { updateTestBillingReceipt, updateTestBillingIntegration, createTestBillingIntegration } = require('@condo/domains/billing/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')
const { AcquiringIntegration } = require('@condo/domains/acquiring/utils/serverSchema')
const {
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowMutationError,
} = require('@condo/domains/common/utils/testSchema')
const { FEE_CALCULATION_PATH, WEB_VIEW_PATH } = require('@condo/domains/acquiring/constants/links')
const { DV_UNKNOWN_VERSION_ERROR } = require('@condo/domains/common/constants/errors')
const {
    REGISTER_MP_EMPTY_INPUT,
    REGISTER_MP_EMPTY_RECEIPTS,
    REGISTER_MP_CONSUMERS_DUPLICATE,
    REGISTER_MP_RECEIPTS_DUPLICATE,
    REGISTER_MP_REAL_CONSUMER_MISMATCH,
    REGISTER_MP_NO_ACQUIRING_CONSUMERS,
    REGISTER_MP_MULTIPLE_INTEGRATIONS,
    REGISTER_MP_CANNOT_GROUP_RECEIPTS,
    REGISTER_MP_DELETED_RECEIPTS,
    REGISTER_MP_REAL_RECEIPTS_MISMATCH,
    REGISTER_MP_UNSUPPORTED_BILLING,
    REGISTER_MP_MULTIPLE_CURRENCIES,
    REGISTER_MP_BILLING_ACCOUNTS_NO_MATCH,
} = require('@condo/domains/acquiring/constants/errors')
const faker = require('faker')
const dayjs = require('dayjs')
 
describe('RegisterMultiPaymentService', () => {
    describe('Execute', () => {
        describe('Resident',  () => {
            const cases = [[1, 1], [1, 2], [2, 1], [2, 2]]
            test.each(cases)('Consumers: %p | Receipts in each consumer: %p', async (consumers, receipts) => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(consumers, receipts)
                const hostUrl = commonData.acquiringIntegration.hostUrl
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receiptsIds: batch.billingReceipts.map(receipt => receipt.id),
                }))
                const [result] = await registerMultiPaymentByTestClient(commonData.client, payload)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('dv', 1)
                expect(result).toHaveProperty('multiPaymentId')
                expect(result).toHaveProperty('webViewUrl', `${hostUrl}${WEB_VIEW_PATH.replace('[id]', result.multiPaymentId )}`)
                expect(result).toHaveProperty('feeCalculationUrl', `${hostUrl}${FEE_CALCULATION_PATH.replace('[id]', result.multiPaymentId )}`)
            })
        })
        test('Anonymous user', async () => {
            const { serviceConsumer, billingReceipts } = await makePayer()
            const payload = [{
                consumerId: serviceConsumer.id,
                receiptsIds: billingReceipts.map(receipt => receipt.id),
            }]
            const client = await makeClient()
            await expectToThrowAuthenticationError(async () => {
                await registerMultiPaymentByTestClient(client, payload)
            }, 'result')
        })
        test('Staff user', async () => {
            const { serviceConsumer, billingReceipts } = await makePayer()
            const payload = [{
                consumerId: serviceConsumer.id,
                receiptsIds: billingReceipts.map(receipt => receipt.id),
            }]
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerMultiPaymentByTestClient(client, payload)
            })
        })
    })
    describe('Validations', () => {
        describe('Input checks', () => {
            test('Should check dv (=== 1)', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer()
                const payload = [{
                    consumerId: serviceConsumer.id,
                    receiptsIds: billingReceipts.map(receipt => receipt.id),
                }]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload, { dv: 2 })
                }, DV_UNKNOWN_VERSION_ERROR)
            })
            test('Should check sender dv (=== 1)', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer()
                const sender = { dv: 2, fingerprint: faker.random.alphaNumeric(8) }
                const payload = {
                    consumerId: serviceConsumer.id,
                    receiptsIds: billingReceipts.map(receipt => receipt.id),
                }
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload, { sender })
                }, DV_UNKNOWN_VERSION_ERROR)
            })
            test('Should check emptiness of input arrays', async () => {
                const { serviceConsumer, client } = await makePayer()
                let payload = []
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_EMPTY_INPUT)
                payload = [
                    {
                        consumerId: serviceConsumer.id,
                        receiptsIds: [],
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_EMPTY_RECEIPTS)
            })
        })
        describe('Duplicates checks', () => {
            test('Should contains unique ServiceConsumers', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer(2)
                const payload = [
                    {
                        consumerId: serviceConsumer.id,
                        receiptsIds: [billingReceipts[0].id],
                    },
                    {
                        consumerId: serviceConsumer.id,
                        receiptsIds: billingReceipts[1].id,
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_CONSUMERS_DUPLICATE)
            })
            test('Should contains unique receipts', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer()
                const payload = [
                    {
                        consumerId: serviceConsumer.id,
                        receiptsIds: [billingReceipts[0].id, billingReceipts[0].id],
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_RECEIPTS_DUPLICATE)
            })
        })
        describe('ServiceConsumers checks', () => {
            test('Input should contains existing ServiceConsumers id', async () => {
                const { billingReceipts, client } = await makePayer(2)
                const fakeUuid = faker.datatype.uuid()
                const payload = [
                    {
                        consumerId: fakeUuid,
                        receiptsIds: billingReceipts.map(receipt => receipt.id),
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_REAL_CONSUMER_MISMATCH)
            })
            test('All ServiceConsumers should have AcquiringIntegrationContext', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receiptsIds: batch.billingReceipts.map(receipt => receipt.id),
                }))
                await updateTestServiceConsumer(commonData.admin, batches[1].serviceConsumer.id, {
                    acquiringIntegrationContext: { disconnectAll: true },
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_NO_ACQUIRING_CONSUMERS)
            })
            describe('AcquiringIntegrationContext', () => {
                test('All should be linked to same AcquiringIntegration', async () => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)

                    const payload = batches.map(batch => ({
                        consumerId: batch.serviceConsumer.id,
                        receiptsIds: batch.billingReceipts.map(receipt => receipt.id),
                    }))
                    const billings = batches.map(batch => batch.billingIntegration)
                    const [secondAcquiring] = await createTestAcquiringIntegration(commonData.admin, billings)
                    await updateTestAcquiringIntegrationContext(commonData.admin, batches[0].acquiringContext.id, {
                        integration: { connect: { id: secondAcquiring.id } },
                    })
                    await expectToThrowMutationError(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, REGISTER_MP_MULTIPLE_INTEGRATIONS)
                })
            })
        })
        describe('BillingReceipts checks', () => {
            describe('Cannot be multiple if acquiring cannot group receipts', () => {
                const cases = [[1, 2], [2, 1]]
                test.each(cases)('%p receipts in %p ServiceConsumers', async (consumers, receipts) => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(consumers, receipts)

                    const payload = batches.map(batch => ({
                        consumerId: batch.serviceConsumer.id,
                        receiptsIds: batch.billingReceipts.map(receipt => receipt.id),
                    }))
                    await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                        canGroupReceipts: false,
                    })
                    await expectToThrowMutationError(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, REGISTER_MP_CANNOT_GROUP_RECEIPTS)
                })
            })
            test('Should have existing ids', async () => {
                const { serviceConsumer, client } = await makePayer()
                const payload = [{
                    consumerId: serviceConsumer.id,
                    receiptsIds: faker.datatype.uuid(),
                }]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_REAL_RECEIPTS_MISMATCH)
            })
            test('Should not be able to pay for deleted receipts', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(1, 2)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receiptsIds: batch.billingReceipts.map(receipt => receipt.id),
                }))
                await updateTestBillingReceipt(commonData.admin, batches[0].billingReceipts[0].id, {
                    deletedAt: dayjs().toISOString(),
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_DELETED_RECEIPTS)
            })
            test('Should be linked to BillingIntegration which supported by acquiring', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receiptsIds: batch.billingReceipts.map(receipt => receipt.id),
                }))
                await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                    supportedBillingIntegrations: { disconnect: [{ id: batches[1].billingIntegration.id }] },
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_UNSUPPORTED_BILLING)
            })
            test('Cannot pay for receipts with multiple currencies', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receiptsIds: batch.billingReceipts.map(receipt => receipt.id),
                }))
                await updateTestBillingIntegration(commonData.admin, batches[1].billingIntegration.id, {
                    currencyCode: 'USD',
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_MULTIPLE_CURRENCIES)
            })
            test('Should have common billing account with ServiceConsumer', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = [
                    {
                        consumerId: batches[0].serviceConsumer.id,
                        receiptsIds: batches[1].billingReceipts.map(receipt => receipt.id),
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_BILLING_ACCOUNTS_NO_MATCH)
            })
        })
    })
    // TODO(savelevMatthew): Remove this test after custom GQL refactoring
    describe('ServerSchema get all should provide enough fields', () => {
        setFakeClientMode(require.resolve('../../../index'))
        let context
        beforeAll(async () => {
            const app = await prepareKeystoneExpressApp(require.resolve('../../../index'))
            const { keystone } = app
            context = await keystone.createContext({ skipAccessControl: true })
        })
        test('AcquiringIntegration', async () => {
            const admin = await makeLoggedInAdminClient()
            const [firstBilling] = await createTestBillingIntegration(admin)
            const [secondBilling] = await createTestBillingIntegration(admin)
            const [acquiring] = await createTestAcquiringIntegration(admin, [firstBilling, secondBilling])
            const [serverObtainedAcquiring] = await AcquiringIntegration.getAll(context, {
                id: acquiring.id,
            })
            expect(serverObtainedAcquiring).toBeDefined()
            expect(serverObtainedAcquiring).toHaveProperty('id')
            expect(serverObtainedAcquiring).toHaveProperty('canGroupReceipts')
            expect(serverObtainedAcquiring).toHaveProperty('supportedBillingIntegrations')
            expect(serverObtainedAcquiring.supportedBillingIntegrations).toHaveLength(2)
        })
    })
})