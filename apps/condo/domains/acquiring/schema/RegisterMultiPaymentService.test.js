/**
 * Generated by `createservice acquiring.RegisterMultiPaymentService`
 */

const faker = require('faker')
const dayjs = require('dayjs')

const {
    makeClient,
    makeLoggedInAdminClient,
} = require('@core/keystone/test.utils')
const {
    AcquiringIntegration,
    registerMultiPaymentByTestClient,
    registerMultiPaymentForOneReceiptByTestClient,
    createTestAcquiringIntegration,
    updateTestAcquiringIntegrationContext,
    createTestAcquiringIntegrationContext,
    makePayerWithMultipleConsumers,
    makePayer,
    updateTestAcquiringIntegration,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    updateTestServiceConsumer,
    createTestResident,
    createTestServiceConsumer,
} = require('@condo/domains/resident/utils/testSchema')
const {
    updateTestBillingReceipt,
    updateTestBillingIntegration,
    createTestBillingIntegration,
    updateTestBillingIntegrationOrganizationContext,
} = require('@condo/domains/billing/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')
const {
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult,
    catchErrorFrom,
} = require('@condo/domains/common/utils/testSchema')
const {
    FEE_CALCULATION_PATH,
    WEB_VIEW_PATH,
    DIRECT_PAYMENT_PATH,
    GET_CARD_TOKENS_PATH,
} = require('@condo/domains/acquiring/constants/links')
const { updateTestBillingAccount } = require('@condo/domains/billing/utils/testSchema')

describe('RegisterMultiPaymentService', () => {
    describe('Execute', () => {
        describe('Resident', () => {
            const cases = [[1, 1], [1, 2], [2, 1], [2, 2]]
            test.each(cases)('Consumers: %p | Receipts in each consumer: %p', async (consumers, receipts) => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(consumers, receipts)
                const hostUrl = commonData.acquiringIntegration.hostUrl
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const [result] = await registerMultiPaymentByTestClient(commonData.client, payload)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('dv', 1)
                expect(result).toHaveProperty('multiPaymentId')
                expect(result).toHaveProperty('webViewUrl', `${hostUrl}${WEB_VIEW_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('feeCalculationUrl', `${hostUrl}${FEE_CALCULATION_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('directPaymentUrl', `${hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('getCardTokensUrl', `${hostUrl}${GET_CARD_TOKENS_PATH.replace('[id]', batches[0].resident.user.id)}`)
            })
            test('From receipt', async () => {
                const {
                    billingReceipts,
                    acquiringContext,
                    acquiringIntegration,
                    client,
                    resident,
                } = await makePayer()
                const hostUrl = acquiringIntegration.hostUrl
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const [result] = await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('dv', 1)
                expect(result).toHaveProperty('multiPaymentId')
                expect(result).toHaveProperty('webViewUrl', `${hostUrl}${WEB_VIEW_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('feeCalculationUrl', `${hostUrl}${FEE_CALCULATION_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('directPaymentUrl', `${hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('getCardTokensUrl', `${hostUrl}${GET_CARD_TOKENS_PATH.replace('[id]', resident.user.id)}`)
            })
        })
        test('Anonymous user', async () => {
            const { serviceConsumer, billingReceipts } = await makePayer()
            const payload = [{
                consumerId: serviceConsumer.id,
                receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
            }]
            const client = await makeClient()
            await expectToThrowAuthenticationError(async () => {
                await registerMultiPaymentByTestClient(client, payload)
            }, 'result')
        })
        test('Staff user', async () => {
            const { serviceConsumer, billingReceipts } = await makePayer()
            const payload = [{
                consumerId: serviceConsumer.id,
                receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
            }]
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerMultiPaymentByTestClient(client, payload)
            })
        })
    })
    describe('RegisterMultiPayment mutation Validations', () => {
        describe('Input checks', () => {
            test('Should check dv (=== 1)', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer()
                const payload = [{
                    consumerId: serviceConsumer.id,
                    receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
                }]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload, { dv: 2 })
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Wrong value for data version number',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'dv'],
                            code: 'BAD_USER_INPUT',
                            type: 'DV_VERSION_MISMATCH',
                            message: 'Wrong value for data version number',
                        },
                    }])
                })
            })
            describe('Should check sender', () => {
                let consumerId
                let receipts
                let client
                beforeAll(async () => {
                    const data = await makePayer()
                    consumerId = data.serviceConsumer.id
                    receipts = data.billingReceipts.map(receipt => ({ id: receipt.id }))
                    client = data.client
                })
                const cases = [
                    [2, faker.random.alphaNumeric(8)],
                    [1, faker.random.alphaNumeric(3)],
                    [1, faker.random.alphaNumeric(60)],
                    [1, 'КиРиЛЛиЦА'],
                ]
                test.each(cases)('dv: %p, fingerprint: %p', async (dv, fingerprint) => {
                    const sender = { dv, fingerprint }
                    const payload = {
                        consumerId,
                        receipts,
                    }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentByTestClient(client, payload, { sender })
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPayment',
                                variable: ['data', 'sender'],
                                code: 'BAD_USER_INPUT',
                                type: 'WRONG_FORMAT',
                            },
                        }])
                        expect(errors[0].message).toMatch('Invalid format of "sender" field value.')
                        expect(errors[0].extensions.message).toMatch('Invalid format of "sender" field value.')
                    })
                })
            })
            test('Should check emptiness of input arrays', async () => {
                const { serviceConsumer, client } = await makePayer()
                let payload = []
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Missing required value for "groupedReceipts" field',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts'],
                            code: 'BAD_USER_INPUT',
                            type: 'REQUIRED',
                            message: 'Missing required value for "groupedReceipts" field',
                        },
                    }])
                })
                payload = [
                    {
                        consumerId: serviceConsumer.id,
                        receipts: [],
                    },
                ]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Each group of receipts should contain at least 1 receipt',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts'],
                            code: 'BAD_USER_INPUT',
                            type: 'REQUIRED',
                            message: 'Each group of receipts should contain at least 1 receipt',
                        },
                    }])
                })
            })
        })
        describe('Duplicates checks', () => {
            test('Should contain unique ServiceConsumers', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer(2)
                const payload = [
                    {
                        consumerId: serviceConsumer.id,
                        receipts: [{ id: billingReceipts[0].id }],
                    },
                    {
                        consumerId: serviceConsumer.id,
                        receipts: [{ id: billingReceipts[1].id }],
                    },
                ]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'There are some groupedReceipts with same consumerId',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_UNIQUE',
                            message: 'There are some groupedReceipts with same consumerId',
                        },
                    }])
                })
            })
            test('Should contain unique receipts', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer()
                const payload = [
                    {
                        consumerId: serviceConsumer.id,
                        receipts: [{ id: billingReceipts[0].id }, { id: billingReceipts[0].id }],
                    },
                ]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Found duplicated receipt ids. Note, each receipt can only occur in single ServiceConsumer per mutation run and cannot be noticed twice',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_UNIQUE',
                            message: 'Found duplicated receipt ids. Note, each receipt can only occur in single ServiceConsumer per mutation run and cannot be noticed twice',
                        },
                    }])
                })
            })
        })
        describe('ServiceConsumers checks', () => {
            test('Input should contain existing ServiceConsumers id', async () => {
                const { billingReceipts, client } = await makePayer(2)
                const fakeUuid = faker.datatype.uuid()
                const payload = [
                    {
                        consumerId: fakeUuid,
                        receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
                    },
                ]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot find specified ServiceConsumers with following ids: ${fakeUuid}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_FOUND',
                            message: 'Cannot find specified ServiceConsumers with following ids: {ids}',
                            messageInterpolation: {
                                ids: fakeUuid,
                            },
                        },
                    }])
                })
            })
            test('All ServiceConsumers should have AcquiringIntegrationContext', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const disconnectedServiceConsumerId = batches[1].serviceConsumer.id
                await updateTestServiceConsumer(commonData.admin, disconnectedServiceConsumerId, {
                    acquiringIntegrationContext: { disconnectAll: true },
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `ServiceConsumers with ids ${disconnectedServiceConsumerId} does not have AcquiringIntegrationContext`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING',
                            message: 'ServiceConsumers with ids {ids} does not have AcquiringIntegrationContext',
                        },
                    }])
                })
            })
            describe('AcquiringIntegrationContext', () => {
                test('All should be linked to same AcquiringIntegration', async () => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                    const billings = batches.map(batch => batch.billingIntegration)

                    const [secondAcquiring] = await createTestAcquiringIntegration(commonData.admin, billings)
                    await updateTestAcquiringIntegrationContext(commonData.admin, batches[1].acquiringContext.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    const [secondContext] = await createTestAcquiringIntegrationContext(commonData.admin, batches[1].organization, secondAcquiring)
                    const [secondResident] = await createTestResident(commonData.admin, commonData.client.user, batches[1].organization, batches[1].property)
                    const [secondConsumer] = await createTestServiceConsumer(commonData.admin, secondResident, batches[1].organization, {
                        acquiringIntegrationContext: { connect: { id: secondContext.id } },
                        billingIntegrationContext: { connect: { id: batches[1].billingContext.id } },
                        billingAccount: { connect: { id: batches[1].billingAccount.id } },
                    })

                    const payload = [
                        { consumerId: batches[0].serviceConsumer.id, receipts: batches[0].billingReceipts.map(receipt => ({ id: receipt.id })) },
                        { consumerId: secondConsumer.id, receipts: batches[1].billingReceipts.map(receipt => ({ id: receipt.id })) },
                    ]

                    await catchErrorFrom(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Listed consumerIds are linked to different acquiring integrations',
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPayment',
                                variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                                code: 'BAD_USER_INPUT',
                                type: 'MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS',
                                message: 'Listed consumerIds are linked to different acquiring integrations',
                            },
                        }])
                    })
                })
            })
        })
        describe('BillingReceipts checks', () => {
            describe('Cannot be multiple if acquiring cannot group receipts', () => {
                const cases = [[1, 2], [2, 1]]
                test.each(cases)('%p receipts in %p ServiceConsumers', async (consumers, receipts) => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(consumers, receipts)

                    const payload = batches.map(batch => ({
                        consumerId: batch.serviceConsumer.id,
                        receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                    }))
                    await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                        canGroupReceipts: false,
                    })
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: `Receipts cannot be grouped by AcquiringIntegration with id "${commonData.acquiringIntegration.id}", because a value of "canGroupReceipts" field is false`,
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPayment',
                                variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION',
                                message: 'Receipts cannot be grouped by AcquiringIntegration with id "{id}", because a value of "canGroupReceipts" field is false',
                            },
                        }])
                    })
                })
            })
            test('Should have existing ids', async () => {
                const { serviceConsumer, client } = await makePayer()
                const missingReceiptId = faker.datatype.uuid()
                const payload = [{
                    consumerId: serviceConsumer.id,
                    receipts: { id: missingReceiptId },
                }]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot find all specified BillingReceipts with ids ${missingReceiptId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'CANNOT_FIND_ALL_BILLING_RECEIPTS',
                            message: 'Cannot find all specified BillingReceipts with ids {missingReceiptIds}',
                        },
                    }])
                })
            })
            test('Should be linked to BillingIntegration which supported by acquiring', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const disconnectedBillingIntegrationId = batches[1].billingIntegration.id
                await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                    supportedBillingIntegrations: { disconnect: [{ id: disconnectedBillingIntegrationId }] },
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Some of ServiceConsumer's AcquiringIntegration does not supports following BillingReceipt's BillingIntegrations: ${disconnectedBillingIntegrationId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION',
                            message: 'Some of ServiceConsumer\'s AcquiringIntegration does not supports following BillingReceipt\'s BillingIntegrations: {unsupportedBillingIntegrations}',
                        },
                    }])
                })
            })
            test('Cannot pay for receipts with multiple currencies', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingIntegration(commonData.admin, batches[1].billingIntegration.id, {
                    currencyCode: 'USD',
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'BillingReceipts has multiple currencies',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'RECEIPTS_HAS_MULTIPLE_CURRENCIES',
                            message: 'BillingReceipts has multiple currencies',
                        },
                    }])
                })
            })
            describe('Cannot pay for receipts with negative toPay', () => {
                const cases = ['0.0', '-1', '-50.00', '-0.000000']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                    const payload = batches.map(batch => ({
                        consumerId: batch.serviceConsumer.id,
                        receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                    }))
                    await updateTestBillingReceipt(commonData.admin, batches[1].billingReceipts[0].id, {
                        toPay,
                    })
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: `Cannot pay for BillingReceipts ${batches[1].billingReceipts[0].id} with negative "toPay" value`,
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPayment',
                                variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE',
                                message: 'Cannot pay for BillingReceipts {ids} with negative "toPay" value',
                            },
                        }])
                    })
                })
            })
            test('Should have common billing account with ServiceConsumer', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const serviceConsumerId = batches[0].serviceConsumer.id
                const payload = [
                    {
                        consumerId: serviceConsumerId,
                        receipts: batches[1].billingReceipts.map(receipt => ({ id: receipt.id })),
                    },
                ]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `BillingReceipt with id "${batches[1].billingReceipts[0].id}" does not have common BillingAccount with specified ServiceConsumer with id "${serviceConsumerId}"`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER',
                            message: 'BillingReceipt with id "{receiptId}" does not have common BillingAccount with specified ServiceConsumer with id "{serviceConsumerId}"',
                        },
                    }])
                })
            })
            test('Should have billing account with same unitType as ServiceConsumer.unitType', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const serviceConsumerId = batches[0].serviceConsumer.id
                const payload = [
                    {
                        consumerId: serviceConsumerId,
                        receipts: batches[1].billingReceipts.map(receipt => ({ id: receipt.id })),
                    },
                ]
                await updateTestBillingAccount(commonData.admin, batches[0].billingAccount.id, { unitType: 'parking' })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `BillingReceipt with id "${batches[1].billingReceipts[0].id}" does not have common BillingAccount with specified ServiceConsumer with id "${serviceConsumerId}"`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER',
                            message: 'BillingReceipt with id "{receiptId}" does not have common BillingAccount with specified ServiceConsumer with id "{serviceConsumerId}"',
                        },
                    }])
                })
            })
        })
        describe('deletedAt check', () => {
            test('Should not be able to pay for deleted receipts', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(1, 2)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const deletedReceiptId = batches[0].billingReceipts[0].id
                await updateTestBillingReceipt(commonData.admin, deletedReceiptId, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot pay for deleted receipts ${deletedReceiptId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'RECEIPTS_ARE_DELETED',
                            message: 'Cannot pay for deleted receipts {ids}',
                        },
                    }])
                })
            })
            test('Should not be able to pay for deleted service consumer', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const deletedConsumerId = batches[0].serviceConsumer.id
                await updateTestServiceConsumer(commonData.admin, deletedConsumerId, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Some of specified ServiceConsumers with ids ${deletedConsumerId} were deleted, so you cannot pay for them anymore`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_FOUND',
                            message: 'Some of specified ServiceConsumers with ids {ids} were deleted, so you cannot pay for them anymore',
                        },
                    }])
                })
            })
            test('Should not be able to pay for consumer with deleted acquiring context', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestAcquiringIntegrationContext(commonData.admin, batches[1].acquiringContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Some ServiceConsumers has deleted AcquiringIntegrationContext',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED',
                            message: 'Some ServiceConsumers has deleted AcquiringIntegrationContext',
                            data: {
                                failedConsumers: [{
                                    consumerId: batches[1].serviceConsumer.id,
                                    acquiringContextId: batches[1].acquiringContext.id,
                                }],
                            },
                        },
                    }])
                })
            })
            test('Should not be able to pay using deleted acquiring integration', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot pay via deleted acquiring integration with id "${commonData.acquiringIntegration.id}"`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_IS_DELETED',
                            message: 'Cannot pay via deleted acquiring integration with id "{id}"',
                        },
                    }])
                })
            })
            test('Should not be able to pay for receipt with deleted BillingIntegrationOrganizationContext', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingIntegrationOrganizationContext(commonData.admin, batches[0].billingContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'BillingIntegrationOrganizationContext is deleted for some BillingReceipts',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED',
                            message: 'BillingIntegrationOrganizationContext is deleted for some BillingReceipts',
                            data: {
                                failedReceipts: [{
                                    receiptId: batches[0].billingReceipts[0].id,
                                    contextId: batches[0].billingReceipts[0].context.id,
                                }],
                            },
                        },
                    }])
                })
            })
            test('Should not be able to pay for BillingReceipt with deleted BillingIntegration', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingIntegration(commonData.admin, batches[0].billingIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'BillingReceipt has deleted BillingIntegration',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'RECEIPT_HAS_DELETED_BILLING_INTEGRATION',
                            message: 'BillingReceipt has deleted BillingIntegration',
                            data: {
                                failedReceipts: [{
                                    receiptId: batches[0].billingReceipts[0].id,
                                    integrationId: batches[0].billingIntegration.id,
                                }],
                            },
                        },
                    }])
                })
            })
        })
    })
    describe('RegisterMultiPaymentForOneReceipt mutation Validations', () => {
        describe('Input checks', () => {
            test('Should check dv (=== 1)', async () => {
                const {
                    billingReceipts,
                    acquiringContext,
                    client,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }

                await catchErrorFrom(async () => {
                    await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext, { dv: 2 })
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Wrong value for data version number',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForOneReceipt',
                            variable: ['data', 'dv'],
                            code: 'BAD_USER_INPUT',
                            type: 'DV_VERSION_MISMATCH',
                            message: 'Wrong value for data version number',
                        },
                    }])
                })
            })
            describe('Should check sender', () => {
                let acquiringIntegrationContext
                let receipt
                let client
                beforeAll(async () => {
                    const data = await makePayer()
                    receipt = { id: data.billingReceipts[0].id }
                    acquiringIntegrationContext = { id: data.acquiringContext.id }
                    client = data.client
                })
                const cases = [
                    [2, faker.random.alphaNumeric(8)],
                    [1, faker.random.alphaNumeric(3)],
                    [1, faker.random.alphaNumeric(60)],
                    [1, 'КиРиЛЛиЦА'],
                ]
                test.each(cases)('dv: %p, fingerprint: %p', async (dv, fingerprint) => {
                    const sender = { dv, fingerprint }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext, { sender })
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForOneReceipt',
                                variable: ['data', 'sender'],
                                code: 'BAD_USER_INPUT',
                                type: 'WRONG_FORMAT',
                            },
                        }])
                        expect(errors[0].message).toMatch('Invalid format of "sender" field value.')
                        expect(errors[0].extensions.message).toMatch('Invalid format of "sender" field value.')
                    })
                })
            })
        })
        describe('BillingReceipts checks', () => {
            test('Should have existing ids', async () => {
                const {
                    acquiringContext,
                    client,
                } = await makePayer()
                const missingReceiptId = faker.datatype.uuid()
                const receipt = { id: missingReceiptId }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await catchErrorFrom(async () => {
                    await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot find all specified BillingReceipts with ids ${missingReceiptId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForOneReceipt',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'CANNOT_FIND_ALL_BILLING_RECEIPTS',
                            message: 'Cannot find all specified BillingReceipts with ids {missingReceiptIds}',
                        },
                    }])
                })
            })
            test('Should be linked to BillingIntegration which supported by acquiring', async () => {
                const {
                    admin,
                    billingReceipts,
                    billingIntegration,
                    acquiringContext,
                    acquiringIntegration,
                    client,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const [newBillingIntegration] = await createTestBillingIntegration(admin)

                // remap acquiring integration with supported billing integrations
                await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                    supportedBillingIntegrations: { connect: [{ id: newBillingIntegration.id }] },
                })
                await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                    supportedBillingIntegrations: { disconnect: [{ id: billingIntegration.id }] },
                })

                await catchErrorFrom(async () => {
                    await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Some of ServiceConsumer's AcquiringIntegration does not supports following BillingReceipt's BillingIntegrations: ${billingIntegration.id}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForOneReceipt',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION',
                            message: 'Some of ServiceConsumer\'s AcquiringIntegration does not supports following BillingReceipt\'s BillingIntegrations: {unsupportedBillingIntegrations}',
                        },
                    }])
                })
            })
            describe('Cannot pay for receipts with negative toPay', () => {
                const cases = ['0.0', '-1', '-50.00', '-0.000000']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const {
                        admin,
                        billingReceipts,
                        acquiringContext,
                        client,
                    } = await makePayer()
                    const receipt = { id: billingReceipts[0].id }
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await updateTestBillingReceipt(admin, receipt.id, {
                        toPay,
                    })
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: `Cannot pay for BillingReceipts ${receipt.id} with negative "toPay" value`,
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForOneReceipt',
                                variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE',
                                message: 'Cannot pay for BillingReceipts {ids} with negative "toPay" value',
                            },
                        }])
                    })
                })
            })
        })
        describe('deletedAt check', () => {
            test('Should not be able to pay for deleted receipts', async () => {
                const {
                    admin,
                    billingReceipts,
                    acquiringContext,
                    client,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const deletedReceiptId = receipt.id
                await updateTestBillingReceipt(admin, deletedReceiptId, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot pay for deleted receipts ${deletedReceiptId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForOneReceipt',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'RECEIPTS_ARE_DELETED',
                            message: 'Cannot pay for deleted receipts {ids}',
                        },
                    }])
                })
            })
            test('Should not be able to pay for consumer with deleted acquiring context', async () => {
                const {
                    admin,
                    billingReceipts,
                    acquiringContext,
                    client,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Some ServiceConsumers has deleted AcquiringIntegrationContext',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForOneReceipt',
                            variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED',
                            message: 'Some ServiceConsumers has deleted AcquiringIntegrationContext',
                        },
                    }])
                })
            })
            test('Should not be able to pay using deleted acquiring integration', async () => {
                const {
                    admin,
                    billingReceipts,
                    acquiringContext,
                    acquiringIntegration,
                    client,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot pay via deleted acquiring integration with id "${acquiringIntegration.id}"`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForOneReceipt',
                            variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_IS_DELETED',
                            message: 'Cannot pay via deleted acquiring integration with id "{id}"',
                        },
                    }])
                })
            })
            test('Should not be able to pay for receipt with deleted BillingIntegrationOrganizationContext', async () => {
                const {
                    admin,
                    billingReceipts,
                    billingContext,
                    acquiringContext,
                    client,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await updateTestBillingIntegrationOrganizationContext(admin, billingContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'BillingIntegrationOrganizationContext is deleted for some BillingReceipts',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForOneReceipt',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED',
                            message: 'BillingIntegrationOrganizationContext is deleted for some BillingReceipts',
                            data: {
                                failedReceipts: [{
                                    receiptId: receipt.id,
                                    contextId: billingContext.id,
                                }],
                            },
                        },
                    }])
                })
            })
            test('Should not be able to pay for BillingReceipt with deleted BillingIntegration', async () => {
                const {
                    admin,
                    billingReceipts,
                    billingIntegration,
                    acquiringContext,
                    client,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await updateTestBillingIntegration(admin, billingIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentForOneReceiptByTestClient(client, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'BillingReceipt has deleted BillingIntegration',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForOneReceipt',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'RECEIPT_HAS_DELETED_BILLING_INTEGRATION',
                            message: 'BillingReceipt has deleted BillingIntegration',
                            data: {
                                failedReceipts: [{
                                    receiptId: receipt.id,
                                    integrationId: billingIntegration.id,
                                }],
                            },
                        },
                    }])
                })
            })
        })
    })
    // TODO(savelevMatthew): Remove this test after custom GQL refactoring
    describe('ServerSchema get all should provide enough fields', () => {
        test('AcquiringIntegration', async () => {
            const admin = await makeLoggedInAdminClient()
            const [firstBilling] = await createTestBillingIntegration(admin)
            const [secondBilling] = await createTestBillingIntegration(admin)
            const [acquiring] = await createTestAcquiringIntegration(admin, [firstBilling, secondBilling])
            const [serverObtainedAcquiring] = await AcquiringIntegration.getAll(admin, {
                id: acquiring.id,
            })
            expect(serverObtainedAcquiring).toBeDefined()
            expect(serverObtainedAcquiring).toHaveProperty('id')
            expect(serverObtainedAcquiring).toHaveProperty('canGroupReceipts')
            expect(serverObtainedAcquiring).toHaveProperty('supportedBillingIntegrations')
            expect(serverObtainedAcquiring.supportedBillingIntegrations).toHaveLength(2)
        })
    })
})
