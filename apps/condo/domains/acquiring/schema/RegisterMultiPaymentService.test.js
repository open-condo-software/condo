/**
 * Generated by `createservice acquiring.RegisterMultiPaymentService`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const dayjs = require('dayjs')
const { pick } = require('lodash')

const {
    makeClient,
    makeLoggedInAdminClient,
    expectToThrowGQLError, UUID_RE,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult,
    catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const {
    FEE_CALCULATION_PATH,
    WEB_VIEW_PATH,
    DIRECT_PAYMENT_PATH,
    GET_CARD_TOKENS_PATH,
} = require('@condo/domains/acquiring/constants/links')
const {
    PAYMENT_WITHDRAWN_STATUS,
    MULTIPAYMENT_WITHDRAWN_STATUS,
    PAYMENT_PROCESSING_STATUS,
    MULTIPAYMENT_PROCESSING_STATUS,
} = require('@condo/domains/acquiring/constants/payment')
const {
    AcquiringIntegration,
    registerMultiPaymentByTestClient,
    createTestAcquiringIntegration,
    updateTestAcquiringIntegrationContext,
    createTestAcquiringIntegrationContext,
    createTestRecurrentPaymentContext,
    updateTestRecurrentPaymentContext,
    makePayerWithMultipleConsumers,
    makePayer,
    updateTestAcquiringIntegration, updateTestPayment, updateTestMultiPayment,
    getRandomHiddenCard,
    MultiPayment,
} = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBillingCategory, updateTestBillingAccount, createTestRecipient } = require('@condo/domains/billing/utils/testSchema')
const {
    updateTestBillingReceipt,
    updateTestBillingIntegration,
    createTestBillingIntegration,
    updateTestBillingIntegrationOrganizationContext,
} = require('@condo/domains/billing/utils/testSchema')
const {
    createTestBillingIntegrationOrganizationContext,
    createTestBillingProperty,
    createTestBillingAccount,
    createTestBillingReceipt,
} = require('@condo/domains/billing/utils/testSchema')
const { ISO_CODES } = require('@condo/domains/common/constants/currencies')
const { createTestContact } = require('@condo/domains/contact/utils/testSchema')
const {
    INVOICE_CONTEXT_STATUS_FINISHED, INVOICE_STATUS_DRAFT, INVOICE_STATUS_PUBLISHED,
    INVOICE_CONTEXT_STATUS_INPROGRESS,
} = require('@condo/domains/marketplace/constants')
const {
    createTestInvoiceContext,
    createTestInvoice,
    updateTestInvoice,
    updateTestInvoiceContext,
} = require('@condo/domains/marketplace/utils/testSchema')
const { Invoice } = require('@condo/domains/marketplace/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const {
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const {
    updateTestServiceConsumer,
    createTestResident,
    createTestServiceConsumer,
} = require('@condo/domains/resident/utils/testSchema')
const { registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithResidentUser,
} = require('@condo/domains/user/utils/testSchema')
const { makeClientWithStaffUser } = require('@condo/domains/user/utils/testSchema')

let adminClient
let dummyAcquiringIntegration

describe('RegisterMultiPaymentService', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()

        await createTestBillingIntegration(adminClient)
        ;[dummyAcquiringIntegration] = await createTestAcquiringIntegration(adminClient, {
            canGroupReceipts: true,
        })
    })

    describe('Execute', () => {
        describe('Resident', () => {
            const cases = [[1, 1], [1, 2], [2, 1], [2, 2]]
            test.each(cases)('Consumers: %p | Receipts in each consumer: %p', async (consumers, receipts) => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(consumers, receipts)
                const hostUrl = commonData.acquiringIntegration.hostUrl
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const [result] = await registerMultiPaymentByTestClient(commonData.client, payload)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('dv', 1)
                expect(result).toHaveProperty('multiPaymentId')
                expect(result).toHaveProperty('webViewUrl', `${hostUrl}${WEB_VIEW_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('feeCalculationUrl', `${hostUrl}${FEE_CALCULATION_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('directPaymentUrl', `${hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('getCardTokensUrl', `${hostUrl}${GET_CARD_TOKENS_PATH.replace('[id]', batches[0].resident.user.id)}`)
            })
        })
        test('Anonymous user', async () => {
            const { serviceConsumer, billingReceipts } = await makePayer()
            const payload = [{
                serviceConsumer: { id: serviceConsumer.id },
                receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
            }]
            const client = await makeClient()
            await expectToThrowAuthenticationError(async () => {
                await registerMultiPaymentByTestClient(client, payload)
            }, 'result')
        })
        describe('Staff user', () => {
            test('Access denied if no invoices in payload', async () => {
                const { serviceConsumer, billingReceipts } = await makePayer()
                let payload = [{
                    serviceConsumer: { id: serviceConsumer.id },
                    receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
                }]
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                })
            })

            test('Access allowed if invoices in payload', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, o10n)
                const residentClient = await makeClientWithResidentUser()
                const unitType = FLAT_UNIT_TYPE
                const unitName = faker.lorem.word()

                const [resident] = await registerResidentByTestClient(
                    residentClient,
                    {
                        address: property.address,
                        addressMeta: property.addressMeta,
                        unitType,
                        unitName,
                    })

                const staffClient = await makeClientWithStaffUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                    canManageInvoices: true,
                    canManageContacts: true,
                    canReadInvoiceContexts: true,
                })
                await createTestOrganizationEmployee(adminClient, o10n, staffClient.user, role)

                const [contact] = await createTestContact(staffClient, o10n, property, {
                    phone: residentClient.userAttrs.phone,
                    unitType,
                    unitName,
                })

                const [invoiceContext, invoiceContextAttrs] = await createTestInvoiceContext(adminClient, o10n, dummyAcquiringIntegration, {
                    status: INVOICE_CONTEXT_STATUS_FINISHED,
                    implicitFeePercent: '5',
                    recipient: createTestRecipient(),
                })
                const [invoice] = await createTestInvoice(staffClient, invoiceContext, {
                    property: { connect: { id: property.id } },
                    unitType,
                    unitName,
                    contact: { connect: { id: contact.id } },
                    status: INVOICE_STATUS_PUBLISHED,
                })
                const invoiceSum = invoice.rows.reduce((sum, { toPay, count }) => sum.plus(Big(toPay).mul(count)), Big(0))

                const invoices = await Invoice.getAll(residentClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(invoices).toEqual([
                    expect.objectContaining({
                        id: invoice.id,
                        client: expect.objectContaining({ id: resident.user.id, name: resident.user.name }),
                    }),
                ])

                const [result] = await registerMultiPaymentByTestClient(staffClient, null, {
                    invoices: invoices.map(({ id }) => ({ id })),
                })

                expect(result).toMatchObject({
                    dv: 1,
                    multiPaymentId: expect.stringMatching(UUID_RE),
                    webViewUrl: `${dummyAcquiringIntegration.hostUrl}/pay/${result.multiPaymentId}`,
                    feeCalculationUrl: `${dummyAcquiringIntegration.hostUrl}/api/fee/${result.multiPaymentId}`,
                    directPaymentUrl: `${dummyAcquiringIntegration.hostUrl}/api/pay/${result.multiPaymentId}`,
                    getCardTokensUrl: `${dummyAcquiringIntegration.hostUrl}/api/clients/${residentClient.userAttrs.id}/card-tokens`,
                })

                const multipayment = await MultiPayment.getOne(adminClient, { id: result.multiPaymentId })
                expect(multipayment).toMatchObject({
                    currencyCode: invoiceContext.currencyCode,
                    integration: { id: dummyAcquiringIntegration.id },
                    amount: invoiceSum.toString(),
                    implicitFee: Big(invoiceSum).mul(invoiceContextAttrs.implicitFeePercent).div(100).toFixed(8),
                })
            })
        })
        test('Background process for RecurrentPaymentContext', async () => {
            const admin = await makeLoggedInAdminClient()
            const { commonData, batches } = await makePayerWithMultipleConsumers(1, 1)
            const hostUrl = commonData.acquiringIntegration.hostUrl
            const [batch] = batches
            const serviceConsumerId = batch.serviceConsumer.id

            // create RecurrentPaymentContext
            const [billingCategory] = await createTestBillingCategory(
                admin,
                { name: `Category ${new Date()}` },
            )
            const [recurrentContext] = await createTestRecurrentPaymentContext(
                commonData.client,
                {
                    enabled: false,
                    limit: '10000',
                    autoPayReceipts: false,
                    paymentDay: 10,
                    settings: { cardId: faker.datatype.uuid() },
                    serviceConsumer: { connect: { id: serviceConsumerId } },
                    billingCategory: { connect: { id: billingCategory.id } },
                },
            )

            const payload = [{
                serviceConsumer: { id: serviceConsumerId },
                receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
            }]

            const extraArgs = { recurrentPaymentContext: { id: recurrentContext.id } }

            const [result] = await registerMultiPaymentByTestClient(commonData.client, payload, extraArgs)

            expect(result).toBeDefined()
            expect(result).toHaveProperty('dv', 1)
            expect(result).toHaveProperty('multiPaymentId')
            expect(result).toHaveProperty('webViewUrl', `${hostUrl}${WEB_VIEW_PATH.replace('[id]', result.multiPaymentId)}`)
            expect(result).toHaveProperty('feeCalculationUrl', `${hostUrl}${FEE_CALCULATION_PATH.replace('[id]', result.multiPaymentId)}`)
            expect(result).toHaveProperty('directPaymentUrl', `${hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', result.multiPaymentId)}`)
            expect(result).toHaveProperty('getCardTokensUrl', `${hostUrl}${GET_CARD_TOKENS_PATH.replace('[id]', batches[0].resident.user.id)}`)

            const { multiPaymentId } = result
            const multiPayment = await MultiPayment.getOne(admin, { id: multiPaymentId })
            expect(multiPayment).toBeDefined()
            expect(multiPayment).toHaveProperty('recurrentPaymentContext')
            expect(multiPayment.recurrentPaymentContext.id).toEqual(recurrentContext.id)
        })
    })
    describe('Validations', () => {
        describe('Input checks', () => {
            test('Should check dv (=== 1)', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer()
                const payload = [{
                    serviceConsumer: { id: serviceConsumer.id },
                    receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
                }]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload, { dv: 2 })
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Wrong value for data version number',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'dv'],
                            code: 'BAD_USER_INPUT',
                            type: 'DV_VERSION_MISMATCH',
                            message: 'Wrong value for data version number',
                        },
                    }])
                })
            })
            describe('Should check sender', () => {
                let consumerId
                let receipts
                let client
                beforeAll(async () => {
                    const data = await makePayer()
                    consumerId = data.serviceConsumer.id
                    receipts = data.billingReceipts.map(receipt => ({ id: receipt.id }))
                    client = data.client
                })
                const cases = [
                    [2, faker.random.alphaNumeric(8)],
                    [1, faker.random.alphaNumeric(3)],
                    [1, faker.random.alphaNumeric(60)],
                    [1, 'КиРиЛЛиЦА'],
                ]
                test.each(cases)('dv: %p, fingerprint: %p', async (dv, fingerprint) => {
                    const sender = { dv, fingerprint }
                    const payload = {
                        serviceConsumer: { id: consumerId },
                        receipts,
                    }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentByTestClient(client, payload, { sender })
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPayment',
                                variable: ['data', 'sender'],
                                code: 'BAD_USER_INPUT',
                                type: 'WRONG_FORMAT',
                            },
                        }])
                        expect(errors[0].message).toMatch('Invalid format of "sender" field value.')
                        expect(errors[0].extensions.message).toMatch('Invalid format of "sender" field value.')
                    })
                })
            })
            test('Should check emptiness of input arrays', async () => {
                const { serviceConsumer, client } = await makePayer()
                let payload = []
                await expectToThrowGQLError(async () => await registerMultiPaymentByTestClient(client, payload), {
                    mutation: 'registerMultiPayment',
                    code: 'BAD_USER_INPUT',
                    type: 'REQUIRED',
                    message: 'Missing required value for "groupedReceipts" field and/or for "invoices" field',
                }, 'result')

                payload = [
                    {
                        serviceConsumer: { id: serviceConsumer.id },
                        receipts: [],
                    },
                ]
                await expectToThrowGQLError(async () => await registerMultiPaymentByTestClient(client, payload), {
                    mutation: 'registerMultiPayment',
                    variable: ['data', 'groupedReceipts', '[]', 'receipts'],
                    code: 'BAD_USER_INPUT',
                    type: 'REQUIRED',
                    message: 'Each group of receipts should contain at least 1 receipt',
                }, 'result')
            })
        })
        describe('Duplicates checks', () => {
            test('Should contain unique ServiceConsumers', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer(2)
                const payload = [
                    {
                        serviceConsumer: { id: serviceConsumer.id },
                        receipts: [{ id: billingReceipts[0].id }],
                    },
                    {
                        serviceConsumer: { id: serviceConsumer.id },
                        receipts: [{ id: billingReceipts[1].id }],
                    },
                ]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'There are some groupedReceipts with same serviceConsumer',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_UNIQUE',
                            message: 'There are some groupedReceipts with same serviceConsumer',
                        },
                    }])
                })
            })
            test('Should contain unique receipts', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer()
                const payload = [
                    {
                        serviceConsumer: { id: serviceConsumer.id },
                        receipts: [{ id: billingReceipts[0].id }, { id: billingReceipts[0].id }],
                    },
                ]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Found duplicated receipt ids. Note, each receipt can only occur in single ServiceConsumer per mutation run and cannot be noticed twice',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_UNIQUE',
                            message: 'Found duplicated receipt ids. Note, each receipt can only occur in single ServiceConsumer per mutation run and cannot be noticed twice',
                        },
                    }])
                })
            })

            test('Should contain unique invoices', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [invoiceContext] = await createTestInvoiceContext(adminClient, o10n, dummyAcquiringIntegration, { status: INVOICE_CONTEXT_STATUS_FINISHED })
                const [invoice] = await createTestInvoice(adminClient, invoiceContext)

                await expectToThrowGQLError(async () => {
                    await registerMultiPaymentByTestClient(adminClient, null, {
                        invoices: [pick(invoice, 'id'), pick(invoice, 'id')],
                    })
                }, {
                    mutation: 'registerMultiPayment',
                    variable: ['data', 'invoices'],
                    code: 'BAD_USER_INPUT',
                    type: 'NOT_UNIQUE',
                    message: 'Found duplicated invoices.',
                }, 'result')
            })
        })

        describe('ServiceConsumers checks', () => {
            test('Input should contain existing ServiceConsumers id', async () => {
                const { billingReceipts, client } = await makePayer(2)
                const fakeUuid = faker.datatype.uuid()
                const payload = [
                    {
                        serviceConsumer: { id: fakeUuid },
                        receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
                    },
                ]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot find specified ServiceConsumers with following ids: ${fakeUuid}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_FOUND',
                            message: 'Cannot find specified ServiceConsumers with following ids: {ids}',
                            messageInterpolation: {
                                ids: fakeUuid,
                            },
                        },
                    }])
                })
            })
            test('All ServiceConsumers should have AcquiringIntegrationContext', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const disconnectedServiceConsumerId = batches[1].serviceConsumer.id
                await updateTestServiceConsumer(commonData.admin, disconnectedServiceConsumerId, {
                    acquiringIntegrationContext: { disconnectAll: true },
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `ServiceConsumers with ids ${disconnectedServiceConsumerId} does not have AcquiringIntegrationContext`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING',
                            message: 'ServiceConsumers with ids {ids} does not have AcquiringIntegrationContext',
                        },
                    }])
                })
            })
            describe('AcquiringIntegrationContext', () => {
                test('All should be linked to same AcquiringIntegration', async () => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)

                    const [secondAcquiring] = await createTestAcquiringIntegration(commonData.admin)
                    await updateTestAcquiringIntegrationContext(commonData.admin, batches[1].acquiringContext.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    const [secondContext] = await createTestAcquiringIntegrationContext(commonData.admin, batches[1].organization, secondAcquiring)
                    const [secondResident] = await createTestResident(commonData.admin, commonData.client.user, batches[1].property)
                    const [secondConsumer] = await createTestServiceConsumer(commonData.admin, secondResident, batches[1].organization, {
                        acquiringIntegrationContext: { connect: { id: secondContext.id } },
                        billingIntegrationContext: { connect: { id: batches[1].billingContext.id } },
                        billingAccount: { connect: { id: batches[1].billingAccount.id } },
                    })

                    const payload = [
                        {
                            serviceConsumer: { id: batches[0].serviceConsumer.id },
                            receipts: batches[0].billingReceipts.map(receipt => ({ id: receipt.id })),
                        },
                        {
                            serviceConsumer: { id: secondConsumer.id },
                            receipts: batches[1].billingReceipts.map(receipt => ({ id: receipt.id })),
                        },
                    ]

                    await catchErrorFrom(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Listed serviceConsumers are linked to different acquiring integrations',
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPayment',
                                variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
                                code: 'BAD_USER_INPUT',
                                type: 'MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS',
                                message: 'Listed serviceConsumers are linked to different acquiring integrations',
                            },
                        }])
                    })
                })
            })
        })
        describe('BillingReceipts checks', () => {
            describe('Cannot be multiple if acquiring cannot group receipts', () => {
                const cases = [[1, 2], [2, 1]]
                test.each(cases)('%p receipts in %p ServiceConsumers', async (consumers, receipts) => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(consumers, receipts)

                    const payload = batches.map(batch => ({
                        serviceConsumer: { id: batch.serviceConsumer.id },
                        receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                    }))
                    await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                        canGroupReceipts: false,
                    })
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: `Receipts cannot be grouped by AcquiringIntegration with id "${commonData.acquiringIntegration.id}", because a value of "canGroupReceipts" field is false`,
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPayment',
                                variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION',
                                message: 'Receipts cannot be grouped by AcquiringIntegration with id "{id}", because a value of "canGroupReceipts" field is false',
                            },
                        }])
                    })
                })
            })
            test('Should have existing ids', async () => {
                const { serviceConsumer, client } = await makePayer()
                const missingReceiptId = faker.datatype.uuid()
                const payload = [{
                    serviceConsumer: { id: serviceConsumer.id },
                    receipts: { id: missingReceiptId },
                }]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot find all specified BillingReceipts with ids ${missingReceiptId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'CANNOT_FIND_ALL_BILLING_RECEIPTS',
                            message: 'Cannot find all specified BillingReceipts with ids {missingReceiptIds}',
                        },
                    }])
                })
            })
            test('Should be linked to BillingIntegration which supported by acquiring', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const billingIntegrationId = batches[1].billingIntegration.id
                await updateTestBillingIntegration(commonData.admin, billingIntegrationId, {
                    group: faker.random.alpha().toLowerCase(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Some of ServiceConsumer's AcquiringIntegration does not supports following BillingReceipt's BillingIntegrations: ${billingIntegrationId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION',
                            message: 'Some of ServiceConsumer\'s AcquiringIntegration does not supports following BillingReceipt\'s BillingIntegrations: {unsupportedBillingIntegrations}',
                        },
                    }])
                })
            })
            test('Cannot pay for receipts with multiple currencies', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingIntegration(commonData.admin, batches[1].billingIntegration.id, {
                    currencyCode: 'USD',
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'BillingReceipts has multiple currencies',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'RECEIPTS_HAS_MULTIPLE_CURRENCIES',
                            message: 'BillingReceipts has multiple currencies',
                        },
                    }])
                })
            })
            describe('Cannot pay for receipts with negative toPay', () => {
                const cases = ['0.0', '-1', '-50.00', '-0.000000']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                    const payload = batches.map(batch => ({
                        serviceConsumer: { id: batch.serviceConsumer.id },
                        receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                    }))
                    await updateTestBillingReceipt(commonData.admin, batches[1].billingReceipts[0].id, {
                        toPay,
                    })
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: `Cannot pay for BillingReceipts ${batches[1].billingReceipts[0].id} with negative "toPay" value`,
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPayment',
                                variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE',
                                message: 'Cannot pay for BillingReceipts {ids} with negative "toPay" value',
                            },
                        }])
                    })
                })
            })
            test('Should have common billing account with ServiceConsumer', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const serviceConsumerId = batches[0].serviceConsumer.id
                const payload = [
                    {
                        serviceConsumer: { id: serviceConsumerId },
                        receipts: batches[1].billingReceipts.map(receipt => ({ id: receipt.id })),
                    },
                ]
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `BillingReceipt with id "${batches[1].billingReceipts[0].id}" does not have common BillingAccount with specified ServiceConsumer with id "${serviceConsumerId}"`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER',
                            message: 'BillingReceipt with id "{receiptId}" does not have common BillingAccount with specified ServiceConsumer with id "{serviceConsumerId}"',
                        },
                    }])
                })
            })
            test('Should have billing account with same unitType as ServiceConsumer.unitType', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const serviceConsumerId = batches[0].serviceConsumer.id
                const payload = [
                    {
                        serviceConsumer: { id: serviceConsumerId },
                        receipts: batches[1].billingReceipts.map(receipt => ({ id: receipt.id })),
                    },
                ]
                await updateTestBillingAccount(commonData.admin, batches[0].billingAccount.id, { unitType: 'parking' })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `BillingReceipt with id "${batches[1].billingReceipts[0].id}" does not have common BillingAccount with specified ServiceConsumer with id "${serviceConsumerId}"`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER',
                            message: 'BillingReceipt with id "{receiptId}" does not have common BillingAccount with specified ServiceConsumer with id "{serviceConsumerId}"',
                        },
                    }])
                })
            })
        })
        describe('RecurrentPaymentContext checks', () => {
            test('Input should contain existing RecurrentPaymentContext id', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(1, 1)
                const [batch] = batches
                const serviceConsumerId = batch.serviceConsumer.id

                const payload = [{
                    serviceConsumer: { id: serviceConsumerId },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }]

                const recurrentPaymentContextId = faker.datatype.uuid()
                const extraArgs = { recurrentPaymentContext: { id: recurrentPaymentContextId } }

                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload, extraArgs)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot find specified RecurrentPaymentContext with following id: ${recurrentPaymentContextId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'recurrentPaymentContext', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_FOUND',
                            message: 'Cannot find specified RecurrentPaymentContext with following id: {id}',
                        },
                    }])
                })
            })
        })

        describe('Invoices check', () => {
            test('Should not be able to pay for invoices not in "status" status', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [invoiceContext] = await createTestInvoiceContext(adminClient, o10n, dummyAcquiringIntegration, { status: INVOICE_CONTEXT_STATUS_FINISHED })
                const [invoice] = await createTestInvoice(adminClient, invoiceContext, { status: INVOICE_STATUS_DRAFT })

                await expectToThrowGQLError(
                    async () => await registerMultiPaymentByTestClient(
                        adminClient,
                        null,
                        { invoices: [pick(invoice, 'id')] },
                    ),
                    {
                        mutation: 'registerMultiPayment',
                        variable: ['data', 'invoices'],
                        code: 'BAD_USER_INPUT',
                        type: 'INVOICES_ARE_NOT_PUBLISHED',
                        message: 'Found invoices with not "published" status',
                    },
                    'result',
                )
            })

            test('Resident: should not be able to pay for 3rd user\'s', async () => {
                const residentClient = await makeClientWithResidentUser()
                const otherResidentClient = await makeClientWithResidentUser()
                const [o10n] = await createTestOrganization(adminClient)
                const [invoiceContext] = await createTestInvoiceContext(adminClient, o10n, dummyAcquiringIntegration, { status: INVOICE_CONTEXT_STATUS_FINISHED })

                const [invoice] = await createTestInvoice(adminClient, invoiceContext, {
                    status: INVOICE_STATUS_PUBLISHED,
                    client: { connect: { id: residentClient.user.id } },
                })

                await expectToThrowGQLError(
                    async () => await registerMultiPaymentByTestClient(
                        otherResidentClient,
                        null,
                        { invoices: [pick(invoice, 'id')] },
                    ),
                    {
                        mutation: 'registerMultiPayment',
                        variable: ['data', 'invoices'],
                        code: 'BAD_USER_INPUT',
                        type: 'INVOICES_FOR_THIRD_USER',
                        message: 'Found invoices not related to the current user',
                    },
                    'result',
                )
            })

            test('All invoices contexts must be finished', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [invoiceContext] = await createTestInvoiceContext(adminClient, o10n, dummyAcquiringIntegration, { status: INVOICE_CONTEXT_STATUS_FINISHED })
                const [invoice] = await createTestInvoice(adminClient, invoiceContext, { status: INVOICE_STATUS_PUBLISHED })

                await updateTestInvoiceContext(adminClient, invoiceContext.id, { status: INVOICE_CONTEXT_STATUS_INPROGRESS })

                await expectToThrowGQLError(
                    async () => await registerMultiPaymentByTestClient(
                        adminClient,
                        null,
                        { invoices: [pick(invoice, 'id')] },
                    ),
                    {
                        mutation: 'registerMultiPayment',
                        variable: ['data', 'invoices'],
                        code: 'BAD_USER_INPUT',
                        type: 'INVOICE_CONTEXT_NOT_FINISHED',
                        message: 'Invoice context is not finished',
                    },
                    'result',
                )
            })

            test('All invoices contexts must have the same currency', async () => {
                const [o10n1] = await createTestOrganization(adminClient)
                const [o10n2] = await createTestOrganization(adminClient)

                const [invoiceContext1] = await createTestInvoiceContext(adminClient, o10n1, dummyAcquiringIntegration, {
                    status: INVOICE_CONTEXT_STATUS_FINISHED,
                    currencyCode: ISO_CODES[0],
                })
                const [invoice1] = await createTestInvoice(adminClient, invoiceContext1, { status: INVOICE_STATUS_PUBLISHED })
                const [invoiceContext2] = await createTestInvoiceContext(adminClient, o10n2, dummyAcquiringIntegration, {
                    status: INVOICE_CONTEXT_STATUS_FINISHED,
                    currencyCode: ISO_CODES[1],
                })
                const [invoice2] = await createTestInvoice(adminClient, invoiceContext2, { status: INVOICE_STATUS_PUBLISHED })

                await expectToThrowGQLError(
                    async () => await registerMultiPaymentByTestClient(
                        adminClient,
                        null,
                        { invoices: [pick(invoice1, 'id'), pick(invoice2, 'id')] },
                    ),
                    {
                        mutation: 'registerMultiPayment',
                        variable: ['data', 'invoices'],
                        code: 'BAD_USER_INPUT',
                        type: 'INVOICES_HAS_MULTIPLE_CURRENCIES',
                        message: 'Invoices has multiple currencies',
                    },
                    'result',
                )
            })
        })

        test('receipts and invoices must have the same currency', async () => {
            const [o10n1] = await createTestOrganization(adminClient)
            const { batches, commonData: { acquiringIntegration } } = await makePayerWithMultipleConsumers(2, 1)

            const [invoiceContext1] = await createTestInvoiceContext(adminClient, o10n1, acquiringIntegration, {
                status: INVOICE_CONTEXT_STATUS_FINISHED,
                currencyCode: ISO_CODES[0],
                recipient: createTestRecipient(),
            })
            const [invoice1] = await createTestInvoice(adminClient, invoiceContext1, { status: INVOICE_STATUS_PUBLISHED })

            const payload = batches.map(batch => ({
                serviceConsumer: { id: batch.serviceConsumer.id },
                receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
            }))

            await expectToThrowGQLError(
                async () => await registerMultiPaymentByTestClient(
                    adminClient,
                    payload,
                    { invoices: [pick(invoice1, 'id')] },
                ),
                {
                    mutation: 'registerMultiPayment',
                    variable: ['data'],
                    code: 'BAD_USER_INPUT',
                    type: 'DIFFERENT_CURRENCY_CODES_FOR_RECEIPTS_AND_INVOICES',
                    message: 'Receipts and invoices has different currency codes',
                },
                'result',
            )
        })

        describe('deletedAt check', () => {
            test('Should not be able to pay for deleted receipts', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(1, 2)
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const deletedReceiptId = batches[0].billingReceipts[0].id
                await updateTestBillingReceipt(commonData.admin, deletedReceiptId, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot pay for deleted receipts ${deletedReceiptId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'RECEIPTS_ARE_DELETED',
                            message: 'Cannot pay for deleted receipts {ids}',
                        },
                    }])
                })
            })
            test('Should not be able to pay for deleted service consumer', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const deletedConsumerId = batches[0].serviceConsumer.id
                await updateTestServiceConsumer(commonData.admin, deletedConsumerId, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Some of specified ServiceConsumers with ids ${deletedConsumerId} were deleted, so you cannot pay for them anymore`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_FOUND',
                            message: 'Some of specified ServiceConsumers with ids {ids} were deleted, so you cannot pay for them anymore',
                        },
                    }])
                })
            })

            test('Should not be able to pay for deleted invoices', async () => {
                const [o10n] = await createTestOrganization(adminClient)
                const [invoiceContext] = await createTestInvoiceContext(adminClient, o10n, dummyAcquiringIntegration, {
                    status: INVOICE_CONTEXT_STATUS_FINISHED,
                    recipient: createTestRecipient(),
                })
                const [invoice] = await createTestInvoice(adminClient, invoiceContext)

                await updateTestInvoice(adminClient, invoice.id, {
                    deletedAt: dayjs().toISOString(),
                    status: INVOICE_STATUS_PUBLISHED,
                })

                await expectToThrowGQLError(
                    async () => await registerMultiPaymentByTestClient(
                        adminClient,
                        null,
                        { invoices: [pick(invoice, 'id')] },
                    ),
                    {
                        mutation: 'registerMultiPayment',
                        variable: ['data', 'invoices'],
                        code: 'BAD_USER_INPUT',
                        type: 'NOT_FOUND',
                        message: 'Some of specified invoices with ids {ids} were deleted, so you cannot pay for them anymore',
                        messageInterpolation: { ids: invoice.id },
                    },
                    'result',
                )
            })

            test('Should not be able to pay for consumer with deleted acquiring context', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestAcquiringIntegrationContext(commonData.admin, batches[1].acquiringContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Some ServiceConsumers has deleted AcquiringIntegrationContext',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED',
                            message: 'Some ServiceConsumers has deleted AcquiringIntegrationContext',
                            data: {
                                failedConsumers: [{
                                    consumerId: batches[1].serviceConsumer.id,
                                    acquiringContextId: batches[1].acquiringContext.id,
                                }],
                            },
                        },
                    }])
                })
            })
            test('Should not be able to pay using deleted acquiring integration', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot pay via deleted acquiring integration with id "${commonData.acquiringIntegration.id}"`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_IS_DELETED',
                            message: 'Cannot pay via deleted acquiring integration with id "{id}"',
                        },
                    }])
                })
            })
            test('Should not be able to pay for receipt with deleted BillingIntegrationOrganizationContext', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingIntegrationOrganizationContext(commonData.admin, batches[0].billingContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'BillingIntegrationOrganizationContext is deleted for some BillingReceipts',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED',
                            message: 'BillingIntegrationOrganizationContext is deleted for some BillingReceipts',
                            data: {
                                failedReceipts: [{
                                    receiptId: batches[0].billingReceipts[0].id,
                                    contextId: batches[0].billingReceipts[0].context.id,
                                }],
                            },
                        },
                    }])
                })
            })
            test('Should not be able to pay for BillingReceipt with deleted BillingIntegration', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    serviceConsumer: { id: batch.serviceConsumer.id },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingIntegration(commonData.admin, batches[0].billingIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'BillingReceipt has deleted BillingIntegration',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'RECEIPT_HAS_DELETED_BILLING_INTEGRATION',
                            message: 'BillingReceipt has deleted BillingIntegration',
                            data: {
                                failedReceipts: [{
                                    receiptId: batches[0].billingReceipts[0].id,
                                    integrationId: batches[0].billingIntegration.id,
                                }],
                            },
                        },
                    }])
                })
            })
            test('Should not be able to pay for deleted RecurrentPaymentContext', async () => {
                const admin = await makeLoggedInAdminClient()
                const { commonData, batches } = await makePayerWithMultipleConsumers(1, 1)
                const [batch] = batches
                const serviceConsumerId = batch.serviceConsumer.id

                // create RecurrentPaymentContext
                const [billingCategory] = await createTestBillingCategory(
                    admin,
                    { name: `Category ${new Date()}` },
                )
                const [recurrentContext] = await createTestRecurrentPaymentContext(
                    commonData.client,
                    {
                        enabled: false,
                        limit: '10000',
                        autoPayReceipts: false,
                        paymentDay: 10,
                        settings: { cardId: faker.datatype.uuid() },
                        serviceConsumer: { connect: { id: serviceConsumerId } },
                        billingCategory: { connect: { id: billingCategory.id } },
                    },
                )

                // soft delete recurrentPaymentContext
                await updateTestRecurrentPaymentContext(
                    commonData.client,
                    recurrentContext.id,
                    { deletedAt: dayjs().toISOString() },
                )

                const payload = [{
                    serviceConsumer: { id: serviceConsumerId },
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }]

                const extraArgs = { recurrentPaymentContext: { id: recurrentContext.id } }

                await catchErrorFrom(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload, extraArgs)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `RecurrentPaymentContext with following id: ${recurrentContext.id} is deleted`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPayment',
                            variable: ['data', 'recurrentPaymentContext', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'NOT_FOUND',
                            message: 'RecurrentPaymentContext with following id: {id} is deleted',
                        },
                    }])
                })
            })
        })
    })
    describe('Real-life cases', () => {
        test('Should correctly calculate commissions for different categories of payments', async () => {
            const {
                admin,
                client,
                acquiringIntegration,
                acquiringContext,
                billingReceipts,
                serviceConsumer,
            } = await makePayer(2)
            const OVERHAUL_CATEGORY = 'c0b9db6a-c351-4bf4-aa35-8e5a500d0195'
            const HOUSING_CATEGORY = '928c97ef-5289-4daa-b80e-4b9fed50c629'
            const implicitFeeDistributionSchema = [
                { 'recipient': 'organization', 'percent': '1.75', 'category': HOUSING_CATEGORY },
                { 'recipient': 'service', 'percent': '0.95', 'category': HOUSING_CATEGORY },
                { 'recipient': 'acquiring', 'percent': '0.8', 'category': HOUSING_CATEGORY },
                { 'recipient': 'organization', 'percent': '0', 'category': OVERHAUL_CATEGORY },
                { 'recipient': 'service', 'percent': '0.4', 'category': OVERHAUL_CATEGORY },
                { 'recipient': 'acquiring', 'percent': '0.8', 'category': OVERHAUL_CATEGORY },
            ]
            await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                canGroupReceipts: true,
            })
            await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, {
                implicitFeeDistributionSchema,
            })
            await updateTestBillingReceipt(admin, billingReceipts[0].id, {
                toPay: '1000',
                category: { connect: { id: HOUSING_CATEGORY } },
            })
            await updateTestBillingReceipt(admin, billingReceipts[1].id, {
                toPay: '1000',
                category: { connect: { id: OVERHAUL_CATEGORY } },
            })
            const payload = [
                {
                    serviceConsumer: { id: serviceConsumer.id },
                    receipts: billingReceipts.map(({ id }) => ({ id })),
                },
            ]
            const [{ multiPaymentId }] = await registerMultiPaymentByTestClient(client, payload)
            const [multiPayment] = await MultiPayment.getAll(admin, { id: multiPaymentId })
            expect(Big(multiPayment.explicitServiceCharge).toFixed(2)).toEqual('12.00')
        })
        test('Should have common billing account with ServiceConsumer if BillingIntegration is changed', async () => {
            /**
             * 1. Management company created a billing receipt. toPay = x
             * 2. User registered in mobile app
             * 3. Management company changes billing integrtation to another and creates new billing receipt
             * 4. User can pay for new receipt
             */

            const {
                admin,
                client,
                organization,
                property,
                acquiringIntegration,
                billingIntegration,
                billingContext,
                billingAccount,
                serviceConsumer,
            } = await makePayer(1)

            // We create a new billing context and delete old
            await createTestBillingIntegration(admin)
            const [newBillingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, billingIntegration)
            const [newBillingProperty] = await createTestBillingProperty(admin, newBillingContext, { address: property.address })
            const [newBillingAccount] = await createTestBillingAccount(admin, newBillingContext, newBillingProperty, {
                unitName: billingAccount.unitName,
                unitType: billingAccount.unitType,
                number: billingAccount.number,
            })
            const [newReceipt] = await createTestBillingReceipt(admin, newBillingContext, newBillingProperty, newBillingAccount)
            await updateTestAcquiringIntegration(admin, acquiringIntegration.id)

            const payload = [
                {
                    serviceConsumer: { id: serviceConsumer.id },
                    receipts: [{ id: newReceipt.id }],
                },
            ]

            // Delete old context -- change is now complete
            const [oldContext] = await updateTestBillingIntegrationOrganizationContext(admin, billingContext.id, { deletedAt: 'true' })

            const createdMultiPayment = await registerMultiPaymentByTestClient(client, payload)
            expect(createdMultiPayment).toBeDefined()
            expect(oldContext.deletedAt).toBeTruthy()
        })
        test('Partial payments are supported', async () => {
            /**
             * 1. Management company created a billing receipt. toPay = x
             * 2. User paid x for this receipt
             * 3. Management company recreated this billing receipt. toPay = y
             * 4. User sees new billing receipt and is prompted to pay only y-x
             * 5. User creates MultiPayment with toPay = y-x
             */
            const { admin, client, serviceConsumer, billingReceipts } = await makePayer(1)

            const [initialBillingReceipt] = billingReceipts
            const initialToPay = initialBillingReceipt.toPay

            const payload = {
                serviceConsumer: { id: serviceConsumer.id },
                receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
            }
            const [initialMultiPaymentResult] = await registerMultiPaymentByTestClient(client, payload)
            const [initialMultiPayment] = await MultiPayment.getAll(admin, { id: initialMultiPaymentResult.multiPaymentId })

            // User pays for the first time
            await updateTestPayment(admin, initialMultiPayment.payments[0].id, {
                explicitFee: '0.0',
                status: PAYMENT_PROCESSING_STATUS,
            })
            await updateTestMultiPayment(admin, initialMultiPayment.id, {
                explicitFee: '0.0',
                explicitServiceCharge: '0.0',
                status: MULTIPAYMENT_PROCESSING_STATUS,
            })
            await updateTestPayment(admin, initialMultiPayment.payments[0].id, {
                advancedAt: dayjs().toISOString(),
                status: PAYMENT_WITHDRAWN_STATUS,
            })
            await updateTestMultiPayment(admin, initialMultiPayment.id, {
                withdrawnAt: dayjs().toISOString(),
                cardNumber: getRandomHiddenCard(),
                paymentWay: 'CARD',
                transactionId: faker.datatype.uuid(),
                status: MULTIPAYMENT_WITHDRAWN_STATUS,
            })

            const delta = '1500.00000000'

            // Management company updates the receipt
            await updateTestBillingReceipt(admin, initialBillingReceipt.id, {
                toPay: Big(initialToPay).plus(delta),
            })

            // Created MultiPayment should equal delta
            const [multiPaymentResult] = await registerMultiPaymentByTestClient(client, payload)
            const [multiPayment] = await MultiPayment.getAll(admin, { id: multiPaymentResult.multiPaymentId })
            const multiPaymentSum = multiPayment.amountWithoutExplicitFee

            expect(multiPaymentSum).toEqual(delta)
        })

        test('Should correctly calculate commissions for invoices', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const staffClient = await makeClientWithStaffUser()
            const [role] = await createTestOrganizationEmployeeRole(adminClient, o10n, {
                canManageInvoices: true,
                canManageContacts: true,
                canReadInvoiceContexts: true,
            })
            await createTestOrganizationEmployee(adminClient, o10n, staffClient.user, role)

            const [contact] = await createTestContact(staffClient, o10n, property, {
                phone: residentClient.userAttrs.phone,
                unitType,
                unitName,
            })

            const [invoiceContext, invoiceContextAttrs] = await createTestInvoiceContext(adminClient, o10n, dummyAcquiringIntegration, {
                status: INVOICE_CONTEXT_STATUS_FINISHED,
                implicitFeePercent: '5',
                recipient: createTestRecipient(),
            })
            const [invoice] = await createTestInvoice(staffClient, invoiceContext, {
                property: { connect: { id: property.id } },
                unitType,
                unitName,
                contact: { connect: { id: contact.id } },
                status: INVOICE_STATUS_PUBLISHED,
            })
            const invoiceSum = invoice.rows.reduce((sum, { toPay, count }) => sum.plus(Big(toPay).mul(count)), Big(0))

            const invoices = await Invoice.getAll(residentClient, {}, { sortBy: ['updatedAt_DESC'] })

            expect(invoices).toEqual([
                expect.objectContaining({
                    id: invoice.id,
                    client: expect.objectContaining({ id: resident.user.id, name: resident.user.name }),
                }),
            ])

            const [result] = await registerMultiPaymentByTestClient(residentClient, null, {
                invoices: invoices.map(({ id }) => ({ id })),
            })

            expect(result).toMatchObject({
                dv: 1,
                multiPaymentId: expect.stringMatching(UUID_RE),
                webViewUrl: `${dummyAcquiringIntegration.hostUrl}/pay/${result.multiPaymentId}`,
                feeCalculationUrl: `${dummyAcquiringIntegration.hostUrl}/api/fee/${result.multiPaymentId}`,
                directPaymentUrl: `${dummyAcquiringIntegration.hostUrl}/api/pay/${result.multiPaymentId}`,
                getCardTokensUrl: `${dummyAcquiringIntegration.hostUrl}/api/clients/${residentClient.user.id}/card-tokens`,
            })

            const multipayment = await MultiPayment.getOne(adminClient, { id: result.multiPaymentId })
            expect(multipayment).toMatchObject({
                currencyCode: invoiceContext.currencyCode,
                integration: { id: dummyAcquiringIntegration.id },
                amount: invoiceSum.toString(),
                implicitFee: Big(invoiceSum).mul(invoiceContextAttrs.implicitFeePercent).div(100).toFixed(8),
            })
        })
    })
    // TODO(savelevMatthew): Remove this test after custom GQL refactoring
    describe('ServerSchema get all should provide enough fields', () => {
        test('AcquiringIntegration', async () => {
            const admin = await makeLoggedInAdminClient()
            const [acquiring] = await createTestAcquiringIntegration(admin)
            const [serverObtainedAcquiring] = await AcquiringIntegration.getAll(admin, {
                id: acquiring.id,
            })
            expect(serverObtainedAcquiring).toBeDefined()
            expect(serverObtainedAcquiring).toHaveProperty('id')
            expect(serverObtainedAcquiring).toHaveProperty('canGroupReceipts')
            expect(serverObtainedAcquiring).toHaveProperty('supportedBillingIntegrationsGroup')
        })
    })
})
