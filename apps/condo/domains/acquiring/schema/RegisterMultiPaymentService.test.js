/**
 * Generated by `createservice acquiring.RegisterMultiPaymentService`
 */

const faker = require('faker')
const dayjs = require('dayjs')

const {
    makeClient,
    makeLoggedInAdminClient,
    prepareKeystoneExpressApp,
    setFakeClientMode,
} = require('@core/keystone/test.utils')
const {
    registerMultiPaymentByTestClient,
    createTestAcquiringIntegration,
    updateTestAcquiringIntegrationContext,
    createTestAcquiringIntegrationContext,
    makePayerWithMultipleConsumers,
    makePayer,
    updateTestAcquiringIntegration,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    updateTestServiceConsumer,
    createTestResident,
    createTestServiceConsumer,
} = require('@condo/domains/resident/utils/testSchema')
const {
    updateTestBillingReceipt,
    updateTestBillingIntegration,
    createTestBillingIntegration,
    updateTestBillingIntegrationOrganizationContext,
} = require('@condo/domains/billing/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')
const { AcquiringIntegration } = require('@condo/domains/acquiring/utils/serverSchema')
const {
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowMutationError,
} = require('@condo/domains/common/utils/testSchema')
const {
    FEE_CALCULATION_PATH,
    WEB_VIEW_PATH,
    DIRECT_PAYMENT_PATH,
} = require('@condo/domains/acquiring/constants/links')
const { DV_UNKNOWN_VERSION_ERROR } = require('@condo/domains/common/constants/errors')
const {
    REGISTER_MP_EMPTY_INPUT,
    REGISTER_MP_EMPTY_RECEIPTS,
    REGISTER_MP_CONSUMERS_DUPLICATE,
    REGISTER_MP_RECEIPTS_DUPLICATE,
    REGISTER_MP_REAL_CONSUMER_MISMATCH,
    REGISTER_MP_NO_ACQUIRING_CONSUMERS,
    REGISTER_MP_MULTIPLE_INTEGRATIONS,
    REGISTER_MP_CANNOT_GROUP_RECEIPTS,
    REGISTER_MP_DELETED_RECEIPTS,
    REGISTER_MP_REAL_RECEIPTS_MISMATCH,
    REGISTER_MP_UNSUPPORTED_BILLING,
    REGISTER_MP_MULTIPLE_CURRENCIES,
    REGISTER_MP_BILLING_ACCOUNTS_NO_MATCH,
    REGISTER_MP_INVALID_SENDER,
    REGISTER_MP_DELETED_CONSUMERS,
    REGISTER_MP_DELETED_ACQUIRING_CONTEXTS,
    REGISTER_MP_DELETED_ACQUIRING_INTEGRATION,
    REGISTER_MP_DELETED_BILLING_CONTEXT,
    REGISTER_MP_DELETED_BILLING_INTEGRATION,
    REGISTER_MP_NEGATIVE_TO_PAY,
} = require('@condo/domains/acquiring/constants/errors')
const { updateTestBillingAccount } = require('@condo/domains/billing/utils/testSchema')
 
describe('RegisterMultiPaymentService', () => {
    describe('Execute', () => {
        describe('Resident',  () => {
            const cases = [[1, 1], [1, 2], [2, 1], [2, 2]]
            test.each(cases)('Consumers: %p | Receipts in each consumer: %p', async (consumers, receipts) => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(consumers, receipts)
                const hostUrl = commonData.acquiringIntegration.hostUrl
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                const [result] = await registerMultiPaymentByTestClient(commonData.client, payload)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('dv', 1)
                expect(result).toHaveProperty('multiPaymentId')
                expect(result).toHaveProperty('webViewUrl', `${hostUrl}${WEB_VIEW_PATH.replace('[id]', result.multiPaymentId )}`)
                expect(result).toHaveProperty('feeCalculationUrl', `${hostUrl}${FEE_CALCULATION_PATH.replace('[id]', result.multiPaymentId )}`)
                expect(result).toHaveProperty('directPaymentUrl', `${hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', result.multiPaymentId )}`)
            })
        })
        test('Anonymous user', async () => {
            const { serviceConsumer, billingReceipts } = await makePayer()
            const payload = [{
                consumerId: serviceConsumer.id,
                receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
            }]
            const client = await makeClient()
            await expectToThrowAuthenticationError(async () => {
                await registerMultiPaymentByTestClient(client, payload)
            }, 'result')
        })
        test('Staff user', async () => {
            const { serviceConsumer, billingReceipts } = await makePayer()
            const payload = [{
                consumerId: serviceConsumer.id,
                receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
            }]
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerMultiPaymentByTestClient(client, payload)
            })
        })
    })
    describe('Validations', () => {
        describe('Input checks', () => {
            test('Should check dv (=== 1)', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer()
                const payload = [{
                    consumerId: serviceConsumer.id,
                    receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
                }]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload, { dv: 2 })
                }, DV_UNKNOWN_VERSION_ERROR)
            })
            describe('Should check sender', () => {
                let consumerId
                let receipts
                let client
                beforeAll(async () => {
                    const data = await makePayer()
                    consumerId = data.serviceConsumer.id
                    receipts = data.billingReceipts.map(receipt => ({ id: receipt.id }))
                    client = data.client
                })
                const cases = [
                    [2, faker.random.alphaNumeric(8)],
                    [1, faker.random.alphaNumeric(3)],
                    [1, faker.random.alphaNumeric(60)],
                    [1, 'КиРиЛЛиЦА'],
                ]
                test.each(cases)('dv: %p, fingerprint: %p', async (dv, fingerprint) => {
                    const sender = { dv, fingerprint }
                    const payload = {
                        consumerId,
                        receipts,
                    }
                    await expectToThrowMutationError(async () => {
                        await registerMultiPaymentByTestClient(client, payload, { sender })
                    }, REGISTER_MP_INVALID_SENDER)
                })
            })
            test('Should check emptiness of input arrays', async () => {
                const { serviceConsumer, client } = await makePayer()
                let payload = []
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_EMPTY_INPUT)
                payload = [
                    {
                        consumerId: serviceConsumer.id,
                        receipts: [],
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_EMPTY_RECEIPTS)
            })
        })
        describe('Duplicates checks', () => {
            test('Should contains unique ServiceConsumers', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer(2)
                const payload = [
                    {
                        consumerId: serviceConsumer.id,
                        receipts: [{ id: billingReceipts[0].id }],
                    },
                    {
                        consumerId: serviceConsumer.id,
                        receipts: [{ id: billingReceipts[1].id }],
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_CONSUMERS_DUPLICATE)
            })
            test('Should contains unique receipts', async () => {
                const { serviceConsumer, billingReceipts, client } = await makePayer()
                const payload = [
                    {
                        consumerId: serviceConsumer.id,
                        receipts: [{ id: billingReceipts[0].id }, { id: billingReceipts[0].id }],
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_RECEIPTS_DUPLICATE)
            })
        })
        describe('ServiceConsumers checks', () => {
            test('Input should contains existing ServiceConsumers id', async () => {
                const { billingReceipts, client } = await makePayer(2)
                const fakeUuid = faker.datatype.uuid()
                const payload = [
                    {
                        consumerId: fakeUuid,
                        receipts: billingReceipts.map(receipt => ({ id: receipt.id })),
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_REAL_CONSUMER_MISMATCH)
            })
            test('All ServiceConsumers should have AcquiringIntegrationContext', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestServiceConsumer(commonData.admin, batches[1].serviceConsumer.id, {
                    acquiringIntegrationContext: { disconnectAll: true },
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_NO_ACQUIRING_CONSUMERS)
            })
            describe('AcquiringIntegrationContext', () => {
                test('All should be linked to same AcquiringIntegration', async () => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                    const billings = batches.map(batch => batch.billingIntegration)

                    const [secondAcquiring] = await createTestAcquiringIntegration(commonData.admin, billings)
                    await updateTestAcquiringIntegrationContext(commonData.admin, batches[1].acquiringContext.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    const [secondContext] = await createTestAcquiringIntegrationContext(commonData.admin, batches[1].organization, secondAcquiring)
                    const [secondResident] = await createTestResident(commonData.admin, commonData.client.user, batches[1].organization, batches[1].property)
                    const [secondConsumer] = await createTestServiceConsumer(commonData.admin, secondResident, batches[1].organization, {
                        acquiringIntegrationContext: { connect: { id: secondContext.id } },
                        billingIntegrationContext: { connect: { id: batches[1].billingContext.id } },
                        billingAccount: { connect: { id: batches[1].billingAccount.id } },
                    })

                    const payload = [
                        { consumerId: batches[0].serviceConsumer.id, receipts: batches[0].billingReceipts.map(receipt => ({ id: receipt.id })) },
                        { consumerId: secondConsumer.id, receipts: batches[1].billingReceipts.map(receipt => ({ id: receipt.id })) },
                    ]

                    await expectToThrowMutationError(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, REGISTER_MP_MULTIPLE_INTEGRATIONS)
                })
            })
        })
        describe('BillingReceipts checks', () => {
            describe('Cannot be multiple if acquiring cannot group receipts', () => {
                const cases = [[1, 2], [2, 1]]
                test.each(cases)('%p receipts in %p ServiceConsumers', async (consumers, receipts) => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(consumers, receipts)

                    const payload = batches.map(batch => ({
                        consumerId: batch.serviceConsumer.id,
                        receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                    }))
                    await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                        canGroupReceipts: false,
                    })
                    await expectToThrowMutationError(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, REGISTER_MP_CANNOT_GROUP_RECEIPTS)
                })
            })
            test('Should have existing ids', async () => {
                const { serviceConsumer, client } = await makePayer()
                const payload = [{
                    consumerId: serviceConsumer.id,
                    receipts: { id: faker.datatype.uuid() },
                }]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(client, payload)
                }, REGISTER_MP_REAL_RECEIPTS_MISMATCH)
            })
            test('Should be linked to BillingIntegration which supported by acquiring', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                    supportedBillingIntegrations: { disconnect: [{ id: batches[1].billingIntegration.id }] },
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_UNSUPPORTED_BILLING)
            })
            test('Cannot pay for receipts with multiple currencies', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingIntegration(commonData.admin, batches[1].billingIntegration.id, {
                    currencyCode: 'USD',
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_MULTIPLE_CURRENCIES)
            })
            describe('Cannot pay for receipts with negative toPay',  () => {
                const cases = ['0.0', '-1', '-50.00', '-0.000000']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                    const payload = batches.map(batch => ({
                        consumerId: batch.serviceConsumer.id,
                        receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                    }))
                    await updateTestBillingReceipt(commonData.admin, batches[1].billingReceipts[0].id, {
                        toPay,
                    })
                    await expectToThrowMutationError(async () => {
                        await registerMultiPaymentByTestClient(commonData.client, payload)
                    }, REGISTER_MP_NEGATIVE_TO_PAY)
                })
            })
            test('Should have common billing account with ServiceConsumer', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = [
                    {
                        consumerId: batches[0].serviceConsumer.id,
                        receipts: batches[1].billingReceipts.map(receipt => ({ id: receipt.id })),
                    },
                ]
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_BILLING_ACCOUNTS_NO_MATCH)
            })
            test('Should have billing account with same unitType as ServiceConsumer.unitType', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = [
                    {
                        consumerId: batches[0].serviceConsumer.id,
                        receipts: batches[1].billingReceipts.map(receipt => ({ id: receipt.id })),
                    },
                ]
                await updateTestBillingAccount(commonData.admin, batches[0].billingAccount.id, { unitType: 'parking' })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_BILLING_ACCOUNTS_NO_MATCH)
            })
        })
        describe('deletedAt check', () => {
            test('Should not be able to pay for deleted receipts', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(1, 2)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingReceipt(commonData.admin, batches[0].billingReceipts[0].id, {
                    deletedAt: dayjs().toISOString(),
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_DELETED_RECEIPTS)
            })
            test('Should not be able to pay for deleted service consumer', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestServiceConsumer(commonData.admin, batches[0].serviceConsumer.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_DELETED_CONSUMERS)
            })
            test('Should not be able to pay for consumer with deleted acquiring context', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestAcquiringIntegrationContext(commonData.admin, batches[1].acquiringContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_DELETED_ACQUIRING_CONTEXTS)
            })
            test('Should not be able to pay using deleted acquiring integration', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestAcquiringIntegration(commonData.admin, commonData.acquiringIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_DELETED_ACQUIRING_INTEGRATION)
            })
            test('Should not be able to pay for receipt with deleted context', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingIntegrationOrganizationContext(commonData.admin, batches[0].billingContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_DELETED_BILLING_CONTEXT)
            })
            test('Should not be able to pay for receipt with deleted integration', async () => {
                const { commonData, batches } = await makePayerWithMultipleConsumers(2, 1)
                const payload = batches.map(batch => ({
                    consumerId: batch.serviceConsumer.id,
                    receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })),
                }))
                await updateTestBillingIntegration(commonData.admin, batches[0].billingIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await expectToThrowMutationError(async () => {
                    await registerMultiPaymentByTestClient(commonData.client, payload)
                }, REGISTER_MP_DELETED_BILLING_INTEGRATION)
            })
        })
    })
    // TODO(savelevMatthew): Remove this test after custom GQL refactoring
    describe('ServerSchema get all should provide enough fields', () => {
        setFakeClientMode(require.resolve('../../../index'))
        let context
        beforeAll(async () => {
            const app = await prepareKeystoneExpressApp(require.resolve('../../../index'))
            const { keystone } = app
            context = await keystone.createContext({ skipAccessControl: true })
        })
        test('AcquiringIntegration', async () => {
            const admin = await makeLoggedInAdminClient()
            const [firstBilling] = await createTestBillingIntegration(admin)
            const [secondBilling] = await createTestBillingIntegration(admin)
            const [acquiring] = await createTestAcquiringIntegration(admin, [firstBilling, secondBilling])
            const [serverObtainedAcquiring] = await AcquiringIntegration.getAll(context, {
                id: acquiring.id,
            })
            expect(serverObtainedAcquiring).toBeDefined()
            expect(serverObtainedAcquiring).toHaveProperty('id')
            expect(serverObtainedAcquiring).toHaveProperty('canGroupReceipts')
            expect(serverObtainedAcquiring).toHaveProperty('supportedBillingIntegrations')
            expect(serverObtainedAcquiring.supportedBillingIntegrations).toHaveLength(2)
        })
    })
})