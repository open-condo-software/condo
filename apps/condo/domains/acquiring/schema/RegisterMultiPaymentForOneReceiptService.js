/**
 * Generated by `createservice acquiring.RegisterMultiPaymentForOneReceiptService`
 */

const { getById } = require('@core/keystone/schema')

const { GQLCustomSchema } = require('@core/keystone/schema')
const access = require('@condo/domains/acquiring/access/RegisterMultiPaymentForOneReceiptService')
const { DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY } = require('@condo/domains/acquiring/constants/payment')
const {
    FEE_CALCULATION_PATH,
    WEB_VIEW_PATH,
    DIRECT_PAYMENT_PATH,
    GET_CARD_TOKENS_PATH,
} = require('@condo/domains/acquiring/constants/links')
const { JSON_STRUCTURE_FIELDS_CONSTRAINTS } = require('@condo/domains/common/utils/validation.utils')
const { Payment, MultiPayment, AcquiringIntegration } = require('@condo/domains/acquiring/utils/serverSchema')
const {
    getAcquiringIntegrationContextFormula,
    FeeDistribution,
} = require('@condo/domains/acquiring/utils/serverSchema/feeDistribution')
const { freezeBillingReceipt } = require('@condo/domains/acquiring/utils/freezeBillingReceipt')
const { get, isFunction, isNil, isPlainObject } = require('lodash')
const Big = require('big.js')
const validate = require('validate.js')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@core/keystone/errors')
const { DV_VERSION_MISMATCH } = require('@condo/domains/common/constants/errors')
const { WRONG_FORMAT } = require('../../common/constants/errors')
const {
    RECEIPTS_ARE_DELETED,
    RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE,
    ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
    RECEIPT_HAS_DELETED_BILLING_INTEGRATION,
    BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
    ACQUIRING_INTEGRATION_IS_DELETED,
    CANNOT_FIND_ALL_BILLING_RECEIPTS,
    ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
} = require('../constants/errors')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const errors = {
    DV_VERSION_MISMATCH: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
    },
    WRONG_SENDER_FORMAT: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value. {details}',
        correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
    },
    ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'acquiringIntegrationContext', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
        message: 'Cannot pay via deleted acquiring integration context',
    },
    ACQUIRING_INTEGRATION_IS_DELETED: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'acquiringIntegrationContext', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_IS_DELETED,
        message: 'Cannot pay via deleted acquiring integration with id "{id}"',
    },
    CANNOT_FIND_BILLING_RECEIPT: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'receipt', 'id'],
        code: BAD_USER_INPUT,
        type: CANNOT_FIND_ALL_BILLING_RECEIPTS,
        message: 'Cannot find specified BillingReceipt with id {missingReceiptId}',
    },
    RECEIPT_IS_DELETED: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'receipt', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_ARE_DELETED,
        message: 'Cannot pay for deleted receipt {id}',
    },
    RECEIPT_HAVE_NEGATIVE_TO_PAY_VALUE: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'receipt', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE,
        message: 'Cannot pay for BillingReceipt {id} with negative "toPay" value',
    },
    BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'receipt', 'id'],
        code: BAD_USER_INPUT,
        type: BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
        message: 'BillingIntegrationOrganizationContext is deleted for provided BillingReceipt',
    },
    ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'receipt', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
        message: 'AcquiringIntegration does not supports following BillingReceipt\'s BillingIntegration: {unsupportedBillingIntegration}',
    },
    RECEIPT_HAS_DELETED_BILLING_INTEGRATION: {
        mutation: 'registerMultiPaymentForOneReceipt',
        variable: ['data', 'receipt', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPT_HAS_DELETED_BILLING_INTEGRATION,
        message: 'BillingReceipt has deleted BillingIntegration',
    },
}

const throwErrorIf = (errorCondition, baseError, context, extraArgsSupplier) => {
    if (errorCondition) {
        const suppliedArgs = isFunction(extraArgsSupplier) ? extraArgsSupplier() : {}
        const extraArgs = isPlainObject(suppliedArgs) ? suppliedArgs : {}
        const error = { ...baseError, ...extraArgs }
        throw new GQLError(error, context)
    }
}

const SENDER_FIELD_CONSTRAINTS = {
    ...JSON_STRUCTURE_FIELDS_CONSTRAINTS,
    dv: {
        numericality: {
            noStrings: true,
            equalTo: 1,
        },
    },
}

const RegisterMultiPaymentForOneReceiptService = new GQLCustomSchema('RegisterMultiPaymentForOneReceiptService', {
    types: [
        {
            access: true,
            type: 'input RegisterMultiPaymentForOneReceiptInput { dv: Int!, sender: SenderFieldInput!, receipt: BillingReceiptWhereUniqueInput!, acquiringIntegrationContext: AcquiringIntegrationContextWhereUniqueInput! }',
        },
        {
            access: true,
            type: 'type RegisterMultiPaymentForOneReceiptOutput { dv: Int!, multiPaymentId: String!, webViewUrl: String!, feeCalculationUrl: String!, directPaymentUrl: String!, getCardTokensUrl: String! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterMultiPaymentForOneReceipt,
            schema: 'registerMultiPaymentForOneReceipt(data: RegisterMultiPaymentForOneReceiptInput!): RegisterMultiPaymentForOneReceiptOutput',
            resolver: async (parent, args, context) => {
                // wrap validator function to the current call context
                const throwIf = ({ when, error, extraArgsSupplier }) => throwErrorIf(
                    when,
                    error,
                    context,
                    extraArgsSupplier,
                )
                const { data } = args
                const {
                    dv,
                    sender,
                    receipt,
                    acquiringIntegrationContext,
                } = data

                // Stage 0. Check if input is valid
                throwIf({
                    when: dv !== 1, error: errors.DV_VERSION_MISMATCH,
                })

                const senderErrors = validate(sender, SENDER_FIELD_CONSTRAINTS)
                throwIf({
                    when: senderErrors && Object.keys(senderErrors).length,
                    error: errors.WRONG_SENDER_FORMAT,
                    extraArgsSupplier: () => {
                        const details = Object.keys(senderErrors).map(field => {
                            return `${field}: [${senderErrors[field].map(error => `'${error}'`).join(', ')}]`
                        }).join(', ')
                        return { messageInterpolation: { details } }
                    },
                })

                // Stage 1: get acquiring context & integration
                const acquiringContext = await getById('AcquiringIntegrationContext', acquiringIntegrationContext.id)

                throwIf({
                    when: acquiringContext.deletedAt,
                    error: errors.ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
                })

                const acquiringIntegration = await AcquiringIntegration.getOne(context, {
                    id: acquiringContext.integration,
                })

                throwIf({
                    when: acquiringIntegration.deletedAt,
                    error: errors.ACQUIRING_INTEGRATION_IS_DELETED,
                    extraArgsSupplier: () => ({ messageInterpolation: { id: acquiringContext.integration } }),
                })

                // Stage 2. Check BillingReceipts
                const billingReceipt = await getById('BillingReceipt', receipt.id)

                throwIf({
                    when: isNil(billingReceipt),
                    error: errors.CANNOT_FIND_BILLING_RECEIPT,
                    extraArgsSupplier: () => ({ messageInterpolation: { missingReceiptId: receipt.id } }),
                })
                throwIf({
                    when: billingReceipt.deletedAt,
                    error: errors.RECEIPT_IS_DELETED,
                    extraArgsSupplier: () => ({ messageInterpolation: { id: billingReceipt.id } }),
                })

                // negative to pay value
                throwIf({
                    when: Big(billingReceipt.toPay).lte(0),
                    error: errors.RECEIPT_HAVE_NEGATIVE_TO_PAY_VALUE,
                    extraArgsSupplier: () => ({ messageInterpolation: { id: billingReceipt.id } }),
                })

                const billingContext = await getById('BillingIntegrationOrganizationContext', billingReceipt.context)

                throwIf({
                    when: billingContext.deletedAt,
                    error: errors.BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
                    extraArgsSupplier: () => {
                        const failedReceipts = [{ receiptId: billingReceipt.id, contextId: billingReceipt.context }]
                        return { data: { failedReceipts } }
                    },
                })

                const supportedBillingIntegrations = get(acquiringIntegration, 'supportedBillingIntegrations', [])
                    .map(integration => integration.id)

                throwIf({
                    when: !supportedBillingIntegrations.includes(billingContext.integration),
                    error: errors.ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
                    extraArgsSupplier: () => ({ messageInterpolation: { unsupportedBillingIntegration: billingContext.integration } }),
                })

                const billingIntegration = await getById('BillingIntegration', billingContext.integration)

                throwIf({
                    when: billingIntegration.deletedAt,
                    error: errors.RECEIPT_HAS_DELETED_BILLING_INTEGRATION,
                    extraArgsSupplier: () => {
                        const failedReceipts = [{
                            receiptId: billingReceipt.id,
                            integrationId: billingContext.integration,
                        }]
                        return { data: { failedReceipts } }
                    },
                })

                const currencyCode = get(billingIntegration, ['currencyCode'])

                // Stage 3 Generating payments
                const formula = await getAcquiringIntegrationContextFormula(context, acquiringIntegrationContext.id)
                const feeCalculator = new FeeDistribution(formula)
                const frozenReceipt = await freezeBillingReceipt(billingReceipt)
                const billingAccountNumber = get(frozenReceipt, ['data', 'account', 'number'])
                const {
                    type,
                    explicitFee = '0',
                    implicitFee = '0',
                    fromReceiptAmountFee = '0',
                } = feeCalculator.calculate(billingReceipt.toPay)
                const explicitFees = type === 'service' ? {
                    explicitServiceCharge: String(explicitFee),
                    explicitFee: '0',
                } : {
                    explicitServiceCharge: '0',
                    explicitFee: String(explicitFee),
                }
                const paymentCommissionFields = {
                    ...explicitFees,
                    implicitFee: String(implicitFee),
                    serviceFee: String(fromReceiptAmountFee),
                }
                const paymentModel = await Payment.create(context, {
                    dv: 1,
                    sender,
                    amount: billingReceipt.toPay,
                    currencyCode,
                    accountNumber: billingAccountNumber,
                    period: billingReceipt.period,
                    receipt: { connect: { id: billingReceipt.id } },
                    frozenReceipt,
                    context: { connect: { id: acquiringContext.id } },
                    organization: { connect: { id: acquiringContext.organization } },
                    recipientBic: billingReceipt.recipient.bic,
                    recipientBankAccount: billingReceipt.recipient.bankAccount,
                    ...paymentCommissionFields,
                })
                const payment = { ...paymentModel, serviceFee: paymentCommissionFields.serviceFee }

                const totalAmount = {
                    amountWithoutExplicitFee: Big(payment.amount),
                    explicitFee: Big(payment.explicitFee),
                    explicitServiceCharge: Big(payment.explicitServiceCharge),
                    serviceFee: Big(payment.serviceFee),
                    implicitFee: Big(payment.implicitFee),
                }
                const multiPayment = await MultiPayment.create(context, {
                    dv: 1,
                    sender,
                    ...Object.fromEntries(Object.entries(totalAmount).map(([key, value]) => ([key, value.toFixed(2)]))),
                    currencyCode,
                    user: { connect: { id: context.authedItem.id } },
                    integration: { connect: { id: acquiringIntegration.id } },
                    payments: { connect: [{ id: payment.id }] },
                    // TODO(DOMA-1574): add correct category
                    serviceCategory: DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY,
                })
                return {
                    dv: 1,
                    multiPaymentId: multiPayment.id,
                    webViewUrl: `${acquiringIntegration.hostUrl}${WEB_VIEW_PATH.replace('[id]', multiPayment.id)}`,
                    feeCalculationUrl: `${acquiringIntegration.hostUrl}${FEE_CALCULATION_PATH.replace('[id]', multiPayment.id)}`,
                    directPaymentUrl: `${acquiringIntegration.hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', multiPayment.id)}`,
                    getCardTokensUrl: `${acquiringIntegration.hostUrl}${GET_CARD_TOKENS_PATH.replace('[id]', context.authedItem.id)}`,
                }
            },
        },
    ],

})

module.exports = {
    RegisterMultiPaymentForOneReceiptService,
}
