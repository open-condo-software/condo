/**
 * Generated by `createservice acquiring.RegisterMultiPaymentForVirtualReceiptService`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const dayjs = require('dayjs')

const {
    makeClient,
    makeLoggedInAdminClient, expectToThrowGQLError, expectToThrowGQLErrorToResult,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult,
    catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const { GQL_ERRORS: { PAYMENT_AMOUNT_LESS_THAN_MINIMUM, PAYMENT_AMOUNT_GREATER_THAN_MAXIMUM } } = require('@condo/domains/acquiring/constants/errors')
const {
    FEE_CALCULATION_PATH,
    WEB_VIEW_PATH,
    DIRECT_PAYMENT_PATH,
} = require('@condo/domains/acquiring/constants/links')
const {
    AcquiringIntegration,
    registerMultiPaymentForVirtualReceiptByTestClient,
    createTestAcquiringIntegration,
    updateTestAcquiringIntegrationContext,
    makePayer,
    updateTestAcquiringIntegration,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    TestUtils,
    ResidentTestMixin,
} = require('@condo/domains/billing/utils/testSchema/testUtils')

function generateReceipt (billingAccount) {
    return {
        currencyCode: 'RUB',
        amount: '100.45',
        period: '2022-09-01',
        recipient: {
            routingNumber: '044525256',
            bankAccount: '40702810996180000019',
            accountNumber: billingAccount.number,
        },
    }
}

describe('RegisterMultiPaymentForVirtualReceiptService', () => {
    describe('Execute', () => {
        describe('Staff', () => {
            test('From virtual receipt', async () => {
                const {
                    acquiringContext,
                    acquiringIntegration,
                    billingAccount,
                    admin,
                } = await makePayer()
                const hostUrl = acquiringIntegration.hostUrl
                const receipt = generateReceipt(billingAccount)
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('dv', 1)
                expect(result).toHaveProperty('multiPaymentId')
                expect(result).toHaveProperty('webViewUrl', `${hostUrl}${WEB_VIEW_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('feeCalculationUrl', `${hostUrl}${FEE_CALCULATION_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('directPaymentUrl', `${hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', result.multiPaymentId)}`)
            })
        })
        test('Anonymous user', async () => {
            const {
                acquiringContext,
                billingAccount,
            } = await makePayer()
            const receipt = generateReceipt(billingAccount)
            const acquiringIntegrationContext = { id: acquiringContext.id }
            const client = await makeClient()
            await expectToThrowAuthenticationError(async () => {
                await registerMultiPaymentForVirtualReceiptByTestClient(client, receipt, acquiringIntegrationContext)
            }, 'result')
        })
        test('Resident user', async () => {
            const {
                acquiringContext,
                client,
                billingAccount,
            } = await makePayer()
            const receipt = generateReceipt(billingAccount)
            const acquiringIntegrationContext = { id: acquiringContext.id }
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerMultiPaymentForVirtualReceiptByTestClient(client, receipt, acquiringIntegrationContext)
            })
        })
    })
    describe('RegisterMultiPaymentForVirtualReceiptService mutation Validations', () => {
        describe('Input checks', () => {
            test('Should check dv (=== 1)', async () => {
                const {
                    acquiringContext,
                    admin,
                    billingAccount,
                } = await makePayer()
                const receipt = generateReceipt(billingAccount)
                const acquiringIntegrationContext = { id: acquiringContext.id }

                await catchErrorFrom(async () => {
                    await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext, { dv: 2 })
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Wrong value for data version number',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForVirtualReceipt',
                            variable: ['data', 'dv'],
                            code: 'BAD_USER_INPUT',
                            type: 'DV_VERSION_MISMATCH',
                            message: 'Wrong value for data version number',
                        },
                    }])
                })
            })
            describe('Should check sender', () => {
                let acquiringIntegrationContext
                let receipt
                let admin
                beforeAll(async () => {
                    const data = await makePayer()
                    receipt = generateReceipt(data.billingAccount)
                    acquiringIntegrationContext = { id: data.acquiringContext.id }
                    admin = data.admin
                })
                const cases = [
                    [2, faker.random.alphaNumeric(8)],
                    [1, faker.random.alphaNumeric(3)],
                    [1, faker.random.alphaNumeric(60)],
                    [1, 'КиРиЛЛиЦА'],
                ]
                test.each(cases)('dv: %p, fingerprint: %p', async (dv, fingerprint) => {
                    const sender = { dv, fingerprint }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext, { sender })
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForVirtualReceipt',
                                variable: ['data', 'sender'],
                                code: 'BAD_USER_INPUT',
                                type: 'WRONG_FORMAT',
                            },
                        }])
                        expect(errors[0].message).toMatch('Invalid format of "sender" field value.')
                        expect(errors[0].extensions.message).toMatch('Invalid format of "sender" field value.')
                    })
                })
            })
        })
        describe('Receipt checks', () => {
            describe('Cannot pay for receipts with negative toPay', () => {
                const cases = ['0.0', '-1', '-50.00', '-0.000000']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const {
                        admin,
                        acquiringContext,
                        billingAccount,
                    } = await makePayer()
                    const receipt = generateReceipt(billingAccount)
                    receipt.amount = toPay
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot pay for Receipt with negative "toPay" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForVirtualReceipt',
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE',
                                message: 'Cannot pay for Receipt with negative "toPay" value',
                            },
                        }])
                    })
                })
            })
            describe('Cannot pay for Receipt with invalid "toPay" value', () => {
                const cases = ['100 000', 'Hello world', '100 dollars', '100$']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const {
                        admin,
                        acquiringContext,
                        billingAccount,
                    } = await makePayer()
                    const receipt = generateReceipt(billingAccount)
                    receipt.amount = toPay
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot pay for Receipt with invalid "toPay" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForVirtualReceipt',
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPT_HAVE_INVALID_TO_PAY_VALUE',
                                message: 'Cannot pay for Receipt with invalid "toPay" value',
                            },
                        }])
                    })
                })
            })
            describe('Cannot pay for Receipt with invalid "currencyCode" value', () => {
                const cases = ['$', 'dollars', 'RU', 'rub']
                test.each(cases)('ToPay currency: %p', async (currencyCode) => {
                    const {
                        admin,
                        acquiringContext,
                        billingAccount,
                    } = await makePayer()
                    const receipt = generateReceipt(billingAccount)
                    receipt.currencyCode = currencyCode
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot pay for Receipt with invalid "currencyCode" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForVirtualReceipt',
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPT_HAVE_INVALID_CURRENCY_CODE_VALUE',
                                message: 'Cannot pay for Receipt with invalid "currencyCode" value',
                            },
                        }])
                    })
                })
            })
        })
        describe('deletedAt check', () => {
            test('Should not be able to pay for consumer with deleted acquiring context', async () => {
                const {
                    admin,
                    acquiringContext,
                    billingAccount,
                } = await makePayer()
                const receipt = generateReceipt(billingAccount)
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Cannot pay via deleted acquiring integration context',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForVirtualReceipt',
                            variable: ['data', 'acquiringIntegrationContext', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED',
                            message: 'Cannot pay via deleted acquiring integration context',
                        },
                    }])
                })
            })
            test('Should not be able to pay using deleted acquiring integration', async () => {
                const {
                    admin,
                    acquiringContext,
                    acquiringIntegration,
                    billingAccount,
                } = await makePayer()
                const receipt = generateReceipt(billingAccount)
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await expectToThrowGQLErrorToResult(async () => {
                    await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                }, {
                    mutation: 'registerMultiPaymentForVirtualReceipt',
                    variable: ['data', 'acquiringIntegrationContext', 'id'],
                    code: 'BAD_USER_INPUT',
                    type: 'ACQUIRING_INTEGRATION_IS_DELETED',
                    message: 'Cannot pay via deleted acquiring integration with id "{id}"',
                    messageInterpolation: {
                        id: acquiringIntegration.id,
                    },
                })
            })
        })
    })
    // TODO(savelevMatthew): Remove this test after custom GQL refactoring
    describe('ServerSchema get all should provide enough fields', () => {
        test('AcquiringIntegration', async () => {
            const admin = await makeLoggedInAdminClient()
            const [acquiring] = await createTestAcquiringIntegration(admin)
            const [serverObtainedAcquiring] = await AcquiringIntegration.getAll(admin, {
                id: acquiring.id,
            })
            expect(serverObtainedAcquiring).toBeDefined()
            expect(serverObtainedAcquiring).toHaveProperty('id')
            expect(serverObtainedAcquiring).toHaveProperty('canGroupReceipts')
            expect(serverObtainedAcquiring).toHaveProperty('supportedBillingIntegrationsGroup')
        })
    })

    describe('RegisterMultiPaymentForVirtualReceiptService check minimum and maximum payment amount', () => {
        let utils

        beforeAll(async () => {
            utils = new TestUtils([ResidentTestMixin])
            await utils.init()
            await utils.updateAcquiringIntegration({
                explicitFeeDistributionSchema: [
                    { 'recipient': 'acquiring', 'percent': '1.0' },
                    { 'recipient': 'service', 'percent': '0.2' },
                ],
            })
        })

        afterEach(async () => {
            await utils.updateAcquiringIntegration({ minimumPaymentAmount: null, maximumPaymentAmount: null })
        })

        test('Payment for acquiring with no set the maximum payment amount', async () => {
            const receipt = generateReceipt({ number: faker.random.numeric(50) })
            const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(utils.clients.admin, receipt, { id: utils.acquiringContext.id })
            expect(result).toHaveProperty('multiPaymentId')
        })

        test('Payment amount is equal to the maximum payment amount required by the acquiring integration', async () => {
            const receipt = generateReceipt({ number: faker.random.numeric(50) })
            const maximumPaymentAmount = Big(receipt.amount).mul(1.012).toFixed(2)
            await utils.updateAcquiringIntegration({ maximumPaymentAmount })
            const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(utils.clients.admin, receipt, { id: utils.acquiringContext.id })
            expect(result).toHaveProperty('multiPaymentId')
        })

        test('Payment amount is greater than the maximum payment amount required by the acquiring integration', async () => {
            const receipt = generateReceipt({ number: faker.random.numeric(50) })
            const maximumPaymentAmount = Big(receipt.amount).minus(100).toString()
            await utils.updateAcquiringIntegration({ maximumPaymentAmount })
            await expectToThrowGQLError(async () => {
                await registerMultiPaymentForVirtualReceiptByTestClient(utils.clients.admin, receipt, { id: utils.acquiringContext.id })
            }, {
                ...PAYMENT_AMOUNT_GREATER_THAN_MAXIMUM,
                messageInterpolation: { maximumPaymentAmount },
            }, 'result')
        })

        test('Payment amount is less than the maximum payment amount required by the acquiring integration', async () => {
            const receipt = generateReceipt({ number: faker.random.numeric(50) })
            const maximumPaymentAmount = Big(receipt.amount).add(100)
            await utils.updateAcquiringIntegration({ maximumPaymentAmount })
            const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(utils.clients.admin, receipt, { id: utils.acquiringContext.id })
            expect(result).toHaveProperty('multiPaymentId')
        })

        test('Payment for acquiring with no set the minimum payment amount', async () => {
            const receipt = generateReceipt({ number: faker.random.numeric(50) })
            const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(utils.clients.admin, receipt, { id: utils.acquiringContext.id })
            expect(result).toHaveProperty('multiPaymentId')
        })

        test('Payment amount is equal to the minimum payment amount required by the acquiring integration', async () => {
            const receipt = generateReceipt({ number: faker.random.numeric(50) })
            const minimumPaymentAmount = Big(receipt.amount).mul(1.012).toFixed(2)
            await utils.updateAcquiringIntegration({ minimumPaymentAmount })
            const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(utils.clients.admin, receipt, { id: utils.acquiringContext.id })
            expect(result).toHaveProperty('multiPaymentId')
        })

        test('Payment amount is greater than the minimum payment amount required by the acquiring integration', async () => {
            const receipt = generateReceipt({ number: faker.random.numeric(50) })
            const minimumPaymentAmount = Big(receipt.amount).minus(1)
            await utils.updateAcquiringIntegration({ minimumPaymentAmount })
            const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(utils.clients.admin, receipt, { id: utils.acquiringContext.id })
            expect(result).toHaveProperty('multiPaymentId')
        })

        test('Payment amount is less than the minimum payment amount required by the acquiring integration', async () => {
            const receipt = generateReceipt({ number: faker.random.numeric(50) })
            const minimumPaymentAmount = Big(receipt.amount).add(100).toString()
            await utils.updateAcquiringIntegration({ minimumPaymentAmount })
            await expectToThrowGQLError(async () => {
                await registerMultiPaymentForVirtualReceiptByTestClient(utils.clients.admin, receipt, { id: utils.acquiringContext.id })
            }, {
                ...PAYMENT_AMOUNT_LESS_THAN_MINIMUM,
                messageInterpolation: { minimumPaymentAmount },
            }, 'result')
        })
    })
})
