/**
 * Generated by `createservice acquiring.RegisterMultiPaymentForVirtualReceiptService`
 */

const faker = require('faker')
const dayjs = require('dayjs')

const {
    makeClient,
    makeLoggedInAdminClient,
} = require('@condo/keystone/test.utils')
const {
    AcquiringIntegration,
    registerMultiPaymentForVirtualReceiptByTestClient,
    createTestAcquiringIntegration,
    updateTestAcquiringIntegrationContext,
    makePayer,
    updateTestAcquiringIntegration,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    createTestBillingIntegration,
} = require('@condo/domains/billing/utils/testSchema')
const {
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult,
    catchErrorFrom,
} = require('@condo/keystone/test.utils')
const {
    FEE_CALCULATION_PATH,
    WEB_VIEW_PATH,
    DIRECT_PAYMENT_PATH,
} = require('@condo/domains/acquiring/constants/links')

function generateReceipt (billingAccount) {
    return {
        currencyCode: 'RUB',
        amount: '100.45',
        period: '2022-09-01',
        recipient: {
            routingNumber: '044525256',
            bankAccount: '40702810996180000019',
            accountNumber: billingAccount.number,
        },
    }
}

describe('RegisterMultiPaymentForVirtualReceiptService', () => {
    describe('Execute', () => {
        describe('Staff', () => {
            test('From virtual receipt', async () => {
                const {
                    acquiringContext,
                    acquiringIntegration,
                    billingAccount,
                    admin,
                } = await makePayer()
                const hostUrl = acquiringIntegration.hostUrl
                const receipt = generateReceipt(billingAccount)
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('dv', 1)
                expect(result).toHaveProperty('multiPaymentId')
                expect(result).toHaveProperty('webViewUrl', `${hostUrl}${WEB_VIEW_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('feeCalculationUrl', `${hostUrl}${FEE_CALCULATION_PATH.replace('[id]', result.multiPaymentId)}`)
                expect(result).toHaveProperty('directPaymentUrl', `${hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', result.multiPaymentId)}`)
            })
        })
        test('Anonymous user', async () => {
            const {
                acquiringContext,
                billingAccount,
            } = await makePayer()
            const receipt = generateReceipt(billingAccount)
            const acquiringIntegrationContext = { id: acquiringContext.id }
            const client = await makeClient()
            await expectToThrowAuthenticationError(async () => {
                await registerMultiPaymentForVirtualReceiptByTestClient(client, receipt, acquiringIntegrationContext)
            }, 'result')
        })
        test('Resident user', async () => {
            const {
                acquiringContext,
                client,
                billingAccount,
            } = await makePayer()
            const receipt = generateReceipt(billingAccount)
            const acquiringIntegrationContext = { id: acquiringContext.id }
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerMultiPaymentForVirtualReceiptByTestClient(client, receipt, acquiringIntegrationContext)
            })
        })
    })
    describe('RegisterMultiPaymentForVirtualReceiptService mutation Validations', () => {
        describe('Input checks', () => {
            test('Should check dv (=== 1)', async () => {
                const {
                    acquiringContext,
                    admin,
                    billingAccount,
                } = await makePayer()
                const receipt = generateReceipt(billingAccount)
                const acquiringIntegrationContext = { id: acquiringContext.id }

                await catchErrorFrom(async () => {
                    await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext, { dv: 2 })
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Wrong value for data version number',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForVirtualReceipt',
                            variable: ['data', 'dv'],
                            code: 'BAD_USER_INPUT',
                            type: 'DV_VERSION_MISMATCH',
                            message: 'Wrong value for data version number',
                        },
                    }])
                })
            })
            describe('Should check sender', () => {
                let acquiringIntegrationContext
                let receipt
                let admin
                beforeAll(async () => {
                    const data = await makePayer()
                    receipt = generateReceipt(data.billingAccount)
                    acquiringIntegrationContext = { id: data.acquiringContext.id }
                    admin = data.admin
                })
                const cases = [
                    [2, faker.random.alphaNumeric(8)],
                    [1, faker.random.alphaNumeric(3)],
                    [1, faker.random.alphaNumeric(60)],
                    [1, 'КиРиЛЛиЦА'],
                ]
                test.each(cases)('dv: %p, fingerprint: %p', async (dv, fingerprint) => {
                    const sender = { dv, fingerprint }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext, { sender })
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForVirtualReceipt',
                                variable: ['data', 'sender'],
                                code: 'BAD_USER_INPUT',
                                type: 'WRONG_FORMAT',
                            },
                        }])
                        expect(errors[0].message).toMatch('Invalid format of "sender" field value.')
                        expect(errors[0].extensions.message).toMatch('Invalid format of "sender" field value.')
                    })
                })
            })
        })
        describe('Receipt checks', () => {
            describe('Cannot pay for receipts with negative toPay', () => {
                const cases = ['0.0', '-1', '-50.00', '-0.000000']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const {
                        admin,
                        acquiringContext,
                        billingAccount,
                    } = await makePayer()
                    const receipt = generateReceipt(billingAccount)
                    receipt.amount = toPay
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot pay for Receipt with negative "toPay" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForVirtualReceipt',
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE',
                                message: 'Cannot pay for Receipt with negative "toPay" value',
                            },
                        }])
                    })
                })
            })
            describe('Cannot pay for Receipt with invalid "toPay" value', () => {
                const cases = ['100 000', 'Hello world', '100 dollars', '100$']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const {
                        admin,
                        acquiringContext,
                        billingAccount,
                    } = await makePayer()
                    const receipt = generateReceipt(billingAccount)
                    receipt.amount = toPay
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot pay for Receipt with invalid "toPay" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForVirtualReceipt',
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPT_HAVE_INVALID_TO_PAY_VALUE',
                                message: 'Cannot pay for Receipt with invalid "toPay" value',
                            },
                        }])
                    })
                })
            })
            describe('Cannot pay for Receipt with invalid "currencyCode" value', () => {
                const cases = ['$', 'dollars', 'RU', 'rub']
                test.each(cases)('ToPay currency: %p', async (currencyCode) => {
                    const {
                        admin,
                        acquiringContext,
                        billingAccount,
                    } = await makePayer()
                    const receipt = generateReceipt(billingAccount)
                    receipt.currencyCode = currencyCode
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot pay for Receipt with invalid "currencyCode" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'registerMultiPaymentForVirtualReceipt',
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPT_HAVE_INVALID_CURRENCY_CODE_VALUE',
                                message: 'Cannot pay for Receipt with invalid "currencyCode" value',
                            },
                        }])
                    })
                })
            })
        })
        describe('deletedAt check', () => {
            test('Should not be able to pay for consumer with deleted acquiring context', async () => {
                const {
                    admin,
                    acquiringContext,
                    billingAccount,
                } = await makePayer()
                const receipt = generateReceipt(billingAccount)
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Cannot pay via deleted acquiring integration context',
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForVirtualReceipt',
                            variable: ['data', 'acquiringIntegrationContext', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED',
                            message: 'Cannot pay via deleted acquiring integration context',
                        },
                    }])
                })
            })
            test('Should not be able to pay using deleted acquiring integration', async () => {
                const {
                    admin,
                    acquiringContext,
                    acquiringIntegration,
                    billingAccount,
                } = await makePayer()
                const receipt = generateReceipt(billingAccount)
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await registerMultiPaymentForVirtualReceiptByTestClient(admin, receipt, acquiringIntegrationContext)
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot pay via deleted acquiring integration with id "${acquiringIntegration.id}"`,
                        path: ['result'],
                        extensions: {
                            mutation: 'registerMultiPaymentForVirtualReceipt',
                            variable: ['data', 'acquiringIntegrationContext', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_IS_DELETED',
                            message: 'Cannot pay via deleted acquiring integration with id "{id}"',
                        },
                    }])
                })
            })
        })
    })
    // TODO(savelevMatthew): Remove this test after custom GQL refactoring
    describe('ServerSchema get all should provide enough fields', () => {
        test('AcquiringIntegration', async () => {
            const admin = await makeLoggedInAdminClient()
            const [firstBilling] = await createTestBillingIntegration(admin)
            const [secondBilling] = await createTestBillingIntegration(admin)
            const [acquiring] = await createTestAcquiringIntegration(admin, [firstBilling, secondBilling])
            const [serverObtainedAcquiring] = await AcquiringIntegration.getAll(admin, {
                id: acquiring.id,
            })
            expect(serverObtainedAcquiring).toBeDefined()
            expect(serverObtainedAcquiring).toHaveProperty('id')
            expect(serverObtainedAcquiring).toHaveProperty('canGroupReceipts')
            expect(serverObtainedAcquiring).toHaveProperty('supportedBillingIntegrations')
            expect(serverObtainedAcquiring.supportedBillingIntegrations).toHaveLength(2)
        })
    })
})
