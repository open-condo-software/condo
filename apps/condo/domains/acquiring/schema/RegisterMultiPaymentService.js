/**
 * Generated by `createservice acquiring.RegisterMultiPaymentService`
 */
const Big = require('big.js')
const dayjs = require('dayjs')
const { get, uniq, map } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { getById, find, GQLCustomSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/acquiring/access/RegisterMultiPaymentService')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS, RECEIPTS_ARE_DELETED, RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE,
    ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION, RECEIPTS_HAS_MULTIPLE_CURRENCIES,
    RECEIPT_HAS_DELETED_BILLING_INTEGRATION, BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER,
    BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED, ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING,
    ACQUIRING_INTEGRATION_IS_DELETED, RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION,
    CANNOT_FIND_ALL_BILLING_RECEIPTS, ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
    INVOICES_ARE_NOT_PUBLISHED, INVOICES_FOR_THIRD_USER, INVOICE_CONTEXT_NOT_FINISHED,
    MULTIPAYMENT_RECEIPTS_WITH_INVOICES_FORBIDDEN,
} = require('@condo/domains/acquiring/constants/errors')
const {
    FEE_CALCULATION_PATH,
    WEB_VIEW_PATH,
    DIRECT_PAYMENT_PATH,
    GET_CARD_TOKENS_PATH,
} = require('@condo/domains/acquiring/constants/links')
const { DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY } = require('@condo/domains/acquiring/constants/payment')
// TODO(savelevMatthew): REPLACE WITH SERVER SCHEMAS AFTER GQL REFACTORING
const { freezeBillingReceipt, freezeInvoice } = require('@condo/domains/acquiring/utils/billingFridge')
const { Payment, MultiPayment, AcquiringIntegration, RecurrentPaymentContext } = require('@condo/domains/acquiring/utils/serverSchema')
const {
    getAcquiringIntegrationContextFormula,
    FeeDistribution,
    compactDistributionSettings,
} = require('@condo/domains/acquiring/utils/serverSchema/feeDistribution')
const { getPaymentsSum } = require('@condo/domains/billing/utils/serverSchema')
const { REQUIRED, NOT_UNIQUE, NOT_FOUND, DV_VERSION_MISMATCH } = require('@condo/domains/common/constants/errors')
const { WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const {
    INVOICE_STATUS_PUBLISHED,
    DEFAULT_INVOICE_CURRENCY_CODE,
    ERROR_DIFFERENT_CURRENCY_CODES_FOR_RECEIPTS_AND_INVOICES,
} = require('@condo/domains/marketplace/constants')

const ERRORS = {
    DV_VERSION_MISMATCH: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
    },
    WRONG_SENDER_FORMAT: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value. {details}',
        correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
    },
    MISSING_REQUIRED_INPUT_DATA: {
        mutation: 'registerMultiPayment',
        code: BAD_USER_INPUT,
        type: REQUIRED,
        message: 'Missing required value for "groupedReceipts" field and/or for "invoices" field',
    },
    MISSING_REQUIRED_RECEIPTS_IN_GROUPED_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts'],
        code: BAD_USER_INPUT,
        type: REQUIRED,
        message: 'Each group of receipts should contain at least 1 receipt',
    },
    DUPLICATED_SERVICE_CONSUMER: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'There are some groupedReceipts with same serviceConsumer',
    },
    DUPLICATED_RECEIPT: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts'],
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'Found duplicated receipt ids. Note, each receipt can only occur in single ServiceConsumer per mutation run and cannot be noticed twice',
    },
    DUPLICATED_INVOICE: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'invoices'],
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'Found duplicated invoices.',
    },
    UNPUBLISHED_INVOICE: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'invoices'],
        code: BAD_USER_INPUT,
        type: INVOICES_ARE_NOT_PUBLISHED,
        message: 'Found invoices with not "published" status',
    },
    INVOICES_FOR_THIRD_USER:{
        mutation: 'registerMultiPayment',
        variable: ['data', 'invoices'],
        code: BAD_USER_INPUT,
        type: INVOICES_FOR_THIRD_USER,
        message: 'Found invoices not related to the current user',
    },
    INVOICE_CONTEXT_NOT_FINISHED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'invoices'],
        code: BAD_USER_INPUT,
        type: INVOICE_CONTEXT_NOT_FINISHED,
        message: 'Invoice context is not finished',
    },
    MISSING_SERVICE_CONSUMERS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find specified ServiceConsumers with following ids: {ids}',
    },
    DELETED_CONSUMERS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Some of specified ServiceConsumers with ids {ids} were deleted, so you cannot pay for them anymore',
    },
    DELETED_INVOICES: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'invoices'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Some of specified invoices with ids {ids} were deleted, so you cannot pay for them anymore',
    },
    ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING,
        message: 'ServiceConsumers with ids {ids} does not have AcquiringIntegrationContext',
    },
    ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
        message: 'Some ServiceConsumers has deleted AcquiringIntegrationContext',
    },
    MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS,
        message: 'Listed serviceConsumers are linked to different acquiring integrations',
    },
    ACQUIRING_INTEGRATION_IS_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_IS_DELETED,
        message: 'Cannot pay via deleted acquiring integration with id "{id}"',
    },
    RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION,
        message: 'Receipts cannot be grouped by AcquiringIntegration with id "{id}", because a value of "canGroupReceipts" field is false',
    },
    CANNOT_FIND_ALL_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: CANNOT_FIND_ALL_BILLING_RECEIPTS,
        message: 'Cannot find all specified BillingReceipts with ids {missingReceiptIds}',
    },
    RECEIPTS_ARE_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_ARE_DELETED,
        message: 'Cannot pay for deleted receipts {ids}',
    },
    RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE,
        message: 'Cannot pay for BillingReceipts {ids} with negative "toPay" value',
    },
    RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER
        ,
        message: 'BillingReceipt with id "{receiptId}" does not have common BillingAccount with specified ServiceConsumer with id "{serviceConsumerId}"',
    },
    BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
        message: 'BillingIntegrationOrganizationContext is deleted for some BillingReceipts',
    },
    ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
        message: 'Some of ServiceConsumer\'s AcquiringIntegration does not supports following BillingReceipt\'s BillingIntegrations: {unsupportedBillingIntegrations}',
    },
    RECEIPT_HAS_DELETED_BILLING_INTEGRATION: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPT_HAS_DELETED_BILLING_INTEGRATION,
        message: 'BillingReceipt has deleted BillingIntegration',
    },
    RECEIPTS_HAS_MULTIPLE_CURRENCIES: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_HAS_MULTIPLE_CURRENCIES,
        message: 'BillingReceipts has multiple currencies',
    },
    RECURRENT_PAYMENT_CONTEXT_IS_MISSING: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'recurrentPaymentContext', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find specified RecurrentPaymentContext with following id: {id}',
    },
    RECURRENT_PAYMENT_CONTEXT_IS_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'recurrentPaymentContext', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'RecurrentPaymentContext with following id: {id} is deleted',
    },
    DIFFERENT_CURRENCY_CODES_FOR_RECEIPTS_AND_INVOICES: {
        mutation: 'registerMultiPayment',
        variable: ['data'],
        code: BAD_USER_INPUT,
        type: ERROR_DIFFERENT_CURRENCY_CODES_FOR_RECEIPTS_AND_INVOICES,
        message: 'Receipts and invoices has different currency codes',
    },
    RECEIPTS_WITH_INVOICES_FORBIDDEN: {
        code: BAD_USER_INPUT,
        type: MULTIPAYMENT_RECEIPTS_WITH_INVOICES_FORBIDDEN,
        message: 'Receipts and invoices are forbidden to be together',
        messageForUser: 'api.acquiring.multiPayment.error.receiptsWithInvoices',
    },
}


const RegisterMultiPaymentService = new GQLCustomSchema('RegisterMultiPaymentService', {
    types: [
        {
            access: true,
            type: 'input RegisterMultiPaymentServiceConsumerInput { serviceConsumer: ServiceConsumerWhereUniqueInput!, receipts: [BillingReceiptWhereUniqueInput!]! }',
        },
        {
            access: true,
            type: 'input RegisterMultiPaymentInput { dv: Int!, sender: SenderFieldInput!, groupedReceipts: [RegisterMultiPaymentServiceConsumerInput!], recurrentPaymentContext: RecurrentPaymentContextWhereUniqueInput, invoices: [InvoiceWhereUniqueInput!] }',
        },
        {
            access: true,
            type: 'type RegisterMultiPaymentOutput { dv: Int!, multiPaymentId: String!, webViewUrl: String!, feeCalculationUrl: String!, directPaymentUrl: String!, getCardTokensUrl: String! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterMultiPayment,
            schema: 'registerMultiPayment(data: RegisterMultiPaymentInput!): RegisterMultiPaymentOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const {
                    sender,
                    recurrentPaymentContext,
                } = data

                const groupedReceipts = get(data, 'groupedReceipts', []) || []
                const invoices = get(data, 'invoices', []) || []

                // Stage 0. Check if input is valid
                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                if (!get(groupedReceipts, 'length') && !get(invoices, 'length')) {
                    throw new GQLError(ERRORS.MISSING_REQUIRED_INPUT_DATA, context)
                }

                if (!!groupedReceipts && groupedReceipts.some(group => !get(group, ['receipts', 'length']))) {
                    throw new GQLError(ERRORS.MISSING_REQUIRED_RECEIPTS_IN_GROUPED_RECEIPTS, context)
                }

                // Stage 0.1: Duplicates check
                const consumersIds = groupedReceipts.map(group => group.serviceConsumer.id)
                const uniqueConsumerIds = new Set(consumersIds)
                if (consumersIds.length !== uniqueConsumerIds.size) {
                    throw new GQLError(ERRORS.DUPLICATED_SERVICE_CONSUMER, context)
                }
                const receiptsIds = groupedReceipts
                    .flatMap(group => group['receipts'])
                    .map(receiptInfo => receiptInfo.id)
                const uniqueReceiptsIds = new Set(receiptsIds)
                if (receiptsIds.length !== uniqueReceiptsIds.size) {
                    throw new GQLError(ERRORS.DUPLICATED_RECEIPT, context)
                }

                if (invoices.length > 0 && invoices.length !== uniq(map(invoices, 'id')).length) {
                    throw new GQLError(ERRORS.DUPLICATED_INVOICE, context)
                }

                // Stage 1. Check Acquiring
                const consumers = await find('ServiceConsumer', {
                    id_in: consumersIds,
                })
                if (consumers.length !== consumersIds.length) {
                    const existingConsumerIds = consumers.map(consumer => consumer.id)
                    const missingConsumerIds = consumersIds.filter(consumerId => !existingConsumerIds.includes(consumerId))
                    throw new GQLError({ ...ERRORS.MISSING_SERVICE_CONSUMERS, messageInterpolation: { ids: missingConsumerIds.join(', ') } }, context)
                }
                const deletedConsumersIds = consumers.filter(consumer => consumer.deletedAt).map(consumer => consumer.id)
                if (deletedConsumersIds.length) {
                    throw new GQLError({ ...ERRORS.DELETED_CONSUMERS, messageInterpolation: { ids: deletedConsumersIds.join(', ') } }, context)
                }
                const contextMissingConsumers = consumers
                    .filter(consumer => !get(consumer, 'acquiringIntegrationContext'))
                    .map(consumer => consumer.id)
                if (contextMissingConsumers.length) {
                    throw new GQLError({ ...ERRORS.ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING, messageInterpolation: { ids: contextMissingConsumers.join(', ') } }, context)
                }

                const consumersByIds = Object.assign({}, ...consumers.map(obj => ({ [obj.id]: obj })))

                const uniqueAcquiringContextsIds = new Set(consumers.map(consumer => consumer.acquiringIntegrationContext))

                const foundInvoices = await find('Invoice', { id_in: uniq(map(invoices, 'id')) })

                const deletedInvoicesIds = foundInvoices.filter(({ deletedAt }) => !!deletedAt).map(({ id }) => id)
                if (deletedInvoicesIds.length) {
                    // All invoices must be not deleted
                    throw new GQLError({
                        ...ERRORS.DELETED_INVOICES,
                        messageInterpolation: { ids: deletedInvoicesIds.join(',') },
                    }, context)
                }

                const acquiringContexts = await find('AcquiringIntegrationContext', {
                    OR: [
                        { id_in: Array.from(uniqueAcquiringContextsIds) },
                        { organization: { id_in: uniq(map(foundInvoices, 'organization')) } },
                    ],
                })

                const deletedAcquiringContextsIds = new Set(acquiringContexts.filter(context => context.deletedAt).map(context => context.id))
                if (deletedAcquiringContextsIds.size) {
                    const failedConsumers = consumers
                        .filter(consumer => deletedAcquiringContextsIds.has(consumer.acquiringIntegrationContext))
                        .map(consumer => ({ consumerId: consumer.id, acquiringContextId: consumer.acquiringIntegrationContext }))
                    throw new GQLError({ ...ERRORS.ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED, data: { failedConsumers } }, context)
                }

                const acquiringContextsByIds = Object.assign({}, ...acquiringContexts.map(obj => ({ [obj.id]: obj })))

                const acquiringIntegrations = new Set([
                    ...acquiringContexts.map(context => context.integration),
                ])

                if (acquiringIntegrations.size > 1) {
                    throw new GQLError(ERRORS.MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS, context)
                }

                // NOTE: Here using serverSchema to get many relation
                const [acquiringIntegration] = await AcquiringIntegration.getAll(context, {
                    id: Array.from(acquiringIntegrations)[0],
                })
                if (acquiringIntegration.deletedAt) {
                    throw new GQLError({ ...ERRORS.ACQUIRING_INTEGRATION_IS_DELETED, messageInterpolation: { id: acquiringIntegration.id } }, context)
                }

                // TODO (savelevMatthew): check that all receipts linked to right consumers?
                // Stage 2. Check BillingReceipts
                if (receiptsIds.length > 1 && !acquiringIntegration.canGroupReceipts) {
                    throw new GQLError({ ...ERRORS.RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION, messageInterpolation: { id: acquiringIntegration.id } }, context)
                }
                const receipts = await find('BillingReceipt', {
                    id_in: receiptsIds,
                })
                if (receipts.length !== receiptsIds.length) {
                    const existingReceiptsIds = new Set(receipts.map(receipt => receipt.id))
                    const missingReceipts = receiptsIds.filter(receiptId => !existingReceiptsIds.has(receiptId))
                    throw new GQLError({ ...ERRORS.CANNOT_FIND_ALL_RECEIPTS, messageInterpolation: { missingReceiptIds: missingReceipts.join(', ') } }, context)
                }

                const deletedReceiptsIds = receipts.filter(receipt => Boolean(receipt.deletedAt)).map(receipt => receipt.id)
                if (deletedReceiptsIds.length) {
                    throw new GQLError({ ...ERRORS.RECEIPTS_ARE_DELETED, messageInterpolation: { ids: deletedReceiptsIds.join(', ') } }, context)
                }

                const negativeReceiptsIds = receipts
                    .filter(receipt => Big(receipt.toPay).lte(0))
                    .map(receipt => receipt.id)
                if (negativeReceiptsIds.length) {
                    throw new GQLError({ ...ERRORS.RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE, messageInterpolation: { ids: negativeReceiptsIds.join(', ') } }, context)
                }

                const receiptsByIds = Object.assign({}, ...receipts.map(obj => ({ [obj.id]: obj })))

                const uniqueBillingContextsIds = new Set(receipts.map(receipt => receipt.context))
                const billingContexts = await find('BillingIntegrationOrganizationContext', {
                    id_in: Array.from(uniqueBillingContextsIds),
                })
                const billingContextsById = Object.assign({}, ...billingContexts.map(obj => ({ [obj.id]: obj })))
                const deletedBillingContextsIds = new Set(billingContexts.filter(context => context.deletedAt).map(context => context.id))
                if (deletedBillingContextsIds.size) {
                    const failedReceipts = receipts
                        .filter(receipt => deletedBillingContextsIds.has(receipt.context))
                        .map(receipt => ({ receiptId: receipt.id, contextId: receipt.context }))
                    throw new GQLError({ ...ERRORS.BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED, data: { failedReceipts } }, context)
                }

                const supportedBillingIntegrationsGroup = get(acquiringIntegration, 'supportedBillingIntegrationsGroup')
                const uniqueBillingIntegrationsIds = new Set(billingContexts.map(context => context.integration))
                const uniqueBillingIntegrations = await find('BillingIntegration', {
                    id_in: Array.from(uniqueBillingIntegrationsIds),
                })

                const unsupportedBillings = Array.from(uniqueBillingIntegrations).filter(integration => integration.group !== supportedBillingIntegrationsGroup)
                if (unsupportedBillings.length) {
                    throw new GQLError({ ...ERRORS.ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION, messageInterpolation: { unsupportedBillingIntegrations:  unsupportedBillings.map(billing => billing.id).join(', ') } }, context)
                }

                const deletedBillingIntegrationsIds = new Set(uniqueBillingIntegrations.filter(integration => integration.deletedAt).map(integration => integration.id))
                if (deletedBillingIntegrationsIds.size) {
                    const failedReceipts = receipts
                        .filter(receipt => deletedBillingIntegrationsIds.has(billingContextsById[receipt.context].integration))
                        .map(receipt => ({ receiptId: receipt.id, integrationId: billingContextsById[receipt.context].integration }))
                    throw new GQLError({ ...ERRORS.RECEIPT_HAS_DELETED_BILLING_INTEGRATION, data: { failedReceipts } }, context)
                }

                if (receipts.length > 0 && foundInvoices.length > 0) {
                    throw new GQLError(ERRORS.RECEIPTS_WITH_INVOICES_FORBIDDEN, context)
                }

                // "consumer-id" -> [array of billing integration contexts that are linked thorough organization to this consumer]
                const billingIntegrationContextsByConsumer = {}
                for (const group of groupedReceipts) {
                    for (const receiptInfo of group['receipts']) {
                        const receipt = receiptsByIds[receiptInfo.id]

                        const billingAccountId = receipt.account
                        const billingAccount = await getById('BillingAccount', billingAccountId)

                        const consumer = consumersByIds[group.serviceConsumer.id]
                        if (!billingIntegrationContextsByConsumer[consumer.id]) {
                            const allBillingContextsForConsumer = await find('BillingIntegrationOrganizationContext', { deletedAt: null, organization: { id: consumer.organization } })
                            billingIntegrationContextsByConsumer[consumer.id] = allBillingContextsForConsumer.map(x => x.id)
                        }

                        if (
                            billingAccount.number !== consumer.accountNumber
                            || (!billingIntegrationContextsByConsumer[consumer.id].includes(billingAccount.context))
                        ) {
                            throw new GQLError({
                                ...ERRORS.RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER,
                                messageInterpolation: {
                                    receiptId: receiptInfo.id,
                                    serviceConsumerId: group.serviceConsumer.id,
                                },
                            }, context)
                        }
                    }
                }

                const currencies = new Set(uniqueBillingIntegrations.map(integration => integration.currencyCode))
                if (currencies.size > 1) {
                    throw new GQLError(ERRORS.RECEIPTS_HAS_MULTIPLE_CURRENCIES, context)
                }
                const billingIntegrationCurrencyCode = get(uniqueBillingIntegrations, ['0', 'currencyCode'])

                // check recurrentPaymentContext if provided
                if (recurrentPaymentContext) {
                    const { id: recurrentPaymentContextId } = recurrentPaymentContext

                    const recurrentContexts = await RecurrentPaymentContext.getAll(context, {
                        id: recurrentPaymentContextId,
                    })

                    if (recurrentContexts.length === 0) {
                        throw new GQLError({
                            ...ERRORS.RECURRENT_PAYMENT_CONTEXT_IS_MISSING,
                            messageInterpolation: { id: recurrentPaymentContextId },
                        }, context)
                    }
                    const [recurrentContext] = recurrentContexts

                    if (recurrentContext.deletedAt) {
                        throw new GQLError({
                            ...ERRORS.RECURRENT_PAYMENT_CONTEXT_IS_DELETED,
                            messageInterpolation: { id: recurrentPaymentContextId },
                        }, context)
                    }
                }

                // Stage 3 Generating payments
                const payments = []
                for (const group of groupedReceipts) {
                    const serviceConsumer = consumersByIds[group.serviceConsumer.id]
                    const acquiringContext = acquiringContextsByIds[serviceConsumer.acquiringIntegrationContext]
                    const formula = await getAcquiringIntegrationContextFormula(context, serviceConsumer.acquiringIntegrationContext)
                    for (const receiptInfo of group['receipts']) {
                        const receipt = receiptsByIds[receiptInfo.id]
                        const billingCategoryId = get(receipt, 'category')
                        const frozenReceipt = await freezeBillingReceipt(receipt)
                        const billingAccountNumber = get(frozenReceipt, ['data', 'account', 'number'])
                        const feeCalculator = new FeeDistribution(formula, billingCategoryId)
                        const organizationId = get(frozenReceipt, ['data', 'organization', 'id'])
                        const period = get(frozenReceipt, ['data', 'period'])
                        const routingNumber = get(frozenReceipt, ['data', 'recipient', 'bic'])
                        const bankAccount = get(frozenReceipt, ['data', 'recipient', 'bankAccount'])

                        const paidAmount = await getPaymentsSum(context, organizationId, billingAccountNumber, period, routingNumber, bankAccount)
                        const amount = String(Big(receipt.toPay).minus(Big(paidAmount)))

                        const { type, explicitFee = '0', implicitFee = '0', fromReceiptAmountFee = '0' } = feeCalculator.calculate(amount)

                        const paymentCommissionFields = {
                            ...type === 'service' ? {
                                explicitServiceCharge: String(explicitFee),
                                explicitFee: '0',
                            } : {
                                explicitServiceCharge: '0',
                                explicitFee: String(explicitFee),
                            },
                            implicitFee: String(implicitFee),
                            serviceFee: String(fromReceiptAmountFee),
                        }
                        const payment = await Payment.create(context, {
                            dv: 1,
                            sender,
                            amount: amount,
                            currencyCode: billingIntegrationCurrencyCode,
                            accountNumber: billingAccountNumber,
                            period: receipt.period,
                            receipt: { connect: { id: receiptInfo.id } },
                            frozenReceipt,
                            context: { connect: { id: acquiringContext.id } },
                            organization: { connect: { id: acquiringContext.organization } },
                            recipientBic: receipt.recipient.bic,
                            recipientBankAccount: receipt.recipient.bankAccount,
                            ...paymentCommissionFields,
                        })
                        payments.push({ ...payment, serviceFee: paymentCommissionFields.serviceFee })
                    }
                }

                // Processing of invoices if provided
                const invoiceIntegrationCurrencyCode = DEFAULT_INVOICE_CURRENCY_CODE
                if (foundInvoices.length > 0) {
                    // All invoices must be published
                    if (foundInvoices.some(({ status }) => status !== INVOICE_STATUS_PUBLISHED)) {
                        throw new GQLError(ERRORS.UNPUBLISHED_INVOICE, context)
                    }

                    // All invoices with client must be related to the current user
                    if (foundInvoices.some(({ client }) => !!client && client !== context.authedItem.id)) {
                        throw new GQLError(ERRORS.INVOICES_FOR_THIRD_USER, context)
                    }

                    // All acquiring contexts must be finished
                    if (acquiringContexts.some(({ invoiceStatus }) => invoiceStatus !== CONTEXT_FINISHED_STATUS)) {
                        throw new GQLError(ERRORS.INVOICE_CONTEXT_NOT_FINISHED, context)
                    }

                    if (
                        !!billingIntegrationCurrencyCode && !!invoiceIntegrationCurrencyCode
                        && billingIntegrationCurrencyCode !== invoiceIntegrationCurrencyCode
                    ) {
                        throw new GQLError(ERRORS.DIFFERENT_CURRENCY_CODES_FOR_RECEIPTS_AND_INVOICES, context)
                    }

                    const acquiringContext = acquiringContexts[0]
                    const acquiringIntegration = await getById('AcquiringIntegration', acquiringContext.integration)

                    for (const invoice of foundInvoices){
                        const frozenInvoice = await freezeInvoice(invoice)
                        const feeCalculator = new FeeDistribution(compactDistributionSettings([
                            ...acquiringIntegration.explicitFeeDistributionSchema,
                            ...acquiringContext.invoiceImplicitFeeDistributionSchema,
                        ]))
                        const organizationId = get(frozenInvoice, ['data', 'organization', 'id'])
                        const routingNumber = get(acquiringContext, ['invoiceRecipient', 'bic'])
                        const bankAccount = get(acquiringContext, ['invoiceRecipient', 'bankAccount'])

                        const amount = String(Big(invoice.toPay))

                        const { type, explicitFee = '0', implicitFee = '0', fromReceiptAmountFee = '0' } = feeCalculator.calculate(amount)

                        const paymentCommissionFields = {
                            ...type === 'service' ? {
                                explicitServiceCharge: String(explicitFee),
                                explicitFee: '0',
                            } : {
                                explicitServiceCharge: '0',
                                explicitFee: String(explicitFee),
                            },
                            implicitFee: String(implicitFee),
                            serviceFee: String(fromReceiptAmountFee),
                        }

                        const payment = await Payment.create(context, {
                            dv: 1,
                            sender,
                            amount: amount,
                            context: { connect : { id: acquiringContext.id } },
                            currencyCode: DEFAULT_INVOICE_CURRENCY_CODE,
                            invoice: { connect: { id: invoice.id } },
                            frozenInvoice,
                            period: dayjs().format('YYYY-MM-01'),
                            organization: { connect: { id: organizationId } },
                            recipientBic: routingNumber,
                            recipientBankAccount: bankAccount,
                            ...paymentCommissionFields,
                        })

                        payments.push({ ...payment, serviceFee: paymentCommissionFields.serviceFee })
                    }
                }

                const currencyCode = billingIntegrationCurrencyCode || invoiceIntegrationCurrencyCode

                const paymentIds = payments.map(payment => ({ id: payment.id }))
                const totalAmount = payments.reduce((acc, cur) => {
                    return {
                        amountWithoutExplicitFee: acc.amountWithoutExplicitFee.plus(Big(cur.amount)),
                        explicitFee: acc.explicitFee.plus(Big(cur.explicitFee)),
                        explicitServiceCharge: acc.explicitServiceCharge.plus(Big(cur.explicitServiceCharge)),
                        serviceFee: acc.serviceFee.plus(Big(cur.serviceFee)),
                        implicitFee: acc.implicitFee.plus(Big(cur.implicitFee)),
                    }
                }, {
                    amountWithoutExplicitFee: Big('0.0'),
                    explicitFee: Big('0.0'),
                    explicitServiceCharge: Big('0.0'),
                    serviceFee: Big('0.0'),
                    implicitFee: Big('0.0'),
                })
                const recurrentPaymentContextField = recurrentPaymentContext ? {
                    recurrentPaymentContext: { connect: { id: recurrentPaymentContext.id } },
                } : {}
                const multiPayment = await MultiPayment.create(context, {
                    dv: 1,
                    sender,
                    ...Object.fromEntries(Object.entries(totalAmount).map(([key, value]) => ([key, value.toFixed(2)]))),
                    currencyCode,
                    user: { connect: { id: context.authedItem.id } },
                    integration: { connect: { id: acquiringIntegration.id } },
                    payments: { connect: paymentIds },
                    // TODO(DOMA-1574): add correct category
                    serviceCategory: DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY,
                    ...recurrentPaymentContextField,
                })
                return {
                    dv: 1,
                    multiPaymentId: multiPayment.id,
                    webViewUrl: `${acquiringIntegration.hostUrl}${WEB_VIEW_PATH.replace('[id]', multiPayment.id)}`,
                    feeCalculationUrl: `${acquiringIntegration.hostUrl}${FEE_CALCULATION_PATH.replace('[id]', multiPayment.id)}`,
                    directPaymentUrl: `${acquiringIntegration.hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', multiPayment.id)}`,
                    getCardTokensUrl: `${acquiringIntegration.hostUrl}${GET_CARD_TOKENS_PATH.replace('[id]', context.authedItem.id)}`,
                }
            },
        },
    ],

})

module.exports = {
    RegisterMultiPaymentService,
}
