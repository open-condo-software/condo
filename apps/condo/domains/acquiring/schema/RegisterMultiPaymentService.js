/**
 * Generated by `createservice acquiring.RegisterMultiPaymentService`
 */

const { getById } = require('@core/keystone/schema')

const { GQLCustomSchema } = require('@core/keystone/schema')
const access = require('@condo/domains/acquiring/access/RegisterMultiPaymentService')
const { DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY } = require('@condo/domains/acquiring/constants/payment')
const {
    FEE_CALCULATION_PATH,
    WEB_VIEW_PATH,
    DIRECT_PAYMENT_PATH,
    GET_CARD_TOKENS_PATH,
} = require('@condo/domains/acquiring/constants/links')
const { JSON_STRUCTURE_FIELDS_CONSTRAINTS } = require('@condo/domains/common/utils/validation.utils')
// TODO(savelevMatthew): REPLACE WITH SERVER SCHEMAS AFTER GQL REFACTORING
const { find } = require('@core/keystone/schema')
const { Payment, MultiPayment, AcquiringIntegration } = require('@condo/domains/acquiring/utils/serverSchema')
const { getAcquiringIntegrationContextFormula, FeeDistribution } = require('@condo/domains/acquiring/utils/serverSchema/feeDistribution')
const { freezeBillingReceipt } = require('@condo/domains/acquiring/utils/freezeBillingReceipt')
const get = require('lodash/get')
const Big = require('big.js')
const validate = require('validate.js')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@core/keystone/errors')
const { REQUIRED, NOT_UNIQUE, NOT_FOUND, DV_VERSION_MISMATCH } = require('@condo/domains/common/constants/errors')
const { WRONG_FORMAT } = require('../../common/constants/errors')
const { MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS, RECEIPTS_ARE_DELETED, RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE,
    ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION, RECEIPTS_HAS_MULTIPLE_CURRENCIES,
    RECEIPT_HAS_DELETED_BILLING_INTEGRATION, BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER,
    BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED, ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING,
    ACQUIRING_INTEGRATION_IS_DELETED, RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION,
    CANNOT_FIND_ALL_BILLING_RECEIPTS, ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
} = require('../constants/errors')

const errors = {
    DV_VERSION_MISMATCH: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
    },
    WRONG_SENDER_FORMAT: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value. {details}',
        correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
    },
    MISSING_REQUIRED_GROUPED_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts'],
        code: BAD_USER_INPUT,
        type: REQUIRED,
        message: 'Missing required value for "groupedReceipts" field',
    },
    /**
     * @deprecated use MISSING_REQUIRED_BILLING_RECEIPTS_IN_GROUPED_RECEIPTS
     */
    MISSING_REQUIRED_RECEIPTS_IN_GROUPED_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts'],
        code: BAD_USER_INPUT,
        type: REQUIRED,
        message: 'Each group of receipts should contain at least 1 receipt',
    },
    MISSING_REQUIRED_BILLING_RECEIPTS_IN_GROUPED_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts'],
        code: BAD_USER_INPUT,
        type: REQUIRED,
        message: 'Each group of billingReceipts should contain at least 1 billingReceipt',
    },
    // (signature change) temporarily
    MISSING_REQUIRED_SERVICE_CONSUMER_IN_GROUPED_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer'],
        code: BAD_USER_INPUT,
        type: REQUIRED,
        message: 'Each group of receipts should contain serviceConsumer',
    },
    // (signature change) temporarily
    MISSING_REQUIRED_CONSUMER_ID_IN_GROUPED_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
        code: BAD_USER_INPUT,
        type: REQUIRED,
        message: 'Each group of receipts should contain consumerId',
    },
    /**
     * @deprecated use DUPLICATED_SERVICE_CONSUMER
     */
    DUPLICATED_CONSUMER: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'There are some groupedReceipts with same consumerId',
    },
    DUPLICATED_SERVICE_CONSUMER: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'There are some groupedReceipts with same serviceConsumer',
    },
    /**
     * @deprecated use DUPLICATED_BILLING_RECEIPT
     */
    DUPLICATED_RECEIPT: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts'],
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'Found duplicated receipt ids. Note, each receipt can only occur in single ServiceConsumer per mutation run and cannot be noticed twice',
    },
    DUPLICATED_BILLING_RECEIPT: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts'],
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'Found duplicated billingReceipts ids. Note, each billingReceipt can only occur in single ServiceConsumer per mutation run and cannot be noticed twice',
    },
    /**
     * @deprecated use MISSING_SERVICE_CONSUMERS
     */
    MISSING_CONSUMERS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find specified ServiceConsumers with following ids: {ids}',
    },
    MISSING_SERVICE_CONSUMERS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find specified ServiceConsumers with following ids: {ids}',
    },
    /**
     * @deprecated use DELETED_CONSUMERS
     */
    DELETED_CONSUMER_IDS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Some of specified ServiceConsumers with ids {ids} were deleted, so you cannot pay for them anymore',
    },
    DELETED_CONSUMERS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Some of specified ServiceConsumers with ids {ids} were deleted, so you cannot pay for them anymore',
    },
    /**
     * @deprecated use ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING
     */
    ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING_FOR_CONSUMER_ID: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING,
        message: 'ServiceConsumers with ids {ids} does not have AcquiringIntegrationContext',
    },
    ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING,
        message: 'ServiceConsumers with ids {ids} does not have AcquiringIntegrationContext',
    },
    /**
     * @deprecated use ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED
     */
    ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED_FOR_CONSUMER_ID: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
        message: 'Some ServiceConsumers has deleted AcquiringIntegrationContext',
    },
    ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
        message: 'Some ServiceConsumers has deleted AcquiringIntegrationContext',
    },
    /**
     * @deprecated use MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS
     */
    MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS_FOR_CONSUMER_ID: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
        code: BAD_USER_INPUT,
        type: MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS,
        message: 'Listed consumerIds are linked to different acquiring integrations',
    },
    MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS,
        message: 'Listed serviceConsumers are linked to different acquiring integrations',
    },
    /**
     * @deprecated use ACQUIRING_INTEGRATION_IS_DELETED
     */
    ACQUIRING_INTEGRATION_IS_DELETED_FOR_CONSUMER_IF: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_IS_DELETED,
        message: 'Cannot pay via deleted acquiring integration with id "{id}"',
    },
    ACQUIRING_INTEGRATION_IS_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_IS_DELETED,
        message: 'Cannot pay via deleted acquiring integration with id "{id}"',
    },
    /**
     * @deprecated use RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION
     */
    RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION_FOR_CONSUMER_ID: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'consumerId'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION,
        message: 'Receipts cannot be grouped by AcquiringIntegration with id "{id}", because a value of "canGroupReceipts" field is false',
    },
    RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'serviceConsumer', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION,
        message: 'Receipts cannot be grouped by AcquiringIntegration with id "{id}", because a value of "canGroupReceipts" field is false',
    },
    CANNOT_FIND_ALL_BILLING_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: CANNOT_FIND_ALL_BILLING_RECEIPTS,
        message: 'Cannot find all specified BillingReceipts with ids {missingReceiptIds}',
    },
    /**
     * @deprecated use CANNOT_FIND_ALL_BILLING_RECEIPTS
     */
    CANNOT_FIND_ALL_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: CANNOT_FIND_ALL_BILLING_RECEIPTS,
        message: 'Cannot find all specified BillingReceipts with ids {missingReceiptIds}',
    },
    /**
     * @deprecated use BILLING_RECEIPTS_ARE_DELETED
     */
    RECEIPTS_ARE_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_ARE_DELETED,
        message: 'Cannot pay for deleted receipts {ids}',
    },
    BILLING_RECEIPTS_ARE_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_ARE_DELETED,
        message: 'Cannot pay for deleted billingReceipts {ids}',
    },
    /**
     * @deprecated use BILLING_RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE
     */
    RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE,
        message: 'Cannot pay for BillingReceipts {ids} with negative "toPay" value',
    },
    BILLING_RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE,
        message: 'Cannot pay for BillingReceipts {ids} with negative "toPay" value',
    },
    /**
     * @deprecated use BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER
     */
    RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER
        ,
        message: 'BillingReceipt with id "{receiptId}" does not have common BillingAccount with specified ServiceConsumer with id "{serviceConsumerId}"',
    },
    BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER
        ,
        message: 'BillingReceipt with id "{receiptId}" does not have common BillingAccount with specified ServiceConsumer with id "{serviceConsumerId}"',
    },
    /**
     * @deprecated use BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED
     */
    BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED_FOR_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
        message: 'BillingIntegrationOrganizationContext is deleted for some BillingReceipts',
    },
    BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
        message: 'BillingIntegrationOrganizationContext is deleted for some BillingReceipts',
    },
    /**
     * @deprecated use ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION
     */
    ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION_FOR_RECEIPTS: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
        message: 'Some of ServiceConsumer\'s AcquiringIntegration does not supports following BillingReceipt\'s BillingIntegrations: {unsupportedBillingIntegrations}',
    },
    ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
        message: 'Some of ServiceConsumer\'s AcquiringIntegration does not supports following BillingReceipt\'s BillingIntegrations: {unsupportedBillingIntegrations}',
    },
    /**
     * @deprecated use BILLING_RECEIPT_HAS_DELETED_BILLING_INTEGRATION
     */
    RECEIPT_HAS_DELETED_BILLING_INTEGRATION: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPT_HAS_DELETED_BILLING_INTEGRATION,
        message: 'BillingReceipt has deleted BillingIntegration',
    },
    BILLING_RECEIPT_HAS_DELETED_BILLING_INTEGRATION: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPT_HAS_DELETED_BILLING_INTEGRATION,
        message: 'BillingReceipt has deleted BillingIntegration',
    },
    /**
     * @deprecated use BILLING_RECEIPTS_HAS_MULTIPLE_CURRENCIES
     */
    RECEIPTS_HAS_MULTIPLE_CURRENCIES: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'receipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_HAS_MULTIPLE_CURRENCIES,
        message: 'BillingReceipts has multiple currencies',
    },
    BILLING_RECEIPTS_HAS_MULTIPLE_CURRENCIES: {
        mutation: 'registerMultiPayment',
        variable: ['data', 'groupedReceipts', '[]', 'billingReceipts', '[]', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPTS_HAS_MULTIPLE_CURRENCIES,
        message: 'BillingReceipts has multiple currencies',
    },
}


const SENDER_FIELD_CONSTRAINTS = {
    ...JSON_STRUCTURE_FIELDS_CONSTRAINTS,
    dv: {
        numericality: {
            noStrings: true,
            equalTo: 1,
        },
    },
}

// TODO find "(signature change)" comments & when the transition of the mobile application to the new signature is completed, delete the logic the old signature and the old signature itself
const RegisterMultiPaymentService = new GQLCustomSchema('RegisterMultiPaymentService', {
    types: [
        {
            access: true,
            type: 'input RegisterMultiPaymentReceiptInfoInput { id: String! }',
        },
        {
            access: true,
            type: 'input RegisterMultiPaymentServiceConsumerInput { consumerId: String @deprecated(reason: "consumerId is deprecated, use serviceConsumer instead."), """consumerId is deprecated, use serviceConsumer instead. Required field (in future)""" serviceConsumer: ServiceConsumerWhereUniqueInput, receipts: [RegisterMultiPaymentReceiptInfoInput!] @deprecated(reason: "receipts is deprecated, use billingReceipts instead."), """receipts is deprecated, use billingReceipts instead. Required field (in future)""" billingReceipts: [BillingReceiptWhereUniqueInput!] }',
        },
        {
            access: true,
            type: 'input RegisterMultiPaymentInput { dv: Int!, sender: SenderFieldInput!, groupedReceipts: [RegisterMultiPaymentServiceConsumerInput!]! }',
        },
        {
            access: true,
            type: 'type RegisterMultiPaymentOutput { dv: Int!, multiPaymentId: String!, webViewUrl: String!, feeCalculationUrl: String!, directPaymentUrl: String!, getCardTokensUrl: String! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterMultiPayment,
            schema: 'registerMultiPayment(data: RegisterMultiPaymentInput!): RegisterMultiPaymentOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { dv, sender, groupedReceipts } = data

                // Stage 0. Check if input is valid
                if (dv !== 1) {
                    throw new GQLError(errors.DV_VERSION_MISMATCH, context)
                }

                const senderErrors = validate(sender, SENDER_FIELD_CONSTRAINTS)
                if (senderErrors && Object.keys(senderErrors).length) {
                    const details = Object.keys(senderErrors).map(field => {
                        return `${field}: [${senderErrors[field].map(error => `'${error}'`).join(', ')}]`
                    }).join(', ')
                    throw new GQLError({ ...errors.WRONG_SENDER_FORMAT, messageInterpolation: { details } }, context)
                }

                if (!get(groupedReceipts, 'length')) {
                    throw new GQLError(errors.MISSING_REQUIRED_GROUPED_RECEIPTS, context)
                }

                // (signature change) in the future, you need to remove these two keys
                // and replace all places where they occur with billingReceipts & serviceConsumer
                const billingReceiptsKey = groupedReceipts.some(group => get(group, ['billingReceipts']))
                    ? 'billingReceipts'
                    : groupedReceipts.some(group => get(group, ['receipts']))
                        ? 'receipts'
                        : 'billingReceipts'
                const serviceConsumerKey = groupedReceipts.some(group => get(group, ['serviceConsumer']))
                    ? 'serviceConsumer'
                    : groupedReceipts.some(group => get(group, ['consumerId']))
                        ? 'consumerId'
                        : 'serviceConsumer'

                if (groupedReceipts.some(group => !get(group, [billingReceiptsKey, 'length']))) {
                    // (signature change) remove the condition and remove the deprecated error
                    if (billingReceiptsKey === 'billingReceipts') {
                        throw new GQLError(errors.MISSING_REQUIRED_BILLING_RECEIPTS_IN_GROUPED_RECEIPTS, context)
                    } else {
                        throw new GQLError(errors.MISSING_REQUIRED_RECEIPTS_IN_GROUPED_RECEIPTS, context)
                    }
                }

                // (signature change) remove the condition and remove the temporarily errors
                if (groupedReceipts.some(group => !get(group, [serviceConsumerKey]))) {
                    if (serviceConsumerKey === 'serviceConsumer') {
                        throw new GQLError(errors.MISSING_REQUIRED_SERVICE_CONSUMER_IN_GROUPED_RECEIPTS, context)
                    } else {
                        throw new GQLError(errors.MISSING_REQUIRED_CONSUMER_ID_IN_GROUPED_RECEIPTS, context)
                    }
                }

                // Stage 0.1: Duplicates check
                const consumersIds = groupedReceipts.map(group => serviceConsumerKey === 'serviceConsumer' ? group.serviceConsumer.id : group.consumerId)
                const uniqueConsumerIds = new Set(consumersIds)
                if (consumersIds.length !== uniqueConsumerIds.size) {
                    // (signature change) remove the condition and remove the deprecated error
                    if (serviceConsumerKey === 'serviceConsumer') {
                        throw new GQLError(errors.DUPLICATED_SERVICE_CONSUMER, context)
                    } else {
                        throw new GQLError(errors.DUPLICATED_CONSUMER, context)
                    }
                }
                const receiptsIds = groupedReceipts
                    .flatMap(group => group[billingReceiptsKey])
                    .map(receiptInfo => receiptInfo.id)
                const uniqueReceiptsIds = new Set(receiptsIds)
                if (receiptsIds.length !== uniqueReceiptsIds.size) {
                    // (signature change) remove the condition and remove the deprecated error
                    if (billingReceiptsKey === 'billingReceipts') {
                        throw new GQLError(errors.DUPLICATED_BILLING_RECEIPT, context)
                    } else {
                        throw new GQLError(errors.DUPLICATED_RECEIPT, context)
                    }
                }

                // Stage 1. Check Acquiring
                const consumers = await find('ServiceConsumer', {
                    id_in: consumersIds,
                })
                if (consumers.length !== consumersIds.length) {
                    const existingConsumerIds = consumers.map(consumer => consumer.id)
                    const missingConsumerIds = consumersIds.filter(consumerId => !existingConsumerIds.includes(consumerId))
                    // (signature change) remove the condition and remove the deprecated error
                    const error = serviceConsumerKey === 'serviceConsumer' ? errors.MISSING_SERVICE_CONSUMERS : errors.MISSING_CONSUMERS
                    throw new GQLError({ ...error, messageInterpolation: { ids: missingConsumerIds.join(', ') } }, context)
                }
                const deletedConsumersIds = consumers.filter(consumer => consumer.deletedAt).map(consumer => consumer.id)
                if (deletedConsumersIds.length) {
                    // (signature change) remove the condition and remove the deprecated error
                    const error = serviceConsumerKey === 'serviceConsumer' ? errors.DELETED_CONSUMERS : errors.DELETED_CONSUMER_IDS
                    throw new GQLError({ ...error, messageInterpolation: { ids: deletedConsumersIds.join(', ') } }, context)
                }
                const contextMissingConsumers = consumers
                    .filter(consumer => !get(consumer, 'acquiringIntegrationContext'))
                    .map(consumer => consumer.id)
                if (contextMissingConsumers.length) {
                    // (signature change) remove the condition and remove the deprecated error
                    const error = serviceConsumerKey === 'serviceConsumer' ? errors.ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING : errors.ACQUIRING_INTEGRATION_CONTEXT_IS_MISSING_FOR_CONSUMER_ID
                    throw new GQLError({ ...error, messageInterpolation: { ids: contextMissingConsumers.join(', ') } }, context)
                }

                const consumersByIds = Object.assign({}, ...consumers.map(obj => ({ [obj.id]: obj })))

                const uniqueAcquiringContextsIds = new Set(consumers.map(consumer => consumer.acquiringIntegrationContext))
                const acquiringContexts = await find('AcquiringIntegrationContext', {
                    id_in: Array.from(uniqueAcquiringContextsIds),
                })

                const deletedAcquiringContextsIds = new Set(acquiringContexts.filter(context => context.deletedAt).map(context => context.id))
                if (deletedAcquiringContextsIds.size) {
                    const failedConsumers = consumers
                        .filter(consumer => deletedAcquiringContextsIds.has(consumer.acquiringIntegrationContext))
                        .map(consumer => ({ consumerId: consumer.id, acquiringContextId: consumer.acquiringIntegrationContext }))
                    // (signature change) remove the condition and remove the deprecated error
                    const error = serviceConsumerKey === 'serviceConsumer' ? errors.ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED : errors.ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED_FOR_CONSUMER_ID
                    throw new GQLError({ ...error, data: { failedConsumers } }, context)
                }

                const acquiringContextsByIds = Object.assign({}, ...acquiringContexts.map(obj => ({ [obj.id]: obj })))

                const acquiringIntegrations = new Set(acquiringContexts.map(context => context.integration))
                if (acquiringIntegrations.size !== 1) {
                    // (signature change) remove the condition and remove the deprecated error
                    const error = serviceConsumerKey === 'serviceConsumer' ? errors.MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS : errors.MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS_FOR_CONSUMER_ID
                    throw new GQLError(error, context)
                }

                // NOTE: Here using serverSchema to get many relation
                const [acquiringIntegration] = await AcquiringIntegration.getAll(context, {
                    id: Array.from(acquiringIntegrations)[0],
                })
                if (acquiringIntegration.deletedAt) {
                    // (signature change) remove the condition and remove the deprecated error
                    const error = serviceConsumerKey === 'serviceConsumer' ? errors.ACQUIRING_INTEGRATION_IS_DELETED : errors.ACQUIRING_INTEGRATION_IS_DELETED_FOR_CONSUMER_IF
                    throw new GQLError({ ...error, messageInterpolation: { id: acquiringIntegration.id } }, context)
                }

                // TODO (savelevMatthew): check that all receipts linked to right consumers?
                // Stage 2. Check BillingReceipts
                if (receiptsIds.length > 1 && !acquiringIntegration.canGroupReceipts) {
                    // (signature change) remove the condition and remove the deprecated error
                    const error = serviceConsumerKey === 'serviceConsumer' ? errors.RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION : errors.RECEIPTS_CANNOT_BE_GROUPED_BY_ACQUIRING_INTEGRATION_FOR_CONSUMER_ID
                    throw new GQLError({ ...error, messageInterpolation: { id: acquiringIntegration.id } }, context)
                }
                const receipts = await find('BillingReceipt', {
                    id_in: receiptsIds,
                })
                if (receipts.length !== receiptsIds.length) {
                    const existingReceiptsIds = new Set(receipts.map(receipt => receipt.id))
                    const missingReceipts = receiptsIds.filter(receiptId => !existingReceiptsIds.has(receiptId))
                    // (signature change) remove the condition and remove the deprecated error
                    const error = billingReceiptsKey === 'billingReceipts' ? errors.CANNOT_FIND_ALL_BILLING_RECEIPTS : errors.CANNOT_FIND_ALL_RECEIPTS
                    throw new GQLError({ ...error, messageInterpolation: { missingReceiptIds: missingReceipts.join(', ') } }, context)
                }

                const deletedReceiptsIds = receipts.filter(receipt => Boolean(receipt.deletedAt)).map(receipt => receipt.id)
                if (deletedReceiptsIds.length) {
                    // (signature change) remove the condition and remove the deprecated error
                    const error = billingReceiptsKey === 'billingReceipts' ? errors.BILLING_RECEIPTS_ARE_DELETED : errors.RECEIPTS_ARE_DELETED
                    throw new GQLError({ ...error, messageInterpolation: { ids: deletedReceiptsIds.join(', ') } }, context)
                }

                const negativeReceiptsIds = receipts
                    .filter(receipt => Big(receipt.toPay).lte(0))
                    .map(receipt => receipt.id)
                if (negativeReceiptsIds.length) {
                    // (signature change) remove the condition and remove the deprecated error
                    const error = billingReceiptsKey === 'billingReceipts' ? errors.BILLING_RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE : errors.RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE
                    throw new GQLError({ ...error, messageInterpolation: { ids: negativeReceiptsIds.join(', ') } }, context)
                }

                const receiptsByIds = Object.assign({}, ...receipts.map(obj => ({ [obj.id]: obj })))

                for (const group of groupedReceipts) {
                    for (const receiptInfo of group[billingReceiptsKey]) {
                        const receipt = receiptsByIds[receiptInfo.id]

                        const billingAccountId = receipt.account
                        const billingAccount = await getById('BillingAccount', billingAccountId)

                        const consumer = consumersByIds[serviceConsumerKey === 'serviceConsumer' ? group.serviceConsumer.id : group.consumerId]
                        const resident = await getById('Resident', consumer.resident)

                        if (
                            billingAccount.number !== consumer.accountNumber
                         || billingAccount.unitName !== resident.unitName
                         || billingAccount.context !== consumer.billingIntegrationContext
                        ) {
                            // (signature change) remove the condition and remove the deprecated error
                            const error = billingReceiptsKey === 'billingReceipts'
                                ? errors.BILLING_RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER
                                : errors.RECEIPT_DOES_NOT_HAVE_COMMON_BILLING_ACCOUNT_WITH_SERVICE_CONSUMER
                            throw new GQLError({
                                ...error,
                                messageInterpolation: {
                                    receiptId: receiptInfo.id,
                                    serviceConsumerId: serviceConsumerKey === 'serviceConsumer' ? group.serviceConsumer.id : group.consumerId,
                                },
                            }, context)
                        }
                    }
                }

                const uniqueBillingContextsIds = new Set(receipts.map(receipt => receipt.context))
                const billingContexts = await find('BillingIntegrationOrganizationContext', {
                    id_in: Array.from(uniqueBillingContextsIds),
                })
                const billingContextsById = Object.assign({}, ...billingContexts.map(obj => ({ [obj.id]: obj })))
                const deletedBillingContextsIds = new Set(billingContexts.filter(context => context.deletedAt).map(context => context.id))
                if (deletedBillingContextsIds.size) {
                    const failedReceipts = receipts
                        .filter(receipt => deletedBillingContextsIds.has(receipt.context))
                        .map(receipt => ({ receiptId: receipt.id, contextId: receipt.context }))
                    // (signature change) remove the condition and remove the deprecated error
                    const error = billingReceiptsKey === 'billingReceipts' ? errors.BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED : errors.BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED_FOR_RECEIPTS
                    throw new GQLError({ ...error, data: { failedReceipts } }, context)
                }
                const supportedBillingIntegrations = get(acquiringIntegration, 'supportedBillingIntegrations', [])
                    .map(integration => integration.id)
                const uniqueBillingIntegrationsIds = new Set(billingContexts.map(context => context.integration))
                const unsupportedBillings = Array.from(uniqueBillingIntegrationsIds)
                    .filter(integration => !supportedBillingIntegrations.includes(integration))
                if (unsupportedBillings.length) {
                    // (signature change) remove the condition and remove the deprecated error
                    const error = billingReceiptsKey === 'billingReceipts' ? errors.ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION : errors.ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION_FOR_RECEIPTS
                    throw new GQLError({ ...error, messageInterpolation: { unsupportedBillingIntegrations:  unsupportedBillings.join(', ') } }, context)
                }

                const billingIntegrations = await find('BillingIntegration', {
                    id_in: Array.from(uniqueBillingIntegrationsIds),
                })
                const deletedBillingIntegrationsIds = new Set(billingIntegrations.filter(integration => integration.deletedAt).map(integration => integration.id))
                if (deletedBillingIntegrationsIds.size) {
                    const failedReceipts = receipts
                        .filter(receipt => deletedBillingIntegrationsIds.has(billingContextsById[receipt.context].integration))
                        .map(receipt => ({ receiptId: receipt.id, integrationId: billingContextsById[receipt.context].integration }))
                    // (signature change) remove the condition and remove the deprecated error
                    const error = billingReceiptsKey === 'billingReceipts' ? errors.BILLING_RECEIPT_HAS_DELETED_BILLING_INTEGRATION : errors.RECEIPT_HAS_DELETED_BILLING_INTEGRATION
                    throw new GQLError({ ...error, data: { failedReceipts } }, context)
                }

                const currencies = new Set(billingIntegrations.map(integration => integration.currencyCode))
                if (currencies.size > 1) {
                    // (signature change) remove the condition and remove the deprecated error
                    const error = billingReceiptsKey === 'billingReceipts' ? errors.BILLING_RECEIPTS_HAS_MULTIPLE_CURRENCIES : errors.RECEIPTS_HAS_MULTIPLE_CURRENCIES
                    throw new GQLError(error, context)
                }
                const currencyCode = get(billingIntegrations, ['0', 'currencyCode'])

                // Stage 3 Generating payments
                const payments = []
                for (const group of groupedReceipts) {
                    const serviceConsumer = consumersByIds[serviceConsumerKey === 'serviceConsumer' ? group.serviceConsumer.id : group.consumerId]
                    const acquiringContext = acquiringContextsByIds[serviceConsumer.acquiringIntegrationContext]
                    const formula = await getAcquiringIntegrationContextFormula(context, serviceConsumer.acquiringIntegrationContext)
                    const feeCalculator = new FeeDistribution(formula)
                    for (const receiptInfo of group[billingReceiptsKey]) {
                        const receipt = receiptsByIds[receiptInfo.id]
                        const frozenReceipt = await freezeBillingReceipt(receipt)
                        const billingAccountNumber = get(frozenReceipt, ['data', 'account', 'number'])
                        const { type, explicitFee = '0', implicitFee = '0', fromReceiptAmountFee = '0' } = feeCalculator.calculate(receipt.toPay)
                        const paymentCommissionFields = {
                            ...type === 'service' ? {
                                explicitServiceCharge: String(explicitFee),
                                explicitFee: '0',
                            } : {
                                explicitServiceCharge: '0',
                                explicitFee: String(explicitFee),
                            },
                            implicitFee: String(implicitFee),
                            serviceFee: String(fromReceiptAmountFee),
                        }
                        const payment = await Payment.create(context, {
                            dv: 1,
                            sender,
                            amount: receipt.toPay,
                            currencyCode,
                            accountNumber: billingAccountNumber,
                            period: receipt.period,
                            receipt: { connect: { id: receiptInfo.id } },
                            frozenReceipt,
                            context: { connect: { id: acquiringContext.id } },
                            organization: { connect: { id: acquiringContext.organization } },
                            recipientBic: receipt.recipient.bic,
                            recipientBankAccount: receipt.recipient.bankAccount,
                            ...paymentCommissionFields,
                        })
                        payments.push({ ...payment, serviceFee: paymentCommissionFields.serviceFee })
                    }
                }
                const paymentIds = payments.map(payment => ({ id: payment.id }))
                const totalAmount = payments.reduce((acc, cur) => {
                    return {
                        amountWithoutExplicitFee: acc.amountWithoutExplicitFee.plus(Big(cur.amount)),
                        explicitFee: acc.explicitFee.plus(Big(cur.explicitFee)),
                        explicitServiceCharge: acc.explicitServiceCharge.plus(Big(cur.explicitServiceCharge)),
                        serviceFee: acc.serviceFee.plus(Big(cur.serviceFee)),
                        implicitFee: acc.implicitFee.plus(Big(cur.implicitFee)),
                    }
                }, {
                    amountWithoutExplicitFee: Big('0.0'),
                    explicitFee: Big('0.0'),
                    explicitServiceCharge: Big('0.0'),
                    serviceFee: Big('0.0'),
                    implicitFee: Big('0.0'),
                })
                const multiPayment = await MultiPayment.create(context, {
                    dv: 1,
                    sender,
                    ...Object.fromEntries(Object.entries(totalAmount).map(([key, value]) => ([key, value.toFixed(2)]))),
                    currencyCode,
                    user: { connect: { id: context.authedItem.id } },
                    integration: { connect: { id: acquiringIntegration.id } },
                    payments: { connect: paymentIds },
                    // TODO(DOMA-1574): add correct category
                    serviceCategory: DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY,
                })
                return {
                    dv: 1,
                    multiPaymentId: multiPayment.id,
                    webViewUrl: `${acquiringIntegration.hostUrl}${WEB_VIEW_PATH.replace('[id]', multiPayment.id)}`,
                    feeCalculationUrl: `${acquiringIntegration.hostUrl}${FEE_CALCULATION_PATH.replace('[id]', multiPayment.id)}`,
                    directPaymentUrl: `${acquiringIntegration.hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', multiPayment.id)}`,
                    getCardTokensUrl: `${acquiringIntegration.hostUrl}${GET_CARD_TOKENS_PATH.replace('[id]', context.authedItem.id)}`,
                }
            },
        },
    ],

})

module.exports = {
    RegisterMultiPaymentService,
}
