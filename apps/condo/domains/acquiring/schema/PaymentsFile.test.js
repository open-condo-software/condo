/**
 * Generated by `createschema acquiring.PaymentsFile 'number:Text;file:File;billingIntegrationOrganizationContextId:Text;externalId:Text;account:Text;dateBegin:CalendarDay;dateEnd:CalendarDay;dateLoad:DateTimeUtc;uploadedRecords:Integer;amount:Decimal;amountBring:Decimal;registryName:Text;bankStatus:Text;bankComment:Text;fileName:Text;'`
 */

const {
    makeLoggedInAdminClient,
    makeClient,
    expectValuesOfCommonFields,
    expectToThrowUniqueConstraintViolationError,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { PaymentsFile, createTestPaymentsFile, updateTestPaymentsFile, createTestAcquiringIntegration } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestAcquiringIntegrationContext, createTestAcquiringIntegrationAccessRight } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestOrganization, createTestOrganizationEmployeeRole, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { SERVICE } = require('@condo/domains/user/constants/common')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')
const { makeClientWithServiceUser } = require('@condo/domains/user/utils/testSchema')


describe('PaymentsFile', () => {
    let admin, support, user, anonymous
    let organization, integration, context

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient();

        [organization] = await createTestOrganization(admin);
        [integration] = await createTestAcquiringIntegration(admin);
        [context] = await createTestAcquiringIntegrationContext(admin, organization, integration)

    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestPaymentsFile(admin, context)

                expectValuesOfCommonFields(obj, attrs, admin)
            })

            test('support can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestPaymentsFile(support, context)
                })
            })

            describe('user', () => {
                test(`user without type ${SERVICE} can't`, async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestPaymentsFile(user, context)
                    })
                })

                test(`user with type ${SERVICE} but without rights can't`, async () => {
                    const serviceWithoutRights = await makeClientWithServiceUser()
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestPaymentsFile(serviceWithoutRights, context)
                    })
                })

                test(`user with type ${SERVICE} and rights can`, async () => {
                    const service = await makeClientWithServiceUser()
                    await createTestAcquiringIntegrationAccessRight(admin, integration, service.user)
                    const [obj, attrs] = await createTestPaymentsFile(service, context)
                    expectValuesOfCommonFields(obj, attrs, service)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestPaymentsFile(anonymous, context)
                })
            })

        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestPaymentsFile(admin, context)
                const [obj, attrs] = await updateTestPaymentsFile(admin, objCreated.id)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            })

            test('support can\'t', async () => {
                const [objCreated] = await createTestPaymentsFile(admin, context)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestPaymentsFile(support, objCreated.id)
                })
            })

            describe('user', () => {
                test(`user without type ${SERVICE} can't`, async () => {
                    const [objCreated] = await createTestPaymentsFile(admin, context)
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestPaymentsFile(user, objCreated.id)
                    })
                })

                test(`user with type ${SERVICE} but without rights can't`, async () => {
                    const [objCreated] = await createTestPaymentsFile(admin, context)
                    const serviceWithoutRights = await makeClientWithServiceUser()
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestPaymentsFile(serviceWithoutRights, objCreated.id)
                    })
                })

                test(`user with type ${SERVICE} and rights can`, async () => {
                    const service = await makeClientWithServiceUser()
                    await createTestAcquiringIntegrationAccessRight(admin, integration, service.user)
                    const [objCreated] = await createTestPaymentsFile(service, context)
                    const [obj, attrs] = await updateTestPaymentsFile(service, objCreated.id)
                    expect(obj.dv).toEqual(1)
                    expect(obj.sender).toEqual(attrs.sender)
                    expect(obj.v).toEqual(2)
                    expect(obj.updatedBy).toEqual(expect.objectContaining({ id: service.user.id }))
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestPaymentsFile(admin, context)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestPaymentsFile(user, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestPaymentsFile(admin, context)
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestPaymentsFile(anonymous, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [objCreated] = await createTestPaymentsFile(admin, context)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentsFile.delete(admin, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestPaymentsFile(admin, context)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentsFile.delete(user, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestPaymentsFile(admin, context)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentsFile.delete(anonymous, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj] = await createTestPaymentsFile(admin, context)
                const objs = await PaymentsFile.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })
                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: obj.id }),
                ]))
            })

            test('user without `canReadPayments` can\'t', async () => {
                await createTestPaymentsFile(admin, context)

                const paymentsFiles = await PaymentsFile.getAll(user, {}, { sortBy: ['updatedAt_DESC'] })
                expect(paymentsFiles).toBeDefined()
                expect(paymentsFiles).toHaveLength(0)
            })

            test('user with `canReadPayments` can', async () => {
                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestAcquiringIntegration(admin)
                const [context] = await createTestAcquiringIntegrationContext(admin, organization, integration)
                await createTestPaymentsFile(admin, context)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    canReadPayments: true,
                })
                const employeeClient = await makeClientWithNewRegisteredAndLoggedInUser()
                await createTestOrganizationEmployee(admin, organization, employeeClient.user, role)

                const paymentsFiles = await PaymentsFile.getAll(employeeClient, {}, { sortBy: ['updatedAt_DESC'] })
                expect(paymentsFiles).toBeDefined()
                expect(paymentsFiles).toHaveLength(1)
            })

            test('service user can read for own acquiring integration', async () => {
                const service = await makeClientWithServiceUser()
                const [ownIntegration] = await createTestAcquiringIntegration(admin)
                await createTestAcquiringIntegrationAccessRight(admin, ownIntegration, service.user)
                const [ownContext] = await createTestAcquiringIntegrationContext(admin, organization, ownIntegration)
                await createTestPaymentsFile(admin, ownContext)

                const allowedPaymentsFiles = await PaymentsFile.getAll(service, {}, { sortBy: ['updatedAt_DESC'] })
                expect(allowedPaymentsFiles).toBeDefined()
                expect(allowedPaymentsFiles).toHaveLength(1)
            })

            test('service user can\'t read for another acquiring integration', async () => {
                const service = await makeClientWithServiceUser()
                const [ownIntegration] = await createTestAcquiringIntegration(admin)
                const [anotherIntegration] = await createTestAcquiringIntegration(admin)
                await createTestAcquiringIntegrationAccessRight(admin, ownIntegration, service.user)
                const [anotherContext] = await createTestAcquiringIntegrationContext(admin, organization, anotherIntegration)
                await createTestPaymentsFile(admin, anotherContext)

                const notAllowedPaymentsFiles = await PaymentsFile.getAll(service, {}, { sortBy: ['updatedAt_DESC'] })
                expect(notAllowedPaymentsFiles).toBeDefined()
                expect(notAllowedPaymentsFiles).toHaveLength(0)
            })

            test('anonymous can\'t', async () => {
                await createTestPaymentsFile(admin, context)
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await PaymentsFile.getAll(anonymous, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('Should have correct dv field (=== 1)', async () => {
            const [obj] = await createTestPaymentsFile(admin, context)
            expect(obj.dv).toEqual(1)
        })

        test('There can only be one payments file for one context, registryName and loadedAt', async () => {
            const loadedAt = new Date()
            await createTestPaymentsFile(admin, context, { registryName: 'name', loadedAt })

            await expectToThrowUniqueConstraintViolationError(async () => {
                await createTestPaymentsFile(admin, context, { registryName: 'name', loadedAt })
            }, 'PaymentsFile_uniq_for_context')
        })
    })
})
