/**
 * Generated by `createservice billing.ExportPaymentsService`
 */

const { faker } = require('@faker-js/faker')

const { makeClient } = require('@open-condo/keystone/test.utils')
const { i18n } = require('@open-condo/locales/loader')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { EXPORT_PAYMENTS_TO_EXCEL } = require('@condo/domains/acquiring/gql')
const { makePayer, createTestPayment, updateTestAcquiringIntegrationContext, createTestMultiPayment } = require('@condo/domains/acquiring/utils/testSchema')
const { exportPaymentsServiceByTestClient, formatDateWithDefaultTimeZone } = require('@condo/domains/acquiring/utils/testSchema')
const { downloadFile, getTmpFile, readXlsx, expectDataFormat } = require('@condo/domains/common/utils/testSchema/file')
const { createTestContact } = require('@condo/domains/contact/utils/testSchema')
const { INVOICE_STATUS_PUBLISHED } = require('@condo/domains/marketplace/constants')
const { createTestInvoice } = require('@condo/domains/marketplace/utils/testSchema')
const { DEFAULT_ORGANIZATION_TIMEZONE } = require('@condo/domains/organization/constants/common')
const { makeClientWithProperty } = require('@condo/domains/property/utils/testSchema')


function prepareVariables (organization) {
    return {
        data: {
            dv: 1,
            sender: { dv: 1, fingerprint: 'test-' + faker.random.alphaNumeric(8) },
            where: { organization: { id: organization.id } },
            sortBy: 'advancedAt_DESC',
            timeZone: DEFAULT_ORGANIZATION_TIMEZONE,
        },
    }
}

describe('ExportPaymentsService', () => {
    describe('User', () => {
        it('can get payments export from selected organization', async () => {
            const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
            await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

            const {
                data: {
                    result: {
                        status,
                        linkToFile,
                    },
                },
            } = await admin.query(EXPORT_PAYMENTS_TO_EXCEL, prepareVariables(organization))

            expect(status).toBe('ok')
            expect(linkToFile).not.toHaveLength(0)
        })

        it('can not get contacts export from another organization', async () => {
            const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
            const { organization: organization2 } = await makePayer()
            await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

            const {
                data: { result },
                errors,
            } = await admin.query(EXPORT_PAYMENTS_TO_EXCEL, prepareVariables(organization2))

            expect(result).toBeNull()
            expect(errors).toHaveLength(1)
        })

        it('can not get payments export in case of no payments found', async () => {
            const { admin, organization } = await makePayer()

            const {
                data: { result },
                errors,
            } = await admin.query(EXPORT_PAYMENTS_TO_EXCEL, prepareVariables(organization))

            expect(result).toBeNull()
            expect(errors).toHaveLength(1)
            expect(errors).toMatchObject([{
                message: 'No payments found to export',
                path: ['result'],
                extensions: {
                    query: 'exportPaymentsToExcel',
                    code: 'BAD_USER_INPUT',
                    type: 'NOTHING_TO_EXPORT',
                    message: 'No payments found to export',
                },
            }])
        })
    })

    it('check payments export', async () => {
        const locale = 'ru'
        const { admin, billingReceipts, acquiringContext, acquiringIntegration, organization } = await makePayer()
        const [receiptPayment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
        await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, {
            invoiceStatus: CONTEXT_FINISHED_STATUS,
        })
        const [invoice] = await createTestInvoice(admin, { id: organization.id }, {
            status: INVOICE_STATUS_PUBLISHED,
            client: { connect: { id: admin.user.id } },
        })
        const [invoicePayment] = await createTestPayment(admin, organization, null, acquiringContext, { invoice })
        await createTestMultiPayment(admin, [invoicePayment], admin.user, acquiringIntegration)

        const [{ status, linkToFile }] = await exportPaymentsServiceByTestClient(
            admin,
            { invoice: { organization: { id: organization.id } } },
            { sortBy: 'advancedAt_DESC', timeZone: DEFAULT_ORGANIZATION_TIMEZONE }
        )

        const filename = getTmpFile('xlsx')
        await downloadFile(linkToFile, filename)
        const data = await readXlsx(filename)

        expectDataFormat(data, [
            ['Дата', 'ЛС', 'Адрес', 'Помещение', 'Тип', 'Транзакция', 'П/П', 'Статус', 'Сумма'],
            [
                formatDateWithDefaultTimeZone(invoicePayment.advancedAt),
                invoicePayment.accountNumber,
                '-',
                '-',
                acquiringIntegration.name,
                '',
                '',
                i18n('payment.status.' + invoicePayment.status, { locale }),
                Number(invoicePayment.amount).toFixed(2).toString(),
            ],
        ])
        expect(status).toBe('ok')
        expect(linkToFile).not.toHaveLength(0)

        const [{ status: status2, linkToFile: linkToFile2 }] = await exportPaymentsServiceByTestClient(
            admin,
            { organization: { id: organization.id }, invoice_is_null: true },
            { sortBy: 'advancedAt_DESC', timeZone: DEFAULT_ORGANIZATION_TIMEZONE }
        )

        const filename2 = getTmpFile('xlsx')
        await downloadFile(linkToFile2, filename2)
        const data2 = await readXlsx(filename2)

        expectDataFormat(data2, [
            ['Дата', 'ЛС', 'Адрес', 'Помещение', 'Тип', 'Транзакция', 'П/П', 'Статус', 'Сумма'],
            [
                formatDateWithDefaultTimeZone(receiptPayment.advancedAt),
                receiptPayment.accountNumber,
                receiptPayment.receipt.property.address,
                receiptPayment.receipt.account.unitName,
                acquiringIntegration.name,
                '',
                '',
                i18n('payment.status.' + receiptPayment.status, { locale }),
                Number(receiptPayment.amount).toFixed(2).toString(),
            ],
        ])
        expect(status2).toBe('ok')
        expect(linkToFile2).not.toHaveLength(0)
    })

    describe('Anonymous', () => {
        it('can not get payments export', async () => {
            const client = await makeClient()
            const client2 = await makeClientWithProperty()
            await createTestContact(client2, client2.organization, client2.property)

            const {
                data: { result },
                errors,
            } = await client.query(EXPORT_PAYMENTS_TO_EXCEL, prepareVariables(client2.organization))

            expect(result).toBeNull()
            expect(errors).toHaveLength(1)
            expect(errors[0]).toMatchObject({
                'message': 'No or incorrect authentication credentials',
                'name': 'AuthenticationError',
            })
        })
    })
})
