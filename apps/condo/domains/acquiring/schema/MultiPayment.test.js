/**
 * Generated by `createschema acquiring.MultiPayment 'amount:Decimal; commission?:Decimal; time:DateTimeUtc; cardNumber:Text; serviceCategory:Text;'`
 */

const { makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')
const { makeLoggedInAdminClient, makeClient } = require('@core/keystone/test.utils')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')
const { makePayerFromClient, getRandomHiddenCard } = require('@condo/domains/acquiring/utils/testSchema')

const {
    MultiPayment,
    createTestMultiPayment,
    updateTestMultiPayment,
    createTestAcquiringIntegration,
    createTestAcquiringIntegrationAccessRight,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowValidationFailureError,
} = require('@condo/domains/common/utils/testSchema')
const { MULTIPAYMENT_ERROR_STATUS, MULTIPAYMENT_INIT_STATUS, MULTIPAYMENT_DONE_STATUS, MULTIPAYMENT_PROCESSING_STATUS } = require('../constants')
const dayjs = require('dayjs')
const faker = require('faker')

describe('MultiPayment', () => {
    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const admin = await makeLoggedInAdminClient()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(admin)
                const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                expect(multiPayment).toBeDefined()
                expect(multiPayment).toHaveProperty(['integration', 'id'], acquiringIntegration.id)
                expect(multiPayment).toHaveProperty('receipts', billingReceipts)
            })
            test('support can\'t', async () => {
                const support = await makeClientWithSupportUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(support)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMultiPayment(support, billingReceipts, resident, acquiringIntegration)
                })
            })
            test('user can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMultiPayment(client, billingReceipts, resident, acquiringIntegration)
                })
            })
            test('anonymous can\'t', async () => {
                const anonymousClient = await makeClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestMultiPayment(anonymousClient, billingReceipts, resident, acquiringIntegration)
                })
            })
        })
        describe('read', () => {
            test('admin can', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                const multiPayments = await MultiPayment.getAll(admin)
                expect(multiPayments).toBeDefined()
                expect(multiPayments).not.toHaveLength(0)
            })
            test('support can', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                const support = await makeClientWithSupportUser()
                const multiPayments = await MultiPayment.getAll(support)
                expect(multiPayments).toBeDefined()
                expect(multiPayments).not.toHaveLength(0)
            })
            describe('user', () => {
                test('resident can see only it\'s own multipayments', async () => {
                    const admin = await makeLoggedInAdminClient()
                    const firstClient = await makeClientWithResidentUser()
                    const secondClient = await makeClientWithResidentUser()
                    const { billingReceipts: firstBillingReceipts, resident: firstResident, acquiringIntegration: firstAcquiringIntegration } = await makePayerFromClient(firstClient)
                    const { billingReceipts: secondBillingReceipts, resident: secondResident } = await makePayerFromClient(secondClient)
                    const [firstMultiPayment] = await createTestMultiPayment(admin, firstBillingReceipts, firstResident, firstAcquiringIntegration)
                    const [secondMultiPayment] = await createTestMultiPayment(admin, secondBillingReceipts, secondResident, firstAcquiringIntegration)
                    let multiPayments = await MultiPayment.getAll(firstClient)
                    expect(multiPayments).toBeDefined()
                    expect(multiPayments).toHaveLength(1)
                    expect(multiPayments).toHaveProperty(['0', 'id'], firstMultiPayment.id)
                    multiPayments = await MultiPayment.getAll(secondClient)
                    expect(multiPayments).toBeDefined()
                    expect(multiPayments).toHaveLength(1)
                    expect(multiPayments).toHaveProperty(['0', 'id'], secondMultiPayment.id)
                })
                test('integration account can see only multipayments linked to it\'s integration', async () => {
                    const admin = await makeLoggedInAdminClient()
                    const firstClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const { billingReceipts, resident, acquiringIntegration: firstIntegration } = await makePayerFromClient(firstClient)
                    const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, firstIntegration)
                    const [secondIntegration] = await createTestAcquiringIntegration(admin)

                    const firstIntegrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const secondIntegrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestAcquiringIntegrationAccessRight(admin, firstIntegration, firstIntegrationClient.user)
                    await createTestAcquiringIntegrationAccessRight(admin, secondIntegration, secondIntegrationClient.user)

                    let multiPayments = await MultiPayment.getAll(firstIntegrationClient)
                    expect(multiPayments).toBeDefined()
                    expect(multiPayments).toHaveLength(1)
                    expect(multiPayments).toHaveProperty(['0', 'id'], multiPayment.id)
                    multiPayments = await MultiPayment.getAll(secondIntegrationClient)
                    expect(multiPayments).toBeDefined()
                    expect(multiPayments).toHaveLength(0)
                })
                test('can\'t see in other cases', async () => {
                    const admin = await makeLoggedInAdminClient()
                    const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(admin)
                    await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const multiPayments = await MultiPayment.getAll(client)

                    expect(multiPayments).toBeDefined()
                    expect(multiPayments).toHaveLength(0)
                })
            })
            test('anonymous can\'t', async () => {
                const anonymousClient = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await MultiPayment.getAll(anonymousClient)
                })
            })
        })
        describe('update', () => {
            test('admin can', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                const [updatedMultiPayment] = await updateTestMultiPayment(admin, multiPayment.id, {
                    status: MULTIPAYMENT_ERROR_STATUS,
                })
                expect(updatedMultiPayment).toBeDefined()
                expect(updatedMultiPayment).toHaveProperty('status', MULTIPAYMENT_ERROR_STATUS)

            })
            test('support can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                const support = await makeClientWithSupportUser()
                const payload = {}
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMultiPayment(support, multiPayment.id, payload)
                })
            })
            describe('user',  () => {
                test('acquiring integration can change it\'s own multipayments', async () => {
                    const admin = await makeLoggedInAdminClient()
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                    const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                    const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)
                    const [updatedMultiPayment] = await updateTestMultiPayment(integrationClient, multiPayment.id, {
                        status: MULTIPAYMENT_ERROR_STATUS,
                    })
                    expect(updatedMultiPayment).toBeDefined()
                    expect(updatedMultiPayment).toHaveProperty('status', MULTIPAYMENT_ERROR_STATUS)
                })
                test('resident can\'t', async () => {
                    const admin = await makeLoggedInAdminClient()
                    const client = await makeClientWithResidentUser()
                    const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                    const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                    const payload = {}
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestMultiPayment(client, multiPayment.id, payload)
                    })
                })
                test('can\'t in other cases', async () => {
                    const admin = await makeLoggedInAdminClient()
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                    const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                    const payload = {}
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestMultiPayment(client, multiPayment.id, payload)
                    })
                })
            })
            test('anonymous can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                const anonymousClient = await makeClient()
                const payload = {}
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestMultiPayment(anonymousClient, multiPayment.id, payload)
                })
            })
        })
        describe('delete',  () => {
            test('admin can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MultiPayment.delete(admin, multiPayment.id)
                })
            })
            test('support can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                const support = await makeClientWithSupportUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MultiPayment.delete(support, multiPayment.id)
                })
            })

            test('user can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MultiPayment.delete(client, multiPayment.id)
                })
            })

            test('anonymous can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                const anonymousClient = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MultiPayment.delete(anonymousClient, multiPayment.id)
                })
            })
        })
    })
    describe('real-life cases', () => {
        describe('acquiring integration account updating it\'s own MultiPayments', () => {
            describe('invalid mutations (validation cases)', () => {
                test('Cannot change frozen fields', async () => {
                    const admin = await makeLoggedInAdminClient()
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                    const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                    const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(integrationClient, multiPayment.id, {
                            status: MULTIPAYMENT_ERROR_STATUS,
                            receipts: [],
                        })
                    })
                })
                test('Cannot update without specifying / changing status', async () => {
                    const admin = await makeLoggedInAdminClient()
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                    const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                    const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(integrationClient, multiPayment.id, {})
                    })
                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(integrationClient, multiPayment.id, {
                            status: MULTIPAYMENT_INIT_STATUS,
                        })
                    })
                })
                test('Cannot change status chaotically. Only specific transitions allowed', async () => {
                    // List of available transitions can be seen in domain constants
                    const admin = await makeLoggedInAdminClient()
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                    const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                    const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                    // Valid transition
                    const [updatedMultiPayment] = await updateTestMultiPayment(integrationClient, multiPayment.id, {
                        status: MULTIPAYMENT_ERROR_STATUS,
                    })
                    expect(updatedMultiPayment).toBeDefined()
                    expect(updatedMultiPayment).toHaveProperty('status', MULTIPAYMENT_ERROR_STATUS)

                    // Invalid transitions
                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(integrationClient, updatedMultiPayment.id, {
                            status: MULTIPAYMENT_INIT_STATUS,
                        })
                    })
                })
                test('Should specify required fields in transition', async () => {
                    const admin = await makeLoggedInAdminClient()
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                    const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                    const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(integrationClient, multiPayment.id, {
                            status: MULTIPAYMENT_DONE_STATUS,
                        })
                    })
                    const payload = {
                        status: MULTIPAYMENT_DONE_STATUS,
                        time: dayjs().toISOString(),
                        cardNumber: getRandomHiddenCard(),
                        paymentWay: 'CARD',
                        transactionId: faker.datatype.uuid(),
                    }
                    const [updatedMultiPayment] = await updateTestMultiPayment(integrationClient, multiPayment.id, payload)
                    expect(updatedMultiPayment).toBeDefined()
                    expect(updatedMultiPayment).toEqual(expect.objectContaining(payload))
                })
            })
            describe('valid flow', () => {
                describe('MultiPayments with processing',  () => {
                    test('Fails at the end', async () => {
                        const admin = await makeLoggedInAdminClient()
                        const client = await makeClientWithNewRegisteredAndLoggedInUser()
                        const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                        const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                        await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                        const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)
                        // Integration moves MP to processing status
                        const [firstStage] = await updateTestMultiPayment(integrationClient, multiPayment.id, {
                            status: MULTIPAYMENT_PROCESSING_STATUS,
                        })
                        expect(firstStage).toBeDefined()
                        expect(firstStage).toHaveProperty('status', MULTIPAYMENT_PROCESSING_STATUS)
                        // Integration guide user through payment process, but somehow fails
                        // (No money was on card, was not possible to complete payment...etc)
                        const [secondStage] = await updateTestMultiPayment(integrationClient, firstStage.id, {
                            status: MULTIPAYMENT_ERROR_STATUS,
                        })
                        expect(secondStage).toBeDefined()
                        expect(secondStage).toHaveProperty('status', MULTIPAYMENT_ERROR_STATUS)
                    })
                    test('Completed at the end', async () => {
                        const admin = await makeLoggedInAdminClient()
                        const client = await makeClientWithNewRegisteredAndLoggedInUser()
                        const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                        const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                        await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                        const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)
                        // Integration moves MP to processing status
                        const [firstStage] = await updateTestMultiPayment(integrationClient, multiPayment.id, {
                            status: MULTIPAYMENT_PROCESSING_STATUS,
                        })
                        expect(firstStage).toBeDefined()
                        expect(firstStage).toHaveProperty('status', MULTIPAYMENT_PROCESSING_STATUS)
                        // Integration guide user through payment process, and then additional info to payment
                        const payload = {
                            status: MULTIPAYMENT_DONE_STATUS,
                            time: dayjs().toISOString(),
                            paymentWay: 'CARD',
                            payerEmail: 'example@domain.com',
                            cardNumber: getRandomHiddenCard(),
                            transactionId: faker.datatype.uuid(),
                        }
                        const [secondStage] = await updateTestMultiPayment(integrationClient, firstStage.id, payload)
                        expect(secondStage).toBeDefined()
                        expect(secondStage).toEqual(expect.objectContaining(payload))
                    })
                })
                describe('MultiPayments with instant payment',  () => {
                    test('Fails', async () => {
                        const admin = await makeLoggedInAdminClient()
                        const client = await makeClientWithNewRegisteredAndLoggedInUser()
                        const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                        const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                        await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                        const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)
                        // Payment fails instantly
                        const [failedMultiPayment] = await updateTestMultiPayment(integrationClient, multiPayment.id, {
                            status: MULTIPAYMENT_ERROR_STATUS,
                        })
                        expect(failedMultiPayment).toBeDefined()
                        expect(failedMultiPayment).toHaveProperty('status', MULTIPAYMENT_ERROR_STATUS)
                    })
                    test('Completed', async () => {
                        const admin = await makeLoggedInAdminClient()
                        const client = await makeClientWithNewRegisteredAndLoggedInUser()
                        const { billingReceipts, resident, acquiringIntegration } = await makePayerFromClient(client)
                        const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                        await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                        const [multiPayment] = await createTestMultiPayment(admin, billingReceipts, resident, acquiringIntegration)

                        // Integration guide user through payment process, and then move MultiPayment directly to done
                        const payload = {
                            status: MULTIPAYMENT_DONE_STATUS,
                            time: dayjs().toISOString(),
                            paymentWay: 'CARD',
                            payerEmail: 'example@domain.com',
                            cardNumber: getRandomHiddenCard(),
                            transactionId: faker.datatype.uuid(),
                        }
                        const [completedMultiPayment] = await updateTestMultiPayment(integrationClient, multiPayment.id, payload)
                        expect(completedMultiPayment).toBeDefined()
                        expect(completedMultiPayment).toEqual(expect.objectContaining(payload))
                    })
                })
            })
        })
    })
})
