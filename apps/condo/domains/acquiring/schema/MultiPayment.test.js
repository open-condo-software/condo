/**
 * Generated by `createschema acquiring.MultiPayment 'amount:Decimal; commission?:Decimal; time:DateTimeUtc; cardNumber:Text; serviceCategory:Text;'`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const dayjs = require('dayjs')
const { get, omit } = require('lodash')

const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowValidationFailureError,
    expectToThrowAccessDeniedError,
} = require('@open-condo/keystone/test.utils')
const { makeLoggedInAdminClient, makeClient } = require('@open-condo/keystone/test.utils')
const { expectToThrowGQLError } = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    MULTIPAYMENT_EMPTY_PAYMENTS,
    MULTIPAYMENT_TOO_BIG_IMPLICIT_FEE,
    MULTIPAYMENT_MULTIPLE_CURRENCIES,
    MULTIPAYMENT_NOT_UNIQUE_RECEIPTS,
    MULTIPAYMENT_TOTAL_AMOUNT_MISMATCH,
    MULTIPAYMENT_MULTIPLE_ACQUIRING_INTEGRATIONS,
    MULTIPAYMENT_ACQUIRING_INTEGRATIONS_MISMATCH,
    MULTIPAYMENT_CANNOT_GROUP_RECEIPTS,
    MULTIPAYMENT_NOT_ALLOWED_TRANSITION,
    MULTIPAYMENT_MISSING_REQUIRED_FIELDS,
    MULTIPAYMENT_FROZEN_FIELD_INCLUDED,
    MULTIPAYMENT_UNDONE_PAYMENTS,
    MULTIPAYMENT_EXPLICIT_FEE_MISMATCH,
    MULTIPAYMENT_INCONSISTENT_IMPLICIT_FEE,
    MULTIPAYMENT_INCONSISTENT_SERVICE_FEE,
    MULTIPAYMENT_IMPLICIT_FEE_MISMATCH,
    MULTIPAYMENT_DELETED_PAYMENTS,
    MULTIPAYMENT_NON_INIT_PAYMENTS,
    MULTIPAYMENT_PAYMENTS_ALREADY_WITH_MP,
    MULTIPAYMENT_EXPLICIT_SERVICE_CHARGE_MISMATCH,
} = require('@condo/domains/acquiring/constants/errors')
const {
    MULTIPAYMENT_INIT_STATUS,
    MULTIPAYMENT_PROCESSING_STATUS,
    MULTIPAYMENT_ERROR_STATUS,
    MULTIPAYMENT_DONE_STATUS,
    PAYMENT_DONE_STATUS,
    PAYMENT_PROCESSING_STATUS,
    PAYMENT_ERROR_STATUS,
    MULTIPAYMENT_FROZEN_FIELDS,
    MULTIPAYMENT_WITHDRAWN_STATUS,
    PAYMENT_WITHDRAWN_STATUS,
} = require('@condo/domains/acquiring/constants/payment')
const {
    Payment,
    MultiPayment,
    MultiPaymentWithPayerInfo,
    MultiPaymentAdmin,
    createTestMultiPayment,
    updateTestMultiPayment,
    createTestAcquiringIntegration,
    updateTestAcquiringIntegration,
    createTestAcquiringIntegrationAccessRight,
    createTestPayment,
    updateTestPayment,
    getRandomHiddenCard,
    registerMultiPaymentByTestClient,
    makePayerAndPayments,
    makePayer,
    makePayerWithMultipleConsumers,
    updateTestAcquiringIntegrationContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const { INVOICE_STATUS_PUBLISHED } = require('@condo/domains/marketplace/constants')
const { createTestInvoice } = require('@condo/domains/marketplace/utils/testSchema')
const { UserAdmin, makeClientWithSupportUser, makeClientWithServiceUser, createTestPhone, createTestEmail, updateTestUser } = require('@condo/domains/user/utils/testSchema')


describe('MultiPayment', () => {
    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const admin = await makeLoggedInAdminClient()
                const { payments, acquiringIntegration, client } = await makePayerAndPayments()
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                const paymentsIds = payments.map(payment => ({ id: payment.id }))

                expect(multiPayment).toBeDefined()
                expect(multiPayment).toHaveProperty(['integration', 'id'], acquiringIntegration.id)
                expect(multiPayment).toHaveProperty('payments')
                expect(multiPayment.payments).toEqual(expect.arrayContaining(paymentsIds))
            })
            test('support can\'t', async () => {
                const support = await makeClientWithSupportUser()
                const { payments, acquiringIntegration, client } = await makePayerAndPayments()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMultiPayment(support, payments, client.user, acquiringIntegration)
                })
            })
            test('user can\'t', async () => {
                const { payments, acquiringIntegration, client } = await makePayerAndPayments()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMultiPayment(client, payments, client.user, acquiringIntegration)
                })
            })
            test('anonymous can\'t', async () => {
                const anonymousClient = await makeClient()
                const { payments, acquiringIntegration, client } = await makePayerAndPayments()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestMultiPayment(anonymousClient, payments, client.user, acquiringIntegration)
                })
            })
        })
        describe('read', () => {
            test('admin can', async () => {
                const { payments, acquiringIntegration, client, admin } = await makePayerAndPayments()
                await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                const multiPayments = await MultiPayment.getAll(admin)
                expect(multiPayments).toBeDefined()
                expect(multiPayments).not.toHaveLength(0)
            })
            test('support can', async () => {
                const { payments, acquiringIntegration, client, admin } = await makePayerAndPayments()
                await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                const support = await makeClientWithSupportUser()
                const multiPayments = await MultiPayment.getAll(support)
                expect(multiPayments).toBeDefined()
                expect(multiPayments).not.toHaveLength(0)
            })
            describe('user', () => {
                test('user can see only it\'s own multipayments', async () => {
                    const { admin, payments: firstPayments, acquiringIntegration: firstAcquiringIntegration, client: firstClient } = await makePayerAndPayments()
                    const { payments: secondPayments, client: secondClient, acquiringIntegration: secondAcquiringIntegration } = await makePayerAndPayments()
                    const [firstMultiPayment] = await createTestMultiPayment(admin, firstPayments, firstClient.user, firstAcquiringIntegration)
                    const [secondMultiPayment] = await createTestMultiPayment(admin, secondPayments, secondClient.user, secondAcquiringIntegration)
                    let { data: { objs: firstMultiPayments } } = await MultiPayment.getAll(firstClient, {}, { raw:true })
                    expect(firstMultiPayments).toBeDefined()
                    expect(firstMultiPayments).toHaveLength(1)
                    expect(firstMultiPayments).toHaveProperty(['0', 'id'], firstMultiPayment.id)
                    let { data: { objs: secondMultiPayments } } = await MultiPayment.getAll(secondClient, {}, { raw:true })
                    expect(secondMultiPayments).toBeDefined()
                    expect(secondMultiPayments).toHaveLength(1)
                    expect(secondMultiPayments).toHaveProperty(['0', 'id'], secondMultiPayment.id)
                })
                test('integration account can see only multipayments linked to it\'s integration', async () => {
                    const { admin, payments, acquiringIntegration: firstIntegration, client } = await makePayerAndPayments()
                    const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, firstIntegration)
                    const [secondIntegration] = await createTestAcquiringIntegration(admin)

                    const firstIntegrationClient = await makeClientWithServiceUser()
                    const secondIntegrationClient = await makeClientWithServiceUser()
                    await createTestAcquiringIntegrationAccessRight(admin, firstIntegration, firstIntegrationClient.user)
                    await createTestAcquiringIntegrationAccessRight(admin, secondIntegration, secondIntegrationClient.user)

                    let { data: { objs: firstMultiPayments } } = await MultiPayment.getAll(firstIntegrationClient, {}, { raw:true })
                    expect(firstMultiPayments).toBeDefined()
                    expect(firstMultiPayments).toHaveLength(1)
                    expect(firstMultiPayments).toHaveProperty(['0', 'id'], multiPayment.id)
                    let { data: { objs: secondMultiPayments } } = await MultiPayment.getAll(secondIntegrationClient, {}, { raw:true })
                    expect(secondMultiPayments).toBeDefined()
                    expect(secondMultiPayments).toHaveLength(0)
                })
            })
            test('anonymous can\'t', async () => {
                const anonymousClient = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await MultiPayment.getAll(anonymousClient)
                })
            })
            describe('fields', () => {

                describe('payerInfo', () => {
                    let admin
                    let user
                    let multiPaymentId
                    let acquiringIntegration

                    beforeEach(async () => {
                        const {
                            admin: createdAdmin,
                            acquiringIntegration: createdAcquiringIntegration,
                            client,
                            payments,
                            
                        } = await makePayerAndPayments()
                        const [{ id: createdMultiPaymentId }] = await createTestMultiPayment(createdAdmin, payments, client.user, createdAcquiringIntegration)
                        admin = createdAdmin
                        user = client
                        multiPaymentId = createdMultiPaymentId
                        acquiringIntegration = createdAcquiringIntegration
                    })
                    test('admin can', async () => {
                        const multiPayment = await MultiPaymentWithPayerInfo.getOne(admin, { id: multiPaymentId })
                        expect(multiPayment).toBeDefined()
                        expect(multiPayment.payerInfo).toBeDefined()
                    })
                    it('support can\'t', async () => {
                        const support = await makeClientWithSupportUser()
                        await expectToThrowAccessDeniedError(async () => {
                            await MultiPaymentWithPayerInfo.getAll(support, { id: multiPaymentId })
                        }, ['objs', 0, 'payerInfo'])
                    })
                    describe('user', () => {
                        it('resident can\'t', async () => {
                            // NOTE(YEgorLu): for some reason expectToThrowAccessDeniedError can't find access error for ['objs', 0, 'payerInfo'] path here 
                            const { data, errors } = await MultiPaymentWithPayerInfo.getAll(user, { id: multiPaymentId }, { raw: true })
                            const multiPayment = data?.objs?.[0]
                            expect(errors.length).toBeGreaterThanOrEqual(1)
                            expect(errors).toEqual(expect.arrayContaining([expect.objectContaining({
                                message: 'You do not have access to this resource',
                                name: 'AccessDeniedError',
                                path: ['objs', 0, 'payerInfo'],

                            })]))
                            expect(multiPayment).toBeDefined()
                            expect(multiPayment.id).toEqual(multiPaymentId)
                            expect(multiPayment.payerInfo).toBeNull()
                        })
                        test('acquiring integration service user can see', async () => {
                            const integrationClient = await makeClientWithServiceUser()
                            await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)
                            const multiPayment = await MultiPaymentWithPayerInfo.getOne(integrationClient, { id: multiPaymentId })
                            expect(multiPayment).toBeDefined()
                            expect(multiPayment.payerInfo).toBeDefined()
                        })
                        test('service user from another acquiring integration can\'t see', async () => {
                            const { acquiringIntegration: anotherAcquiringIntegration } = await makePayer()
                            const anotherIntegrationClient = await makeClientWithServiceUser()
                            await createTestAcquiringIntegrationAccessRight(admin, anotherAcquiringIntegration, anotherIntegrationClient.user)
                            const multiPayments = await MultiPaymentWithPayerInfo.getAll(anotherIntegrationClient, { id: multiPaymentId })
                            expect(multiPayments).toHaveLength(0)
                        })
                    })
                    test('anonymous can\'t', async () => {
                        const anonymous = await makeClient()
                        await expectToThrowAuthenticationErrorToObjects(async () => {
                            await MultiPayment.getAll(anonymous, { id: multiPaymentId })
                        })
                    })
                })

            })
        })
        describe('update', () => {
            test('admin can', async () => {
                const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                const payload = {
                    status: MULTIPAYMENT_ERROR_STATUS,
                }
                const [updatedMultiPayment] = await updateTestMultiPayment(admin, multiPayment.id, payload)
                expect(updatedMultiPayment).toBeDefined()
                expect(updatedMultiPayment).toHaveProperty('status', MULTIPAYMENT_ERROR_STATUS)

            })
            test('support can\'t', async () => {
                const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                const support = await makeClientWithSupportUser()
                const payload = {}
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMultiPayment(support, multiPayment.id, payload)
                })
            })
            describe('user',  () => {
                test('acquiring integration account can change it\'s own multipayments', async () => {
                    const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
                    const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                    const integrationClient = await makeClientWithServiceUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)
                    const [updatedMultiPayment] = await updateTestMultiPayment(integrationClient, multiPayment.id, {
                        status: MULTIPAYMENT_ERROR_STATUS,
                    })
                    expect(updatedMultiPayment).toBeDefined()
                    expect(updatedMultiPayment).toHaveProperty('status', MULTIPAYMENT_ERROR_STATUS)
                })
                test('user can\'t', async () => {
                    const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
                    const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                    const payload = {}
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestMultiPayment(client, multiPayment.id, payload)
                    })
                })
            })
            test('anonymous can\'t', async () => {
                const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                const anonymousClient = await makeClient()
                const payload = {}
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestMultiPayment(anonymousClient, multiPayment.id, payload)
                })
            })
        })
        describe('delete',  () => {
            test('admin can\'t', async () => {
                const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MultiPayment.delete(admin, multiPayment.id)
                })
            })
            test('support can\'t', async () => {
                const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                const support = await makeClientWithSupportUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MultiPayment.delete(support, multiPayment.id)
                })
            })

            test('user can\'t', async () => {
                const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MultiPayment.delete(client, multiPayment.id)
                })
            })

            test('anonymous can\'t', async () => {
                const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)

                const anonymousClient = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MultiPayment.delete(anonymousClient, multiPayment.id)
                })
            })
        })
    })
    describe('Validation tests', () => {
        describe('Fields validation', () => {
            test('Should have correct dv field (=== 1)', async () => {
                const { payments, acquiringIntegration, client, admin } = await makePayerAndPayments()
                await expectToThrowGQLError(async () => await createTestMultiPayment(admin, payments, client.user, acquiringIntegration, {
                    dv: 2,
                }), {
                    'code': 'BAD_USER_INPUT',
                    'type': 'DV_VERSION_MISMATCH',
                    'message': 'Wrong value for data version number',
                    'mutation': 'createMultiPayment',
                    'variable': ['data', 'dv'],
                })
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                await expectToThrowGQLError(async () => await updateTestMultiPayment(admin, multiPayment.id, {
                    dv: 2,
                }), {
                    'code': 'BAD_USER_INPUT',
                    'type': 'DV_VERSION_MISMATCH',
                    'message': 'Wrong value for data version number',
                    'mutation': 'updateMultiPayment',
                    'variable': ['data', 'dv'],
                })

            })
            test('Payments should not be empty', async () => {
                const { payments, acquiringIntegration, client, admin } = await makePayerAndPayments()
                await expectToThrowValidationFailureError(async () => {
                    await createTestMultiPayment(admin, payments, client.user, acquiringIntegration, {
                        payments: { disconnectAll: true },
                    })
                }, MULTIPAYMENT_EMPTY_PAYMENTS)
            })
            describe('Should check for non-negative money fields', () => {
                const cases = [
                    ['explicitFee', '-0.01'], ['explicitFee', '-30'], ['explicitFee', '-10.50'],
                    ['serviceFee', '-0.01'], ['serviceFee', '-30'], ['serviceFee', '-10.50'],
                ]
                test.each(cases)('%p: %p', async (field, amount) => {
                    const { payments, acquiringIntegration, client, admin } = await makePayerAndPayments()
                    await expectToThrowValidationFailureError(async () => {
                        await createTestMultiPayment(admin, payments, client.user, acquiringIntegration, {
                            [field]: amount,
                        })
                    }, 'Specified number has an invalid sign')
                })
            })
            test('Implicit fee cannot be greater than amountWithoutExplicitFee', async () => {
                const { admin, organization, billingReceipts, acquiringContext, client, acquiringIntegration  } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext, {
                    amount: '100',
                })
                await expectToThrowValidationFailureError(async () => {
                    await createTestMultiPayment(admin, [payment], client.user, acquiringIntegration, {
                        implicitFee: '105',
                    })
                }, MULTIPAYMENT_TOO_BIG_IMPLICIT_FEE)
            })
        })
        describe('Model validation', () => {
            describe('All linked payments should have', () => {
                test('Same currency code', async () => {
                    const { admin, organization, billingReceipts, acquiringContext, client, acquiringIntegration } = await makePayer(2)
                    const [firstPayment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    const [secondPayment] = await createTestPayment(admin, organization, billingReceipts[1], acquiringContext, {
                        currencyCode: 'USD',
                    })
                    await expectToThrowValidationFailureError(async () => {
                        await createTestMultiPayment(admin, [firstPayment, secondPayment], client.user, acquiringIntegration)
                    }, MULTIPAYMENT_MULTIPLE_CURRENCIES)
                })
                test('Unique receipts', async () => {
                    const { admin, organization, billingReceipts, acquiringContext, client, acquiringIntegration } = await makePayer()
                    const [firstPayment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    const [secondPayment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    await expectToThrowValidationFailureError(async () => {
                        await createTestMultiPayment(admin, [firstPayment, secondPayment], client.user, acquiringIntegration)
                    }, MULTIPAYMENT_NOT_UNIQUE_RECEIPTS)
                })
                test('Unique invoices', async () => {
                    const { admin, organization, acquiringContext, client, acquiringIntegration } = await makePayer()

                    await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, { invoiceStatus: CONTEXT_FINISHED_STATUS })

                    const [invoice] = await createTestInvoice(admin, organization, {
                        status: INVOICE_STATUS_PUBLISHED,
                        client: { connect: { id: client.user.id } },
                    })

                    const [firstPayment] = await createTestPayment(admin, organization, null, acquiringContext, { invoice })
                    const [secondPayment] = await createTestPayment(admin, organization, null, acquiringContext, { invoice })

                    await expectToThrowGQLError(async () => {
                        await createTestMultiPayment(admin, [firstPayment, secondPayment], client.user, acquiringIntegration)
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'MULTIPAYMENT_NOT_UNIQUE_INVOICES',
                        message: 'Not unique invoices',
                    })
                })
                test('Matching amount', async () => {
                    const { admin, organization, billingReceipts, acquiringContext, client, acquiringIntegration } = await makePayer(2)
                    const [firstPayment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    const [secondPayment] = await createTestPayment(admin, organization, billingReceipts[1], acquiringContext)
                    await expectToThrowValidationFailureError(async () => {
                        await createTestMultiPayment(admin, [firstPayment, secondPayment], client.user, acquiringIntegration, {
                            amountWithoutExplicitFee: Big(billingReceipts[0].toPay).plus(Big(billingReceipts[1].toPay)).plus(Big(50)).toString(),
                        })
                    }, MULTIPAYMENT_TOTAL_AMOUNT_MISMATCH)
                })
                test('Same acquiring', async () => {
                    const { admin, payments, client, acquiringIntegration } = await makePayerAndPayments()
                    const { payments: secondPayments } = await makePayerAndPayments()
                    await expectToThrowValidationFailureError(async () => {
                        await createTestMultiPayment(admin, [payments[0], secondPayments[0]], client.user, acquiringIntegration)
                    }, MULTIPAYMENT_MULTIPLE_ACQUIRING_INTEGRATIONS)
                })
            })
            test('Cannot accept payments with different acquiring', async () => {
                const { admin, payments, client } = await makePayerAndPayments()
                const [integration] = await createTestAcquiringIntegration(admin)
                await expectToThrowValidationFailureError(async () => {
                    await createTestMultiPayment(admin, payments, client.user, integration)
                }, MULTIPAYMENT_ACQUIRING_INTEGRATIONS_MISMATCH)
            })
            test('Cannot accept multiple receipts if acquiring cannot group receipts', async () => {
                const { admin, payments, client, acquiringIntegration } = await makePayerAndPayments(2)
                await expectToThrowValidationFailureError(async () => {
                    await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                }, MULTIPAYMENT_CANNOT_GROUP_RECEIPTS)
            })

            test('Can\'t accept receipts with invoices', async () => {
                const { admin, organization, acquiringContext, client, acquiringIntegration, payments } = await makePayerAndPayments()

                await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, { invoiceStatus: CONTEXT_FINISHED_STATUS })

                const [invoice] = await createTestInvoice(admin, organization, {
                    status: INVOICE_STATUS_PUBLISHED,
                    client: { connect: { id: client.user.id } },
                })

                const [invoicePayment] = await createTestPayment(admin, organization, null, acquiringContext, { invoice })

                await expectToThrowGQLError(async () => await createTestMultiPayment(admin, [...payments, invoicePayment], client.user, acquiringIntegration), {
                    code: 'BAD_USER_INPUT',
                    type: 'MULTIPAYMENT_RECEIPTS_WITH_INVOICES_FORBIDDEN',
                    message: 'Receipts and invoices are forbidden to be together',
                    messageForUser: 'api.acquiring.multiPayment.RECEIPTS_WITH_INVOICES_FORBIDDEN',
                })
            })
        })
        describe('Status-dependent model validations', () => {
            test('Cannot change statuses if it\'s transition is not specified', async () => {
                const { admin, payments, client, acquiringIntegration } = await makePayerAndPayments()
                const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration, {
                    status: MULTIPAYMENT_ERROR_STATUS,
                })
                await expectToThrowValidationFailureError(async () => {
                    await updateTestMultiPayment(admin, multiPayment.id, {
                        status: MULTIPAYMENT_DONE_STATUS,
                    })
                }, MULTIPAYMENT_NOT_ALLOWED_TRANSITION)
            })
            describe('Should include all status-required fields for successful transition', () => {
                const requiredPayload = {
                    withdrawnAt: dayjs().toISOString(),
                    cardNumber: getRandomHiddenCard(),
                    paymentWay: 'CARD',
                    transactionId: faker.datatype.uuid(),
                }
                const cases = ['withdrawnAt', 'cardNumber', 'paymentWay', 'transactionId', 'explicitFee', 'explicitServiceCharge']
                test.each(cases)(`Status ${MULTIPAYMENT_DONE_STATUS}, missing %p field`, async (field) => {
                    const { admin, payments, client, acquiringIntegration } = await makePayerAndPayments(1)
                    const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration, {
                        explicitFee: null,
                        explicitServiceCharge: null,
                    })
                    const explicitFee = payments.reduce((acc, cur) => acc.plus(cur.explicitFee || '0'), Big(0)).toString()
                    const explicitServiceCharge = payments.reduce((acc, cur) => acc.plus(cur.explicitServiceCharge || '0'), Big(0)).toString()
                    for (const payment of payments) {
                        await updateTestPayment(admin, payment.id, {
                            status: PAYMENT_DONE_STATUS,
                            advancedAt: dayjs().toISOString(),
                        })
                    }
                    const payload = {
                        ...requiredPayload,
                        explicitFee,
                        explicitServiceCharge,
                    }
                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(admin, multiPayment.id, {
                            status: MULTIPAYMENT_DONE_STATUS,
                            ...omit(payload, field),
                        })
                    }, MULTIPAYMENT_MISSING_REQUIRED_FIELDS)
                })
            })
            describe('Frozen fields cannot be changed', () => {
                const relations = ['integration', 'user']
                const values = ['amountWithoutExplicitFee', 'currencyCode']
                const statuses = [MULTIPAYMENT_INIT_STATUS, MULTIPAYMENT_PROCESSING_STATUS, MULTIPAYMENT_WITHDRAWN_STATUS]
                describe('Relation-fields', () => {
                    const cases = statuses.map(status => {
                        return MULTIPAYMENT_FROZEN_FIELDS[status]
                            .filter(field => relations.includes(field))
                            .map(field => [status, field])
                    }).flat(1)
                    test.each(cases)('Old status: %p, Field: %p', async (status, field) => {
                        const { admin, client, payments, acquiringIntegration } = await makePayerAndPayments()
                        const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration, {
                            status,
                        })
                        await expectToThrowValidationFailureError(async () => {
                            await updateTestMultiPayment(admin, multiPayment.id, {
                                status: MULTIPAYMENT_ERROR_STATUS,
                                [field]: { disconnectAll: true },
                            })
                        }, MULTIPAYMENT_FROZEN_FIELD_INCLUDED)
                    })
                })
                describe('Value-fields', () => {
                    const cases = statuses.map(status => {
                        return MULTIPAYMENT_FROZEN_FIELDS[status]
                            .filter(field => values.includes(field))
                            .map(field => [status, field])
                    }).flat(1)
                    test.each(cases)('Old status: %p, Field: %p', async (status, field) => {
                        const { admin, client, payments, acquiringIntegration } = await makePayerAndPayments()
                        const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration, {
                            status,
                        })
                        await expectToThrowValidationFailureError(async () => {
                            await updateTestMultiPayment(admin, multiPayment.id, {
                                status: MULTIPAYMENT_ERROR_STATUS,
                                [field]: get(multiPayment, field, null),
                            })
                        }, MULTIPAYMENT_FROZEN_FIELD_INCLUDED)
                    })
                })
            })
            describe('Cannot be created if any of payments', () => {
                test('Has not init status', async () => {
                    const { admin, billingReceipts, organization, acquiringContext, client, acquiringIntegration } = await makePayer(1)
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext, {
                        status: PAYMENT_DONE_STATUS,
                    })
                    await expectToThrowValidationFailureError(async () => {
                        await createTestMultiPayment(admin, [payment], client.user, acquiringIntegration)
                    }, MULTIPAYMENT_NON_INIT_PAYMENTS)
                })
                test('Already has multipayment', async () => {
                    const { admin, client, acquiringIntegration, payments } = await makePayerAndPayments()
                    await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                    await expectToThrowValidationFailureError(async () => {
                        await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                    }, MULTIPAYMENT_PAYMENTS_ALREADY_WITH_MP)
                })
            })
            // NOTE: SUM OF FEES AS WELL AS AVAILABILITY OF ALL/NONE IMPLICIT FEES WAS APPROVED BY ALEXANDER
            describe('DONE-status checks', () => {
                const multiPaymentDonePayload = {
                    withdrawnAt: dayjs().toISOString(),
                    cardNumber: getRandomHiddenCard(),
                    paymentWay: 'CARD',
                    transactionId: faker.datatype.uuid(),
                    status: MULTIPAYMENT_DONE_STATUS,
                }
                test('All payments must have done status before moving MP to done', async () => {
                    const { payments, acquiringIntegration, admin, client } = await makePayerAndPayments(2)
                    await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                        canGroupReceipts: true,
                    })
                    const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                    await updateTestPayment(admin, payments[0].id, {
                        status: PAYMENT_DONE_STATUS,
                    })
                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(admin, multiPayment.id, multiPaymentDonePayload)
                    }, MULTIPAYMENT_UNDONE_PAYMENTS)
                })
                const equalityCases = [
                    ['explicitFee', 'explicitServiceCharge', MULTIPAYMENT_EXPLICIT_FEE_MISMATCH],
                    ['explicitServiceCharge', 'explicitFee', MULTIPAYMENT_EXPLICIT_SERVICE_CHARGE_MISMATCH],
                ]
                test.each(equalityCases)('Sum of all Payment\'s %p should be equal to MP one', async (fieldName, zeroFieldName, errorMessage) => {
                    const { payments, acquiringIntegration, admin, client } = await makePayerAndPayments(2)
                    const amount = faker.datatype.number()
                    const multiPaymentFieldValue = Big(amount).plus(payments[1].explicitFee).plus(50).toString()
                    await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                        canGroupReceipts: true,
                    })
                    const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                    await updateTestPayment(admin, payments[0].id, {
                        status: PAYMENT_DONE_STATUS,
                        [fieldName]: String(amount),
                        [zeroFieldName]: '0',
                    })
                    await updateTestPayment(admin, payments[1].id, {
                        status: PAYMENT_DONE_STATUS,
                    })
                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(admin, multiPayment.id, {
                            ...multiPaymentDonePayload,
                            [fieldName]: multiPaymentFieldValue,
                        })
                    }, errorMessage)
                })
                describe('All payments inside single MP should either have or not have', () => {
                    const emptyPayload = {
                        implicitFee: null,
                        serviceFee: null,
                    }
                    const cases = [
                        ['implicit fee', 'implicitFee', MULTIPAYMENT_INCONSISTENT_IMPLICIT_FEE],
                        ['service fee', 'serviceFee', MULTIPAYMENT_INCONSISTENT_SERVICE_FEE],
                    ]
                    test.each(cases)('%p', async (name, fieldName, errorMessage) => {
                        const { admin, billingReceipts, organization, acquiringContext, acquiringIntegration, client } = await makePayer(2)
                        await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                            canGroupReceipts: true,
                        })
                        const [firstPayment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext, emptyPayload)
                        const [secondPayment] = await createTestPayment(admin, organization, billingReceipts[1], acquiringContext, {
                            ...emptyPayload,
                            [fieldName]: '50.0',
                        })

                        const [multiPayment] = await createTestMultiPayment(admin, [firstPayment, secondPayment], client.user, acquiringIntegration)

                        await updateTestPayment(admin, firstPayment.id, { status: PAYMENT_DONE_STATUS })
                        await updateTestPayment(admin, secondPayment.id, { status: PAYMENT_DONE_STATUS })

                        await expectToThrowValidationFailureError(async () => {
                            await updateTestMultiPayment(admin, multiPayment.id, {
                                ...multiPaymentDonePayload,
                            })
                        }, errorMessage)
                    })
                })
                test('If payments implicit fees are specified, their sum should match with multiPayment one', async () => {
                    const { payments, acquiringIntegration, admin, client } = await makePayerAndPayments(2)
                    const implicitFee = Big(payments[0].implicitFee).plus(payments[1].implicitFee).plus(1).toString()
                    await updateTestAcquiringIntegration(admin, acquiringIntegration.id, {
                        canGroupReceipts: true,
                    })
                    const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                    await updateTestPayment(admin, payments[0].id, {
                        status: PAYMENT_DONE_STATUS,
                    })
                    await updateTestPayment(admin, payments[1].id, {
                        status: PAYMENT_DONE_STATUS,
                    })
                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(admin, multiPayment.id, {
                            ...multiPaymentDonePayload,
                            implicitFee,
                        })
                    }, MULTIPAYMENT_IMPLICIT_FEE_MISMATCH)
                })
                test('All payments should not be deleted', async () => {
                    const { admin, payments, client, acquiringIntegration } = await makePayerAndPayments(1)
                    const [multiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                    await updateTestPayment(admin, payments[0].id, {
                        status: PAYMENT_DONE_STATUS,
                        deletedAt: dayjs().toISOString(),
                    })
                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMultiPayment(admin, multiPayment.id, multiPaymentDonePayload)
                    }, MULTIPAYMENT_DELETED_PAYMENTS)
                })
            })
        })
    })
    describe('real-life cases', () => {
        describe('UPS', () => {
            let integrationClient
            let registerMPResult
            beforeEach(async () => {
                const {
                    admin,
                    acquiringIntegration,
                    billingReceipts,
                    serviceConsumer,
                    client,
                } = await makePayer(1)
                integrationClient = await makeClientWithServiceUser()
                await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)
                const [obj] = await registerMultiPaymentByTestClient(client, [
                    { serviceConsumer: { id: serviceConsumer.id }, receipts: [{ id: billingReceipts[0].id }] },
                ], { sender: client.userAttrs.sender })
                registerMPResult = obj
            })
            describe('Successful payment',  () => {
                const cases = [
                    ['Housing and communal services', '100', '0'],
                    ['Not housing and communal services', '0', '100'],
                ]
                test.each(cases)('%p', async (name, explicitServiceCharge, explicitFee) => {
                    // Stage 1. User goes to service and confirm payment with fee / charge...
                    // Meanwhile acquiring integration service move MP and P to PROCESSING and setting explicit fee / charge
                    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
                    const { multiPaymentId } = registerMPResult
                    const payments = await Payment.getAll(integrationClient, {
                        multiPayment: { id: multiPaymentId },
                    })
                    expect(payments).toBeDefined()
                    expect(payments).toHaveLength(1)
                    let [payment] = payments
                    let multiPayment = await MultiPayment.update(integrationClient, multiPaymentId, {
                        dv: 1,
                        sender,
                        status: MULTIPAYMENT_PROCESSING_STATUS,
                        explicitServiceCharge,
                        explicitFee,
                    })
                    expect(multiPayment).toBeDefined()
                    expect(multiPayment).toHaveProperty('status', MULTIPAYMENT_PROCESSING_STATUS)
                    expect(multiPayment).toHaveProperty('explicitFee')
                    expect(Big(multiPayment.explicitFee).eq(explicitFee)).toBeTruthy()
                    expect(Big(multiPayment.explicitServiceCharge).eq(explicitServiceCharge)).toBeTruthy()
                    payment = await Payment.update(integrationClient, payment.id, {
                        dv: 1,
                        sender,
                        status: PAYMENT_PROCESSING_STATUS,
                        explicitServiceCharge,
                        explicitFee,
                    })
                    expect(payment).toBeDefined()
                    expect(payment).toHaveProperty('status', PAYMENT_PROCESSING_STATUS)
                    expect(Big(payment.explicitFee).eq(explicitFee)).toBeTruthy()
                    expect(Big(payment.explicitServiceCharge).eq(explicitServiceCharge)).toBeTruthy()

                    // Stage 2. Our acquiring integration service after detecting successful redirect moving MP and P to WITHDRAWN
                    const transactionTime = dayjs().toISOString()
                    const cardNumber = getRandomHiddenCard()
                    const paymentWay = 'CARD'
                    const transactionId = faker.datatype.uuid()

                    payment = await Payment.update(integrationClient, payment.id, {
                        dv: 1,
                        sender,
                        status: PAYMENT_WITHDRAWN_STATUS,
                    })
                    expect(payment).toBeDefined()
                    expect(payment).toHaveProperty('status', PAYMENT_WITHDRAWN_STATUS)

                    multiPayment = await MultiPayment.update(integrationClient, multiPayment.id, {
                        dv: 1,
                        sender,
                        status: MULTIPAYMENT_WITHDRAWN_STATUS,
                        withdrawnAt: transactionTime,
                        cardNumber,
                        paymentWay,
                        transactionId,
                    })
                    expect(multiPayment).toBeDefined()
                    expect(multiPayment).toHaveProperty('withdrawnAt', transactionTime)
                    expect(multiPayment).toHaveProperty('cardNumber', cardNumber)
                    expect(multiPayment).toHaveProperty('paymentWay', paymentWay)
                    expect(multiPayment).toHaveProperty('transactionId', transactionId)
                    expect(multiPayment).toHaveProperty('status', MULTIPAYMENT_WITHDRAWN_STATUS)

                    // Stage 3. Our acquiring integration service after polling UPS service move everything to DONE
                    payment = await Payment.update(integrationClient, payment.id, {
                        dv: 1,
                        sender,
                        status: PAYMENT_DONE_STATUS,
                        advancedAt: transactionTime,
                    })
                    expect(payment).toBeDefined()
                    expect(payment).toHaveProperty('status', PAYMENT_DONE_STATUS)
                    expect(payment).toHaveProperty('advancedAt', transactionTime)
                    multiPayment = await MultiPayment.update(integrationClient, multiPaymentId, {
                        dv: 1,
                        sender,
                        status: MULTIPAYMENT_DONE_STATUS,
                    })
                    expect(multiPayment).toBeDefined()
                    expect(multiPayment).toHaveProperty('withdrawnAt', transactionTime)
                    expect(multiPayment).toHaveProperty('cardNumber', cardNumber)
                    expect(multiPayment).toHaveProperty('paymentWay', paymentWay)
                    expect(multiPayment).toHaveProperty('transactionId', transactionId)
                    expect(multiPayment).toHaveProperty('status', MULTIPAYMENT_DONE_STATUS)
                })

            })
            test('Payment failed during money processing', async () => {
                // Stage 1. Same as above
                const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
                const { multiPaymentId } = registerMPResult
                const payments = await Payment.getAll(integrationClient, {
                    multiPayment: { id: multiPaymentId },
                })
                const explicitFee = '100.00'
                const explicitServiceCharge = '0'
                let [payment] = payments
                await MultiPayment.update(integrationClient, multiPaymentId, {
                    dv: 1,
                    sender,
                    status: MULTIPAYMENT_PROCESSING_STATUS,
                    explicitFee,
                    explicitServiceCharge,
                })
                await Payment.update(integrationClient, payment.id, {
                    dv: 1,
                    sender,
                    status: PAYMENT_PROCESSING_STATUS,
                    explicitFee,
                    explicitServiceCharge,
                })

                // Stage 2. Our acquiring integration service after polling UPS service move everything to ERROR
                payment = await Payment.update(integrationClient, payment.id, {
                    dv: 1,
                    sender,
                    status: PAYMENT_ERROR_STATUS,
                })
                expect(payment).toBeDefined()
                expect(payment).toHaveProperty('status', PAYMENT_ERROR_STATUS)
                const multiPayment = await MultiPayment.update(integrationClient, multiPaymentId, {
                    dv: 1,
                    sender,
                    status: MULTIPAYMENT_ERROR_STATUS,
                })
                expect(multiPayment).toBeDefined()
                expect(multiPayment).toHaveProperty('status', MULTIPAYMENT_ERROR_STATUS)
            })
        })
        describe('Settlement bank', () => {
            let integrationClient
            let registerMPResult
            beforeEach(async () => {
                const {
                    commonData: { admin, acquiringIntegration, client },
                    batches,
                } = await makePayerWithMultipleConsumers(5, 1)
                integrationClient = await makeClientWithServiceUser()
                await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)
                const payload = batches.map(batch => ({ serviceConsumer: { id: batch.serviceConsumer.id }, receipts: batch.billingReceipts.map(receipt => ({ id: receipt.id })) }))
                const [obj] = await registerMultiPaymentByTestClient(client, payload, { sender: client.userAttrs.sender })
                registerMPResult = obj
            })
            test('Successful combined payment', async () => {
                // Stage 1. User goes to service and confirm payment with fee + charge...
                // Meanwhile acquiring integration service move MP and P to PROCESSING and setting fees and charge

                const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
                const { multiPaymentId } = registerMPResult
                const payments = await Payment.getAll(integrationClient, {
                    multiPayment: { id: multiPaymentId },
                })
                expect(payments).toBeDefined()
                expect(payments).toHaveLength(5)

                for (let i = 0; i < 5; i++) {
                    const payment = payments[i]
                    const updatedPayment = await Payment.update(integrationClient, payment.id, {
                        dv: 1,
                        sender,
                        status: PAYMENT_PROCESSING_STATUS,
                    })
                    expect(updatedPayment).toBeDefined()
                    expect(updatedPayment).toHaveProperty('status', PAYMENT_PROCESSING_STATUS)
                }

                let multiPayment = await MultiPayment.update(integrationClient, multiPaymentId, {
                    dv: 1,
                    sender,
                    status: MULTIPAYMENT_PROCESSING_STATUS,
                })
                expect(multiPayment).toBeDefined()
                expect(multiPayment).toHaveProperty('status', MULTIPAYMENT_PROCESSING_STATUS)

                // Stage 2. Our acquiring integration service after detecting successful redirect moving MP and P to WITHDRAWN
                const transactionTime = dayjs().toISOString()
                const cardNumber = getRandomHiddenCard()
                const paymentWay = 'CARD'
                const transactionId = faker.datatype.uuid()
                for (let i = 0; i < 5; i++) {
                    const payment = payments[i]
                    const updatedPayment = await Payment.update(integrationClient, payment.id, {
                        dv: 1,
                        sender,
                        status: PAYMENT_WITHDRAWN_STATUS,
                    })
                    expect(updatedPayment).toBeDefined()
                    expect(updatedPayment).toHaveProperty('status', PAYMENT_WITHDRAWN_STATUS)
                }
                multiPayment = await MultiPayment.update(integrationClient, multiPayment.id, {
                    dv: 1,
                    sender,
                    status: MULTIPAYMENT_WITHDRAWN_STATUS,
                    withdrawnAt: transactionTime,
                    cardNumber,
                    paymentWay,
                    transactionId,
                })
                expect(multiPayment).toBeDefined()
                expect(multiPayment).toHaveProperty('withdrawnAt', transactionTime)
                expect(multiPayment).toHaveProperty('cardNumber', cardNumber)
                expect(multiPayment).toHaveProperty('paymentWay', paymentWay)
                expect(multiPayment).toHaveProperty('transactionId', transactionId)
                expect(multiPayment).toHaveProperty('status', MULTIPAYMENT_WITHDRAWN_STATUS)

                // Stage 3. On next day after Settlement bank complete payments, acquiring integration account setting everything to done
                for (const payment of payments) {
                    const advancedAt = dayjs().toISOString()
                    const updatedPayment = await Payment.update(integrationClient, payment.id, {
                        dv: 1,
                        sender,
                        status: PAYMENT_DONE_STATUS,
                        advancedAt: advancedAt,
                    })
                    expect(updatedPayment).toBeDefined()
                    expect(updatedPayment).toHaveProperty('status', PAYMENT_DONE_STATUS)
                    expect(updatedPayment).toHaveProperty('advancedAt', advancedAt)
                }
                multiPayment = await MultiPayment.update(integrationClient, multiPaymentId, {
                    dv: 1,
                    sender,
                    status: MULTIPAYMENT_DONE_STATUS,
                })
                expect(multiPayment).toBeDefined()
                expect(multiPayment).toHaveProperty('withdrawnAt', transactionTime)
                expect(multiPayment).toHaveProperty('cardNumber', cardNumber)
                expect(multiPayment).toHaveProperty('paymentWay', paymentWay)
                expect(multiPayment).toHaveProperty('transactionId', transactionId)
                expect(multiPayment).toHaveProperty('status', MULTIPAYMENT_DONE_STATUS)
            })
        })
        test('mobile resident can\'t see his sensitive data in his own MultiPayments', async () => {
            const { admin, payments, acquiringIntegration, client } = await makePayerAndPayments()
            const [createdMultiPayment] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
            // We use raw: true because when using field access, all fields that are not permitted result in error which stops the test
            let { data: { objs: multiPayments } } = await MultiPayment.getAll(client, {}, { raw: true })
            expect(multiPayments).toBeDefined()
            expect(multiPayments).toHaveLength(1)
            const retrievedMultiPayment = multiPayments[0]
            expect(retrievedMultiPayment.id).toBe(createdMultiPayment.id)
            expect(retrievedMultiPayment.implicitFee).toBeNull()
            expect(retrievedMultiPayment.transactionId).toBeNull()
            expect(retrievedMultiPayment.meta).toBeNull()
        })
        describe('payerInfo', () => {
            test('takes info from MultiPayment.user', async () => {
                const {
                    admin,
                    acquiringIntegration,
                    client,
                    payments,
                } = await makePayerAndPayments()

                const user = await UserAdmin.getOne(admin, { id: client.user.id })

                const [{ id: createdMultiPaymentId }] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                const [createdMultiPayment] = await MultiPaymentAdmin.getAll(admin, { id: createdMultiPaymentId })

                // payerInfo took data from user
                expect(createdMultiPayment).toBeDefined()
                expect(createdMultiPayment).toHaveProperty(['payerInfo', 'id'], user.id)
                expect(createdMultiPayment).toHaveProperty(['payerInfo', 'name'], user.name)
                expect(createdMultiPayment).toHaveProperty(['payerInfo', 'email'], (user.isEmailVerified && user.email ? user.email : null) ?? null)
                expect(createdMultiPayment).toHaveProperty(['payerInfo', 'phone'], (user.isPhoneVerified && user.phone ? user.phone : null) ?? null)

                // payerInfo did not took data from createdBy
                expect(createdMultiPayment).toHaveProperty('createdBy')
                expect(createdMultiPayment).toHaveProperty('user')
                expect(createdMultiPayment.createdBy.id).not.toEqual(createdMultiPayment.user.id)
            }) 
            test('email and phone are skipped, if they are not verified', async () => {
                const {
                    admin,
                    acquiringIntegration,
                    client,
                    payments,
                } = await makePayerAndPayments()

                const [{ id: createdMultiPaymentId }] = await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                let multiPayment
                const getMultiPayment = () => MultiPaymentAdmin.getAll(admin, { id: createdMultiPaymentId }).then(multiPayments => multiPayments[0])

                const phone = createTestPhone()
                const email = createTestEmail()

                // 1. phone and email are verified
                await updateTestUser(admin, client.user.id, { phone, email, isPhoneVerified: true, isEmailVerified: true })
                multiPayment = await getMultiPayment()
                expect(multiPayment).toHaveProperty(['payerInfo', 'email'], email)
                expect(multiPayment).toHaveProperty(['payerInfo', 'phone'], phone)

                // 2. email is not verified
                await updateTestUser(admin, client.user.id, { isEmailVerified: false })
                multiPayment = await getMultiPayment()
                expect(multiPayment).toHaveProperty(['payerInfo', 'email'], null)
                expect(multiPayment).toHaveProperty(['payerInfo', 'phone'], phone)
                
                // 3. phone is not verified
                await updateTestUser(admin, client.user.id, { isEmailVerified: false, isPhoneVerified: false })
                multiPayment = await getMultiPayment()
                expect(multiPayment).toHaveProperty(['payerInfo', 'email'], null)
                expect(multiPayment).toHaveProperty(['payerInfo', 'phone'], null)
            })
        })
    })
})
