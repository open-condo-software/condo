/**
 * Generated by `createservice acquiring.CalculateFeeForReceiptService --type queries`
 */
const Big = require('big.js')
const { isNil, get } = require('lodash')

const { GQLError } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, getById, getByCondition } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/acquiring/access/CalculateFeeForReceiptService')
const { GQL_ERRORS: { PAYMENT_AMOUNT_LESS_THAN_MINIMUM } } = require('@condo/domains/acquiring/constants/errors')

const { getAcquiringIntegrationContextFormula, FeeDistribution } = require('../utils/serverSchema/feeDistribution')

const ERRORS = {
    PAYMENT_AMOUNT_LESS_THAN_MINIMUM: {
        ...PAYMENT_AMOUNT_LESS_THAN_MINIMUM,
        mutation: 'registerMultiPaymentForOneReceipt',
    },
}

const CalculateFeeForReceiptService = new GQLCustomSchema('CalculateFeeForReceiptService', {
    types: [
        {
            access: true,
            type: 'input CalculateFeeForReceiptInput { receipt: BillingReceiptWhereUniqueInput!, amount: String! }',
        },
        {
            access: true,
            type: 'type CalculateFeeForReceiptOutput { amountWithoutExplicitFee: String!, explicitFee: String!, explicitServiceCharge: String! }',
        },
    ],
    
    queries: [
        {
            access: access.canCalculateFeeForReceipt,
            schema: 'calculateFeeForReceipt (data: CalculateFeeForReceiptInput!): CalculateFeeForReceiptOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { receipt, amount } = data
                
                const billingReceipt = await getById('BillingReceipt', receipt.id)

                if (isNil(billingReceipt)) {
                    throw new GQLError({
                        ...ERRORS.CANNOT_FIND_BILLING_RECEIPT,
                        messageInterpolation: { missingReceiptId: receipt.id },
                    }, context)
                }

                if (billingReceipt.deletedAt) {
                    throw new GQLError({
                        ...ERRORS.RECEIPT_IS_DELETED,
                        messageInterpolation: { id: billingReceipt.id },
                    }, context)
                }

                if (Big(billingReceipt.toPay).lte(0)) {
                    throw new GQLError({
                        ...ERRORS.RECEIPT_HAVE_NEGATIVE_TO_PAY_VALUE,
                        messageInterpolation: { id: billingReceipt.id },
                    }, context)
                }

                const billingContext = await getById('BillingIntegrationOrganizationContext', billingReceipt.context)
                const billingIntegration = await getById('BillingIntegration', billingContext.integration)
                const acquiringContext = await getByCondition('AcquiringIntegrationContext', { organization: { id: billingContext.organization } })
                const acquiringIntegration = await  getById('AcquiringIntegration', acquiringContext.integration)

                if (acquiringContext.deletedAt) {
                    throw new GQLError(ERRORS.ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED, context)
                }

                if (acquiringIntegration.deletedAt) {
                    throw new GQLError({
                        ...ERRORS.ACQUIRING_INTEGRATION_IS_DELETED,
                        messageInterpolation: { id: acquiringContext.integration },
                    }, context)
                }
                
                if (billingContext.deletedAt) {
                    const failedReceipts = [{ receiptId: billingReceipt.id, contextId: billingReceipt.context }]
                    throw new GQLError({
                        ...ERRORS.BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
                        data: { failedReceipts },
                    }, context)
                }

                const supportedBillingIntegrationsGroup = get(acquiringIntegration, 'supportedBillingIntegrationsGroup')

                if (billingIntegration.group !== supportedBillingIntegrationsGroup) {
                    throw new GQLError({
                        ...ERRORS.ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
                        messageInterpolation: { unsupportedBillingIntegration: billingContext.integration },
                    }, context)
                }

                if (billingIntegration.deletedAt) {
                    const failedReceipts = [{
                        receiptId: billingReceipt.id,
                        integrationId: billingContext.integration,
                    }]
                    throw new GQLError({
                        ...ERRORS.RECEIPT_HAS_DELETED_BILLING_INTEGRATION,
                        data: { failedReceipts },
                    }, context)
                }

                const formula = await getAcquiringIntegrationContextFormula(context, acquiringContext.id)
                const feeCalculator = new FeeDistribution(formula)

                const { type, explicitFee = '0' } = feeCalculator.calculate(amount)
                const explicitFees = type === 'service'
                    ? { explicitServiceCharge: String(explicitFee), explicitFee: '0' }
                    : { explicitServiceCharge: '0', explicitFee: String(explicitFee) }

                const amountToPay = Big(amount)
                    .add(Big(explicitFees.explicitFee))
                    .add(Big(explicitFees.explicitServiceCharge))
                if (acquiringIntegration.minimumPaymentAmount && Big(amountToPay).lt(acquiringIntegration.minimumPaymentAmount)) {
                    throw new GQLError({
                        ...ERRORS.PAYMENT_AMOUNT_LESS_THAN_MINIMUM,
                        messageInterpolation: { minimumPaymentAmount: Big(acquiringIntegration.minimumPaymentAmount).toString() },
                    }, context)
                }

                return {
                    amountWithoutExplicitFee: Big(amount),
                    explicitFee: Big(explicitFees.explicitFee),
                    explicitServiceCharge: Big(explicitFees.explicitServiceCharge),
                }
            },
        },
    ],
    
})

module.exports = {
    CalculateFeeForReceiptService,
}
