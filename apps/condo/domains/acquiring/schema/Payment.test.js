/**
 * Generated by `createschema acquiring.Payment 'amount:Decimal; currencyCode:Text; time:DateTimeUtc; accountNumber:Text; purpose?:Text; receipts:Relationship:BillingReceipt:PROTECT; multiPayment:Relationship:MultiPayment:PROTECT; context:Relationship:AcquiringIntegrationContext:PROTECT;' --force`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const dayjs = require('dayjs')

const { makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowValidationFailureError, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')
const { expectToThrowGQLError } = require('@open-condo/keystone/test.utils')

const {
    PAYMENT_NO_PAIRED_FROZEN_RECEIPT,
    PAYMENT_NO_PAIRED_RECEIPT,
    PAYMENT_CONTEXT_ORGANIZATION_NOT_MATCH,
    PAYMENT_NOT_ALLOWED_TRANSITION,
    PAYMENT_MISSING_REQUIRED_FIELDS,
    PAYMENT_FROZEN_FIELD_INCLUDED,
    PAYMENT_TOO_BIG_IMPLICIT_FEE,
    PAYMENT_NO_PAIRED_CONTEXT,
    PAYMENT_NO_SUPPORTED_CONTEXT,
    PAYMENT_EXPLICIT_FEE_AND_CHARGE_SAME_TIME,
    PAYMENT_OVERRIDING_EXPLICIT_FEES_MUST_BE_EXPLICIT,
} = require('@condo/domains/acquiring/constants/errors')
const {
    PAYMENT_ERROR_STATUS,
    PAYMENT_INIT_STATUS,
    PAYMENT_DONE_STATUS,
    PAYMENT_WITHDRAWN_STATUS,
    PAYMENT_PROCESSING_STATUS,
    PAYMENT_REQUIRED_FIELDS,
    PAYMENT_FROZEN_FIELDS,
} = require('@condo/domains/acquiring/constants/payment')
const {
    Payment,
    createTestPayment,
    updateTestPayment,
    makePayer,
    createTestAcquiringIntegrationAccessRight,
    createTestMultiPayment,
    createTestAcquiringIntegration,
    createTestAcquiringIntegrationContext,
    updateTestAcquiringIntegrationContext,
    makePayerAndPayments,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    createTestBillingIntegration,
} = require('@condo/domains/billing/utils/testSchema')
const { createTestOrganizationEmployee, createTestOrganizationEmployeeRole } = require('@condo/domains/organization/utils/testSchema')
const {
    createTestOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithSupportUser, makeClientWithNewRegisteredAndLoggedInUser, makeClientWithServiceUser } = require('@condo/domains/user/utils/testSchema')


describe('Payment', () => {
    describe('CRUD tests', () => {
        describe('Create', () => {
            test('admin can', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                expect(payment).toBeDefined()
                expect(payment).toHaveProperty('id')
                expect(payment).toHaveProperty(['context', 'id'], acquiringContext.id)
            })
            test('support can\t', async () => {
                const { billingReceipts, acquiringContext, organization } = await makePayer()
                const support = await makeClientWithSupportUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestPayment(support, organization, billingReceipts[0], acquiringContext)
                })
            })
            test('user can\'t', async () => {
                const { billingReceipts, acquiringContext, organization } = await makePayer()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestPayment(client, organization, billingReceipts[0], acquiringContext)
                })
            })
            test('anonymous can\'t', async () => {
                const { billingReceipts, acquiringContext, organization } = await makePayer()
                const anonymous = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestPayment(anonymous, organization, billingReceipts[0], acquiringContext)
                })
            })
        })
        describe('Read', () => {
            test('admin can', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const payments = await Payment.getAll(admin, {}, { sortBy: ['createdAt_DESC'], first: 10 })

                expect(payments).toBeDefined()
                expect(payments).not.toHaveLength(0)
            })
            test('support can', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const support = await makeClientWithSupportUser()
                const payments = await Payment.getAll(support, {}, { sortBy: ['createdAt_DESC'], first: 10 })
                expect(payments).toBeDefined()
                expect(payments).not.toHaveLength(0)
            })
            describe('user', () => {
                describe('resident can see it\'s own payments when it\'s linked to MultiPayment',  () => {
                    test('not linked', async () => {
                        const { admin, billingReceipts, acquiringContext, organization, client } = await makePayer()
                        await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                        const payments = await Payment.getAll(client)
                        expect(payments).toBeDefined()
                        expect(payments).toHaveLength(0)
                    })
                    test('linked', async () => {
                        const { admin, payments: firstPayments, acquiringIntegration: firstAcquiringIntegration, client: firstClient, organization: firstOrganization } = await makePayerAndPayments()
                        const { payments: secondPayments, acquiringIntegration: secondAcquiringIntegration, client: secondClient, organization: secondOrganization } = await makePayerAndPayments()
                        const [firstMultiPayment] = await createTestMultiPayment(admin, firstPayments, firstClient.user, firstAcquiringIntegration)
                        const [secondMultiPayment] = await createTestMultiPayment(admin, secondPayments, secondClient.user, secondAcquiringIntegration)

                        let { data: { objs: firstUserPayments } } = await Payment.getAll(firstClient, {}, { sortBy: ['createdAt_DESC'], first: 10, raw: true })
                        expect(firstUserPayments).toBeDefined()
                        expect(firstUserPayments).toHaveLength(1)
                        expect(firstUserPayments).toHaveProperty(['0', 'multiPayment', 'id'], firstMultiPayment.id)
                        expect(firstUserPayments).toHaveProperty(['0', 'organization', 'id'], firstOrganization.id)
                        let { data: { objs: secondUserPayments } } = await Payment.getAll(secondClient, {}, { sortBy: ['createdAt_DESC'], first: 10, raw: true })
                        expect(secondUserPayments).toBeDefined()
                        expect(secondUserPayments).toHaveLength(1)
                        expect(secondUserPayments).toHaveProperty(['0', 'multiPayment', 'id'], secondMultiPayment.id)
                        expect(secondUserPayments).toHaveProperty(['0', 'organization', 'id'], secondOrganization.id)
                    })
                })
                test('acquiring account can see it\'s own payments', async () => {
                    const { admin, billingReceipts, acquiringContext, organization, acquiringIntegration } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    const {
                        billingReceipts: secondReceipts,
                        acquiringContext: secondContext,
                        organization: secondOrganization,
                    } = await makePayer()
                    await createTestPayment(admin, secondOrganization, secondReceipts[0], secondContext)
                    const integrationClient = await makeClientWithServiceUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                    const payments = await Payment.getAll(integrationClient)
                    expect(payments).toBeDefined()
                    expect(payments).toHaveLength(1)
                    expect(payments).toHaveProperty(['0', 'id'], payment.id)
                })
                test('Employee with `canReadPayments` can see organization payments', async () => {
                    const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                    // Internal payment (received through our service)
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    // External payment (received through billing / file uploading)
                    const [secondPayment] = await createTestPayment(admin, organization)
                    const {
                        billingReceipts: secondReceipts,
                        acquiringContext: secondContext,
                        organization: secondOrganization,
                    } = await makePayer()
                    await createTestPayment(admin, secondOrganization, secondReceipts[0], secondContext)
                    const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                        canReadPayments: true,
                    })

                    const employeeClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestOrganizationEmployee(admin, organization, employeeClient.user, role)
                    const payments = await Payment.getAll(employeeClient)
                    expect(payments).toBeDefined()
                    expect(payments).toHaveLength(2)
                    expect(payments).toEqual(expect.arrayContaining([
                        expect.objectContaining({ id: payment.id }),
                        expect.objectContaining({ id: secondPayment.id }),
                    ]))
                })
                test('can\'t in other cases', async () => {
                    const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                    await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const payments = await Payment.getAll(client)
                    expect(payments).toBeDefined()
                    expect(payments).toHaveLength(0)
                })
            })
            test('anonymous can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const anonymous = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Payment.getAll(anonymous)
                })
            })
        })
        describe('Update', () => {
            test('admin can', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                const payload = {
                    status: PAYMENT_ERROR_STATUS,
                }
                const [updatedPayment] = await updateTestPayment(admin, payment.id, payload)
                expect(updatedPayment).toBeDefined()
                expect(updatedPayment).toEqual(expect.objectContaining(payload))
            })
            test('cannot connect another organization', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [ newOrganization ] = await createTestOrganization(admin)
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                const payload = {
                    organization: { connect: newOrganization.id },
                }
                await catchErrorFrom(async () => {
                    await updateTestPayment(admin, payment.id, payload)
                }, (e) => {
                    expect(e.errors[0].message).toContain('Field "organization" is not defined by type "PaymentUpdateInput"')
                })
            })
            test('cannot disconnect organization', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                await createTestOrganization(admin)
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                const payload = {
                    organization: { disconnectAll: true },
                }
                await catchErrorFrom(async () => {
                    await updateTestPayment(admin, payment.id, payload)
                }, (e) => {
                    expect(e.errors[0].message).toContain('Field "organization" is not defined by type "PaymentUpdateInput"')
                })
            })
            test('support can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                const payload = {}

                const support = await makeClientWithSupportUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestPayment(support, payment.id, payload)
                })
            })
            describe('user',  () => {
                test('acquiring integration can', async () => {
                    const { admin, billingReceipts, acquiringContext, organization, acquiringIntegration } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    const integrationClient = await makeClientWithServiceUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                    const payload = {
                        status: PAYMENT_ERROR_STATUS,
                    }

                    const [updatedPayment] = await updateTestPayment(integrationClient, payment.id, payload)

                    expect(updatedPayment).toBeDefined()
                    expect(updatedPayment).toEqual(expect.objectContaining(payload))
                })
                test('in other cases can\'t', async () => {
                    const { admin, billingReceipts, acquiringContext, organization, client } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    const payload = {}

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestPayment(client, payment.id, payload)
                    })
                })
            })
            test('anonymous can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                const payload = {}

                const anonymousClient = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestPayment(anonymousClient, payment.id, payload)
                })
            })
        })
        describe('Delete', () => {
            test('admin can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Payment.delete(admin, payment.id)
                })
            })
            test('support can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const support = await makeClientWithSupportUser()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Payment.delete(support, payment.id)
                })
            })

            test('user can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization, client } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Payment.delete(client, payment.id)
                })
            })

            test('anonymous can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const anonymousClient = await makeClient()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Payment.delete(anonymousClient, payment.id)
                })
            })
        })
    })
    describe('resolving tests', () => {
        describe('Should resolve missing explicit fee / charge to zero', () => {
            const cases = [
                ['explicitFee', 'explicitServiceCharge'],
                ['explicitServiceCharge', 'explicitFee'],
            ]
            test.each(cases)('%p is specified, %p is missing', async (specifiedField, missingField) => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext, {
                    [specifiedField]: '50.0',
                    [missingField]: null,
                })
                expect(payment).toBeDefined()
                expect(payment).toHaveProperty(specifiedField)
                expect(payment).toHaveProperty(missingField)
                expect(Big(payment[specifiedField]).eq('50')).toBeTruthy()
                expect(Big(payment[missingField]).eq('0')).toBeTruthy()
            })
        })
    })
    describe('validation tests', () => {
        describe('Fields validations', () => {
            test('can be created without context and receipt', async () => {
                const { admin, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization)
                expect(payment).toBeDefined()
                expect(payment).toHaveProperty('id')
                expect(payment).toHaveProperty('context', null)
                expect(payment).toHaveProperty('frozenReceipt', null)
            })
            test('Should have correct dv field (=== 1)', async () => {
                const { admin, organization } = await makePayer()
                await expectToThrowGQLError(async () => await createTestPayment(admin, organization, null, null, {
                    dv: 2,
                }), {
                    'code': 'BAD_USER_INPUT',
                    'type': 'DV_VERSION_MISMATCH',
                    'message': 'Wrong value for data version number',
                    'mutation': 'createPayment',
                    'variable': ['data', 'dv'],
                })
                const [payment] = await createTestPayment(admin, organization, null, null)
                await expectToThrowGQLError(async () => await updateTestPayment(admin, payment.id, {
                    dv: 2,
                }), {
                    'code': 'BAD_USER_INPUT',
                    'type': 'DV_VERSION_MISMATCH',
                    'message': 'Wrong value for data version number',
                    'mutation': 'updatePayment',
                    'variable': ['data', 'dv'],
                })
            })
            describe('Should check for non-negative money fields', () => {
                const cases = [
                    ['amount', '0'], ['amount', '0.00'], ['amount', '-30'], ['amount', '-100.50'],
                    ['implicitFee', '-0.01'], ['implicitFee', '-30'], ['implicitFee', '-10.50'],
                    ['explicitFee', '-0.01'], ['explicitFee', '-30'], ['explicitFee', '-10.50'],
                ]
                test.each(cases)('%p: %p', async (field, amount) => {
                    const { admin, organization } = await makePayer()
                    await expectToThrowValidationFailureError(async () => {
                        await createTestPayment(admin, organization, null, null, {
                            implicitFee: null,
                            explicitFee: null,
                            [field]: amount,
                        })
                    }, 'Specified number has an invalid sign')
                })
            })
            test('Receipt and frozen receipt should be updated at the same time', async () => {
                const { admin, organization, billingReceipts } = await makePayer()
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, billingReceipts[0], null, {
                        frozenReceipt: null,
                    })
                }, PAYMENT_NO_PAIRED_FROZEN_RECEIPT)
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, null, null, {
                        frozenReceipt: { dv: 1, data: billingReceipts[0] },
                    })
                }, PAYMENT_NO_PAIRED_RECEIPT)
            })
            test('context should should have same organization as payment',  async () => {
                const { admin, acquiringContext } = await makePayer()
                const [secondOrganization] = await createTestOrganization(admin)
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, secondOrganization, null, acquiringContext)
                }, PAYMENT_CONTEXT_ORGANIZATION_NOT_MATCH)
            })
            test('Implicit fee cannot be greater than amount', async () => {
                const { admin, organization } = await makePayer()
                const payload = {
                    amount: '100',
                    implicitFee: '105.50',
                }
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, null, null, payload)
                }, PAYMENT_TOO_BIG_IMPLICIT_FEE)
            })
            describe('Explicit fee and explicit service charge', () => {
                test('Only 1 of them can be greater than zero', async () => {
                    const { admin, billingReceipts, acquiringContext, organization, client, acquiringIntegration } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    await createTestMultiPayment(admin, [payment], client.user, acquiringIntegration)

                    await expectToThrowValidationFailureError(async () => {
                        await updateTestPayment(admin, payment.id, {
                            status: PAYMENT_PROCESSING_STATUS,
                            explicitFee: '50',
                            explicitServiceCharge: '50',
                        })
                    }, PAYMENT_EXPLICIT_FEE_AND_CHARGE_SAME_TIME)
                })
                test('Overriding existing values must be explicit', async () => {
                    const { admin, billingReceipts, acquiringContext, organization, client, acquiringIntegration } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext, {
                        explicitFee: '50',
                    })
                    await createTestMultiPayment(admin, [payment], client.user, acquiringIntegration)

                    await expectToThrowValidationFailureError(async () => {
                        await updateTestPayment(admin, payment.id, {
                            status: PAYMENT_PROCESSING_STATUS,
                            explicitServiceCharge: '50',
                        })
                    }, PAYMENT_OVERRIDING_EXPLICIT_FEES_MUST_BE_EXPLICIT)
                })
            })
        })
        describe('Model validation', () => {
            test('Context is required if receipt was specified', async () => {
                const { admin, organization, billingReceipts } = await makePayer()
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, billingReceipts[0], null)
                }, PAYMENT_NO_PAIRED_CONTEXT)
            })
            test('Receipt\'s billing should be supported by acquiring', async () => {
                const { admin, organization, billingReceipts, acquiringContext } = await makePayer()
                const testBillingGroup = faker.random.alpha().toLowerCase()
                await createTestBillingIntegration(admin, { group: testBillingGroup } )
                const [acquiring] = await createTestAcquiringIntegration(admin, { supportedBillingIntegrationsGroup: testBillingGroup })
                await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, {
                    deletedAt: dayjs().toString(),
                })
                const [context] = await createTestAcquiringIntegrationContext(admin, organization, acquiring)
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, billingReceipts[0], context)
                }, PAYMENT_NO_SUPPORTED_CONTEXT)
            })
        })
        describe('Status-dependent model validations', () => {
            test('Cannot change statuses if it\'s transition is not specified', async () => {
                const { admin, organization, acquiringContext, billingReceipts } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext, {
                    status: PAYMENT_ERROR_STATUS,
                })
                await expectToThrowValidationFailureError(async () => {
                    await updateTestPayment(admin, payment.id, {
                        status: PAYMENT_INIT_STATUS,
                    })
                }, PAYMENT_NOT_ALLOWED_TRANSITION)
            })
            describe('Cannot updated payment without specifying required fields', () => {
                const requiredRelations = ['multiPayment', 'context']
                const transitions = [
                    [PAYMENT_INIT_STATUS, PAYMENT_PROCESSING_STATUS],
                    [PAYMENT_INIT_STATUS, PAYMENT_DONE_STATUS],
                    [PAYMENT_INIT_STATUS, PAYMENT_ERROR_STATUS],
                    [PAYMENT_PROCESSING_STATUS, PAYMENT_WITHDRAWN_STATUS],
                ]
                const cases = transitions.map(transition => {
                    return PAYMENT_REQUIRED_FIELDS[transition[1]].map(field => [transition[1], field, transition[0]])
                }).flat(1)
                test.each(cases)('Status: %p, missing field: %p', async (statusTo, field, statusFrom) => {
                    const { admin, organization, acquiringContext, billingReceipts, client, acquiringIntegration } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    if (statusFrom !== PAYMENT_INIT_STATUS) {
                        await createTestMultiPayment(admin, [payment], client.user, acquiringIntegration)
                        const [updatedPayment] = await updateTestPayment(admin, payment.id, {
                            status: statusFrom,
                        })
                        expect(updatedPayment).toBeDefined()
                    }

                    const fieldValue = requiredRelations.includes(field) ? { disconnectAll: true } : null

                    await expectToThrowValidationFailureError(async () => {
                        await updateTestPayment(admin, payment.id, {
                            status: statusTo,
                            [field]: fieldValue,
                        })
                    }, PAYMENT_MISSING_REQUIRED_FIELDS)
                })
            })
            describe('Cannot update frozen fields', () => {
                const nonUpdatableFields = ['organization']
                const relationFields = ['organization', 'context', 'multiPayment', 'receipt']
                const valueFields = ['amount', 'currencyCode', 'period', 'accountNumber', 'recipientBic', 'recipientBankAccount']
                // NOTE: Cannot transit from other statuses, so checking only this ones
                const statuses = [PAYMENT_INIT_STATUS, PAYMENT_PROCESSING_STATUS]
                describe('Value-fields', () => {
                    const fieldCases = Object.keys(PAYMENT_FROZEN_FIELDS)
                        .filter(status => statuses.includes(status))
                        .map(status => {
                            const frozenFields = PAYMENT_FROZEN_FIELDS[status]
                                .filter(field => valueFields.includes(field))
                            return frozenFields.map(field => [status, field])
                        }).flat(1)
                    test.each(fieldCases)('From: %p, field: %p', async (status, field) => {
                        const { payments, admin, client, acquiringIntegration } = await makePayerAndPayments()
                        await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                        const [payment] = payments
                        if (payment.status !== status) {
                            await updateTestPayment(admin, payment.id, {
                                status,
                            })
                        }
                        await expectToThrowValidationFailureError(async () => {
                            await updateTestPayment(admin, payment.id, {
                                status: PAYMENT_ERROR_STATUS,
                                [field]: payment[field],
                            })
                        }, PAYMENT_FROZEN_FIELD_INCLUDED)
                    })
                })
                describe('Relation-fields', () => {
                    const relationCases = Object.keys(PAYMENT_FROZEN_FIELDS)
                        .filter(status => statuses.includes(status))
                        .map(status => {
                            const frozenFields = PAYMENT_FROZEN_FIELDS[status]
                                .filter(field => !nonUpdatableFields.includes(field))
                                .filter(field => relationFields.includes(field))
                            return frozenFields.map(field => [status, field])
                        }).flat(1)
                    test.each(relationCases)('From: %p, relation: %p', async (status, field) => {
                        const { payments, admin, client, acquiringIntegration } = await makePayerAndPayments()
                        await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                        const [payment] = payments
                        if (payment.status !== status) {
                            await updateTestPayment(admin, payment.id, {
                                status,
                            })
                        }
                        await expectToThrowValidationFailureError(async () => {
                            await updateTestPayment(admin, payment.id, {
                                status: PAYMENT_ERROR_STATUS,
                                [field]: { disconnectAll: true },
                            })
                        }, PAYMENT_FROZEN_FIELD_INCLUDED)
                    })
                })
            })
        })
    })
    describe('real-life cases', () => {
        test('mobile app requests payments by user and can\'t see sensitive data', async () => {
            const { admin, payments: firstPayments, acquiringIntegration: firstAcquiringIntegration, client: firstClient } = await makePayerAndPayments()
            await createTestMultiPayment(admin, firstPayments, firstClient.user, firstAcquiringIntegration)

            let { data: { objs: firstUserPayments } } = await Payment.getAll(firstClient, {}, { sortBy: ['createdAt_DESC'], first: 10, raw: true })
            const firstUserPayment = firstUserPayments[0]
            expect(firstUserPayment).toBeDefined()
            expect(firstUserPayment.status).toBeDefined()
            expect(firstUserPayment.amount).toBeDefined()
            expect(firstUserPayment.explicitFee).toBeDefined()
            expect(firstUserPayment.currencyCode).toBeDefined()
            expect(firstUserPayment.accountNumber).toBeDefined()
            expect(firstUserPayment.implicitFee).toBeNull()
            expect(firstUserPayment.frozenReceipt).toBeNull()
            expect(firstUserPayment.context).toBeNull()
        })
    })
})
