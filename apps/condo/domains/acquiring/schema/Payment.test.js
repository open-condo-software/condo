/**
 * Generated by `createschema acquiring.Payment 'amount:Decimal; currencyCode:Text; time:DateTimeUtc; accountNumber:Text; purpose?:Text; receipts:Relationship:BillingReceipt:PROTECT; multiPayment:Relationship:MultiPayment:PROTECT; context:Relationship:AcquiringIntegrationContext:PROTECT;' --force`
 */

const { makePayerAndPayments } = require('../utils/testSchema')
const { createTestOrganizationEmployee, createTestOrganizationEmployeeRole } = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithSupportUser, makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')
const { makeClient } = require('@core/keystone/test.utils')

const {
    Payment,
    createTestPayment,
    updateTestPayment,
    makePayer,
    createTestAcquiringIntegrationAccessRight,
    createTestMultiPayment,
    createTestAcquiringIntegration,
    createTestAcquiringIntegrationContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    createTestBillingIntegration,
} = require('@condo/domains/billing/utils/testSchema')
const {
    createTestOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowValidationFailureError,
} = require('@condo/domains/common/utils/testSchema')
const { DV_UNKNOWN_VERSION_ERROR } = require('@condo/domains/common/constants/errors')
const { PAYMENT_ERROR_STATUS, PAYMENT_INIT_STATUS, PAYMENT_PROCESSING_STATUS, PAYMENT_REQUIRED_FIELDS, PAYMENT_FROZEN_FIELDS } = require('@condo/domains/acquiring/constants/payment')
const {
    PAYMENT_NO_PAIRED_FROZEN_RECEIPT,
    PAYMENT_NO_PAIRED_RECEIPT,
    PAYMENT_CONTEXT_ORGANIZATION_NOT_MATCH,
    PAYMENT_NOT_ALLOWED_TRANSITION,
    PAYMENT_MISSING_REQUIRED_FIELDS,
    PAYMENT_FROZEN_FIELD_INCLUDED,
    PAYMENT_TOO_BIG_IMPLICIT_FEE,
    PAYMENT_NO_PAIRED_CONTEXT,
    PAYMENT_NO_SUPPORTED_CONTEXT,
} = require('@condo/domains/acquiring/constants/errors')

describe('Payment', () => {
    describe('CRUD tests', () => {
        describe('Create', () => {
            test('admin can', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                expect(payment).toBeDefined()
                expect(payment).toHaveProperty('id')
                expect(payment).toHaveProperty(['context', 'id'], acquiringContext.id)
            })
            test('support can\t', async () => {
                const { billingReceipts, acquiringContext, organization } = await makePayer()
                const support = await makeClientWithSupportUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestPayment(support, organization, billingReceipts[0], acquiringContext)
                })
            })
            test('user can\'t', async () => {
                const { billingReceipts, acquiringContext, organization } = await makePayer()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestPayment(client, organization, billingReceipts[0], acquiringContext)
                })
            })
            test('anonymous can\'t', async () => {
                const { billingReceipts, acquiringContext, organization } = await makePayer()
                const anonymous = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestPayment(anonymous, organization, billingReceipts[0], acquiringContext)
                })
            })
        })
        describe('Read', () => {
            test('admin can', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const payments = await Payment.getAll(admin)
                expect(payments).toBeDefined()
                expect(payments).not.toHaveLength(0)
            })
            test('support can', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const support = await makeClientWithSupportUser()
                const payments = await Payment.getAll(support)
                expect(payments).toBeDefined()
                expect(payments).not.toHaveLength(0)
            })
            describe('user', () => {
                describe('resident can see it\'s own payments when it\'s linked to MultiPayment',  () => {
                    test('not linked', async () => {
                        const { admin, billingReceipts, acquiringContext, organization, client } = await makePayer()
                        await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                        const payments = await Payment.getAll(client)
                        expect(payments).toBeDefined()
                        expect(payments).toHaveLength(0)
                    })
                    test('linked', async () => {
                        const { admin, payments: firstPayments, acquiringIntegration: firstAcquiringIntegration, client: firstClient } = await makePayerAndPayments()
                        const { payments: secondPayments, acquiringIntegration: secondAcquiringIntegration, client: secondClient } = await makePayerAndPayments()
                        const [firstMultiPayment] = await createTestMultiPayment(admin, firstPayments, firstClient.user, firstAcquiringIntegration)
                        const [secondMultiPayment] = await createTestMultiPayment(admin, secondPayments, secondClient.user, secondAcquiringIntegration)

                        let { data: { objs: firstUserPayments } } = await Payment.getAll(firstClient, {}, { raw:true })
                        expect(firstUserPayments).toBeDefined()
                        expect(firstUserPayments).toHaveLength(1)
                        expect(firstUserPayments).toHaveProperty(['0', 'multiPayment', 'id'], firstMultiPayment.id)
                        let { data: { objs: secondUserPayments } } = await Payment.getAll(secondClient, {}, { raw:true })
                        expect(secondUserPayments).toBeDefined()
                        expect(secondUserPayments).toHaveLength(1)
                        expect(secondUserPayments).toHaveProperty(['0', 'multiPayment', 'id'], secondMultiPayment.id)
                    })
                })
                test('acquiring account can see it\'s own payments', async () => {
                    const { admin, billingReceipts, acquiringContext, organization, acquiringIntegration } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    const {
                        billingReceipts: secondReceipts,
                        acquiringContext: secondContext,
                        organization: secondOrganization,
                    } = await makePayer()
                    await createTestPayment(admin, secondOrganization, secondReceipts[0], secondContext)
                    const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                    const payments = await Payment.getAll(integrationClient)
                    expect(payments).toBeDefined()
                    expect(payments).toHaveLength(1)
                    expect(payments).toHaveProperty(['0', 'id'], payment.id)
                })
                test('Employee with `canReadPayments` can see organization payments', async () => {
                    const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                    // Internal payment (received through our service)
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    // External payment (received through billing / file uploading)
                    const [secondPayment] = await createTestPayment(admin, organization)
                    const {
                        billingReceipts: secondReceipts,
                        acquiringContext: secondContext,
                        organization: secondOrganization,
                    } = await makePayer()
                    await createTestPayment(admin, secondOrganization, secondReceipts[0], secondContext)
                    const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                        canReadPayments: true,
                    })

                    const employeeClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestOrganizationEmployee(admin, organization, employeeClient.user, role)
                    const payments = await Payment.getAll(employeeClient)
                    expect(payments).toBeDefined()
                    expect(payments).toHaveLength(2)
                    expect(payments).toEqual(expect.arrayContaining([
                        expect.objectContaining({ id: payment.id }),
                        expect.objectContaining({ id: secondPayment.id }),
                    ]))
                })
                test('can\'t in other cases', async () => {
                    const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                    await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const payments = await Payment.getAll(client)
                    expect(payments).toBeDefined()
                    expect(payments).toHaveLength(0)
                })
            })
            test('anonymous can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const anonymous = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Payment.getAll(anonymous)
                })
            })
        })
        describe('Update', () => {
            test('admin can', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                const payload = {
                    status: PAYMENT_ERROR_STATUS,
                }
                const [updatedPayment] = await updateTestPayment(admin, payment.id, payload)
                expect(updatedPayment).toBeDefined()
                expect(updatedPayment).toEqual(expect.objectContaining(payload))
            })
            test('support can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                const payload = {}

                const support = await makeClientWithSupportUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestPayment(support, payment.id, payload)
                })
            })
            describe('user',  () => {
                test('acquiring integration can', async () => {
                    const { admin, billingReceipts, acquiringContext, organization, acquiringIntegration } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    const integrationClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, integrationClient.user)

                    const payload = {
                        status: PAYMENT_ERROR_STATUS,
                    }

                    const [updatedPayment] = await updateTestPayment(integrationClient, payment.id, payload)

                    expect(updatedPayment).toBeDefined()
                    expect(updatedPayment).toEqual(expect.objectContaining(payload))
                })
                test('in other cases can\'t', async () => {
                    const { admin, billingReceipts, acquiringContext, organization, client } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    const payload = {}

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestPayment(client, payment.id, payload)
                    })
                })
            })
            test('anonymous can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                const payload = {}

                const anonymousClient = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestPayment(anonymousClient, payment.id, payload)
                })
            })
        })
        describe('Delete', () => {
            test('admin can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Payment.delete(admin, payment.id)
                })
            })
            test('support can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const support = await makeClientWithSupportUser()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Payment.delete(support, payment.id)
                })
            })

            test('user can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization, client } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Payment.delete(client, payment.id)
                })
            })

            test('anonymous can\'t', async () => {
                const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)

                const anonymousClient = await makeClient()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Payment.delete(anonymousClient, payment.id)
                })
            })
        })
    })
    describe('validation tests', () => {
        describe('Fields validations', () => {
            test('can be created without context and receipt', async () => {
                const { admin, organization } = await makePayer()
                const [payment] = await createTestPayment(admin, organization)
                expect(payment).toBeDefined()
                expect(payment).toHaveProperty('id')
                expect(payment).toHaveProperty('context', null)
                expect(payment).toHaveProperty('frozenReceipt', null)
            })
            test('Should have correct dv field (=== 1)', async () => {
                const { admin, organization } = await makePayer()
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, null, null, {
                        dv: 2,
                    }, DV_UNKNOWN_VERSION_ERROR)
                })
                const [payment] = await createTestPayment(admin, organization, null, null)
                await expectToThrowValidationFailureError(async () => {
                    await updateTestPayment(admin, payment.id, {
                        dv: 2,
                    })
                }, DV_UNKNOWN_VERSION_ERROR)
            })
            describe('Should check for non-negative money fields', () => {
                const cases = [
                    ['amount', '0'], ['amount', '0.00'], ['amount', '-30'], ['amount', '-100.50'],
                    ['implicitFee', '-0.01'], ['implicitFee', '-30'], ['implicitFee', '-10.50'],
                    ['explicitFee', '-0.01'], ['explicitFee', '-30'], ['explicitFee', '-10.50'],
                ]
                test.each(cases)('%p: %p', async (field, amount) => {
                    const { admin, organization } = await makePayer()
                    await expectToThrowValidationFailureError(async () => {
                        await createTestPayment(admin, organization, null, null, {
                            implicitFee: null,
                            explicitFee: null,
                            [field]: amount,
                        })
                    }, 'Specified number has an invalid sign')
                })
            })
            test('Receipt and frozen receipt should be updated at the same time', async () => {
                const { admin, organization, billingReceipts } = await makePayer()
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, billingReceipts[0], null, {
                        frozenReceipt: null,
                    })
                }, PAYMENT_NO_PAIRED_FROZEN_RECEIPT)
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, null, null, {
                        frozenReceipt: { dv: 1, data: billingReceipts[0] },
                    }, PAYMENT_NO_PAIRED_RECEIPT)
                })
            })
            test('context should should have same organization as payment',  async () => {
                const { admin, acquiringContext } = await makePayer()
                const [secondOrganization] = await createTestOrganization(admin)
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, secondOrganization, null, acquiringContext)
                }, PAYMENT_CONTEXT_ORGANIZATION_NOT_MATCH)
            })
            test('Implicit fee cannot be greater than amount', async () => {
                const { admin, organization } = await makePayer()
                const payload = {
                    amount: '100',
                    implicitFee: '105.50',
                }
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, null, null, payload)
                }, PAYMENT_TOO_BIG_IMPLICIT_FEE)
            })
        })
        describe('Model validation', () => {
            test('Context is required if receipt was specified', async () => {
                const { admin, organization, billingReceipts } = await makePayer()
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, billingReceipts[0], null)
                }, PAYMENT_NO_PAIRED_CONTEXT)
            })
            test('Receipt\'s billing should be supported by acquiring', async () => {
                const { admin, organization, billingReceipts } = await makePayer()
                const [billing] = await createTestBillingIntegration(admin)
                const [acquiring] = await createTestAcquiringIntegration(admin, [billing])
                const [context] = await createTestAcquiringIntegrationContext(admin, organization, acquiring)
                await expectToThrowValidationFailureError(async () => {
                    await createTestPayment(admin, organization, billingReceipts[0], context)
                }, PAYMENT_NO_SUPPORTED_CONTEXT)
            })
        })
        describe('Status-dependent model validations', () => {
            test('Cannot change statuses if it\'s transition is not specified', async () => {
                const { admin, organization, acquiringContext, billingReceipts } = await makePayer()
                const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext, {
                    status: PAYMENT_ERROR_STATUS,
                })
                await expectToThrowValidationFailureError(async () => {
                    await updateTestPayment(admin, payment.id, {
                        status: PAYMENT_INIT_STATUS,
                    })
                }, PAYMENT_NOT_ALLOWED_TRANSITION)
            })
            describe('Cannot updated payment without specifying required fields', () => {
                const cases = Object.keys(PAYMENT_REQUIRED_FIELDS).map(status => {
                    return PAYMENT_REQUIRED_FIELDS[status].map(field => [status, field])
                }).flat(1)
                test.each(cases)('Status: %p,  missing field: %p', async (status, field) => {
                    const { admin, organization, acquiringContext, billingReceipts } = await makePayer()
                    const [payment] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
                    await expectToThrowValidationFailureError(async () => {
                        await updateTestPayment(admin, payment.id, {
                            status,
                            [field]: null,
                        })
                    }, PAYMENT_MISSING_REQUIRED_FIELDS)
                })
            })
            describe('Cannot update frozen fields', () => {
                const relationFields = ['organization', 'context', 'multiPayment', 'receipt']
                const valueFields = ['amount', 'currencyCode', 'period', 'accountNumber']
                // NOTE: Cannot transit from other statuses, so checking only this ones
                const statuses = [PAYMENT_INIT_STATUS, PAYMENT_PROCESSING_STATUS]
                describe('Value-fields', async () => {
                    const fieldCases = Object.keys(PAYMENT_FROZEN_FIELDS)
                        .filter(status => statuses.includes(status))
                        .map(status => {
                            const frozenFields = PAYMENT_FROZEN_FIELDS[status]
                                .filter(field => valueFields.includes(field))
                            return frozenFields.map(field => [status, field])
                        }).flat(1)
                    test.each(fieldCases)('From: %p, field: %p', async (status, field) => {
                        const { payments, admin, client, acquiringIntegration } = await makePayerAndPayments()
                        await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                        const [payment] = payments
                        if (payment.status !== status) {
                            await updateTestPayment(admin, payment.id, {
                                status,
                            })
                        }
                        await expectToThrowValidationFailureError(async () => {
                            await updateTestPayment(admin, payment.id, {
                                status: PAYMENT_ERROR_STATUS,
                                [field]: payment[field],
                            })
                        }, PAYMENT_FROZEN_FIELD_INCLUDED)
                    })
                })
                describe('Relation-fields', () => {
                    const relationCases = Object.keys(PAYMENT_FROZEN_FIELDS)
                        .filter(status => statuses.includes(status))
                        .map(status => {
                            const frozenFields = PAYMENT_FROZEN_FIELDS[status]
                                .filter(field => relationFields.includes(field))
                            return frozenFields.map(field => [status, field])
                        }).flat(1)
                    test.each(relationCases)('From: %p, relation: %p', async (status, field) => {
                        const { payments, admin, client, acquiringIntegration } = await makePayerAndPayments()
                        await createTestMultiPayment(admin, payments, client.user, acquiringIntegration)
                        const [payment] = payments
                        if (payment.status !== status) {
                            await updateTestPayment(admin, payment.id, {
                                status,
                            })
                        }
                        await expectToThrowValidationFailureError(async () => {
                            await updateTestPayment(admin, payment.id, {
                                status: PAYMENT_ERROR_STATUS,
                                [field]: { disconnectAll: true },
                            })
                        }, PAYMENT_FROZEN_FIELD_INCLUDED)
                    })
                })
            })
        })
    })
    describe('real-life cases', () => {
        test('mobile app requests payments by user and can\'t see sensitive data', async () => {
            const { admin, payments: firstPayments, acquiringIntegration: firstAcquiringIntegration, client: firstClient } = await makePayerAndPayments()
            await createTestMultiPayment(admin, firstPayments, firstClient.user, firstAcquiringIntegration)

            let { data: { objs: firstUserPayments } } = await Payment.getAll(firstClient, {}, { raw:true })
            const firstUserPayment = firstUserPayments[0]
            expect(firstUserPayment).toBeDefined()
            expect(firstUserPayment.status).toBeDefined()
            expect(firstUserPayment.amount).toBeDefined()
            expect(firstUserPayment.explicitFee).toBeDefined()
            expect(firstUserPayment.currencyCode).toBeDefined()
            expect(firstUserPayment.accountNumber).toBeDefined()
            expect(firstUserPayment.implicitFee).toBeNull()
            expect(firstUserPayment.frozenReceipt).toBeNull()
            expect(firstUserPayment.context).toBeNull()
        })
    })
})
