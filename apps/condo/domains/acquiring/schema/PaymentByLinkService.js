/**
 * Generated by `createservice acquiring.PaymentByLinkService`
 */

const { get } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { createInstance } = require('@open-condo/keystone/plugins/utils/address-service-client')
const { GQLCustomSchema, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/acquiring/access/PaymentByLinkService')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { registerMultiPaymentForOneReceipt, registerMultiPaymentForVirtualReceipt } = require('@condo/domains/acquiring/utils/serverSchema')
const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const { BankAccount } = require('@condo/domains/banking/utils/serverSchema')
const { validateQRCode, BillingReceipt, BillingIntegrationOrganizationContext, BillingRecipient } = require('@condo/domains/billing/utils/serverSchema')
const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const { Property } = require('@condo/domains/property/utils/serverSchema')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    ADDRESS_IS_INVALID: {
        mutation: 'paymentByLink',
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Provided address did not match any FIAS address',
    },
    BANK_ACCOUNT_IS_INVALID: {
        mutation: 'paymentByLink',
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Provided bank account is not in the system',
    },
    NO_BILLING_RECEIPTS_FOUND: {
        mutation: 'paymentByLink',
        code: INTERNAL_ERROR,
        type: NOT_FOUND,
        message: 'No Billing Receipts were found for provided accounts',
    },
}

const PaymentByLinkService = new GQLCustomSchema('PaymentByLinkService', {
    types: [
        {
            access: true,
            type: 'input PaymentByLinkInput { dv: Int!, sender: SenderFieldInput!, qrCode: String! }',
        },
        {
            access: true,
            type: 'type PaymentByLinkOutput { multiPaymentId: ID!, address: String!, unitName: String!, accountNumber: String! }',
        },
    ],

    mutations: [
        {
            access: access.canPaymentByLink,
            schema: 'paymentByLink(data: PaymentByLinkInput!): PaymentByLinkOutput',
            resolver: async (parent, args, context) => {
                const { data: { dv, sender, qrCode } } = args

                // Stage 0: validate QR code and normalize address
                const { qrCodeFields: { PersonalAcc, BIC, PayerAddress, lastName, paymPeriod, Sum, PayeeINN, PersAcc } } = await validateQRCode(context, { dv, sender, qrCode })
                const addressServiceClient = createInstance({ address: PayerAddress })
                const normalizedAddress = await addressServiceClient.search(PayerAddress, { extractUnit: true })

                if (!normalizedAddress.addressKey) throw new GQLError(ERRORS.ADDRESS_IS_INVALID, context)

                // Stage 1: find properties by addressKey
                const properties = await Property.getAll(context, {
                    addressKey: normalizedAddress.addressKey,
                    deletedAt: null,
                })

                // Stage 2: find organizations with valid contexts and make contexts map
                const validIntegrationContexts = await BillingIntegrationOrganizationContext.getAll(context, {
                    organization: { id_in: properties.map((item) => item.organization.id), deletedAt: null },
                    status: CONTEXT_FINISHED_STATUS,
                    deletedAt: null,
                })

                const validAcquiringContexts = await AcquiringIntegrationContext.getAll(context, {
                    organization: { id_in: properties.map((item) => item.organization.id), deletedAt: null },
                    status: CONTEXT_FINISHED_STATUS,
                    deletedAt: null,
                })

                const validOrganizationIds = []
                const contextsMap = {}

                for (const integrationContext of validIntegrationContexts) {
                    for (const acquiringContext of validAcquiringContexts) {
                        const orgId = get(integrationContext, ['organization', 'id'])
                        if (orgId === get(acquiringContext, ['organization', 'id'])) {
                            contextsMap[integrationContext.id] = acquiringContext.id
                            validOrganizationIds.push(orgId)
                        }
                    }
                }

                // Stage 3: make sure PersonalAccount is in our system (either in BankAccount or in BillingRecipient)
                const bankAccounts = await BankAccount.getAll(context, {
                    number: PersonalAcc,
                    organization: { id_in: validOrganizationIds, deletedAt: null },
                    routingNumber: BIC,
                    deletedAt: null,
                })

                if (bankAccounts.length < 1) {
                    const billingRecipients = await BillingRecipient.getAll(context, {
                        context: { id_in: validIntegrationContexts.map((context) => context.id), deletedAt: null },
                        bankAccount: PersonalAcc,
                        deletedAt: null,
                    })

                    if (billingRecipients.length < 1) throw new GQLError(ERRORS.BANK_ACCOUNT_IS_INVALID, context)
                }


                // Stage 4: find BillingReceipt with provided Personal Accounts and period
                const period = `${paymPeriod.split('.')[1]}-${paymPeriod.split('.')[0]}-01`

                const billingReceipt = await BillingReceipt.getAll(context, {
                    account: { number: PersAcc, deletedAt: null },
                    receiver: { bankAccount: PersonalAcc, deletedAt: null },
                    period,
                    deletedAt: null,
                })

                // if period matches we use found receipt to create MultiPayment
                let multiPaymentId
                if (billingReceipt.length === 1) {
                    const { multiPaymentId: id } = await registerMultiPaymentForOneReceipt(context, {
                        dv, sender,
                        receipt: { id: billingReceipt[0].id },
                        acquiringIntegrationContext: { id: contextsMap[get(billingReceipt[0], ['context', 'id'])] },
                    })
                    multiPaymentId = id
                } else {

                    // check if there is an older receipt
                    const billingReceipt = await BillingReceipt.getAll(context, {
                        account: { number: PersAcc, deletedAt: null },
                        receiver: { bankAccount: PersonalAcc, deletedAt: null },
                        deletedAt: null,
                    }, {
                        sortBy: ['period_DESC'],
                        first: 1,
                    })

                    // if no receipts -> no payment
                    if (billingReceipt.length === 0) throw new GQLError(ERRORS.NO_BILLING_RECEIPTS_FOUND, context)

                    // find acquiring context and routing number from older receipt
                    // TODO: check context status (can be invalid or old)
                    const billingIntegrationContext = await getById('BillingIntegrationOrganizationContext', billingReceipt[0].context.id)
                    const acquiringContext = await AcquiringIntegrationContext.getAll(context, {
                        organization: { id: billingIntegrationContext.organization.id, deletedAt: null },
                        status: CONTEXT_FINISHED_STATUS,
                        deletedAt: null,
                    })
                    const bankAccount = await BankAccount.getAll(context, {
                        organization: { id: billingIntegrationContext.organization.id, deletedAt: null },
                        deletedAt: null,
                    })

                    const { multiPaymentId: id } = await registerMultiPaymentForVirtualReceipt(context, {
                        dv, sender,
                        receipt: {
                            currencyCode: bankAccount[0].currencyCode,
                            amount: Sum,
                            period,
                            recipient: {
                                routingNumber: bankAccount[0].routingNumber,
                                bankAccount: PersAcc,
                                accountNumber: PersonalAcc,
                            },
                        },
                        acquiringIntegrationContext: {
                            id: acquiringContext[0].id,
                        },
                    })

                    multiPaymentId = id
                }

                return {
                    multiPaymentId,
                    address: normalizedAddress.address,
                    unitName: normalizedAddress.addressMeta.unitName,
                    accountNumber: PersonalAcc,
                }
            },
        },
    ],
})

module.exports = {
    PaymentByLinkService,
}
