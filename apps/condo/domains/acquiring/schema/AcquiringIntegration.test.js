/**
 * Generated by `createschema acquiring.AcquiringIntegration 'name:Text;'`
 */

const { faker } = require('@faker-js/faker')

const { makeLoggedInAdminClient, makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowGQLError,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowValidationFailureError,
} = require('@open-condo/keystone/test.utils')

const { AcquiringIntegration, createTestAcquiringIntegration, updateTestAcquiringIntegration } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBillingIntegration } = require('@condo/domains/billing/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

const { SUPPORTED_BILLING_INTEGRATION_GROUP_DOESNT_EXIST_ERROR } = require('../constants/errors')

describe('AcquiringIntegration', () => {
    let admin
    let support
    let user
    let anonymous
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
        // NOTE: If no billings in db no test won't work because of toplenboren's grouping :)
        await createTestBillingIntegration(admin)

    })
    describe('CRUD tests', () => {
        describe('create',  () => {
            test('user can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestAcquiringIntegration(user)
                })
            })
            test('anonymous can\'t', async () => {
                const anonymousClient = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestAcquiringIntegration(anonymousClient)
                })
            })
            test('support can', async () => {
                const [integration, attrs] = await createTestAcquiringIntegration(support)
                expect(integration).toEqual(expect.objectContaining({
                    name: attrs.name,
                }))
            })
            test('admin can', async () => {
                const [integration, attrs] = await createTestAcquiringIntegration(admin, { canGroupReceipts: true })
                expect(integration).toEqual(expect.objectContaining({
                    name: attrs.name,
                    canGroupReceipts: true,
                }))
            })
        })
        describe('read', () => {
            let acquiring
            beforeAll(async () => {
                [acquiring] = await createTestAcquiringIntegration(admin)
            })
            test('user can', async () => {
                const integrations = await AcquiringIntegration.getAll(user, { id: acquiring.id })
                expect(integrations).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: acquiring.id }),
                ]))
            })
            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await AcquiringIntegration.getAll(anonymous, {})
                })
            })
            test('support can', async () => {
                const integrations = await AcquiringIntegration.getAll(support, { id: acquiring.id })
                expect(integrations).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: acquiring.id }),
                ]))
            })
            test('admin can', async () => {
                const integrations = await AcquiringIntegration.getAll(admin, { id: acquiring.id })
                expect(integrations).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: acquiring.id }),
                ]))
            })
        })
        describe('update',  () => {
            let integration
            beforeAll(async () => {
                [integration] = await createTestAcquiringIntegration(admin)
            })
            test('user can\'t', async () => {
                const payload = {}
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestAcquiringIntegration(user, integration.id, payload)
                })
            })
            test('anonymous can\'t', async () => {
                const payload = {}
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestAcquiringIntegration(anonymous, integration.id, payload)
                })
            })
            test('support can', async () => {
                const name = `${faker.company.companyName(0)} acquiring`
                const payload = { name }
                const [newIntegration] = await updateTestAcquiringIntegration(support, integration.id, payload)
                expect(newIntegration).toEqual(expect.objectContaining(payload))
            })
            test('admin can', async () => {
                const name = `${faker.company.companyName(0)} acquiring`
                const payload = { name }
                const [newIntegration] = await updateTestAcquiringIntegration(admin, integration.id, payload)
                expect(newIntegration).toEqual(expect.objectContaining(payload))
            })
        })
        describe('hard delete',  () => {
            let integrationToDelete
            beforeAll(async () => {
                [integrationToDelete] = await createTestAcquiringIntegration(admin)
            })
            test('user can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AcquiringIntegration.delete(user, integrationToDelete.id)
                })
            })
            test('anonymous can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AcquiringIntegration.delete(anonymous, integrationToDelete.id)
                })
            })
            test('support can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AcquiringIntegration.delete(support, integrationToDelete.id)
                })
            })
            test('admin can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AcquiringIntegration.delete(admin, integrationToDelete.id)
                })
            })
        })
    })
    describe('Validation tests', () => {
        test('Fails if supportedBillingIntegrationGroup doesn\'t exist', async () => {
            const NON_EXISTING_INTEGRATION_NAME = 'nonexistingbillingintegrationname'
            await expectToThrowValidationFailureError(async () => await createTestAcquiringIntegration(support, {
                supportedBillingIntegrationsGroup: NON_EXISTING_INTEGRATION_NAME,
            }), SUPPORTED_BILLING_INTEGRATION_GROUP_DOESNT_EXIST_ERROR)
            const [integration] = await createTestAcquiringIntegration(support)
            await expectToThrowValidationFailureError(async () => await updateTestAcquiringIntegration(support, integration.id, {
                supportedBillingIntegrationsGroup: NON_EXISTING_INTEGRATION_NAME,
            }), SUPPORTED_BILLING_INTEGRATION_GROUP_DOESNT_EXIST_ERROR)
        })
        test('Should have correct dv field (=== 1)', async () => {
            await expectToThrowGQLError(async () => await createTestAcquiringIntegration(admin, {
                dv: 2,
            }), {
                'code': 'BAD_USER_INPUT',
                'type': 'DV_VERSION_MISMATCH',
                'message': 'Wrong value for data version number',
                'mutation': 'createAcquiringIntegration',
                'variable': ['data', 'dv'],
            })
            const [integration] = await createTestAcquiringIntegration(admin)
            await expectToThrowGQLError(async () => await updateTestAcquiringIntegration(admin, integration.id, {
                dv: 2,
            }), {
                'code': 'BAD_USER_INPUT',
                'type': 'DV_VERSION_MISMATCH',
                'message': 'Wrong value for data version number',
                'mutation': 'updateAcquiringIntegration',
                'variable': ['data', 'dv'],
            })
        })
    })
    describe('Resolving tests', () => {
        test('vatPercentOptions is comma separated string of numbers', async () => {
            const [integration] = await createTestAcquiringIntegration(admin, { vatPercentOptions: '0,10,13.3,20' })
            expect(integration.vatPercentOptions).toBe('0,10,13.3,20')

            const [updatedIntegration1] = await updateTestAcquiringIntegration(admin, integration.id, { vatPercentOptions: '.,hello,0,,50,oops,.7,..|,' })
            expect(updatedIntegration1.vatPercentOptions).toBe('0,50,0.7')

            const [updatedIntegration2] = await updateTestAcquiringIntegration(admin, integration.id)
            expect(updatedIntegration2.vatPercentOptions).toBe('0,50,0.7')
        })
    })
})
