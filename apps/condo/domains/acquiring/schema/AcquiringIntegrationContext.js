/**
 * Generated by `createschema acquiring.AcquiringIntegrationContext 'integration:Relationship:AcquiringIntegration:PROTECT; organization:Relationship:Organization:PROTECT; settings:Json; state:Json;' --force`
 */

const get = require('lodash/get')
const isEmpty = require('lodash/isEmpty')
const isNull = require('lodash/isNull')
const isUndefined = require('lodash/isUndefined')

const { GQLError } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById } = require('@open-condo/keystone/schema')
const { webHooked } = require('@open-condo/webhooks/plugins')

const access = require('@condo/domains/acquiring/access/AcquiringIntegrationContext')
const {
    CONTEXT_FINISHED_STATUS,
    CONTEXT_VERIFICATION_STATUS,
    CONTEXT_STATUSES,
    TAX_REGIMES,
    TAX_REGIME_SIMPLE,
} = require('@condo/domains/acquiring/constants/context')
const {
    GQL_ERRORS,
} = require('@condo/domains/acquiring/constants/errors')
const { CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT } = require('@condo/domains/acquiring/constants/errors')
const { FEE_DISTRIBUTION_SCHEMA_FIELD } = require('@condo/domains/acquiring/schema/fields/json/FeeDistribution')
const { RECIPIENT_FIELD } = require('@condo/domains/acquiring/schema/fields/Recipient')
const { ACQUIRING_INTEGRATION_FIELD } = require('@condo/domains/acquiring/schema/fields/relations')
const { AcquiringIntegrationContext: ContextServerSchema } = require('@condo/domains/acquiring/utils/serverSchema')
const { PERCENT_FIELD } = require('@condo/domains/common/schema/fields')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { hasValidJsonStructure } = require('@condo/domains/common/utils/validation.utils')
const { MarketSetting } = require('@condo/domains/marketplace/utils/serverSchema')
const { STATUS_FIELD, getStatusDescription, getStatusResolver } = require('@condo/domains/miniapp/schema/fields/context')

const AcquiringIntegrationContext = new GQLListSchema('AcquiringIntegrationContext', {
    schemaDoc: 'Object, which links `acquiring integration` with `service provider`, and stores additional data for it\'s proper work',
    fields: {
        integration: {
            ...ACQUIRING_INTEGRATION_FIELD,
            access: {
                create: true,
                read: true,
                update: false,
            },
        },

        organization: {
            schemaDoc: 'Service provider (organization)',
            type: 'Relationship',
            ref: 'Organization',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
            access: {
                create: true,
                read: true,
                update: false,
            },
        },

        settings: {
            schemaDoc: 'Settings that are required for acquiring to work properly. The data structure depends on the integration and defined here',
            type: 'Json',
            sensitive: true,
            isRequired: true,
            hooks: {
                validateInput: (args) => {
                    hasValidJsonStructure(args, true, 1, {})
                },
            },
        },

        state: {
            schemaDoc: 'The current state of the integration process. Some integration need to store past state here, additional data and etc.',
            type: 'Json',
            sensitive: true,
            isRequired: true,
            hooks: {
                validateInput: (args) => {
                    hasValidJsonStructure(args, true, 1, {})
                },
            },
        },

        reason: {
            schemaDoc: 'Contract number and date. Basis for invoicing',
            type: 'Text',
            isRequired: false,
            access: {
                read: true,
                create: access.canManageReasonAndFeeFields,
                update: access.canManageReasonAndFeeFields,
            },
        },

        invoiceReason: {
            schemaDoc: 'Contract number and date. Basis for invoicing',
            type: 'Text',
            isRequired: false,
            access: {
                read: true,
                create: access.canManageReasonAndFeeFields,
                update: access.canManageReasonAndFeeFields,
            },
        },

        email: {
            schemaDoc: 'Acquiring payments report will be sent to this email',
            type: 'Text',
            sensitive: true,
            kmigratorOptions: { null: true, unique: false },
            hooks: {
                resolveInput: ({ resolvedData }) => {
                    if (isUndefined(resolvedData.email)) return undefined
                    if (isNull(resolvedData.email) || isEmpty(resolvedData.email)) return null
                    return normalizeEmail(resolvedData['email']) || resolvedData['email']
                },
            },
        },

        invoiceEmails: {
            schemaDoc: 'Email addresses separated by `,` or `;` Acquiring payments report will be sent to this emails',
            type: 'Text',
            sensitive: true,
            kmigratorOptions: { null: true, unique: false },
            hooks: {
                resolveInput: ({ resolvedData }) => {
                    if (isUndefined(resolvedData.invoiceEmails)) return undefined
                    if (isNull(resolvedData.invoiceEmails) || isEmpty(resolvedData.invoiceEmails)) return null

                    const emails = get(resolvedData, 'invoiceEmails', '').split(/[,;]/).map(normalizeEmail).filter(Boolean)
                    if (emails.length > 0) {
                        return emails.join(',')
                    }

                    return resolvedData['invoiceEmails']
                },
            },
        },

        recipient: {
            ...RECIPIENT_FIELD,
            schemaDoc: 'Requisites from agreement. Are used for invoicing in case of not confirmed billing recipient in receipt',
            isRequired: false,
        },

        invoiceRecipient: {
            ...RECIPIENT_FIELD,
            schemaDoc: 'Requisites from agreement. Are used for invoicing of invoices.',
            isRequired: false,
        },

        implicitFeeDistributionSchema: {
            ...FEE_DISTRIBUTION_SCHEMA_FIELD,
            isRequired: false,
            schemaDoc: 'Contains information about the default distribution of implicit fee. Each part is paid by the recipient organization on deducted from payment amount. If part exists then explicit part with the same name from AcquiringIntegration.explicitFeeDistributionSchema is ignored',
            access: {
                read: true,
                create: access.canManageReasonAndFeeFields,
                update: access.canManageReasonAndFeeFields,
            },
        },

        invoiceImplicitFeeDistributionSchema: {
            ...FEE_DISTRIBUTION_SCHEMA_FIELD,
            isRequired: false,
            schemaDoc: 'Contains information about the default distribution of implicit fee. Each part is paid by the recipient organization on deducted from payment amount. If part exists then explicit part with the same name from AcquiringIntegration.explicitFeeDistributionSchema is ignored',
        },

        status: {
            ...STATUS_FIELD,
            options: CONTEXT_STATUSES,
            schemaDoc: getStatusDescription('AcquiringIntegration'),
            hooks: {
                resolveInput: getStatusResolver('AcquiringIntegration', 'integration'),
            },
            access: {
                read: true,
                create: access.canManageStatusField,
                update: access.canManageStatusField,
            },
            graphQLReturnType: 'String',
        },

        invoiceStatus: {
            ...STATUS_FIELD,
            options: CONTEXT_STATUSES,
            schemaDoc: getStatusDescription('AcquiringIntegration'),
            hooks: {
                resolveInput: getStatusResolver('AcquiringIntegration', 'integration'),
            },
            access: {
                read: true,
                create: access.canManageStatusField,
                update: access.canManageStatusField,
            },
            graphQLReturnType: 'String',
        },

        invoiceTaxRegime: {
            schemaDoc: 'The regime of counting taxes for company',
            isRequired: false,
            type: 'Select',
            dataType: 'string',
            options: TAX_REGIMES,
        },

        invoiceVatPercent: {
            ...PERCENT_FIELD,
            schemaDoc: 'The percentage of VAT. Depends of integrations settings (see AcquiringIntegration.vatPercentOptions)',
        },

        invoiceSalesTaxPercent: PERCENT_FIELD,
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), webHooked(), analytical()],
    access: {
        read: access.canReadAcquiringIntegrationContexts,
        create: access.canManageAcquiringIntegrationContexts,
        update: access.canManageAcquiringIntegrationContexts,
        delete: false,
        auth: true,
    },
    hooks: {
        validateInput: async ({ resolvedData, context, addValidationError, existingItem }) => {
            if (
                (
                    [CONTEXT_FINISHED_STATUS, CONTEXT_VERIFICATION_STATUS].includes(resolvedData['status'])
                    || [CONTEXT_FINISHED_STATUS, CONTEXT_VERIFICATION_STATUS].includes(resolvedData['invoiceStatus'])
                )
                && !resolvedData['deletedAt']
            ) {
                const newItem = { ...existingItem, ...resolvedData }
                const activeContextsCount = await ContextServerSchema.count(context, {
                    organization: { id: newItem['organization'] },
                    OR: [
                        { status_in: [CONTEXT_FINISHED_STATUS, CONTEXT_VERIFICATION_STATUS] },
                        { invoiceStatus_in: [CONTEXT_FINISHED_STATUS, CONTEXT_VERIFICATION_STATUS] },
                    ],
                    deletedAt: null,
                    id_not: newItem['id'],
                })
                if (activeContextsCount) {
                    addValidationError(CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)
                }
            }

            /*
             vatPercent constraints:
             __________________________________
                       |  vatPercent values
             taxRegime | 20% | 10% |  0% | null
             ---------------------------------
             general   |  +  |  +  |  +  |  +
             simple    |  +  |  +  |  -  |  +
             ----------------------------------
             */
            const nextData = { ...existingItem, ...resolvedData }
            const nextVat = get(nextData, 'invoiceVatPercent')
            const resolvedVat = get(resolvedData, 'invoiceVatPercent')
            const nextTaxRegime = get(nextData, 'invoiceTaxRegime')

            if (nextTaxRegime === TAX_REGIME_SIMPLE && nextVat === '0') {
                throw new GQLError(GQL_ERRORS.TAX_REGIME_AND_VAT_NOT_MATCHED, context)
            }

            if (resolvedVat) {
                const nextIntegrationId = get(nextData, 'integration')
                const integration = await getById('AcquiringIntegration', nextIntegrationId)
                const possibleVatValues = (get(integration, 'vatPercentOptions', '') || '').split(',').filter(Boolean)

                if (possibleVatValues.length > 0 && !possibleVatValues.includes(resolvedVat)) {
                    throw new GQLError(GQL_ERRORS.VAT_NOT_MATCHED_TO_INTEGRATION_OPTIONS(integration.vatPercentOptions), context)
                }
            }
        },
        afterChange: async ({ operation, originalInput, context, updatedItem }) => {
            const orgId = updatedItem.organization

            if (updatedItem.invoiceStatus === CONTEXT_FINISHED_STATUS && !updatedItem.deletedAt) {
                const [marketSetting] = await MarketSetting.getAll(context, {
                    deletedAt: null,
                    organization: { id: orgId },
                })
                if (!marketSetting) await MarketSetting.create(context, {
                    organization: { connect: { id: orgId } },
                    dv: originalInput.dv,
                    sender: originalInput.sender,
                })
            }

        },
    },
})

module.exports = {
    AcquiringIntegrationContext,
}
