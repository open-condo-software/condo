/**
 * Generated by `createschema acquiring.AcquiringIntegrationContext 'integration:Relationship:AcquiringIntegration:PROTECT; organization:Relationship:Organization:PROTECT; settings:Json; state:Json;' --force`
 */

const { Text, Relationship } = require('@keystonejs/fields')
const { isEmpty, isUndefined, isNull } = require('lodash')

const { Json } = require('@open-condo/keystone/fields')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')
const { webHooked } = require('@open-condo/webhooks/plugins')

const access = require('@condo/domains/acquiring/access/AcquiringIntegrationContext')
const { CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT } = require('@condo/domains/acquiring/constants/errors')
const { FEE_DISTRIBUTION_SCHEMA_FIELD } = require('@condo/domains/acquiring/schema/fields/json/FeeDistribution')
const { RECIPIENT_FIELD } = require('@condo/domains/acquiring/schema/fields/Recipient')
const { ACQUIRING_INTEGRATION_FIELD } = require('@condo/domains/acquiring/schema/fields/relations')
const { AcquiringIntegrationContext: ContextServerSchema } = require('@condo/domains/acquiring/utils/serverSchema')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { hasValidJsonStructure } = require('@condo/domains/common/utils/validation.utils')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { STATUS_FIELD, getStatusDescription, getStatusResolver } = require('@condo/domains/miniapp/schema/fields/context')


const AcquiringIntegrationContext = new GQLListSchema('AcquiringIntegrationContext', {
    schemaDoc: 'Object, which links `acquiring integration` with `service provider`, and stores additional data for it\'s proper work',
    fields: {
        integration: {
            ...ACQUIRING_INTEGRATION_FIELD,
            access: {
                create: true,
                read: true,
                update: false,
            },
        },

        organization: {
            schemaDoc: 'Service provider (organization)',
            type: Relationship,
            ref: 'Organization',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
            access: {
                create: true,
                read: true,
                update: false,
            },
        },

        settings: {
            schemaDoc: 'Settings that are required for acquiring to work properly. The data structure depends on the integration and defined here',
            type: Json,
            isRequired: true,
            hooks: {
                validateInput: (args) => {
                    hasValidJsonStructure(args, true, 1, {})
                },
            },
        },

        state: {
            schemaDoc: 'The current state of the integration process. Some integration need to store past state here, additional data and etc.',
            type: Json,
            isRequired: true,
            hooks: {
                validateInput: (args) => {
                    hasValidJsonStructure(args, true, 1, {})
                },
            },
        },

        reason: {
            schemaDoc: 'Contract number and date. Basis for invoicing',
            type: Text,
            isRequired: false,
        },

        email: {
            schemaDoc: 'Acquiring payments report will be sent to this email',
            type: Text,
            kmigratorOptions: { null: true, unique: false },
            hooks: {
                resolveInput: ({ resolvedData }) => {
                    if (isUndefined(resolvedData.email)) return undefined
                    if (isNull(resolvedData.email) || isEmpty(resolvedData.email)) return null
                    return normalizeEmail(resolvedData['email']) || resolvedData['email']
                },
            },
        },

        recipient: {
            ...RECIPIENT_FIELD,
            schemaDoc: 'Requisites from agreement. Are used for invoicing in case of not confirmed billing recipient in receipt',
            isRequired: false,
        },

        implicitFeeDistributionSchema: {
            ...FEE_DISTRIBUTION_SCHEMA_FIELD,
            isRequired: false,
            schemaDoc: 'Contains information about the default distribution of implicit fee. Each part is paid by the recipient organization on deducted from payment amount. If part exists then explicit part with the same name from AcquiringIntegration.explicitFeeDistributionSchema is ignored',
        },
        status: {
            ...STATUS_FIELD,
            schemaDoc: getStatusDescription('AcquiringIntegration'),
            hooks: {
                resolveInput: getStatusResolver('AcquiringIntegration', 'integration'),
            },
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), webHooked()],
    access: {
        read: access.canReadAcquiringIntegrationContexts,
        create: access.canManageAcquiringIntegrationContexts,
        update: access.canManageAcquiringIntegrationContexts,
        delete: false,
        auth: true,
    },
    hooks: {
        validateInput: async ({ resolvedData, context, addValidationError, existingItem }) => {
            if (resolvedData['status'] === CONTEXT_FINISHED_STATUS && !resolvedData['deletedAt']) {
                const newItem = { ...existingItem, ...resolvedData }
                const activeContexts = await ContextServerSchema.getAll(context, {
                    organization: { id: newItem['organization'] },
                    status: CONTEXT_FINISHED_STATUS,
                    deletedAt: null,
                })
                if (activeContexts.length) {
                    addValidationError(CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)
                }
            }
        },
    },
})

module.exports = {
    AcquiringIntegrationContext,
}
