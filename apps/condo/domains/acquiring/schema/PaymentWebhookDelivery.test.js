/**
 * Generated by `createschema acquiring.PaymentWebhookDelivery`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const {
    makeLoggedInAdminClient,
    makeClient,
    UUID_RE,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    initTestExpressApp,
    getTestExpressApp,
    waitFor,
} = require('@open-condo/keystone/test.utils')

const {
    PAYMENT_WEBHOOK_DELIVERY_STATUS_PENDING,
    PAYMENT_WEBHOOK_DELIVERY_STATUS_SUCCESS,
    PAYMENT_WEBHOOK_DELIVERY_STATUS_FAILED,
} = require('@condo/domains/acquiring/constants/webhook')
const {
    PaymentWebhookDelivery,
    createTestPaymentWebhookDelivery,
    updateTestPaymentWebhookDelivery,
    makePayer,
    createTestPayment,
    updateTestPayment,
    createTestMultiPayment,
    createTestPaymentWebhookDeliveryWhiteListItem,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    WebhookTestingApp,
    SUCCESS_WEBHOOK_PATH,
    FAIL_WEBHOOK_PATH_500,
    clearReceivedWebhooks,
    getReceivedWebhooks,
} = require('@condo/domains/acquiring/utils/testSchema/WebhookTestingApp')
const { updateTestBillingReceipt } = require('@condo/domains/billing/utils/testSchema')
const { createTestOrganizationEmployeeRole, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')


describe('PaymentWebhookDelivery', () => {
    let adminClient
    let payment
    let organization

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()

        // Create a payment for testing
        const payerData = await makePayer()
        organization = payerData.organization
        const [createdPayment] = await createTestPayment(
            adminClient,
            payerData.organization,
            payerData.billingReceipts[0],
            payerData.acquiringContext
        )
        payment = createdPayment
    })

    describe('CRUD', () => {
        describe('Create', () => {
            test('admin: can create PaymentWebhookDelivery', async () => {
                const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

                expect(delivery.id).toMatch(UUID_RE)
                expect(delivery.payment.id).toBe(payment.id)
                expect(delivery.previousStatus).toBe('CREATED')
                expect(delivery.newStatus).toBe('PROCESSING')
                expect(delivery.callbackUrl).toBe('https://example.com/webhook')
                expect(delivery.status).toBe(PAYMENT_WEBHOOK_DELIVERY_STATUS_PENDING)
                expect(delivery.attempt).toBe(0)
            })

            test('anonymous: cannot create PaymentWebhookDelivery', async () => {
                const anonymousClient = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestPaymentWebhookDelivery(anonymousClient, payment)
                })
            })

            test('user: cannot create PaymentWebhookDelivery', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestPaymentWebhookDelivery(userClient, payment)
                })
            })
        })

        describe('Read', () => {
            test('admin: can read PaymentWebhookDelivery', async () => {
                const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

                const readDelivery = await PaymentWebhookDelivery.getOne(adminClient, { id: delivery.id })

                expect(readDelivery.id).toBe(delivery.id)
            })

            test('anonymous: cannot read PaymentWebhookDelivery', async () => {
                const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)
                const anonymousClient = await makeClient()

                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await PaymentWebhookDelivery.getOne(anonymousClient, { id: delivery.id })
                })
            })

            test('employee with canReadPayments: can read PaymentWebhookDelivery', async () => {
                const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canReadPayments: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role, {
                    isAccepted: true,
                })

                const readDelivery = await PaymentWebhookDelivery.getOne(userClient, { id: delivery.id })
                expect(readDelivery.id).toBe(delivery.id)
            })

            test('employee without canReadPayments: cannot read PaymentWebhookDelivery', async () => {
                const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canReadPayments: false,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role, {
                    isAccepted: true,
                })

                const readDelivery = await PaymentWebhookDelivery.getOne(userClient, { id: delivery.id })
                expect(readDelivery).toBeUndefined()
            })
        })

        describe('Update', () => {
            test('admin: can update PaymentWebhookDelivery', async () => {
                const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

                const [updatedDelivery] = await updateTestPaymentWebhookDelivery(adminClient, delivery.id, {
                    status: PAYMENT_WEBHOOK_DELIVERY_STATUS_SUCCESS,
                    httpStatusCode: 200,
                    responseBody: '{"received":true}',
                    sentAt: dayjs().toISOString(),
                })

                expect(updatedDelivery.status).toBe(PAYMENT_WEBHOOK_DELIVERY_STATUS_SUCCESS)
                expect(updatedDelivery.httpStatusCode).toBe(200)
                expect(updatedDelivery.responseBody).toBe('{"received":true}')
            })

            test('anonymous: cannot update PaymentWebhookDelivery', async () => {
                const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)
                const anonymousClient = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestPaymentWebhookDelivery(anonymousClient, delivery.id, {
                        status: PAYMENT_WEBHOOK_DELIVERY_STATUS_SUCCESS,
                    })
                })
            })

            test('user: cannot update PaymentWebhookDelivery', async () => {
                const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestPaymentWebhookDelivery(userClient, delivery.id, {
                        status: PAYMENT_WEBHOOK_DELIVERY_STATUS_SUCCESS,
                    })
                })
            })
        })

        describe('Delete', () => {
            test('admin: cannot delete PaymentWebhookDelivery', async () => {
                const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentWebhookDelivery.delete(adminClient, delivery.id)
                })
            })
        })
    })

    describe('Fields', () => {
        test('should set default status to pending', async () => {
            const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

            expect(delivery.status).toBe(PAYMENT_WEBHOOK_DELIVERY_STATUS_PENDING)
        })

        test('should set default attempt to 0', async () => {
            const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

            expect(delivery.attempt).toBe(0)
        })

        test('should allow setting failed status', async () => {
            const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

            const [updatedDelivery] = await updateTestPaymentWebhookDelivery(adminClient, delivery.id, {
                status: PAYMENT_WEBHOOK_DELIVERY_STATUS_FAILED,
                errorMessage: 'Connection refused',
            })

            expect(updatedDelivery.status).toBe(PAYMENT_WEBHOOK_DELIVERY_STATUS_FAILED)
            expect(updatedDelivery.errorMessage).toBe('Connection refused')
        })

        test('should increment attempt on update', async () => {
            const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

            const [updatedDelivery] = await updateTestPaymentWebhookDelivery(adminClient, delivery.id, {
                attempt: 1,
            })

            expect(updatedDelivery.attempt).toBe(1)
        })
    })

    describe('Querying', () => {
        test('can query by status', async () => {
            const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

            const deliveries = await PaymentWebhookDelivery.getAll(adminClient, {
                status: PAYMENT_WEBHOOK_DELIVERY_STATUS_PENDING,
                id: delivery.id,
            })

            expect(deliveries).toHaveLength(1)
            expect(deliveries[0].id).toBe(delivery.id)
        })

        test('can query by payment', async () => {
            const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment)

            const deliveries = await PaymentWebhookDelivery.getAll(adminClient, {
                payment: { id: payment.id },
                id: delivery.id,
            })

            expect(deliveries).toHaveLength(1)
            expect(deliveries[0].id).toBe(delivery.id)
        })

        test('can query by nextRetryAt', async () => {
            const now = dayjs()
            const [delivery] = await createTestPaymentWebhookDelivery(adminClient, payment, {
                nextRetryAt: now.toISOString(),
            })

            const deliveries = await PaymentWebhookDelivery.getAll(adminClient, {
                nextRetryAt_lte: now.add(1, 'minute').toISOString(),
                id: delivery.id,
            })

            expect(deliveries).toHaveLength(1)
            expect(deliveries[0].id).toBe(delivery.id)
        })
    })

    describe('Real-life webhook delivery', () => {
        let testExpressAppBaseUrl

        initTestExpressApp('WebhookTesting', new WebhookTestingApp().prepareMiddleware())

        beforeAll(async () => {
            const testExpressApp = getTestExpressApp('WebhookTesting')
            testExpressAppBaseUrl = testExpressApp.baseUrl
        })

        beforeEach(() => {
            clearReceivedWebhooks()
        })

        test('webhook is delivered when payment status changes (BillingReceipt with callback URL)', async () => {
            const uniqueId = faker.random.alphaNumeric(10)
            const callbackUrl = `${testExpressAppBaseUrl}${SUCCESS_WEBHOOK_PATH}/${uniqueId}`

            // Add URL to whitelist
            await createTestPaymentWebhookDeliveryWhiteListItem(adminClient, {
                url: callbackUrl,
                isEnabled: true,
            })

            // Create payer and update receipt with callback URL
            const payerData = await makePayer()
            const receipt = payerData.billingReceipts[0]

            // Update receipt with callback URL
            await updateTestBillingReceipt(adminClient, receipt.id, {
                statusChangeCallbackUrl: callbackUrl,
            })

            // Create payment for the receipt
            const [testPayment] = await createTestPayment(
                adminClient,
                payerData.organization,
                receipt,
                payerData.acquiringContext
            )

            // Create MultiPayment (required before changing payment status)
            await createTestMultiPayment(adminClient, [testPayment], payerData.client.user, payerData.acquiringIntegration)

            // Update payment status to trigger webhook
            await updateTestPayment(adminClient, testPayment.id, {
                status: 'PROCESSING',
            })

            // Wait for webhook to be delivered
            await waitFor(async () => {
                const webhooks = getReceivedWebhooks()
                return webhooks.length > 0
            }, { timeout: 10000, interval: 500 })

            // Verify webhook was received
            const webhooks = getReceivedWebhooks()
            expect(webhooks.length).toBeGreaterThanOrEqual(1)

            const webhook = webhooks[0]
            expect(webhook.headers['x-condo-signature']).toBeTruthy()
            expect(webhook.headers['x-condo-delivery-id']).toBeTruthy()
            expect(webhook.body.data).toHaveProperty('paymentId', testPayment.id)
            expect(webhook.body.data).toHaveProperty('previousStatus', 'CREATED')
            expect(webhook.body.data).toHaveProperty('newStatus', 'PROCESSING')

            // Verify delivery record was updated to success
            await waitFor(async () => {
                const deliveries = await PaymentWebhookDelivery.getAll(adminClient, {
                    payment: { id: testPayment.id },
                    status: PAYMENT_WEBHOOK_DELIVERY_STATUS_SUCCESS,
                })
                return deliveries.length > 0
            }, { timeout: 10000, interval: 500 })

            const deliveries = await PaymentWebhookDelivery.getAll(adminClient, {
                payment: { id: testPayment.id },
            })
            expect(deliveries.length).toBeGreaterThanOrEqual(1)

            const successDelivery = deliveries.find(d => d.status === PAYMENT_WEBHOOK_DELIVERY_STATUS_SUCCESS)
            expect(successDelivery).toBeTruthy()
            expect(successDelivery.httpStatusCode).toBe(200)
        })

        test('webhook delivery fails and records error on 500 response', async () => {
            const uniqueId = faker.random.alphaNumeric(10)
            const callbackUrl = `${testExpressAppBaseUrl}${FAIL_WEBHOOK_PATH_500}/${uniqueId}`

            // Add URL to whitelist
            await createTestPaymentWebhookDeliveryWhiteListItem(adminClient, {
                url: callbackUrl,
                isEnabled: true,
            })

            // Create payer and update receipt with callback URL
            const payerData = await makePayer()
            const receipt = payerData.billingReceipts[0]

            await updateTestBillingReceipt(adminClient, receipt.id, {
                statusChangeCallbackUrl: callbackUrl,
            })

            // Create payment for the receipt
            const [testPayment] = await createTestPayment(
                adminClient,
                payerData.organization,
                receipt,
                payerData.acquiringContext
            )

            // Create MultiPayment (required before changing payment status)
            await createTestMultiPayment(adminClient, [testPayment], payerData.client.user, payerData.acquiringIntegration)

            // Update payment status to trigger webhook
            await updateTestPayment(adminClient, testPayment.id, {
                status: 'PROCESSING',
            })

            // Wait for webhook attempt
            await waitFor(async () => {
                const webhooks = getReceivedWebhooks()
                return webhooks.length > 0
            }, { timeout: 10000, interval: 500 })

            // Wait for delivery record to be updated
            await waitFor(async () => {
                const deliveries = await PaymentWebhookDelivery.getAll(adminClient, {
                    payment: { id: testPayment.id },
                    attempt_gte: 1,
                })
                return deliveries.length > 0
            }, { timeout: 10000, interval: 500 })

            // Verify delivery record shows failure
            const deliveries = await PaymentWebhookDelivery.getAll(adminClient, {
                payment: { id: testPayment.id },
            })
            expect(deliveries.length).toBeGreaterThanOrEqual(1)

            const delivery = deliveries[0]
            expect(delivery.httpStatusCode).toBe(500)
            expect(delivery.attempt).toBeGreaterThanOrEqual(1)
            // Should still be pending for retry or failed
            expect([PAYMENT_WEBHOOK_DELIVERY_STATUS_PENDING, PAYMENT_WEBHOOK_DELIVERY_STATUS_FAILED]).toContain(delivery.status)
        })

        test('webhook payload contains correct signature for verification', async () => {
            const uniqueId = faker.random.alphaNumeric(10)
            const callbackUrl = `${testExpressAppBaseUrl}${SUCCESS_WEBHOOK_PATH}/${uniqueId}`

            // Add URL to whitelist
            await createTestPaymentWebhookDeliveryWhiteListItem(adminClient, {
                url: callbackUrl,
                isEnabled: true,
            })

            // Create payer and update receipt with callback URL
            const payerData = await makePayer()
            const receipt = payerData.billingReceipts[0]

            await updateTestBillingReceipt(adminClient, receipt.id, {
                statusChangeCallbackUrl: callbackUrl,
            })

            // Create payment for the receipt
            const [testPayment] = await createTestPayment(
                adminClient,
                payerData.organization,
                receipt,
                payerData.acquiringContext
            )

            // Create MultiPayment (required before changing payment status)
            await createTestMultiPayment(adminClient, [testPayment], payerData.client.user, payerData.acquiringIntegration)

            // Update payment status to trigger webhook
            await updateTestPayment(adminClient, testPayment.id, {
                status: 'PROCESSING',
            })

            // Wait for webhook to be delivered
            await waitFor(async () => {
                const webhooks = getReceivedWebhooks()
                return webhooks.length > 0
            }, { timeout: 10000, interval: 500 })

            const webhooks = getReceivedWebhooks()
            const webhook = webhooks[0]

            // Verify signature format (should be hex string)
            expect(webhook.headers['x-condo-signature']).toMatch(/^[a-f0-9]{64}$/)

            // Verify webhook payload structure
            expect(webhook.body).toHaveProperty('event', 'payment.status.changed')
            expect(webhook.body).toHaveProperty('timestamp')
            expect(webhook.body).toHaveProperty('deliveryId')
            expect(webhook.body.data).toHaveProperty('paymentId', testPayment.id)
            expect(webhook.body.data).toHaveProperty('receipt')
            expect(webhook.body.data.receipt).toHaveProperty('id', receipt.id)
        })

        test('no webhook is triggered when receipt has no callback URL', async () => {
            // Create payer without callback URL
            const payerData = await makePayer()
            const receipt = payerData.billingReceipts[0]

            // Create payment for the receipt
            const [testPayment] = await createTestPayment(
                adminClient,
                payerData.organization,
                receipt,
                payerData.acquiringContext
            )

            // Create MultiPayment (required before changing payment status)
            await createTestMultiPayment(adminClient, [testPayment], payerData.client.user, payerData.acquiringIntegration)

            // Update payment status
            await updateTestPayment(adminClient, testPayment.id, {
                status: 'PROCESSING',
            })

            // Wait a bit to ensure no webhook is triggered
            await new Promise(resolve => setTimeout(resolve, 2000))

            // Verify no webhook was received
            const webhooks = getReceivedWebhooks()
            expect(webhooks).toHaveLength(0)

            // Verify no delivery record was created
            const deliveries = await PaymentWebhookDelivery.getAll(adminClient, {
                payment: { id: testPayment.id },
            })
            expect(deliveries).toHaveLength(0)
        })
    })
})
