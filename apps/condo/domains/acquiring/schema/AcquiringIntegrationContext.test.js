/**
 * Generated by `createschema acquiring.AcquiringIntegrationContext 'integration:Relationship:AcquiringIntegration:PROTECT; organization:Relationship:Organization:PROTECT; settings:Json; state:Json;' --force`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { makeLoggedInAdminClient, makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowValidationFailureError,
    expectToThrowGraphQLRequestError,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS, CONTEXT_ERROR_STATUS, CONTEXT_VERIFICATION_STATUS } = require('@condo/domains/acquiring/constants/context')
const { CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT } = require('@condo/domains/acquiring/constants/errors')
const {
    AcquiringIntegrationContext,
    createTestAcquiringIntegrationContext,
    updateTestAcquiringIntegrationContext,
    createTestAcquiringIntegration,
    createTestAcquiringIntegrationAccessRight,
} = require('@condo/domains/acquiring/utils/testSchema')
const { createTestRecipient, createTestBillingIntegration } = require('@condo/domains/billing/utils/testSchema')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const { createTestOrganizationEmployeeRole } = require('@condo/domains/organization/utils/testSchema')
const { createTestOrganizationEmployee, createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { registerNewOrganization, makeEmployeeUserClientWithAbilities } = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser, makeClientWithServiceUser } = require('@condo/domains/user/utils/testSchema')


describe('AcquiringIntegrationContext', () => {
    let admin
    let support
    let context
    let manager
    let readPaymentsEmployee
    let noPermissionEmployee
    let serviceUser
    let anonymous
    let organization
    let integration
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        manager = await makeEmployeeUserClientWithAbilities({
            canManageIntegrations: true,
        })
        organization = manager.organization

        const [noAccessRole] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageIntegrations: false,
            canReadPayments: false,
        })
        noPermissionEmployee = await makeClientWithNewRegisteredAndLoggedInUser()
        noPermissionEmployee.organization = organization
        await createTestOrganizationEmployee(admin, organization, noPermissionEmployee.user, noAccessRole, { isAccepted: true })

        const [readRole] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageIntegrations: false,
            canReadPayments: true,
        })
        readPaymentsEmployee = await makeClientWithNewRegisteredAndLoggedInUser()
        readPaymentsEmployee.organization = organization
        await createTestOrganizationEmployee(admin, organization, readPaymentsEmployee.user, readRole, { isAccepted: true })

        anonymous = await makeClient()

        // Make sure billing with default group exists
        await createTestBillingIntegration(admin);

        [integration] = await createTestAcquiringIntegration(support)
        serviceUser = await makeClientWithServiceUser()
        await createTestAcquiringIntegrationAccessRight(support, integration, serviceUser.user)
    })
    afterEach(async () => {
        if (context) {
            await updateTestAcquiringIntegrationContext(admin, context.id, {
                deletedAt: dayjs().toISOString(),
            })
            context = undefined
        }
    })
    describe('CRUD tests', () => {
        describe('Create', () => {
            test('Admin can', async () => {
                [context] = await createTestAcquiringIntegrationContext(admin, organization, integration)
                expect(context).toBeDefined()
                expect(context).toHaveProperty(['organization', 'id'], organization.id)
                expect(context).toHaveProperty(['integration', 'id'], integration.id)
            })
            test('Support can', async () => {
                [context] = await createTestAcquiringIntegrationContext(support, organization, integration)
                expect(context).toBeDefined()
                expect(context).toHaveProperty(['organization', 'id'], organization.id)
                expect(context).toHaveProperty(['integration', 'id'], integration.id)
            })
            describe('Staff user', () => {
                test('can if it\'s integration manager of organization (has `canManageIntegrations`)', async () => {
                    [context] = await createTestAcquiringIntegrationContext(manager, organization, integration)
                    expect(context).toBeDefined()
                    expect(context).toHaveProperty(['organization', 'id'], organization.id)
                    expect(context).toHaveProperty(['integration', 'id'], integration.id)
                })
                test('can\'t in other cases', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestAcquiringIntegrationContext(readPaymentsEmployee, organization, integration)
                    })
                })
            })
            describe('Service user', () => {
                test('Can if it has access rights to integration and organization was created by it (UPS Case)', async () => {
                    const [org2] = await registerNewOrganization(serviceUser);
                    [context] = await createTestAcquiringIntegrationContext(serviceUser, org2, integration)
                    expect(context).toHaveProperty(['organization', 'id'], org2.id)
                    expect(context).toHaveProperty(['integration', 'id'], integration.id)
                })
            })
            test('Anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestAcquiringIntegrationContext(anonymous, organization, integration)
                })
            })
        })
        describe('Read', () => {
            beforeEach(async () => {
                [context] = await createTestAcquiringIntegrationContext(support, organization, integration)
            })
            test('Admin can', async () => {
                const contexts = await AcquiringIntegrationContext.getAll(admin, { id: context.id })
                expect(contexts).toHaveLength(1)
                expect(contexts).toHaveProperty(['0', 'id'], context.id)
            })
            test('Support can', async () => {
                const contexts = await AcquiringIntegrationContext.getAll(support, { id: context.id })
                expect(contexts).toHaveLength(1)
                expect(contexts).toHaveProperty(['0', 'id'], context.id)
            })
            describe('Staff user: can if have permission `canReadPayments` set', () => {
                test('Permission set', async () => {
                    const contexts = await AcquiringIntegrationContext.getAll(readPaymentsEmployee, { id: context.id })
                    expect(contexts).toHaveLength(1)
                    expect(contexts).toHaveProperty(['0', 'id'], context.id)
                })
                test('Permission not set', async () => {
                    const contexts = await AcquiringIntegrationContext.getAll(noPermissionEmployee, { id: context.id })
                    expect(contexts).toHaveLength(0)
                })
            })
            describe('Service user', () => {
                test('Can if have access rights to integration',  async () => {
                    const contexts = await AcquiringIntegrationContext.getAll(serviceUser, { id: context.id })
                    expect(contexts).toHaveLength(1)
                    expect(contexts).toHaveProperty(['0', 'id'], context.id)
                })
                test('Can\'t otherwise', async () => {
                    const anotherServiceUser = await makeClientWithServiceUser()
                    const contexts = await AcquiringIntegrationContext.getAll(anotherServiceUser, { id: context.id })
                    expect(contexts).toHaveLength(0)
                })
            })
            test('Anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await AcquiringIntegrationContext.getAll(anonymous, {})
                })
            })
        })
        describe('Update', () => {
            beforeEach(async () => {
                [context] = await createTestAcquiringIntegrationContext(support, organization, integration)
            })
            test('Admin can', async () => {
                const payload = {
                    settings: { dv: 1, fieldOne: 'value' },
                }

                const [updatedContext] = await updateTestAcquiringIntegrationContext(admin, context.id, payload )
                expect(updatedContext).toEqual(expect.objectContaining(payload))
            })
            test('Support can', async () => {
                const [updatedContext] =  await updateTestAcquiringIntegrationContext(support, context.id, {
                    deletedAt: dayjs().toISOString(),
                })

                // NOTE: prevent re-deletion in afterEach
                context = undefined

                expect(updatedContext).toBeDefined()
                expect(updatedContext).toHaveProperty('deletedAt')
                expect(updatedContext.deletedAt).not.toBeNull()
            })
            describe('Staff user', () => {
                test(`can if context status is "${CONTEXT_IN_PROGRESS_STATUS}" and user is integration manager (have canManageIntegration = true)`, async () => {
                    const feePayload = { implicitFeeDistributionSchema: [] }
                    const [newContext] = await updateTestAcquiringIntegrationContext(manager, context.id, feePayload)
                    expect(newContext).toEqual(expect.objectContaining(feePayload))
                })

                test(`can't if context status is "${CONTEXT_FINISHED_STATUS}" and user is integration manager (have 'canManageIntegration' = true)`, async () => {
                    await updateTestAcquiringIntegrationContext(support, context.id, { status: CONTEXT_FINISHED_STATUS })
                    const feePayload = { implicitFeeDistributionSchema: [] }
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestAcquiringIntegrationContext(manager, context.id, feePayload)
                    })
                })

                test(`can't if status is "${CONTEXT_ERROR_STATUS}" and integration manager (have 'canManageIntegration' = true)`, async () => {
                    await updateTestAcquiringIntegrationContext(support, context.id, { status: CONTEXT_ERROR_STATUS })
                    const feePayload = { implicitFeeDistributionSchema: [] }
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestAcquiringIntegrationContext(manager, context.id, feePayload)
                    })
                })

                test('can\'t in other cases', async () => {
                    const payload = {}
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestAcquiringIntegrationContext(readPaymentsEmployee, context.id, payload)
                    })
                })
            })
            describe('Service user', () => {
                test('Can if have access rights to integration',  async () => {
                    const statePayload = { state:  { dv: 1, myParameter: 'value' } }
                    const [updatedContext] = await updateTestAcquiringIntegrationContext(serviceUser, context.id, statePayload)
                    expect(updatedContext).toEqual(expect.objectContaining(statePayload))
                })
                test('Can\'t otherwise', async () => {
                    const anotherServiceUser = await makeClientWithServiceUser()
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestAcquiringIntegrationContext(anotherServiceUser, context.id, {})
                    })
                })
            })
            test('anonymous can\'t', async () => {
                const payload = {}
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestAcquiringIntegrationContext(anonymous, context.id, payload)
                })
            })
        })
        describe('Delete', () => {
            beforeEach(async () => {
                [context] = await createTestAcquiringIntegrationContext(support, organization, integration)
            })
            test('Admin can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AcquiringIntegrationContext.delete(admin, context.id)
                })
            })
            test('support can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AcquiringIntegrationContext.delete(support, context.id)
                })
            })
            test('user can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AcquiringIntegrationContext.delete(manager, context.id)
                })
            })
            test('anonymous can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AcquiringIntegrationContext.delete(anonymous, context.id)
                })
            })
        })
    })
    describe('Validation tests', () => {
        test('Should have correct dv field (=== 1)', async () => {
            await expectToThrowGQLError(async () => await createTestAcquiringIntegrationContext(admin, organization, integration, {
                dv: 2,
                sender: { dv: 1, fingerprint: 'tests' },
            }), {
                'code': 'BAD_USER_INPUT',
                'type': 'DV_VERSION_MISMATCH',
                'message': 'Wrong value for data version number',
                'mutation': 'createAcquiringIntegrationContext',
                'variable': ['data', 'dv'],
            });
            [context] = await createTestAcquiringIntegrationContext(admin, organization, integration)
            await expectToThrowGQLError(async () => await updateTestAcquiringIntegrationContext(admin, context.id, {
                dv: 2,
                sender: { dv: 1, fingerprint: 'tests' },
            }), {
                'code': 'BAD_USER_INPUT',
                'type': 'DV_VERSION_MISMATCH',
                'message': 'Wrong value for data version number',
                'mutation': 'updateAcquiringIntegrationContext',
                'variable': ['data', 'dv'],
            })
        })
        test('Organization and integration fields cannot be changed', async () => {
            [context] = await createTestAcquiringIntegrationContext(admin, organization, integration)
            const [secondOrganization] = await createTestOrganization(admin)
            const [secondIntegration] = await createTestAcquiringIntegration(admin)
            await expectToThrowGraphQLRequestError(async () => {
                await updateTestAcquiringIntegrationContext(admin,  context.id, {
                    organization: { connect: { id: secondOrganization.id } },
                })
            }, 'Field "organization" is not defined')
            await expectToThrowGraphQLRequestError(async () => {
                await updateTestAcquiringIntegrationContext(admin, context.id, {
                    integration: { connect: { id: secondIntegration.id } },
                })
            }, 'Field "integration" is not defined')
        })
        test(`Organization can have only 1 active context (having "${CONTEXT_VERIFICATION_STATUS}" or "${CONTEXT_FINISHED_STATUS}" status) at the time`, async () => {
            [context] = await createTestAcquiringIntegrationContext(manager, organization, integration, {
                status: CONTEXT_IN_PROGRESS_STATUS,
            })
            expect(context).toBeDefined()
            const [anotherIntegration] = await createTestAcquiringIntegration(support)
            const [thirdIntegration] = await createTestAcquiringIntegration(support)
            const [anotherContext] = await createTestAcquiringIntegrationContext(support, organization, anotherIntegration, {
                status: CONTEXT_IN_PROGRESS_STATUS,
            })
            // Multiple contexts in progress are allowed
            expect(anotherContext).toBeDefined()

            // One of contexts became connected (but not verified yet), so it becomes active
            const [connectedContext] = await updateTestAcquiringIntegrationContext(manager, context.id, {
                status: CONTEXT_VERIFICATION_STATUS,
            })
            expect(connectedContext).toHaveProperty('status', CONTEXT_VERIFICATION_STATUS)

            // Cannot bypass verification by finishing another context
            await expectToThrowValidationFailureError(async () => {
                await updateTestAcquiringIntegrationContext(manager, anotherContext.id, {
                    status: CONTEXT_FINISHED_STATUS,
                })
            }, CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)

            // Cannot create new context if active exist (same integration)
            await expectToThrowValidationFailureError(async () => {
                await createTestAcquiringIntegrationContext(support, organization, integration, {
                    status: CONTEXT_FINISHED_STATUS,
                })
            }, CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)

            // Cannot create new context if active exist (another integration)
            await expectToThrowValidationFailureError(async () => {
                await createTestAcquiringIntegrationContext(support, organization, thirdIntegration, {
                    status: CONTEXT_FINISHED_STATUS,
                })
            }, CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)

            // Cannot start new verification while another one is active
            await expectToThrowValidationFailureError(async () => {
                await createTestAcquiringIntegrationContext(manager, organization, thirdIntegration, {
                    status: CONTEXT_VERIFICATION_STATUS,
                })
            }, CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)

            // Verification approved by support team
            const [finished] = await updateTestAcquiringIntegrationContext(support, context.id, {
                status: CONTEXT_FINISHED_STATUS,
            })
            expect(finished).toHaveProperty('status', CONTEXT_FINISHED_STATUS)

            // Cannot finish connecting another context
            await expectToThrowValidationFailureError(async () => {
                await updateTestAcquiringIntegrationContext(manager, anotherContext.id, {
                    status: CONTEXT_FINISHED_STATUS,
                })
            }, CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)

            // Cannot create new context if active exist (same integration)
            await expectToThrowValidationFailureError(async () => {
                await createTestAcquiringIntegrationContext(support, organization, integration, {
                    status: CONTEXT_FINISHED_STATUS,
                })
            }, CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)

            // Cannot create new context if active exist (another integration)
            await expectToThrowValidationFailureError(async () => {
                await createTestAcquiringIntegrationContext(support, organization, thirdIntegration, {
                    status: CONTEXT_FINISHED_STATUS,
                })
            }, CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)

            // Cannot start new verification while another one is active
            await expectToThrowValidationFailureError(async () => {
                await createTestAcquiringIntegrationContext(manager, organization, thirdIntegration, {
                    status: CONTEXT_VERIFICATION_STATUS,
                })
            }, CONTEXT_ALREADY_HAVE_ACTIVE_CONTEXT)
        })
    })
    describe('Fields tests', () => {
        test('Fields check', async () => {
            const recipient = createTestRecipient()
            const reason = faker.lorem.sentence(1)
            const email = faker.internet.email();
            [context] = await createTestAcquiringIntegrationContext(admin, organization, integration, { email, reason, recipient })
            expect(context.email).toEqual(normalizeEmail(email))
            expect(context.reason).toEqual(reason)
            expect(context.recipient.bankAccount).toEqual(recipient.bankAccount)
            expect(context.recipient.iec).toEqual(recipient.iec)
            expect(context.recipient.tin).toEqual(recipient.tin)
            expect(context.recipient.bic).toEqual(recipient.bic)
        })
        describe('Status', () => {
            test(`Nobody except admin or support cannot change status from "${CONTEXT_VERIFICATION_STATUS}"`, async () => {
                [context] = await createTestAcquiringIntegrationContext(manager, organization, integration, {
                    status: CONTEXT_VERIFICATION_STATUS,
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestAcquiringIntegrationContext(manager, context.id, {
                        status: CONTEXT_FINISHED_STATUS,
                    })
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestAcquiringIntegrationContext(serviceUser, context.id, {
                        status: CONTEXT_FINISHED_STATUS,
                    })
                })
                const [updated] = await updateTestAcquiringIntegrationContext(support, context.id, {
                    status: CONTEXT_FINISHED_STATUS,
                })
                expect(updated).toHaveProperty('status', CONTEXT_FINISHED_STATUS)

                const [blocked] = await updateTestAcquiringIntegrationContext(support, context.id, {
                    status: CONTEXT_VERIFICATION_STATUS,
                })
                expect(blocked).toHaveProperty('status', CONTEXT_VERIFICATION_STATUS)

                const [restored] = await updateTestAcquiringIntegrationContext(admin, context.id, {
                    status: CONTEXT_FINISHED_STATUS,
                })
                expect(restored).toHaveProperty('status', CONTEXT_FINISHED_STATUS)
            })
            test(`Organization employee can finish connecting by itself if organization.type is "${SERVICE_PROVIDER_TYPE}"`, async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [org2] = await registerNewOrganization(client, {
                    type: SERVICE_PROVIDER_TYPE,
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestAcquiringIntegrationContext(client, org2, integration, {
                        status: CONTEXT_FINISHED_STATUS,
                    })
                });

                [context] = await createTestAcquiringIntegrationContext(client, org2, integration, {
                    status: CONTEXT_IN_PROGRESS_STATUS,
                })
                expect(context).toHaveProperty('status', CONTEXT_IN_PROGRESS_STATUS)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestAcquiringIntegrationContext(client, context.id, {
                        status: CONTEXT_FINISHED_STATUS,
                    })
                })

                const [updated] = await updateTestAcquiringIntegrationContext(client, context.id, {
                    status: CONTEXT_VERIFICATION_STATUS,
                })
                expect(updated).toHaveProperty('status', CONTEXT_VERIFICATION_STATUS)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestAcquiringIntegrationContext(client, context.id, {
                        status: CONTEXT_FINISHED_STATUS,
                    })
                })
            })
        })
    })
})
