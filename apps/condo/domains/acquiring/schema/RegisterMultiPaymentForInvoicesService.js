/**
 * Generated by `createservice acquiring.RegisterMultiPaymentForInvoicesService '--type=mutations' 'invoices:[InvoiceWhereUniqueInput!]!'`
 */

const Big = require('big.js')
const dayjs = require('dayjs')
const { uniq, map, find: _find, get } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/acquiring/access/RegisterMultiPaymentForInvoicesService')
const {
    ACQUIRING_INTEGRATION_IS_DELETED,
    INVOICES_ARE_NOT_PUBLISHED,
    INVOICE_CONTEXT_NOT_FINISHED,
    INVOICES_HAS_MULTIPLE_CURRENCIES,
    MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS,
} = require('@condo/domains/acquiring/constants/errors')
const {
    WEB_VIEW_PATH,
    FEE_CALCULATION_PATH,
    DIRECT_PAYMENT_PATH,
    ANONYMOUS_PAYMENT_PATH,
} = require('@condo/domains/acquiring/constants/links')
const { DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY } = require('@condo/domains/acquiring/constants/payment')
const { freezeInvoice } = require('@condo/domains/acquiring/utils/billingFridge')
const {
    AcquiringIntegration,
    Payment,
    MultiPayment,
} = require('@condo/domains/acquiring/utils/serverSchema')
const {
    FeeDistribution,
    compactDistributionSettings,
} = require('@condo/domains/acquiring/utils/serverSchema/feeDistribution')
const { NOT_FOUND, NOT_UNIQUE } = require('@condo/domains/common/constants/errors')
const { INVOICE_STATUS_PUBLISHED, INVOICE_CONTEXT_STATUS_FINISHED } = require('@condo/domains/marketplace/constants')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    DUPLICATED_INVOICE: {
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'Found duplicated invoices',
    },
    INVOICES_NOT_FOUND: (ids) => ({
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Invoices not found: {ids}',
        messageInterpolation: { ids: ids.sort().join(',') },
    }),
    DELETED_INVOICES: (ids) => ({
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Some of specified invoices with ids {ids} were deleted, so you cannot pay for them anymore',
        messageInterpolation: { ids: ids.sort().join(',') },
    }),
    MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS: {
        code: BAD_USER_INPUT,
        type: MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS,
        message: 'Listed serviceConsumers are linked to different acquiring integrations',
    },
    ACQUIRING_INTEGRATION_IS_DELETED: (id) => ({
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_IS_DELETED,
        message: 'Cannot pay via deleted acquiring integration with id "{id}"',
        messageInterpolation: { id },
    }),
    UNPUBLISHED_INVOICE: {
        code: BAD_USER_INPUT,
        type: INVOICES_ARE_NOT_PUBLISHED,
        message: 'Found invoices with not "published" status',
    },
    NOT_UNIQUE_CLIENTS: {
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'All invoices must relate to the same user or be anonymous',
    },
    INVOICE_CONTEXT_NOT_FINISHED: {
        code: BAD_USER_INPUT,
        type: INVOICE_CONTEXT_NOT_FINISHED,
        message: 'Invoice context is not finished',
    },
    INVOICES_HAS_MULTIPLE_CURRENCIES: {
        code: BAD_USER_INPUT,
        type: INVOICES_HAS_MULTIPLE_CURRENCIES,
        message: 'Invoices has multiple currencies',
    },
}

const RegisterMultiPaymentForInvoicesService = new GQLCustomSchema('RegisterMultiPaymentForInvoicesService', {
    types: [
        {
            access: true,
            type: 'input RegisterMultiPaymentForInvoicesInput { dv: Int!, sender: JSON!, invoices:[InvoiceWhereUniqueInput!]! }',
        },
        {
            access: true,
            type: 'type RegisterMultiPaymentForInvoicesOutput { dv: Int!, multiPaymentId: String!, webViewUrl: String!, feeCalculationUrl: String!, directPaymentUrl: String!, anonymousPaymentUrl: String! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterMultiPaymentForInvoices,
            schema: 'registerMultiPaymentForInvoices(data: RegisterMultiPaymentForInvoicesInput!): RegisterMultiPaymentForInvoicesOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data } = args
                const { sender, invoices } = data

                const invoicesIds = map(invoices, 'id')

                if (invoices.length > 0 && invoices.length !== uniq(invoicesIds).length) {
                    throw new GQLError(ERRORS.DUPLICATED_INVOICE, context)
                }

                const foundInvoices = await find('Invoice', { id_in: invoicesIds })

                if (foundInvoices.length !== invoices.length) {
                    const foundInvoicesIds = map(foundInvoices, 'id')
                    throw new GQLError(ERRORS.INVOICES_NOT_FOUND(invoicesIds.filter((invoiceId) => !foundInvoicesIds.includes(invoiceId))), context)
                }

                const deletedInvoicesIds = foundInvoices.filter(({ deletedAt }) => !!deletedAt).map(({ id }) => id)
                if (deletedInvoicesIds.length) {
                    throw new GQLError(ERRORS.DELETED_INVOICES(deletedInvoicesIds), context)
                }
                const invoicesContexts = await find('InvoiceContext', {
                    deletedAt: null,
                    id_in: uniq(map(foundInvoices, 'context')),
                })

                const acquiringIntegrations = new Set([
                    ...invoicesContexts.map(context => context.integration),
                ])

                if (acquiringIntegrations.size > 1) {
                    throw new GQLError(ERRORS.MULTIPLE_ACQUIRING_INTEGRATION_CONTEXTS, context)
                }

                const [acquiringIntegrationModel] = await AcquiringIntegration.getAll(context, {
                    id: Array.from(acquiringIntegrations)[0],
                })
                if (acquiringIntegrationModel.deletedAt) {
                    throw new GQLError(ERRORS.ACQUIRING_INTEGRATION_IS_DELETED(acquiringIntegrationModel.id), context)
                }

                // All invoices must be published
                if (foundInvoices.some(({ status }) => status !== INVOICE_STATUS_PUBLISHED)) {
                    throw new GQLError(ERRORS.UNPUBLISHED_INVOICE, context)
                }

                // All invoices must be related to the same user or be anonymous
                const clients = new Set(map(foundInvoices, 'client'))
                if (clients.size > 1) {
                    throw new GQLError(ERRORS.NOT_UNIQUE_CLIENTS, context)
                }

                // All invoices contexts must be finished
                if (invoicesContexts.some(({ status }) => status !== INVOICE_CONTEXT_STATUS_FINISHED)) {
                    throw new GQLError(ERRORS.INVOICE_CONTEXT_NOT_FINISHED, context)
                }

                // All invoices context must have the same currencyCode
                if (uniq(invoicesContexts.map(({ currencyCode }) => currencyCode)).length !== 1) {
                    throw new GQLError(ERRORS.INVOICES_HAS_MULTIPLE_CURRENCIES, context)
                }

                const payments = []
                const acquiringIntegration = await getById('AcquiringIntegration', invoicesContexts[0].integration)

                for (const invoice of foundInvoices) {
                    const invoiceContext = _find(invoicesContexts, { id: invoice.context })
                    const frozenInvoice = await freezeInvoice(invoice)
                    const feeCalculator = new FeeDistribution(compactDistributionSettings([
                        ...acquiringIntegration.explicitFeeDistributionSchema,
                        { recipient: 'organization', percent: Big(invoiceContext.implicitFeePercent).toFixed(2) },
                    ]))
                    const organizationId = get(frozenInvoice, ['data', 'organization', 'id'])
                    const routingNumber = get(frozenInvoice, ['data', 'context', 'recipient', 'bic'])
                    const bankAccount = get(frozenInvoice, ['data', 'context', 'recipient', 'bankAccount'])

                    const amount = String(Big(invoice.toPay))

                    const {
                        type,
                        explicitFee = '0',
                        implicitFee = '0',
                        fromReceiptAmountFee = '0',
                    } = feeCalculator.calculate(amount)

                    const paymentCommissionFields = {
                        ...type === 'service' ? {
                            explicitServiceCharge: String(explicitFee),
                            explicitFee: '0',
                        } : {
                            explicitServiceCharge: '0',
                            explicitFee: String(explicitFee),
                        },
                        implicitFee: String(implicitFee),
                        serviceFee: String(fromReceiptAmountFee),
                    }

                    const payment = await Payment.create(context, {
                        dv: 1,
                        sender,
                        amount: amount,
                        currencyCode: invoiceContext.currencyCode,
                        invoice: { connect: { id: invoice.id } },
                        frozenInvoice,
                        period: dayjs().format('YYYY-MM-01'),
                        organization: { connect: { id: organizationId } },
                        recipientBic: routingNumber,
                        recipientBankAccount: bankAccount,
                        ...paymentCommissionFields,
                    })

                    payments.push({ ...payment, serviceFee: paymentCommissionFields.serviceFee })
                }

                const currencyCode = get(invoicesContexts, [0, 'currencyCode'])

                const paymentIds = payments.map(payment => ({ id: payment.id }))
                const totalAmount = payments.reduce((acc, cur) => {
                    return {
                        amountWithoutExplicitFee: acc.amountWithoutExplicitFee.plus(Big(cur.amount)),
                        explicitFee: acc.explicitFee.plus(Big(cur.explicitFee)),
                        explicitServiceCharge: acc.explicitServiceCharge.plus(Big(cur.explicitServiceCharge)),
                        serviceFee: acc.serviceFee.plus(Big(cur.serviceFee)),
                        implicitFee: acc.implicitFee.plus(Big(cur.implicitFee)),
                    }
                }, {
                    amountWithoutExplicitFee: Big('0.0'),
                    explicitFee: Big('0.0'),
                    explicitServiceCharge: Big('0.0'),
                    serviceFee: Big('0.0'),
                    implicitFee: Big('0.0'),
                })

                const multiPayment = await MultiPayment.create(context, {
                    dv: 1,
                    sender,
                    ...Object.fromEntries(Object.entries(totalAmount).map(([key, value]) => ([key, value.toFixed(2)]))),
                    currencyCode,
                    integration: { connect: { id: acquiringIntegrationModel.id } },
                    payments: { connect: paymentIds },
                    // TODO(DOMA-1574): add correct category
                    serviceCategory: DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY,
                })

                return {
                    dv: 1,
                    multiPaymentId: multiPayment.id,
                    webViewUrl: `${acquiringIntegrationModel.hostUrl}${WEB_VIEW_PATH.replace('[id]', multiPayment.id)}`,
                    feeCalculationUrl: `${acquiringIntegrationModel.hostUrl}${FEE_CALCULATION_PATH.replace('[id]', multiPayment.id)}`,
                    directPaymentUrl: `${acquiringIntegrationModel.hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', multiPayment.id)}`,
                    anonymousPaymentUrl: `${acquiringIntegrationModel.hostUrl}${ANONYMOUS_PAYMENT_PATH.replace('[id]', multiPayment.id)}`,
                }
            },
        },
    ],

})

module.exports = {
    RegisterMultiPaymentForInvoicesService,
}
