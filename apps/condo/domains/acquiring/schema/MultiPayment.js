/**
 * Generated by `createschema acquiring.MultiPayment 'amount:Decimal; commission?:Decimal; time:DateTimeUtc; cardNumber:Text; serviceCategory:Text;'`
 */

const { Text, DateTimeUtc, Decimal, Select, Relationship } = require('@keystonejs/fields')
const { getById } = require('@core/keystone/schema')
const { Json } = require('@core/keystone/fields')
const { GQLListSchema } = require('@core/keystone/schema')
const { historical, versioned, uuided, tracked, softDeleted } = require('@core/keystone/plugins')
const { SENDER_FIELD, DV_FIELD, CURRENCY_CODE_FIELD } = require('@condo/domains/common/schema/fields')
const { RESIDENT } = require('@condo/domains/user/constants/common')
const {
    AVAILABLE_PAYMENT_METHODS,
    MULTIPAYMENT_STATUSES,
    MULTIPAYMENT_INIT_STATUS,
    MULTIPAYMENT_FROZEN_FIELDS,
    MULTIPAYMENT_TRANSITIONS,
    MULTIPAYMENT_REQUIRED_FIELDS,
} = require('../constants')
const { ACQUIRING_INTEGRATION_FIELD } = require('./fields/relations')
const access = require('@condo/domains/acquiring/access/MultiPayment')
const get = require('lodash/get')


const MultiPayment = new GQLListSchema('MultiPayment', {
    schemaDoc: 'Information about resident\'s payment for single or multiple services/receipts',
    fields: {
        dv: DV_FIELD,
        sender: SENDER_FIELD,

        amount: {
            schemaDoc: 'Total amount of payment, not including commission.',
            type: Decimal,
            isRequired: true,
        },

        commission: {
            schemaDoc: 'The amount of money needed by the service to complete the transaction',
            type: Decimal,
            isRequired: false,
        },

        currencyCode: CURRENCY_CODE_FIELD,

        time: {
            schemaDoc: 'Time of money withdraw (UTC)',
            type: DateTimeUtc,
            isRequired: false,
        },

        cardNumber: {
            schemaDoc: 'Number of the card (masked) from which the money was withdrawn. Needed for creating receipt',
            type: Text,
            isRequired: false,
        },

        paymentWay: {
            schemaDoc: 'Payment way, such as `CARD` or `APPLE_PAY`',
            type: Select,
            dataType: 'string',
            isRequired: false,
            options: AVAILABLE_PAYMENT_METHODS,
        },

        payerEmail: {
            schemaDoc: 'Payer email address (optional). Can be used by support to find MultiPayment faster or to send digital receipt',
            type: Text,
            isRequired: false,
        },

        serviceCategory: {
            schemaDoc: 'Name of the payment document, such as `Квитанция`, `Штраф`',
            type: Text,
            isRequired: true,
        },

        transactionId: {
            schemaDoc: 'Transaction ID of money withdraw',
            type: Text,
            isRequired: false,
        },

        meta: {
            schemaDoc: 'Additional acquiring-specific information',
            type: Json,
            isRequired: false,
        },

        status: {
            schemaDoc: `Status of payment. Can be: ${MULTIPAYMENT_STATUSES.map(status => `"${status}"`).join(', ')}`,
            type: Select,
            dataType: 'string',
            isRequired: true,
            options: MULTIPAYMENT_STATUSES,
            defaultValue: MULTIPAYMENT_INIT_STATUS,
        },

        user: {
            schemaDoc: 'Link to user',
            type: Relationship,
            ref: 'User',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
            hooks: {
                validateInput: async ({ operation, resolvedData, fieldPath, addFieldValidationError }) => {
                    if (operation === 'create') {
                        const userId = get(resolvedData, fieldPath)
                        if (!userId) {
                            addFieldValidationError('No user specified')
                            return
                        }
                        const user = await getById('User', userId)
                        if (get(user, 'type') !== RESIDENT) {
                            addFieldValidationError('Cannot create Multipayment to non-resident type of user')
                        }
                    }
                },
            },
        },

        receipts: {
            schemaDoc: 'List of all billing receipts, that make up MultiPayment. Created using mutation. Displaying all needed information to resolve conflicts. Mainly used by support team',
            type: Json,
            isRequired: true,
        },

        integration: ACQUIRING_INTEGRATION_FIELD,
    },
    hooks: {
        validateInput: async ({ addValidationError, existingItem, originalInput, operation }) => {
            if (operation === 'update') {
                const afterStatus = get(originalInput, 'status')
                if (!afterStatus) {
                    addValidationError('Status of multipayment should be provided')
                    return
                }
                const beforeStatus = existingItem['status']
                if (afterStatus === beforeStatus) {
                    addValidationError('Cannot update multipayment without changing it\'s status')
                    return
                }
                const enabledTransitions = get(MULTIPAYMENT_TRANSITIONS, beforeStatus, [])
                if (!enabledTransitions.includes(afterStatus)) {
                    addValidationError(`Incorrect status transition. Available transitions for status "${beforeStatus}" are: [ ${enabledTransitions.join(', ')} ]`)
                }
                const frozenFields = get(MULTIPAYMENT_FROZEN_FIELDS, beforeStatus, [])
                frozenFields.forEach(field => {
                    if (originalInput.hasOwnProperty(field)) addValidationError(`It's no longer possible to change "${field}" field at this stage`)
                })

                const requiredFields = get(MULTIPAYMENT_REQUIRED_FIELDS, afterStatus, [])
                const newObject = { ...existingItem, ...originalInput }
                const missingFields = requiredFields.filter(field => get(newObject, field, null) === null)
                if (missingFields.length) {
                    addValidationError(`Missing required fields for this status or it's values are nulls: [ ${missingFields.join(', ')} ]`)
                }
                // TODO (savelevMatthew): Add payments checking in DONE status
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), historical()],
    access: {
        read: access.canReadMultiPayments,
        create: access.canManageMultiPayments,
        update: access.canManageMultiPayments,
        delete: false,
        auth: true,
    },
})

module.exports = {
    MultiPayment,
}
