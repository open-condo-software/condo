/**
 * Generated by `createschema acquiring.MultiPayment 'amount:Decimal; commission?:Decimal; time:DateTimeUtc; cardNumber:Text; serviceCategory:Text;'`
 */

const { Text, DateTimeUtc, Select, Relationship, Virtual } = require('@keystonejs/fields')
const { getById } = require('@core/keystone/schema')
const { Json } = require('@core/keystone/fields')
const { GQLListSchema } = require('@core/keystone/schema')
const { historical, versioned, uuided, tracked, softDeleted } = require('@core/keystone/plugins')
const { SENDER_FIELD, DV_FIELD, CURRENCY_CODE_FIELD, MONEY_AMOUNT_FIELD } = require('@condo/domains/common/schema/fields')
const { RESIDENT } = require('@condo/domains/user/constants/common')
const {
    AVAILABLE_PAYMENT_METHODS,
    MULTIPAYMENT_STATUSES,
    MULTIPAYMENT_INIT_STATUS,
} = require('../constants/payment')
const { ACQUIRING_INTEGRATION_FIELD } = require('./fields/relations')
const access = require('@condo/domains/acquiring/access/MultiPayment')
const get = require('lodash/get')


const MultiPayment = new GQLListSchema('MultiPayment', {
    schemaDoc: 'Information about resident\'s payment for single or multiple services/receipts',
    fields: {
        dv: DV_FIELD,
        sender: SENDER_FIELD,

        amount: {
            schemaDoc: 'Total amount of withdraw. amount = amountWithoutExplicitFee + explicitFee',
            type: Virtual,
            resolver: (item) => {
                const explicitFee = get(item, 'explicitFee')
                const floatFee = parseFloat(explicitFee || '0')
                const floatAmount = parseFloat(item.amountWithOutExplicitFee)
                return String(floatAmount + floatFee)
            },
        },

        explicitFee: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'The amount of commission which resident pay on top of amount',
            isRequired: false,
        },

        serviceFee: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'The amount of money charged by service (Doma) for the provision of service. Can be explicit or implicit',
            isRequired: false,
        },

        implicitFee: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'Total amount of money charged from recipients of multipayment as fee for transaction',
            isRequired: false,
            access: { read: access.canReadMultiPaymentsSensitiveData },
        },

        amountWithoutExplicitFee: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'The amount of money used to pay bills, initialized by resident.',
            isRequired: true,
        },

        currencyCode: CURRENCY_CODE_FIELD,

        withdrawnAt: {
            schemaDoc: 'Time of money withdraw (UTC)',
            type: DateTimeUtc,
            isRequired: false,
        },

        cardNumber: {
            schemaDoc: 'Number of the card (masked) from which the money was withdrawn. Needed for creating receipt',
            type: Text,
            isRequired: false,
        },

        paymentWay: {
            schemaDoc: 'Payment way, such as `CARD` or `APPLE_PAY`',
            type: Select,
            dataType: 'string',
            isRequired: false,
            options: AVAILABLE_PAYMENT_METHODS,
        },

        payerEmail: {
            schemaDoc: 'Payer email address (optional). Can be used by support to find MultiPayment faster or to send digital receipt',
            type: Text,
            isRequired: false,
        },

        serviceCategory: {
            schemaDoc: 'Name of the payment document, such as `Квитанция`, `Штраф`',
            type: Text,
            isRequired: true,
        },

        transactionId: {
            schemaDoc: 'Transaction ID of money withdraw',
            type: Text,
            isRequired: false,
            access: { read: access.canReadMultiPaymentsSensitiveData },
        },

        meta: {
            schemaDoc: 'Additional acquiring-specific information',
            type: Json,
            isRequired: false,
            access: { read: access.canReadMultiPaymentsSensitiveData },
        },

        status: {
            schemaDoc: `Status of multipayment. Can be: ${MULTIPAYMENT_STATUSES.map(status => `"${status}"`).join(', ')}`,
            type: Select,
            dataType: 'string',
            isRequired: true,
            options: MULTIPAYMENT_STATUSES,
            defaultValue: MULTIPAYMENT_INIT_STATUS,
        },

        user: {
            schemaDoc: 'Link to user',
            type: Relationship,
            ref: 'User',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
            hooks: {
                validateInput: async ({ operation, resolvedData, fieldPath, addFieldValidationError }) => {
                    if (operation === 'create') {
                        const userId = get(resolvedData, fieldPath)
                        if (!userId) {
                            addFieldValidationError('No user specified')
                            return
                        }
                        const user = await getById('User', userId)
                        if (get(user, 'type') !== RESIDENT) {
                            addFieldValidationError('Cannot create Multipayment to non-resident type of user')
                        }
                    }
                },
            },
        },

        payments: {
            schemaDoc: 'Link to all related payments',
            type: Relationship,
            ref: 'Payment.multiPayment',
            isRequired: true,
            many: true,
        },

        integration: ACQUIRING_INTEGRATION_FIELD,
    },
    hooks: {
        // TODO (savelevMatthew): Create proper validations
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), historical()],
    access: {
        read: access.canReadMultiPayments,
        create: access.canManageMultiPayments,
        update: access.canManageMultiPayments,
        delete: false,
        auth: true,
    },
})

module.exports = {
    MultiPayment,
}
