/**
 * Generated by `createservice acquiring.GeneratePaymentLinkService`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { map, pick } = require('lodash')

const conf = require('@open-condo/config')
const {
    catchErrorFrom, expectToThrowAccessDeniedError, expectToThrowGQLError, makeLoggedInAdminClient,
} = require('@open-condo/keystone/test.utils')

const {
    PAYMENT_LINK_PATH,
    PAYMENT_LINK_QP: {
        acquiringIntegrationContextQp,
        successUrlQp,
        failureUrlQp,
        billingReceiptQp,
        currencyCodeQp,
        amountQp,
        periodQp,
        accountNumberQp,
    },
} = require('@condo/domains/acquiring/constants/links')
const {
    generatePaymentLinkByTestClient,
    updateTestAcquiringIntegrationContext,
    makePayer, createTestAcquiringIntegrationContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const { createTestAcquiringIntegration } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBillingIntegration } = require('@condo/domains/billing/utils/testSchema')
const {
    updateTestBillingReceipt,
} = require('@condo/domains/billing/utils/testSchema')
const { INVOICE_CONTEXT_STATUS_FINISHED, INVOICE_STATUS_PUBLISHED } = require('@condo/domains/marketplace/constants')
const { createTestInvoiceContext } = require('@condo/domains/marketplace/utils/testSchema')
const { createTestInvoice, updateTestInvoice } = require('@condo/domains/marketplace/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')

const hostUrl = conf.SERVER_URL

const callbacks = () => ({
    successUrl: 'http://success.ru',
    failureUrl: 'http://failure.ru',
})

const receiptData = () => ({
    currencyCode: 'RUB',
    amount: '100.23',
    periodYear: 2022,
    periodMonth: 1,
    accountNumber: '7200123006',
})

describe('GeneratePaymentLinkService', () => {
    let adminClient
    let acquiringIntegrationContext
    let dummyO10n, dummyIntegration, dummyInvoiceContext

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()

        ;[dummyO10n] = await createTestOrganization(adminClient)
        await createTestBillingIntegration(adminClient)
        const [acquiringIntegration] = await createTestAcquiringIntegration(adminClient)
        ;[acquiringIntegrationContext] = await createTestAcquiringIntegrationContext(adminClient, dummyO10n, acquiringIntegration)
        ;[dummyIntegration] = await createTestAcquiringIntegration(adminClient)
        ;[dummyInvoiceContext] = await createTestInvoiceContext(adminClient, dummyO10n, dummyIntegration, { status: INVOICE_CONTEXT_STATUS_FINISHED })
    })

    describe('Execute', () => {
        describe('Resident user', () => {
            test('From receipt', async () => {
                const {
                    billingReceipts,
                    acquiringContext,
                    client,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const callbackUrls = callbacks()
                await expectToThrowAccessDeniedError(async () => {
                    await generatePaymentLinkByTestClient(client, receipt, null, acquiringIntegrationContext, callbackUrls)
                }, 'result')
            })
            test('From receipt data', async () => {
                const {
                    acquiringContext,
                    client,
                } = await makePayer()
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const receipt = receiptData()
                await expectToThrowAccessDeniedError(async () => {
                    await generatePaymentLinkByTestClient(client, null, receipt, acquiringIntegrationContext, callbacks())
                }, 'result')
            })
        })
        describe('Admin user', () => {
            test('From receipt', async () => {
                const {
                    billingReceipts,
                    acquiringContext,
                    admin,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const callbackUrls = callbacks()
                const [result] = await generatePaymentLinkByTestClient(admin, receipt, null, acquiringIntegrationContext, callbackUrls)

                const paymentLink = new URL(`${hostUrl}${PAYMENT_LINK_PATH}`)
                paymentLink.searchParams.set(acquiringIntegrationContextQp, acquiringIntegrationContext.id)
                paymentLink.searchParams.set(successUrlQp, callbackUrls.successUrl)
                paymentLink.searchParams.set(failureUrlQp, callbackUrls.failureUrl)
                paymentLink.searchParams.set(billingReceiptQp, receipt.id)

                expect(result).toBeDefined()
                expect(result).toHaveProperty('dv', 1)
                expect(result).toHaveProperty('paymentUrl', paymentLink.toString())
            })
            test('From receipt data', async () => {
                const {
                    acquiringContext,
                    admin,
                } = await makePayer()
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const callbackUrls = callbacks()
                const receipt = receiptData()
                const [result] = await generatePaymentLinkByTestClient(admin, null, receipt, acquiringIntegrationContext, callbacks())

                const paymentLink = new URL(`${hostUrl}${PAYMENT_LINK_PATH}`)
                paymentLink.searchParams.set(acquiringIntegrationContextQp, acquiringIntegrationContext.id)
                paymentLink.searchParams.set(successUrlQp, callbackUrls.successUrl)
                paymentLink.searchParams.set(failureUrlQp, callbackUrls.failureUrl)
                paymentLink.searchParams.set(currencyCodeQp, receipt.currencyCode)
                paymentLink.searchParams.set(amountQp, receipt.amount)
                paymentLink.searchParams.set(periodQp, '2022-01-01')
                paymentLink.searchParams.set(accountNumberQp, receipt.accountNumber)

                expect(result).toBeDefined()
                expect(result).toHaveProperty('dv', 1)
                expect(result).toHaveProperty('paymentUrl', paymentLink.toString())
            })

            test('From invoices', async () => {
                const [invoice1] = await createTestInvoice(adminClient, dummyInvoiceContext, { status: INVOICE_STATUS_PUBLISHED })
                const [invoice2] = await createTestInvoice(adminClient, dummyInvoiceContext, { status: INVOICE_STATUS_PUBLISHED })

                const callbackUrls = callbacks()

                const [result1] = await generatePaymentLinkByTestClient(adminClient, null, null, null, callbackUrls, {
                    invoices: [pick(invoice1, 'id')],
                })
                const [result2] = await generatePaymentLinkByTestClient(adminClient, null, null, null, callbackUrls, {
                    invoices: [pick(invoice1, 'id'), pick(invoice2, 'id')],
                })

                const paymentLink1 = new URL(`${hostUrl}/payment-link`)
                paymentLink1.searchParams.set('su', callbackUrls.successUrl)
                paymentLink1.searchParams.set('fu', callbackUrls.failureUrl)
                paymentLink1.searchParams.set('i', invoice1.id)

                expect(result1).toBeDefined()
                expect(result1).toHaveProperty('dv', 1)
                expect(result1).toHaveProperty('paymentUrl', paymentLink1.toString())

                const paymentLink2 = new URL(`${hostUrl}/payment-link`)
                paymentLink2.searchParams.set('su', callbackUrls.successUrl)
                paymentLink2.searchParams.set('fu', callbackUrls.failureUrl)
                paymentLink2.searchParams.set('i', `${invoice1.id},${invoice2.id}`)

                expect(result2).toBeDefined()
                expect(result2).toHaveProperty('dv', 1)
                expect(result2).toHaveProperty('paymentUrl', paymentLink2.toString())
            })
        })
    })
    describe('GeneratePaymentLinkService query Validations', () => {
        describe('Input checks', () => {
            test('Should check dv (=== 1)', async () => {
                const {
                    billingReceipts,
                    acquiringContext,
                    admin,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }

                await catchErrorFrom(async () => {
                    await generatePaymentLinkByTestClient(admin, receipt, null, acquiringIntegrationContext, callbacks(), { dv: 2 })
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Wrong value for data version number',
                        path: ['result'],
                        extensions: {
                            mutation: 'generatePaymentLink',
                            variable: ['data', 'dv'],
                            code: 'BAD_USER_INPUT',
                            type: 'DV_VERSION_MISMATCH',
                            message: 'Wrong value for data version number',
                        },
                    }])
                })
            })

            describe('There can be only one', () => {
                let adminClient
                beforeAll(async () => {
                    adminClient = await makeLoggedInAdminClient()
                })

                const acquiringIntegrationContext = { id: faker.datatype.uuid() }
                const receipt = { id: faker.datatype.uuid() }
                const invoices = [{ id: faker.datatype.uuid() }]

                const cases = [
                    { extraAttrs: { receipt, receiptData: receiptData() } },
                    { extraAttrs: { receipt, invoices } },
                    { extraAttrs: { receiptData: receiptData(), invoices } },
                    { extraAttrs: { receipt, receiptData: receiptData(), invoices } },
                ]

                test.each(cases)('%#', async ({ extraAttrs }) => {
                    await expectToThrowGQLError(async () => await generatePaymentLinkByTestClient(adminClient, null, null, acquiringIntegrationContext, callbacks(), extraAttrs), {
                        code: 'BAD_USER_INPUT',
                        type: 'MUTALLY_EXCLUSIVE_DATA',
                        message: 'Mutually exclusive data was sent',
                    }, 'result')
                })
            })

            describe('Should check sender', () => {
                let acquiringIntegrationContext
                let receipt
                let admin
                beforeAll(async () => {
                    const data = await makePayer()
                    receipt = { id: data.billingReceipts[0].id }
                    acquiringIntegrationContext = { id: data.acquiringContext.id }
                    admin = data.admin
                })
                const cases = [
                    [2, faker.random.alphaNumeric(8)],
                    [1, faker.random.alphaNumeric(3)],
                    [1, faker.random.alphaNumeric(60)],
                    [1, 'КиРиЛЛиЦА'],
                ]
                test.each(cases)('dv: %p, fingerprint: %p', async (dv, fingerprint) => {
                    const sender = { dv, fingerprint }
                    await catchErrorFrom(async () => {
                        await generatePaymentLinkByTestClient(admin, receipt, null, acquiringIntegrationContext, callbacks(), { sender })
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            path: ['result'],
                            extensions: {
                                mutation: 'generatePaymentLink',
                                variable: ['data', 'sender'],
                                code: 'BAD_USER_INPUT',
                                type: 'WRONG_FORMAT',
                            },
                        }])
                        expect(errors[0].message).toMatch('Invalid format of "sender" field value.')
                        expect(errors[0].extensions.message).toMatch('Invalid format of "sender" field value.')
                    })
                })
            })
        })
        describe('BillingReceipts checks', () => {
            test('Should have existing ids', async () => {
                const {
                    acquiringContext,
                    admin,
                } = await makePayer()
                const missingReceiptId = faker.datatype.uuid()
                const receipt = { id: missingReceiptId }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await catchErrorFrom(async () => {
                    await generatePaymentLinkByTestClient(admin, receipt, null, acquiringIntegrationContext, callbacks())
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot find specified BillingReceipt with id ${missingReceiptId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'generatePaymentLink',
                            variable: ['data', 'receipt', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'CANNOT_FIND_ALL_BILLING_RECEIPTS',
                            message: 'Cannot find specified BillingReceipt with id {missingReceiptId}',
                        },
                    }])
                })
            })
            describe('Cannot generate link for receipts with negative toPay', () => {
                const cases = ['0.0', '-1', '-50.00', '-0.000000']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const {
                        admin,
                        billingReceipts,
                        acquiringContext,
                    } = await makePayer()
                    const receipt = { id: billingReceipts[0].id }
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await updateTestBillingReceipt(admin, receipt.id, {
                        toPay,
                    })
                    await catchErrorFrom(async () => {
                        await generatePaymentLinkByTestClient(admin, receipt, null, acquiringIntegrationContext, callbacks())
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot generate payment link with negative "toPay" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'generatePaymentLink',
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE',
                                message: 'Cannot generate payment link with negative "toPay" value',
                            },
                        }])
                    })
                })
            })
        })
        describe('deletedAt check', () => {
            test('Should not be able to generate link for deleted receipts', async () => {
                const {
                    admin,
                    billingReceipts,
                    acquiringContext,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                const deletedReceiptId = receipt.id
                await updateTestBillingReceipt(admin, deletedReceiptId, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await generatePaymentLinkByTestClient(admin, receipt, null, acquiringIntegrationContext, callbacks())
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: `Cannot generate payment link with deleted receipt ${deletedReceiptId}`,
                        path: ['result'],
                        extensions: {
                            mutation: 'generatePaymentLink',
                            variable: ['data', 'receipt', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'RECEIPTS_ARE_DELETED',
                            message: 'Cannot generate payment link with deleted receipt {id}',
                        },
                    }])
                })
            })
            test('Should not be able to generate link for consumer with deleted acquiring context', async () => {
                const {
                    admin,
                    billingReceipts,
                    acquiringContext,
                } = await makePayer()
                const receipt = { id: billingReceipts[0].id }
                const acquiringIntegrationContext = { id: acquiringContext.id }
                await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await catchErrorFrom(async () => {
                    await generatePaymentLinkByTestClient(admin, receipt, null, acquiringIntegrationContext, callbacks())
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        message: 'Cannot generate payment link with deleted acquiring integration context',
                        path: ['result'],
                        extensions: {
                            mutation: 'generatePaymentLink',
                            variable: ['data', 'acquiringIntegrationContext', 'id'],
                            code: 'BAD_USER_INPUT',
                            type: 'ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED',
                            message: 'Cannot generate payment link with deleted acquiring integration context',
                        },
                    }])
                })
            })
        })
        describe('ReceiptData checks', () => {
            describe('Cannot generate link for receipts with negative toPay', () => {
                const cases = ['0.0', '-1', '-50.00', '-0.000000']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const {
                        admin,
                        acquiringContext,
                    } = await makePayer()
                    const receipt = receiptData()
                    receipt.amount = toPay
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await generatePaymentLinkByTestClient(admin, null, receipt, acquiringIntegrationContext, callbacks())
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot generate payment link with negative "toPay" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'generatePaymentLink',
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPTS_HAVE_NEGATIVE_TO_PAY_VALUE',
                                message: 'Cannot generate payment link with negative "toPay" value',
                            },
                        }])
                    })
                })
            })
            describe('Cannot generate link for Receipt with invalid "toPay" value', () => {
                const cases = ['100 000', 'Hello world', '100 dollars', '100$']
                test.each(cases)('ToPay: %p', async (toPay) => {
                    const {
                        admin,
                        acquiringContext,
                    } = await makePayer()
                    const receipt = receiptData()
                    receipt.amount = toPay
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await generatePaymentLinkByTestClient(admin, null, receipt, acquiringIntegrationContext, callbacks())
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot generate payment link with invalid "toPay" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'generatePaymentLink',
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPT_HAVE_INVALID_TO_PAY_VALUE',
                                message: 'Cannot generate payment link with invalid "toPay" value',
                            },
                        }])
                    })
                })
            })
            describe('Cannot generate link for Receipt with invalid "currencyCode" value', () => {
                const cases = ['$', 'dollars', 'RU', 'rub']
                test.each(cases)('ToPay currency: %p', async (currencyCode) => {
                    const {
                        admin,
                        acquiringContext,
                    } = await makePayer()
                    const receipt = receiptData()
                    receipt.currencyCode = currencyCode
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await generatePaymentLinkByTestClient(admin, null, receipt, acquiringIntegrationContext, callbacks())
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot generate payment link with invalid "currencyCode" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'generatePaymentLink',
                                variable: ['data', 'receiptData', 'currencyCode'],
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPT_HAVE_INVALID_CURRENCY_CODE_VALUE',
                                message: 'Cannot generate payment link with invalid "currencyCode" value',
                            },
                        }])
                    })
                })
            })
            describe('Cannot generate link for Receipt with invalid "paymentYear" value', () => {
                const cases = [1000, 0, -2022, new Date().getFullYear() + 1]
                test.each(cases)('ToPay period year: %p', async (year) => {
                    const {
                        admin,
                        acquiringContext,
                    } = await makePayer()
                    const receipt = receiptData()
                    receipt.periodYear = year
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await generatePaymentLinkByTestClient(admin, null, receipt, acquiringIntegrationContext, callbacks())
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot generate payment link with invalid "paymentYear" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'generatePaymentLink',
                                variable: ['data', 'receiptData', 'paymentYear'],
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPT_HAVE_INVALID_PAYMENT_YEAR_VALUE',
                                message: 'Cannot generate payment link with invalid "paymentYear" value',
                            },
                        }])
                    })
                })
            })
            describe('Cannot generate link for Receipt with invalid "paymentMonth" value', () => {
                const cases = [0, -1, 13, 2022]
                test.each(cases)('ToPay period month: %p', async (month) => {
                    const {
                        admin,
                        acquiringContext,
                    } = await makePayer()
                    const receipt = receiptData()
                    receipt.periodMonth = month
                    const acquiringIntegrationContext = { id: acquiringContext.id }
                    await catchErrorFrom(async () => {
                        await generatePaymentLinkByTestClient(admin, null, receipt, acquiringIntegrationContext, callbacks())
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            message: 'Cannot generate payment link with invalid "paymentMonth" value',
                            path: ['result'],
                            extensions: {
                                mutation: 'generatePaymentLink',
                                variable: ['data', 'receiptData', 'paymentMonth'],
                                code: 'BAD_USER_INPUT',
                                type: 'RECEIPT_HAVE_INVALID_PAYMENT_MONTH_VALUE',
                                message: 'Cannot generate payment link with invalid "paymentMonth" value',
                            },
                        }])
                    })
                })
            })
        })

        describe('Invoice check', () => {
            test('Can\'t create link for un-existent invoice', async () => {
                const invoices = [{ id: faker.datatype.uuid() }, { id: faker.datatype.uuid() }]
                await expectToThrowGQLError(async () => await generatePaymentLinkByTestClient(adminClient, null, null, pick(acquiringIntegrationContext, 'id'), callbacks(), {
                    invoices,
                }), {
                    code: 'BAD_USER_INPUT',
                    type: 'CANNOT_FIND_INVOICE',
                    message: `Cannot find specified invoice with id ${map(invoices, 'id').join(',')}`,
                }, 'result')
            })

            test('Can\'t create link for deleted invoice', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyInvoiceContext)
                await updateTestInvoice(adminClient, invoice.id, { deletedAt: dayjs().toISOString() })
                await expectToThrowGQLError(async () => await generatePaymentLinkByTestClient(adminClient, null, null, pick(acquiringIntegrationContext, 'id'), callbacks(), {
                    invoices: [pick(invoice, 'id')],
                }), {
                    code: 'BAD_USER_INPUT',
                    type: 'INVOICE_IS_DELETED',
                    message: `Cannot generate payment link with deleted invoice ${invoice.id}`,
                }, 'result')
            })

            test('Can\'t create link for unpublished invoice', async () => {
                const [invoice] = await createTestInvoice(adminClient, dummyInvoiceContext)
                await expectToThrowGQLError(async () => await generatePaymentLinkByTestClient(adminClient, null, null, pick(acquiringIntegrationContext, 'id'), callbacks(), {
                    invoices: [pick(invoice, 'id')],
                }), {
                    code: 'BAD_USER_INPUT',
                    type: 'INVOICES_ARE_NOT_PUBLISHED',
                    message: 'Found invoices with not "published" status',
                }, 'result')
            })
        })
    })
})
