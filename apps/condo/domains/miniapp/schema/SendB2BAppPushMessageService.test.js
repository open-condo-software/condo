/**
 * Generated by `createservice miniapp.SendB2BAppPushMessageService '--type=mutations'`
 */

const { faker } = require('@faker-js/faker')

const conf = require('@open-condo/config')
const { makeLoggedInAdminClient, makeClient, UUID_RE, expectToThrowAccessDeniedErrorToResult, expectToThrowAuthenticationErrorToResult, waitFor, expectToThrowGQLErrorToResult } = require('@open-condo/keystone/test.utils')

const { LOCALES } = require('@condo/domains/common/constants/locale')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { sendB2BAppPushMessageByTestClient, createTestAppMessageSetting, createTestB2BApp, createTestB2BAppContext, createTestB2BAppAccessRightSet, createTestB2BAppAccessRight } = require('@condo/domains/miniapp/utils/testSchema')
const { MESSAGE_SENT_STATUS, B2B_APP_MESSAGE_PUSH_TYPE, DEVICE_PLATFORM_ANDROID, APP_MASTER_ID_ANDROID, PASS_TICKET_CREATED_MESSAGE_TYPE } = require('@condo/domains/notification/constants/constants')
const { Message, syncRemoteClientWithPushTokenByTestClient } = require('@condo/domains/notification/utils/testSchema')
const { createTestOrganizationEmployeeRole, registerNewOrganization, inviteNewOrganizationEmployee, acceptOrRejectOrganizationInviteById } = require('@condo/domains/organization/utils/testSchema')
const { User, updateTestUser, makeClientWithServiceUser, makeClientWithSupportUser, makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')

const { ERRORS, MESSAGE_TYPES_REQUIRING_URL } = require('./SendB2BAppPushMessageService')

describe('SendB2BAppPushMessageService', () => {
    let serviceUser,
        admin,
        support,
        staffClient,
        anonymous,
        organization,
        b2bApp

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
    })

    beforeEach(async () => {
        staffClient = await makeClientWithNewRegisteredAndLoggedInUser({
            locale: faker.helpers.arrayElement(Object.keys(LOCALES)),
        })
        serviceUser = await makeClientWithServiceUser()

        const [testOrganization] = await registerNewOrganization(staffClient)
        const [app] = await createTestB2BApp(support)
        await createTestB2BAppContext(staffClient, app, testOrganization, { status: CONTEXT_FINISHED_STATUS })

        const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
            canExecuteSendB2BAppPushMessage: true,
        })
        await createTestB2BAppAccessRight(support, serviceUser.user, app, accessRightSet)

        await syncRemoteClientWithPushTokenByTestClient(staffClient, { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID })

        organization = testOrganization
        b2bApp = app
    })

    describe('Access', () => {
        describe('Service user', () => {
            test('can execute', async () => {
                const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user)

                expect(result.id).toMatch(UUID_RE)
            })

            test('can not execute if organization has not B2BAppContext with b2bApp', async () => {
                const otherServiceUser = await makeClientWithServiceUser()

                const [organization] = await registerNewOrganization(staffClient)
                const [b2bApp] = await createTestB2BApp(support)

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendB2BAppPushMessageByTestClient(otherServiceUser, b2bApp, organization, staffClient.user)
                })
            })

            test('can not execute if service user has not B2BAppAccessRightSet with canExecuteSendB2BAppPushMessage', async () => {
                const otherServiceUser = await makeClientWithServiceUser()

                const [organization] = await registerNewOrganization(staffClient)
                const [b2bApp] = await createTestB2BApp(support)
                await createTestB2BAppContext(staffClient, b2bApp, organization, { status: CONTEXT_FINISHED_STATUS })

                const [accessRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, {
                    canExecuteSendB2BAppPushMessage: false,
                })
                await createTestB2BAppAccessRight(support, serviceUser.user, b2bApp, accessRightSet)

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendB2BAppPushMessageByTestClient(otherServiceUser, b2bApp, organization, staffClient.user)
                })
            })
        })

        describe('Admin', () => {
            test('can not execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendB2BAppPushMessageByTestClient(admin, b2bApp, organization, staffClient.user)
                })
            })
        })

        describe('Support', () => {
            test('can not execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendB2BAppPushMessageByTestClient(support, b2bApp, organization, staffClient.user)
                })
            })
        })

        describe('User', () => {
            test('can not execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendB2BAppPushMessageByTestClient(staffClient, b2bApp, organization, staffClient.user)
                })
            })
        })

        describe('Anonymous', () => {
            test('can not execute', async () => {
                await expectToThrowAuthenticationErrorToResult(async () => {
                    await sendB2BAppPushMessageByTestClient(anonymous, b2bApp, organization, staffClient.user)
                })
            })
        })
    })

    describe('Logic', () => {
        test('Successfully sends a message from a service user with B2B app access rights', async () => {
            const body = faker.random.alphaNumeric(8)
            const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                type: B2B_APP_MESSAGE_PUSH_TYPE,
                meta: {
                    dv: 1,
                    body,
                },
            })
            const user = await User.getOne(support, { id: staffClient.user.id })

            await waitFor(async () => {
                const message = await Message.getOne(staffClient, { id: result.id })

                expect(message.status).toBe(MESSAGE_SENT_STATUS)
                expect(message.organization.id).toBe(organization.id)
                expect(message.user.id).toBe(user.id)
                expect(message.type).toBe(B2B_APP_MESSAGE_PUSH_TYPE)
                expect(message.meta.body).toBe(body)
                expect(message.lang).toBe(user.locale)
            })
        })

        test('Throws an error if no finished B2BContext exists for the specified organization and B2BApp', async () => {
            const [testOrganization] = await registerNewOrganization(staffClient)

            const [otherApp] = await createTestB2BApp(support)
            await createTestB2BAppContext(staffClient, otherApp, testOrganization, { status: CONTEXT_FINISHED_STATUS })

            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, otherApp, {
                canExecuteSendB2BAppPushMessage: true,
            })
            await createTestB2BAppAccessRight(support, serviceUser.user, otherApp, accessRightSet)

            await expectToThrowGQLErrorToResult(async () => {
                await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, testOrganization, staffClient.user)
            }, ERRORS.NO_B2B_CONTEXT)
        })

        test('Throws an error if no B2BAppAccessRight exists with canExecuteSendB2BAppPushMessage', async () => {
            const [app] = await createTestB2BApp(support)
            await createTestB2BAppContext(staffClient, app, organization, { status: CONTEXT_FINISHED_STATUS })
            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app)
            await createTestB2BAppAccessRight(support, serviceUser.user, app, accessRightSet)

            await expectToThrowGQLErrorToResult(async () => {
                await sendB2BAppPushMessageByTestClient(serviceUser, app, organization, staffClient.user)
            }, ERRORS.NO_B2B_APP_ACCESS_RIGHT)
        })

        test('Throws an error if no organization employee exists for the specified user and organization', async () => {
            const user = await makeClientWithNewRegisteredAndLoggedInUser()

            await expectToThrowGQLErrorToResult(async () => {
                await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, user.user)
            }, ERRORS.USER_IS_NOT_AN_EMPLOYEE)
        })

        test('Throws an error if notifications are sent more often than specified in AppMessageSetting', async () => {
            const notificationWindowSize = 3600
            const numberOfNotificationInWindow = 2
            await createTestAppMessageSetting(support, {
                b2bApp,
                notificationWindowSize,
                numberOfNotificationInWindow,
            })

            const [message1] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                type: B2B_APP_MESSAGE_PUSH_TYPE,
            })
            expect(message1.id).toMatch(UUID_RE)

            const [message2] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                type: B2B_APP_MESSAGE_PUSH_TYPE,
            })
            expect(message2.id).toMatch(UUID_RE)

            await expectToThrowGQLErrorToResult(async () => {
                await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                    type: B2B_APP_MESSAGE_PUSH_TYPE,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })
        })

        test('Throws an error if AppMessageSetting has numberOfNotificationInWindow: 0', async () => {
            const numberOfNotificationInWindow = 0
            await createTestAppMessageSetting(support, {
                b2bApp,
                numberOfNotificationInWindow,
                type: PASS_TICKET_CREATED_MESSAGE_TYPE,
            })

            const [message] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                type: B2B_APP_MESSAGE_PUSH_TYPE,
            })
            expect(message.id).toMatch(UUID_RE)

            await expectToThrowGQLErrorToResult(async () => {
                await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                    type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })
        })

        test('Throws an error if employee role has not B2BAppRole', async () => {
            const staffWithoutB2BAppRole = await makeClientWithNewRegisteredAndLoggedInUser()
            const [role] = await createTestOrganizationEmployeeRole(staffClient, organization)
            const [invitedEmployee] = await inviteNewOrganizationEmployee(staffClient, organization, staffWithoutB2BAppRole.userAttrs, role)
            await acceptOrRejectOrganizationInviteById(staffWithoutB2BAppRole, invitedEmployee)

            await expectToThrowGQLErrorToResult(async () => {
                await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffWithoutB2BAppRole.user, {
                    type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                })
            }, ERRORS.NO_B2B_APP_ROLE_FOR_EMPLOYEE_ROLE_AND_B2B_APP)
        })

        test('Throws an error if user is deleted', async () => {
            await updateTestUser(support, staffClient.user.id, {
                deletedAt: new Date().toISOString(),
            })

            await expectToThrowGQLErrorToResult(async () => {
                await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                    type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                })
            }, ERRORS.USER_IS_NOT_AN_EMPLOYEE)
        })

        describe('URL generation', () => {
            test('Generates URL for message types in MESSAGE_TYPES_REQUIRING_URL (PASS_TICKET_CREATED_MESSAGE_TYPE)', async () => {
                const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                    type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                    meta: {
                        dv: 1,
                        data: {
                            openAt: faker.random.word(),
                        },
                    },
                })

                const message = await Message.getOne(staffClient, { id: result.id })
                const expectedUrl = `${conf.SERVER_URL}/miniapps/${b2bApp.id}`

                expect(message.meta.data.url).toEqual(expectedUrl)
                expect(MESSAGE_TYPES_REQUIRING_URL).toContain(PASS_TICKET_CREATED_MESSAGE_TYPE)
            })

            test('Does not generate URL for message types not in MESSAGE_TYPES_REQUIRING_URL (B2B_APP_MESSAGE_PUSH_TYPE)', async () => {
                const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                    type: B2B_APP_MESSAGE_PUSH_TYPE,
                    meta: {
                        dv: 1,
                        title: faker.random.word(),
                        body: faker.random.word(),
                    },
                })

                const message = await Message.getOne(staffClient, { id: result.id })

                expect(message.meta.data?.url).toBeUndefined()
                expect(MESSAGE_TYPES_REQUIRING_URL).not.toContain(B2B_APP_MESSAGE_PUSH_TYPE)
            })

            describe('URL encoding with appInitialContext', () => {
                test('Encodes special characters in appInitialContext using encodeURIComponent', async () => {
                    const appInitialContext = 'next=/pass/ticket/123&source=notification with spaces'
                    const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                        type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                        appInitialContext,
                        meta: {
                            dv: 1,
                            data: {
                                openAt: faker.random.word(),
                            },
                        },
                    })

                    const message = await Message.getOne(staffClient, { id: result.id })
                    const expectedEncodedContext = encodeURIComponent(appInitialContext)
                    const expectedUrl = `${conf.SERVER_URL}/miniapps/${b2bApp.id}#${expectedEncodedContext}`

                    expect(message.meta.data.url).toEqual(expectedUrl)
                    expect(message.meta.data.url).toContain('notification%20with%20spaces')
                })

                test('Encodes ampersands and equals signs in appInitialContext', async () => {
                    const appInitialContext = 'param1=value1&param2=value with & and = signs'
                    const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                        type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                        appInitialContext,
                        meta: {
                            dv: 1,
                            data: {
                                openAt: faker.random.word(),
                            },
                        },
                    })

                    const message = await Message.getOne(staffClient, { id: result.id })
                    const expectedEncodedContext = encodeURIComponent(appInitialContext)
                    const expectedUrl = `${conf.SERVER_URL}/miniapps/${b2bApp.id}#${expectedEncodedContext}`

                    expect(message.meta.data.url).toEqual(expectedUrl)
                    expect(message.meta.data.url).toContain('%26') // encoded &
                    expect(message.meta.data.url).toContain('%3D') // encoded =
                })

                test('Encodes Unicode characters in appInitialContext', async () => {
                    const appInitialContext = 'key1=значение1&key2=テスト'
                    const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                        type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                        appInitialContext,
                        meta: {
                            dv: 1,
                            data: {
                                openAt: faker.random.word(),
                            },
                        },
                    })

                    const message = await Message.getOne(staffClient, { id: result.id })
                    const expectedEncodedContext = encodeURIComponent(appInitialContext)
                    const expectedUrl = `${conf.SERVER_URL}/miniapps/${b2bApp.id}#${expectedEncodedContext}`

                    expect(message.meta.data.url).toEqual(expectedUrl)
                })

                test('Handles empty appInitialContext without encoding', async () => {
                    const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                        type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                        appInitialContext: '',
                        meta: {
                            dv: 1,
                            data: {
                                openAt: faker.random.word(),
                            },
                        },
                    })

                    const message = await Message.getOne(staffClient, { id: result.id })
                    const expectedUrl = `${conf.SERVER_URL}/miniapps/${b2bApp.id}`

                    expect(message.meta.data.url).toEqual(expectedUrl)
                    expect(message.meta.data.url).not.toContain('#')
                })

                test('Handles undefined appInitialContext without encoding', async () => {
                    const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                        type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                        meta: {
                            dv: 1,
                            data: {
                                openAt: faker.random.word(),
                            },
                        },
                    })

                    const message = await Message.getOne(staffClient, { id: result.id })
                    const expectedUrl = `${conf.SERVER_URL}/miniapps/${b2bApp.id}`

                    expect(message.meta.data.url).toEqual(expectedUrl)
                    expect(message.meta.data.url).not.toContain('#')
                })

                test('Encodes complex URL paths and query parameters', async () => {
                    const appInitialContext = 'next=/pass/ticket/123?status=active&filter=urgent'
                    const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                        type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                        appInitialContext,
                        meta: {
                            dv: 1,
                            data: {
                                openAt: faker.random.word(),
                            },
                        },
                    })

                    const message = await Message.getOne(staffClient, { id: result.id })
                    const expectedEncodedContext = encodeURIComponent(appInitialContext)
                    const expectedUrl = `${conf.SERVER_URL}/miniapps/${b2bApp.id}#${expectedEncodedContext}`

                    expect(message.meta.data.url).toEqual(expectedUrl)
                    expect(message.meta.data.url).toContain('%2F') // encoded /
                    expect(message.meta.data.url).toContain('%3F') // encoded ?
                    expect(message.meta.data.url).toContain('%26') // encoded &
                })
            })
        })

        describe('appInitialContext', () => {
            const validAppInitialContextCases = [
                ['next=/pass/ticket/123&source=notification', 'path with parameters'],
                ['filter=active&sort=date&page=1', 'query-like parameters'],
                ['userId=123&action=view&timestamp=1640995200', 'numeric values'],
                ['text=hello%20world&encoded=value%2Bwith%2Bplus', 'URL encoded values'],
                ['custom-string-format-without-equals', 'custom format without equals'],
                ['123456789', 'numeric string'],
            ]

            test.each(validAppInitialContextCases)('Successfully accepts valid appInitialContext: %p (%s)', async (appInitialContext) => {
                const [result] = await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                    type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                    appInitialContext,
                    meta: {
                        dv: 1,
                        data: {
                            openAt: faker.random.word(),
                        },
                    },
                })

                const message = await Message.getOne(staffClient, { id: result.id })
                const expectedUrl = `${conf.SERVER_URL}/miniapps/${b2bApp.id}#${encodeURIComponent(appInitialContext)}`

                expect(message.meta.data.url).toEqual(expectedUrl)
                expect(result.id).toMatch(UUID_RE)
            })

            const invalidAppInitialContextCases = [
                ['javascript:alert(1)', 'javascript protocol'],
                [null, 'null value'],
            ]

            test.each(invalidAppInitialContextCases)('Throws an error for invalid appInitialContext: %p (%s)', async (appInitialContext) => {
                await expectToThrowGQLErrorToResult(async () => {
                    await sendB2BAppPushMessageByTestClient(serviceUser, b2bApp, organization, staffClient.user, {
                        type: PASS_TICKET_CREATED_MESSAGE_TYPE,
                        appInitialContext,
                        meta: {
                            dv: 1,
                            data: {
                                openAt: faker.random.word(),
                            },
                        },
                    })
                }, ERRORS.INVALID_APP_INITIAL_CONTEXT)
            })
        })
    })
})