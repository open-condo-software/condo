/**
 * Generated by `createschema miniapp.B2BAppRole 'app:Relationship:B2BApp:CASCADE; role:Relationship:OrganizationEmployeeRole:CASCADE; permissions:Json;'`
 */

const Ajv = require('ajv')
const get = require('lodash/get')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { getById, getByCondition, find } = require('@open-condo/keystone/schema')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { getGQLErrorValidator } = require('@condo/domains/common/schema/json.utils')
const access = require('@condo/domains/miniapp/access/B2BAppRole')
const { APP_NOT_CONNECTED_ERROR, INVALID_PERMISSIONS_ERROR, CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')


const ERRORS = {
    APP_NOT_CONNECTED: {
        code: BAD_USER_INPUT,
        type: APP_NOT_CONNECTED_ERROR,
        message: 'B2BApp must be connected in organization, which role belongs to',
    },
    ROLE_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        variable: ['data', 'role'],
        message: 'Role not found',
        messageForUser: 'api.organization.organizationEmployee.NOT_FOUND_ROLE',
    },
}

const ajv = new Ajv()


const B2BAppRole = new GQLListSchema('B2BAppRole', {
    schemaDoc: 'This model links the role of the organization and mini-apps, ' +
        'allowing mini-apps to extend the main role template. ' +
        'Having this mapping between role A and mini-app B means that ' +
        'all employees in the organization with role A can access mini-app B. ' +
        'In addition, a mini-app may want to differentiate access within itself. ' +
        'To do this, it can create B2BAppPermissions via service user, ' +
        'the keys of which will appear as properties in the "permissions" field on all B2BAppRole associated with the mini-app.  ' +
        'By default, all existing and new permissions will be set to "true" for all roles in the organization ' +
        'that have "canManageB2BApps" checked, false for other employees. ' +
        'When connecting the miniapp will be automatically created B2BAppRole for all roles that have the "canManageB2BApps" checkbox. ' +
        'B2BAppRole can be created and updated manually by employees with the "canManageRoles" permission for other roles. ' +
        'When deleting B2BAppPermission, its key is also removed from the permissions field of all corresponding B2BAppRole, ' +
        'and when adding it - it is added to all roles, and the value is set according to the rules described above.',
    fields: {
        app: {
            schemaDoc: 'Link to the application to which the role belongs',
            type: 'Relationship',
            ref: 'B2BApp',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: {
                create: true,
                read: true,
                update: false,
            },
        },

        role: {
            schemaDoc: 'Link to the role of the organization that B2BAppRole extends',
            type: 'Relationship',
            ref: 'OrganizationEmployeeRole',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: {
                create: true,
                read: true,
                update: false,
            },
        },

        permissions: {
            schemaDoc: 'A set of specific permissions within a mini-app for a specific role. ' +
                'Is a Json object where the key is the "key" field from B2BAppPermission and the value is Boolean. ' +
                'Example: "{"canManagePasses": true, "canReadConfig": false}"',
            type: 'Json',
            isRequired: true,
            hooks: {
                validateInput: async (args) => {
                    const { resolvedData, existingItem, operation } = args

                    const appId = operation === 'create' ? resolvedData['app'] : existingItem['app']
                    const permissions = await find('B2BAppPermission', { app: { id: appId }, deletedAt: null })
                    const keys = permissions.map(permission => permission.key)

                    const schema = {
                        type: 'object',
                        properties: Object.assign({}, ...keys.map(key => ({
                            [key]: { type: 'boolean' },
                        }))),
                        additionalProperties: false,
                        required: keys,
                    }

                    const validate = ajv.compile(schema)

                    const validateHook = getGQLErrorValidator(validate, INVALID_PERMISSIONS_ERROR)
                    validateHook(args)
                },
            },
        },

    },
    hooks: {
        validateInput: async ({ resolvedData, operation, context }) => {
            if (operation === 'create') {
                const appId = resolvedData['app']
                const roleId = resolvedData['role']
                const role = await getById('OrganizationEmployeeRole', roleId)
                if (!role || role.deletedAt) throw new GQLError(ERRORS.ROLE_NOT_FOUND, context)

                const orgId = get(role, 'organization')
                if (!orgId) throw new GQLError(ERRORS.APP_NOT_CONNECTED, context)

                const connectedContext = await getByCondition('B2BAppContext', {
                    organization: { id: orgId },
                    deletedAt: null,
                    status: CONTEXT_FINISHED_STATUS,
                    app: { id: appId },
                })

                if (!connectedContext) throw new GQLError(ERRORS.APP_NOT_CONNECTED, context)
            }
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['app', 'role'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'b2bAppRole_unique_app_role',
            },
        ],
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), analytical()],
    access: {
        read: access.canReadB2BAppRoles,
        create: access.canManageB2BAppRoles,
        update: access.canManageB2BAppRoles,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAppRole,
    ERRORS,
}
