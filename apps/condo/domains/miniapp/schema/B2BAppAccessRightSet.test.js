/**
 * Generated by `createschema miniapp.B2BAppAccessRightSet 'app:Relationship:B2BApp:CASCADE;'`
 */

const { faker } = require('@faker-js/faker')

const {
    makeLoggedInAdminClient, makeClient, UUID_RE, catchErrorFrom,
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects,
    expectToThrowUniqueConstraintViolationError, expectToThrowAccessDeniedErrorToCount,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowGQLError, expectToThrowGraphQLRequestError, expectToThrowInternalError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { makePayer, createTestPayment, Payment } = require('@condo/domains/acquiring/utils/testSchema')
const {
    createTestBillingIntegration, updateTestBillingIntegrationOrganizationContext,
    createTestBillingIntegrationOrganizationContext, createTestBillingProperty,
    createTestBillingAccount, createTestBillingReceipt, BillingReceipt,
    BillingIntegrationOrganizationContext,
    createTestBillingRecipient,
    updateTestBillingRecipient,
    BillingRecipient,
    createTestBillingReceiptFile,
    BillingReceiptFile,
    updateTestBillingReceiptFile,
} = require('@condo/domains/billing/utils/testSchema')
const { createTestContact, Contact, updateTestContact } = require('@condo/domains/contact/utils/testSchema')
const {
    CALL_METER_READING_SOURCE_ID,
    COLD_WATER_METER_RESOURCE_ID,
} = require('@condo/domains/meter/constants/constants')
const {
    registerMetersReadingsByTestClient,
    createTestMeterReading,
    MeterReadingSource,
    MeterResource,
    createTestMeter,
    updateTestMeterReading,
} = require('@condo/domains/meter/utils/testSchema')
const { ACCESS_RIGHT_SET_MAX_ITEMS_GLOBAL_TYPE, ACCESS_RIGHT_SET_MAX_ITEMS_SCOPED_TYPE } = require('@condo/domains/miniapp/constants')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRight,
    B2BAppAccessRight,
    updateTestB2BAppAccessRight,
    B2BAppAccessRightSet,
    createTestB2BAppAccessRightSet,
    updateTestB2BAppAccessRightSet, createTestB2BAccessTokenReadonly, B2BAccessTokenReadonly,
    updateTestB2BAccessTokenReadonly,
} = require('@condo/domains/miniapp/utils/testSchema')
const { Organization, createTestOrganization, updateTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema/Organization')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { createTestProperty, Property, updateTestProperty } = require('@condo/domains/property/utils/testSchema')
const { buildFakeAddressAndMeta } = require('@condo/domains/property/utils/testSchema/factories')
const { RESIDENT_COMMENT_TYPE } = require('@condo/domains/ticket/constants')
const { STATUS_IDS } = require('@condo/domains/ticket/constants/statusTransitions')
const {
    createTestTicket,
    createTestTicketComment,
    TicketComment,
    updateTestTicket,
    Ticket,
    updateTestTicketComment, createTestTicketClassifier, createTestTicketFile, createTestTicketCommentFile, TicketFile, updateTestTicketFile, TicketCommentFile, updateTestTicketCommentFile,
} = require('@condo/domains/ticket/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    registerNewServiceUserByTestClient,
    makeLoggedInClient,
} = require('@condo/domains/user/utils/testSchema')


describe('B2BAppAccessRightSet', () => {
    let admin
    let support
    let integratedServiceUser, integratedToAnotherAppServiceUser
    let notServiceUser
    let anonymous

    let app
    let anotherApp

    let accessRightSet

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        notServiceUser = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()

        const [createdApp] = await createTestB2BApp(support)
        app = createdApp

        const [createdApp2] = await createTestB2BApp(support)
        anotherApp = createdApp2

        const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(support, app)
        accessRightSet = createdAccessRightSet

        const [newServiceUser] = await registerNewServiceUserByTestClient(support)
        integratedServiceUser = await makeLoggedInClient({ email: newServiceUser.email, password: newServiceUser.password })
        await createTestB2BAppAccessRight(support, integratedServiceUser.user, app)

        const [newServiceUser2] = await registerNewServiceUserByTestClient(support)
        integratedToAnotherAppServiceUser = await makeLoggedInClient({ email: newServiceUser2.email, password: newServiceUser2.password })
        await createTestB2BAppAccessRight(support, integratedToAnotherAppServiceUser.user, anotherApp)
    })

    describe('Accesses', () => {
        afterEach(async () => {
            // reset to default values
            await updateTestB2BAppAccessRightSet(admin, accessRightSet.id, {
                canReadOrganizations: false,
            })
        })

        describe('Admin', () => {
            test('Can create', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                expect(createdAccessRightSet).toBeDefined()
                expect(createdAccessRightSet.id).toMatch(UUID_RE)
                expect(createdAccessRightSet).toHaveProperty('app.id', app.id)
                expect(createdAccessRightSet).toHaveProperty('canManageOrganizations', false)
                expect(createdAccessRightSet).toHaveProperty('canReadOrganizations', false)
                expect(createdAccessRightSet).toHaveProperty('canManageContacts', false)
                expect(createdAccessRightSet).toHaveProperty('canReadContacts', false)
                expect(createdAccessRightSet).toHaveProperty('canManageProperties', false)
                expect(createdAccessRightSet).toHaveProperty('canReadProperties', false)
            })

            test('Can read everything', async () => {
                const foundedAccessRightSet = await B2BAppAccessRightSet.getOne(admin, {
                    id: accessRightSet.id,
                })
                expect(foundedAccessRightSet).toHaveProperty('id', accessRightSet.id)
            })

            test('Can update', async () => {
                const [updatedAccessRightSet] = await updateTestB2BAppAccessRightSet(admin, accessRightSet.id, {
                    canReadOrganizations: true,
                })
                expect(updatedAccessRightSet).toHaveProperty('id', accessRightSet.id)
                expect(updatedAccessRightSet).toHaveProperty('canReadOrganizations', true)
            })

            test('Can soft-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                const [deletedAccessRightSet] = await B2BAppAccessRightSet.softDelete(admin, createdAccessRightSet.id)
                expect(!!deletedAccessRightSet.deletedAt).toBeTruthy()
            })

            test('Can not hard-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppAccessRightSet.delete(admin, createdAccessRightSet.id)
                })
            })
        })

        describe('Support', () => {
            test('Can create', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(support, app)

                expect(createdAccessRightSet).toBeDefined()
                expect(createdAccessRightSet.id).toMatch(UUID_RE)
                expect(createdAccessRightSet).toHaveProperty('app.id', app.id)
            })

            test('Can read everything', async () => {
                const foundedAccessRightSet = await B2BAppAccessRightSet.getOne(support, {
                    id: accessRightSet.id,
                })
                expect(foundedAccessRightSet).toHaveProperty('id', accessRightSet.id)
            })

            test('Can update', async () => {
                const [updatedAccessRightSet] = await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
                    canReadOrganizations: true,
                })
                expect(updatedAccessRightSet).toHaveProperty('id', accessRightSet.id)
                expect(updatedAccessRightSet).toHaveProperty('canReadOrganizations', true)
            })

            test('Can soft-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                const [deletedAccessRightSet] = await B2BAppAccessRightSet.softDelete(support, createdAccessRightSet.id)
                expect(!!deletedAccessRightSet.deletedAt).toBeTruthy()
            })

            test('Can not hard-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppAccessRightSet.delete(support, createdAccessRightSet.id)
                })
            })
        })

        describe('Service user', () => {
            test('Can not create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BAppAccessRightSet(integratedServiceUser, app)
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BAppAccessRightSet(integratedToAnotherAppServiceUser, app)
                })
            })

            test('Can only read if have B2BAppAccessRight connected to B2BApp "A" and B2BAppAccessRightSet connected to B2BApp "A"', async () => {
                const foundedAccessRightSet = await B2BAppAccessRightSet.getOne(integratedServiceUser, {
                    id: accessRightSet.id,
                })
                expect(foundedAccessRightSet).toHaveProperty('id', accessRightSet.id)

                const [foundedAccessRightSetForAnotherApp] = await B2BAppAccessRightSet.getAll(integratedToAnotherAppServiceUser, {
                    id: accessRightSet.id,
                })
                expect(foundedAccessRightSetForAnotherApp).toBeUndefined()
            })

            test('Can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BAppAccessRightSet(integratedServiceUser, accessRightSet.id, {
                        canReadOrganizations: true,
                    })
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BAppAccessRightSet(integratedToAnotherAppServiceUser, accessRightSet.id, {
                        canReadOrganizations: true,
                    })
                })
            })

            test('Can not soft-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppAccessRightSet.softDelete(integratedToAnotherAppServiceUser, createdAccessRightSet.id)
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppAccessRightSet.softDelete(integratedServiceUser, createdAccessRightSet.id)
                })
            })

            test('Can not hard-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppAccessRightSet.delete(integratedServiceUser, createdAccessRightSet.id)
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppAccessRightSet.delete(integratedToAnotherAppServiceUser, createdAccessRightSet.id)
                })
            })
        })

        describe('Not service user', () => {
            test('Can not create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BAppAccessRightSet(notServiceUser, app)
                })
            })

            test('Can not read', async () => {
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await B2BAppAccessRightSet.getAll(notServiceUser, {
                        id: accessRightSet.id,
                    })
                })
            })

            test('Can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BAppAccessRightSet(notServiceUser, accessRightSet.id, {
                        canReadOrganizations: true,
                    })
                })
            })

            test('Can not soft-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppAccessRightSet.softDelete(notServiceUser, createdAccessRightSet.id)
                })
            })

            test('Can not hard-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppAccessRightSet.delete(notServiceUser, createdAccessRightSet.id)
                })
            })
        })

        describe('Anonymous', () => {
            test('Can not create', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestB2BAppAccessRightSet(anonymous, app)
                })
            })

            test('Can not read', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await B2BAppAccessRightSet.getAll(anonymous, {
                        id: accessRightSet.id,
                    })
                })
            })

            test('Can not update', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestB2BAppAccessRightSet(anonymous, accessRightSet.id, {
                        canReadOrganizations: true,
                    })
                })
            })

            test('Can not soft-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await B2BAppAccessRightSet.softDelete(anonymous, createdAccessRightSet.id)
                })
            })

            test('Can not hard-delete', async () => {
                const [app] = await createTestB2BApp(admin)
                const [createdAccessRightSet] = await createTestB2BAppAccessRightSet(admin, app)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppAccessRightSet.delete(anonymous, createdAccessRightSet.id)
                })
            })
        })
    })

    describe('Constraints', () => {
        test(`Cannot be created ${ACCESS_RIGHT_SET_MAX_ITEMS_GLOBAL_TYPE + 1} active set of access rights with type: GLOBAL for a single app`, async () => {
            const [app] = await createTestB2BApp(admin)
            await createTestB2BAppAccessRightSet(admin, app)

            await expectToThrowUniqueConstraintViolationError(async () => {
                await createTestB2BAppAccessRightSet(admin, app)
            }, 'b2b_app_access_right_set_unique_app')
        })

        test(`Cannot be created ${ACCESS_RIGHT_SET_MAX_ITEMS_SCOPED_TYPE + 1} active sets of access rights with type: SCOPED for a single app`, async () => {
            const [app] = await createTestB2BApp(support)
            await createTestB2BAppAccessRightSet(support, app)
            for (let i = 0; i < ACCESS_RIGHT_SET_MAX_ITEMS_SCOPED_TYPE; i++) {
                const [rightSet] = await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED' })
                expect(rightSet).toBeDefined()
            }

            await expectToThrowGQLError(async () => {
                await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED' })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'ACCESS_RIGHT_SET_TOO_MANY_OF_TYPE',
                message: `Too many items of type "SCOPED". Maximum is "${ACCESS_RIGHT_SET_MAX_ITEMS_SCOPED_TYPE}"`,
            }, 'obj')
        })

        test('Cannot create or update set with type "SCOPED" if type "GLOBAL" doesn\'t exists', async () => {
            const [app] = await createTestB2BApp(support)

            // Can't create
            await expectToThrowGQLError(async () => {
                await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED' })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'ACCESS_RIGHT_SET_GLOBAL_RIGHT_SET_REQUIRED',
                message: 'You need to have "GLOBAL" type right before other types',
            }, 'obj')

            // Can't do something if global right set is deleted
            const [globalRightSet] = await createTestB2BAppAccessRightSet(support, app)
            const [tokenRightSet] = await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED' })
            expect(tokenRightSet).toBeDefined()
            await B2BAppAccessRightSet.softDelete(support, globalRightSet.id, {
                dv: 1, sender: { dv: 1, fingerprint: 'b2b-app-access-right-set-test-case' },
            })
            await expectToThrowInternalError(async () => {
                await updateTestB2BAppAccessRightSet(support, tokenRightSet.id, {})
            }, 'Already deleted', ['obj'])

            // Filters out deleted global right set
            await expectToThrowGQLError(async () => {
                await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED' })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'ACCESS_RIGHT_SET_GLOBAL_RIGHT_SET_REQUIRED',
                message: 'You need to have "GLOBAL" type right before other types',
            }, 'obj')
        })

        test('Can not create or update B2BAppAccessRightSet of type "SCOPED" with more permissions, than set of type "GLOBAL" on same app', async () => {
            const [app] = await createTestB2BApp(support)
            await createTestB2BAppAccessRightSet(support, app, { canReadOrganizations: true })

            await expectToThrowGQLError(async () => {
                await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED', canReadMeters: true })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'ACCESS_RIGHT_SET_TOO_MANY_PERMISSIONS',
                message: 'You trying to give to right set more permissions, than "GLOBAL" right set has',
            }, 'obj')

            const [tokenRightSet] = await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED', canReadOrganizations: true })

            await expectToThrowGQLError(async () => {
                await updateTestB2BAppAccessRightSet(support, tokenRightSet.id, { canReadMeters: true })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'ACCESS_RIGHT_SET_TOO_MANY_PERMISSIONS',
                message: 'You trying to give to right set more permissions, than "GLOBAL" right set has',
            }, 'obj')
        })

        test('Removing permissions on "GLOBAL" B2BAppAccessRightSet leads to removing these permissions from entities with type "SCOPED"', async () => {
            const [app] = await createTestB2BApp(support)
            const [globalRightsSet] = await createTestB2BAppAccessRightSet(support, app, { canReadOrganizations: true })

            for (let i = 0; i < Math.round(Math.random() * (ACCESS_RIGHT_SET_MAX_ITEMS_SCOPED_TYPE - 1)) + 1; i++) {
                const [scopedRightSet] = await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED', canReadOrganizations: true })
                expect(scopedRightSet.canReadOrganizations).toEqual(true)
            }

            await updateTestB2BAppAccessRightSet(support, globalRightsSet.id, { canReadOrganizations: false })
            const scopedRightSets = await B2BAppAccessRightSet.getAll(support, { app: { id: app.id } })
            scopedRightSets.forEach(scopedRightSet => {
                expect(scopedRightSet.canReadOrganizations).toEqual(false)
            })
        })

        test('Deleting "GLOBAL" B2BAppAccessRightSet is leading for related right sets of other types deletion', async () => {
            const [app] = await createTestB2BApp(support)
            const [globalRightsSet] = await createTestB2BAppAccessRightSet(support, app, { canReadOrganizations: true })

            const scopedRightSetsCount = Math.round(Math.random() * (ACCESS_RIGHT_SET_MAX_ITEMS_SCOPED_TYPE - 1)) + 1
            for (let i = 0; i < scopedRightSetsCount; i++) {
                const [scopedRightSet] = await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED', canReadOrganizations: true })
                expect(scopedRightSet.canReadOrganizations).toEqual(true)
            }
            await updateTestB2BAppAccessRightSet(support, globalRightsSet.id, { deletedAt: new Date().toISOString() })
            const deletedScopedRightSets = await B2BAppAccessRightSet.getAll(support, {
                app: { id: app.id },
                type: 'SCOPED',
                OR: [
                    // Hack to make client return deleted items also
                    { deletedAt: null },
                    { deletedAt_not: null },
                ],
            })
            expect(deletedScopedRightSets.length).toBeGreaterThanOrEqual(scopedRightSetsCount)
            for (const scopedRightSet of deletedScopedRightSets) {
                expect(scopedRightSet.deletedAt).not.toBeNull()
            }
        })
    })
    
    describe('Name validations', () => {
        test('Takes "default" name if not provided', async () => {
            const [app] = await createTestB2BApp(support)
            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, { name: undefined })
            expect(accessRightSet).toHaveProperty('name', 'default')
        })

        test('Cannot update "name" to empty', async () => {
            const [app] = await createTestB2BApp(support)
            const name = faker.random.alphaNumeric(8)
            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, { name })
            expect(accessRightSet).toHaveProperty('name', name)

            await expectToThrowGQLError(async () => {
                await updateTestB2BAppAccessRightSet(support, accessRightSet.id, { name: '' })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'ACCESS_RIGHT_SET_NAME_REQUIRED',
                message: 'Name is required',
            }, 'obj')
        })

    })
})

describe('B2BApp permissions for service user', () => {
    let support
    let user
    let serviceUser

    beforeEach(async () => {
        support = await makeClientWithSupportUser()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        const [newServiceUser] = await registerNewServiceUserByTestClient(support)
        serviceUser = await makeLoggedInClient({ email: newServiceUser.email, password: newServiceUser.password })
    })

    test('Get all permissions for app', async () => {
        const [app] = await createTestB2BApp(support)
        const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app)
        await createTestB2BAppAccessRight(support, serviceUser.user, app, accessRightSet)

        const foundRight = await B2BAppAccessRight.getOne(support, { app: { id: app.id } })
        expect(foundRight).toHaveProperty('accessRightSet.canReadContacts', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageContacts', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadMeters', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageMeters', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadMeterReadings', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageMeterReadings', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadOrganizations', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageOrganizations', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadOrganizationEmployees', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageOrganizationEmployees', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadProperties', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageProperties', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageTickets', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadTickets', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageTicketFiles', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadTicketFiles', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageTicketComments', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadTicketComments', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageTicketCommentFiles', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadTicketCommentFiles', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadTicketCommentFiles', false)
        expect(foundRight).toHaveProperty('accessRightSet.canExecuteSendB2BAppPushMessage', false)
        expect(foundRight).toHaveProperty('accessRightSet.canReadOrganizationEmployeeRoles', false)
        expect(foundRight).toHaveProperty('accessRightSet.canManageOrganizationEmployeeRoles', false)
    })

    describe('Bulk-operations', () => {
        test('Cannot create many Properties in one request', async () => {
            const [organization] = await registerNewOrganization(user)
            const [app] = await createTestB2BApp(support)
            await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
            const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app)
            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
                canReadProperties: true,
                canManageProperties: true,
                canReadOrganizations: true,
            })
            await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })

            const { address, addressMeta } = buildFakeAddressAndMeta(false)
            const { address: address2, addressMeta: addressMeta2 } = buildFakeAddressAndMeta(false)
            const attrs = [{
                data: {
                    dv: 1,
                    sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    organization: { connect: { id: organization.id } },
                    type: 'building',
                    name: faker.address.streetAddress(true),
                    address: address,
                    addressMeta: addressMeta,
                },
            }, {
                data:{
                    dv: 1,
                    sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    organization: { connect: { id: organization.id } },
                    type: 'building',
                    name: faker.address.streetAddress(true),
                    address: address2,
                    addressMeta: addressMeta2,
                },
            }]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Property.createMany(serviceUser, attrs)
            })
        })

        test('Cannot update many Properties in one request', async () => {
            const [organization] = await registerNewOrganization(user)
            const [app] = await createTestB2BApp(support)
            await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
            const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app)
            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
                canReadProperties: true,
                canManageProperties: true,
                canReadOrganizations: true,
            })
            await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })

            const [property1] = await createTestProperty(support, organization)
            const [property2] = await createTestProperty(support, organization)

            const attrs = [{
                id: property1.id,
                data: {
                    dv: 1,
                    sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    name: faker.address.streetAddress(true),
                },
            }, {
                id: property2.id,
                data: {
                    dv: 1,
                    sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    name: faker.address.streetAddress(true),
                },
            }]
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Property.updateMany(serviceUser, attrs)
            })
        })
    })

    test('Organization', async () => {
        const [organization] = await registerNewOrganization(user)

        const [app] = await createTestB2BApp(support)
        await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
        const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app)

        // B2BApp without permissions
        {
            const countWithoutPermissions = await Organization.count(serviceUser, {})
            expect(countWithoutPermissions).toBe(0)
            const organizationWithoutPermissions = await Organization.getOne(serviceUser, { id: organization.id })
            expect(organizationWithoutPermissions).toBeUndefined()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestOrganization(serviceUser)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestOrganization(serviceUser, organization.id, {})
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Organization.softDelete(serviceUser, organization.id)
            })
        }

        const countByUser = await Organization.count(user, {})
        expect(countByUser).toBe(1)
        const organizationByUser = await Organization.getOne(user, { id: organization.id })
        expect(organizationByUser.id).toBe(organization.id)

        // you cannot create a field "canManageOrganizations". Only reading! Always false!
        await catchErrorFrom(async () => {
            await createTestB2BAppAccessRightSet(support, app, {
                canManageOrganizations: false,
            })
        }, (e) => {
            expect(e.errors[0].message).toContain('Field "canManageOrganizations" is not defined by type "B2BAppAccessRightSetCreateInput"')
        })

        // add permissions for B2BApp
        const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
            canReadOrganizations: true,
        })
        await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })

        // you can update 'canReadOrganizations'
        await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
            canReadOrganizations: true,
        })

        // you cannot update a field "canManageOrganizations". Only reading! Always false!
        await catchErrorFrom(async () => {
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
                canManageOrganizations: false,
            })
        }, (e) => {
            expect(e.errors[0].message).toContain('Field "canManageOrganizations" is not defined by type "B2BAppAccessRightSetUpdateInput"')
        })

        // B2BApp with permission "canReadOrganization: true"
        {
            const countWithPermissions = await Organization.count(serviceUser, {})
            expect(countWithPermissions).toBe(1)
            const organizationWithPermissions = await Organization.getOne(serviceUser, { id: organization.id })
            expect(organizationWithPermissions.id).toBe(organization.id)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestOrganization(serviceUser)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestOrganization(serviceUser, organization.id, {})
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Organization.softDelete(serviceUser, organization.id)
            })
        }

        // B2BApp with permission "canReadOrganization: false"
        await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
            canReadOrganizations: false,
        })

        {
            const countWithoutPermissions = await Organization.count(serviceUser, {})
            expect(countWithoutPermissions).toBe(0)
            const organizationWithoutPermissions = await Organization.getOne(serviceUser, { id: organization.id })
            expect(organizationWithoutPermissions).toBeUndefined()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestOrganization(serviceUser)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestOrganization(serviceUser, organization.id, {})
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Organization.softDelete(serviceUser, organization.id)
            })
        }
    })

    test('Property', async () => {
        const [organization] = await registerNewOrganization(user)

        const [app] = await createTestB2BApp(support)
        await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
        const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app)

        const [property] = await createTestProperty(user, organization)

        // B2BApp without permissions
        {
            await expectToThrowAccessDeniedErrorToCount(async () => {
                await Property.count(serviceUser, {})
            })
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Property.getOne(serviceUser, { id: property.id })
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestProperty(serviceUser, organization)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestProperty(serviceUser, property.id, {
                    name: faker.lorem.word(),
                })
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Property.softDelete(serviceUser, property.id)
            })
        }

        const countByUser = await Property.count(user, {})
        expect(countByUser).toBe(1)
        const propertyByUser = await Property.getOne(user, { id: property.id })
        expect(propertyByUser.id).toBe(property.id)

        // add permissions for B2BApp
        const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
            canReadOrganizations: true, // required permission for manage property
        })
        await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })

        // you can update 'canReadProperties' and 'canManageProperties'
        await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
            canReadProperties: true,
            canManageProperties: true,
        })

        // B2BApp with permissions { canReadProperties: true, canManageProperties: true, canReadOrganizations: true }
        {
            // can create
            const [createdProperty] = await createTestProperty(serviceUser, organization)
            expect(createdProperty).toBeDefined()

            const countByUser = await Property.count(user, { organization: { id: organization.id } })
            expect(countByUser).toBe(2)

            // can read
            const countWithPermissions = await Property.count(serviceUser, {})
            expect(countWithPermissions).toBe(2)
            const propertyWithPermissions = await Property.getOne(serviceUser, { id: property.id })
            expect(propertyWithPermissions.id).toBe(property.id)

            // can update
            await updateTestProperty(serviceUser, property.id, {
                name: faker.lorem.word(),
            })

            // can delete
            const [deletedProperty] = await Property.softDelete(serviceUser, createdProperty.id)
            expect(deletedProperty).toHaveProperty('id', createdProperty.id)
            expect(!!deletedProperty.deletedAt).toBeTruthy()

            const countByUser2 = await Property.count(user, { organization: { id: organization.id } })
            expect(countByUser2).toBe(1)
        }

        // B2BApp with permissions { canReadProperties: false, canManageProperties: false, canReadOrganizations: false }
        {
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
                canReadProperties: false,
                canManageProperties: false,
                canReadOrganizations: false,
            })

            // cannot read
            await expectToThrowAccessDeniedErrorToCount(async () => {
                await Property.count(serviceUser, {})
            })
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Property.getOne(serviceUser, { id: property.id })
            })

            // cannot create
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestProperty(serviceUser, organization)
            })

            // cannot update
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestProperty(serviceUser, property.id, {
                    name: faker.lorem.word(),
                })
            })

            // cannot delete
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Property.softDelete(serviceUser, property.id)
            })

            const countByUser = await Property.count(user, { organization: { id: organization.id } })
            expect(countByUser).toBe(1)
        }

        // B2BApp with permissions { canReadProperties: true, canManageProperties: false, canReadOrganizations: false }
        {
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
                canReadProperties: true,
                canManageProperties: false,
                canReadOrganizations: false,
            })

            // can read
            const countWithPermissions = await Property.count(serviceUser, {})
            expect(countWithPermissions).toBe(1)
            const propertyWithPermissions = await Property.getOne(serviceUser, { id: property.id })
            expect(propertyWithPermissions.id).toBe(property.id)

            // cannot create
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestProperty(serviceUser, organization)
            })

            // cannot update
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestProperty(serviceUser, property.id, {
                    name: faker.lorem.word(),
                })
            })

            // cannot delete
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Property.softDelete(serviceUser, property.id)
            })

            const countByUser = await Property.count(user, { organization: { id: organization.id } })
            expect(countByUser).toBe(1)
        }

        // B2BApp with permissions { canReadProperties: false, canManageProperties: true, canReadOrganizations: false }
        {
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
                canReadProperties: false,
                canManageProperties: true,
                canReadOrganizations: false,
            })

            // cannot read
            await expectToThrowAccessDeniedErrorToCount(async () => {
                await Property.count(serviceUser, {})
            })
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Property.getOne(serviceUser, { id: property.id })
            })

            // cannot create property because you cannot read organizations
            await catchErrorFrom(async () => {
                await createTestProperty(serviceUser, organization)
            }, (e) => {
                expect(e.errors[0].message).toContain('Unable to connect a Property.organization<Organization>')
            })

            // can update
            const [updatedProperty, attrs] = await updateTestProperty(serviceUser, property.id, {
                name: faker.lorem.word(),
            })
            expect(updatedProperty).toHaveProperty('id', property.id)
            expect(updatedProperty).toHaveProperty('name', attrs.name)


            const [createdPropertyByUser] = await createTestProperty(user, organization)

            // can delete
            const [deletedProperty] = await Property.softDelete(serviceUser, createdPropertyByUser.id)
            expect(deletedProperty).toHaveProperty('id', createdPropertyByUser.id)
            expect(!!deletedProperty.deletedAt).toBeTruthy()

            const countByUser = await Property.count(user, { organization: { id: organization.id } })
            expect(countByUser).toBe(1)
        }

        // B2BApp with permissions { canReadProperties: false, canManageProperties: true, canReadOrganizations: true }
        {
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
                canReadProperties: false,
                canManageProperties: true,
                canReadOrganizations: true,
            })

            // cannot read
            await expectToThrowAccessDeniedErrorToCount(async () => {
                await Property.count(serviceUser, {})
            })
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Property.getOne(serviceUser, { id: property.id })
            })

            // can create
            const [createdProperty] = await createTestProperty(serviceUser, organization)
            expect(createdProperty).toBeDefined()

            // can update
            const [updatedProperty, attrs] = await updateTestProperty(serviceUser, property.id, {
                name: faker.lorem.word(),
            })
            expect(updatedProperty).toHaveProperty('id', property.id)
            expect(updatedProperty).toHaveProperty('name', attrs.name)

            // can delete
            const [deletedProperty] = await Property.softDelete(serviceUser, createdProperty.id)
            expect(deletedProperty).toHaveProperty('id', createdProperty.id)
            expect(!!deletedProperty.deletedAt).toBeTruthy()

            const countByUser = await Property.count(user, { organization: { id: organization.id } })
            expect(countByUser).toBe(1)
        }

        // B2BApp with permissions { canReadProperties: true, canManageProperties: false, canReadOrganizations: true }
        {
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
                canReadProperties: true,
                canManageProperties: false,
                canReadOrganizations: true,
            })

            // can read
            const countWithPermissions = await Property.count(serviceUser, {})
            expect(countWithPermissions).toBe(1)
            const propertyWithPermissions = await Property.getOne(serviceUser, { id: property.id })
            expect(propertyWithPermissions).toHaveProperty('id', property.id)

            // cannot create
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestProperty(serviceUser, organization)
            })

            // canot update
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestProperty(serviceUser, property.id, {
                    name: faker.lorem.word(),
                })
            })

            const [createdPropertyByUser] = await createTestProperty(user, organization)

            // cannot delete
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Property.softDelete(serviceUser, createdPropertyByUser.id)
            })

            await Property.softDelete(user, createdPropertyByUser.id)

            const countByUser = await Property.count(user, { organization: { id: organization.id } })
            expect(countByUser).toBe(1)
        }

        // B2BApp with permissions { canReadProperties: true, canManageProperties: true, canReadOrganizations: false }
        {
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
                canReadProperties: true,
                canManageProperties: true,
                canReadOrganizations: false,
            })

            // can read
            const countWithPermissions = await Property.count(serviceUser, {})
            expect(countWithPermissions).toBe(1)
            const propertyWithPermissions = await Property.getOne(serviceUser, { id: property.id })
            expect(propertyWithPermissions).toHaveProperty('id', property.id)

            // you cannot create property because you cannot read organizations
            await catchErrorFrom(async () => {
                await createTestProperty(serviceUser, organization)
            }, (e) => {
                expect(e.errors[0].message).toContain('Unable to connect a Property.organization<Organization>')
            })

            // can update
            const [updatedProperty, attrs] = await updateTestProperty(serviceUser, property.id, {
                name: faker.lorem.word(),
            })
            expect(updatedProperty).toHaveProperty('id', property.id)
            expect(updatedProperty).toHaveProperty('name', attrs.name)


            const [createdPropertyByUser] = await createTestProperty(user, organization)

            // can delete
            const [deletedProperty] = await Property.softDelete(serviceUser, createdPropertyByUser.id)
            expect(deletedProperty).toHaveProperty('id', createdPropertyByUser.id)
            expect(!!deletedProperty.deletedAt).toBeTruthy()

            const countByUser = await Property.count(user, { organization: { id: organization.id } })
            expect(countByUser).toBe(1)
        }

    })

    test('Contact', async () => {
        const [organization] = await registerNewOrganization(user)

        const [app] = await createTestB2BApp(support)
        await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
        const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app)

        const [property] = await createTestProperty(user, organization)
        const [contact] = await createTestContact(user, organization, property)

        // B2BApp without permissions
        await expectToThrowAccessDeniedErrorToCount(async () => {
            await Contact.count(serviceUser, {})
        })
        await expectToThrowAccessDeniedErrorToObjects(async () => {
            await Contact.getOne(serviceUser, { id: contact.id })
        })

        await expectToThrowAccessDeniedErrorToObj(async () => {
            await createTestContact(serviceUser, organization, property)
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestContact(serviceUser, contact.id, {})
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await Contact.softDelete(serviceUser, contact.id)
        })

        const countByUser = await Contact.count(user, {})
        expect(countByUser).toBe(1)
        const contactByUser = await Contact.getOne(user, { id: contact.id })
        expect(contactByUser.id).toBe(contact.id)

        // add permissions for B2BApp
        const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
            canReadContacts: true,
            canManageContacts: true,
            canReadOrganizations: true, // required permission for manage contact
            canReadProperties: true, // required permission for manage contact
        })
        await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })

        // you can update 'canReadContacts' and 'canManageContacts'
        await updateTestB2BAppAccessRightSet(support, accessRightSet.id, {
            canReadContacts: true,
            canManageContacts: true,
        })

        // B2BApp with permissions
        await createTestContact(serviceUser, organization, property)

        const countByUser2 = await Contact.count(user, { organization: { id: organization.id } })
        expect(countByUser2).toBe(2)

        const countWithPermissions = await Contact.count(serviceUser, {})
        expect(countWithPermissions).toBe(2)
        const contactWithPermissions = await Contact.getOne(serviceUser, { id: contact.id })
        expect(contactWithPermissions.id).toBe(contact.id)

        await updateTestContact(serviceUser, contact.id, {})
        await Contact.softDelete(serviceUser, contact.id)

        const countByUser3 = await Contact.count(user, { organization: { id: organization.id } })
        expect(countByUser3).toBe(1)
    })

    test('Ticket domain', async () => {
        const [organization] = await registerNewOrganization(user)

        const [app] = await createTestB2BApp(support)
        await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
        const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app)

        const [property] = await createTestProperty(user, organization)
        const [classifier] = await createTestTicketClassifier(support)
        const unitName = faker.random.alphaNumeric(3)
        const unitType = FLAT_UNIT_TYPE
        const [contact] = await createTestContact(user, organization, property, {
            unitName,
            unitType,
        })

        const [ticket] = await createTestTicket(user, organization, property, {
            contact: { connect: { id: contact.id } },
            assignee: { connect: { id: user.user.id } },
            executor: { connect: { id: user.user.id } },
            classifier: { connect: { id: classifier.id } },
            unitName,
            unitType,
        })

        const [ticketComment] = await createTestTicketComment(user, ticket, user.user)
        const [ticketFile] = await createTestTicketFile(user, ticket)
        const [ticketCommentFile] = await createTestTicketCommentFile(user, ticket, ticketComment)

        // B2BApp without permissions
        await expectToThrowAccessDeniedErrorToCount(async () => {
            await Ticket.count(serviceUser, {})
        })
        await expectToThrowAccessDeniedErrorToObjects(async () => {
            await Ticket.getOne(serviceUser, {
                id: ticket.id,
            })
        })
        await expectToThrowAccessDeniedErrorToObjects(async () => {
            await Ticket.getAll(serviceUser, {})
        })

        await expectToThrowAccessDeniedErrorToCount(async () => {
            await TicketComment.count(serviceUser, {})
        })
        await expectToThrowAccessDeniedErrorToObjects(async () => {
            await TicketComment.getOne(serviceUser, {
                ticket: { id: ticket.id },
            })
        })
        await expectToThrowAccessDeniedErrorToObjects(async () => {
            await TicketComment.getAll(serviceUser, {})
        })

        await expectToThrowAccessDeniedErrorToObj(async () => {
            await createTestTicket(serviceUser, organization, property)
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestTicket(serviceUser, ticket.id)
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await Ticket.softDelete(serviceUser, ticket.id)
        })

        await expectToThrowAccessDeniedErrorToObj(async () => {
            await createTestTicketComment(serviceUser, ticket, serviceUser.user)
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestTicketComment(serviceUser, ticketComment.id)
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await TicketComment.softDelete(serviceUser, ticketComment.id)
        })

        await expectToThrowAccessDeniedErrorToObjects(async () => {
            await TicketFile.getOne(serviceUser, {
                id: ticketFile.id,
            })
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await createTestTicketFile(serviceUser, ticket)
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestTicketFile(serviceUser, ticketFile.id, {})
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await TicketFile.softDelete(serviceUser, ticketFile.id)
        })

        await expectToThrowAccessDeniedErrorToObjects(async () => {
            await TicketCommentFile.getOne(serviceUser, {
                id: ticketCommentFile.id,
            })
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await createTestTicketCommentFile(serviceUser, ticket, ticketComment)
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestTicketCommentFile(serviceUser, ticketCommentFile.id, {})
        })
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await TicketCommentFile.softDelete(serviceUser, ticketCommentFile.id)
        })

        const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
            canReadContacts: true,
            canManageContacts: true,
            canReadOrganizations: true,
            canReadProperties: true,
            canReadTickets: true,
            canManageTickets: true,
            canReadTicketComments: true,
            canManageTicketComments: true,
            canReadTicketFiles: true,
            canManageTicketFiles: true,
            canReadTicketCommentFiles: true,
            canManageTicketCommentFiles: true,
        })
        await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })

        await createTestTicket(serviceUser, organization, property)

        {
            const countWithPermissions = await Ticket.count(serviceUser, {})
            expect(countWithPermissions).toEqual(2)

            const ticketWithPermissions = await Ticket.getOne(serviceUser, { id: ticket.id })

            expect(ticketWithPermissions.id).toEqual(ticket.id)
            expect(ticketWithPermissions.organization.id).toEqual(ticket.organization.id)
            expect(ticketWithPermissions.status.id).toEqual(ticket.status.id)
            expect(ticketWithPermissions.assignee.id).toEqual(ticket.assignee.id)
            expect(ticketWithPermissions.executor.id).toEqual(ticket.executor.id)
            expect(ticketWithPermissions.source.id).toEqual(ticket.source.id)
            expect(ticketWithPermissions.classifier.id).toEqual(ticket.classifier.id)
            expect(ticketWithPermissions.classifier.place.id).toEqual(ticket.classifier.place.id)
            expect(ticketWithPermissions.classifier.category.id).toEqual(ticket.classifier.category.id)
            expect(ticketWithPermissions.classifier.problem.id).toEqual(ticket.classifier.problem.id)
            expect(ticketWithPermissions.property.id).toEqual(ticket.property.id)
            expect(ticketWithPermissions.property.address).toEqual(ticket.property.address)
            expect(ticketWithPermissions.contact.id).toEqual(ticket.contact.id)
            expect(ticketWithPermissions.contact.phone).toEqual(ticket.contact.phone)
            expect(ticketWithPermissions.contact.email).toEqual(ticket.contact.email)
            expect(ticketWithPermissions.contact.name).toEqual(ticket.contact.name)
        }

        const [updatedTicket] = await updateTestTicket(serviceUser, ticket.id, {
            status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
        })
        expect(updatedTicket.status.id).toEqual(STATUS_IDS.IN_PROGRESS)

        const [ticketCommentByServiceUser] = await createTestTicketComment(serviceUser, ticket, serviceUser.user)
        const [ticketCommentWithResidentType] = await createTestTicketComment(user, ticket, user.user, {
            type: RESIDENT_COMMENT_TYPE,
        })

        {
            const countWithPermissions = await TicketComment.count(serviceUser, {})
            expect(countWithPermissions).toEqual(2)

            const ticketCommentWithPermissions = await TicketComment.getOne(serviceUser, { id: ticketComment.id })
            expect(ticketCommentWithPermissions.id).toEqual(ticketComment.id)
            expect(ticketCommentWithPermissions.user.id).toEqual(ticketComment.user.id)
            expect(ticketCommentWithPermissions.user.name).toEqual(ticketComment.user.name)
            expect(ticketCommentWithPermissions.ticket.id).toEqual(ticketComment.ticket.id)
            expect(ticketCommentWithPermissions.type).toEqual(ticketComment.type)

            // can't read ticket comment type with resident type
            const readTicketCommentWithResidentType = await TicketComment.getOne(serviceUser, { id: ticketCommentWithResidentType.id })
            expect(readTicketCommentWithResidentType).toBeUndefined()
        }

        // can't create ticket comment with resident type
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await createTestTicketComment(serviceUser, ticket, serviceUser.user, {
                type: RESIDENT_COMMENT_TYPE,
            })
        })

        // can't update ticket comment type to resident
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestTicketComment(serviceUser, ticketCommentByServiceUser.id, {
                type: RESIDENT_COMMENT_TYPE,
            })
        })

        // can't update not his own ticket comment
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestTicketComment(serviceUser, ticketComment.id, {})
        })

        const readTicketFile = await TicketFile.getOne(serviceUser, { id: ticketFile.id })
        expect(readTicketFile.ticket.id).toEqual(ticketFile.ticket.id)

        const [ticketFileByServiceUser] = await createTestTicketFile(serviceUser, ticket)
        await updateTestTicketFile(serviceUser, ticketFileByServiceUser.id, {})
        await TicketFile.softDelete(serviceUser, ticketFileByServiceUser.id)

        const readTicketCommentFile = await TicketCommentFile.getOne(serviceUser, { id: ticketCommentFile.id })
        expect(readTicketCommentFile.ticket.id).toEqual(ticketCommentFile.ticket.id)

        // can't read ticket comment file in comment with resident type
        const [ticketCommentFileWithResidentUserComment] = await createTestTicketCommentFile(user, ticket, ticketCommentWithResidentType)
        const readTicketCommentFileWithResidentUserComment = await TicketCommentFile.getOne(serviceUser, { id: ticketCommentFileWithResidentUserComment.id })
        expect(readTicketCommentFileWithResidentUserComment).toBeUndefined()

        // can't create file in not own comment
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await createTestTicketCommentFile(serviceUser, ticket, ticketComment)
        })

        // can't update not own file
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestTicketComment(serviceUser, ticketCommentFile.id, {})
        })

        const [ticketCommentFileByServiceUser] = await createTestTicketCommentFile(serviceUser, ticket, ticketCommentByServiceUser)

        await updateTestTicketComment(serviceUser, ticketCommentByServiceUser.id, {})
        await TicketComment.softDelete(serviceUser, ticketCommentByServiceUser.id)

        await updateTestTicketCommentFile(serviceUser, ticketCommentFileByServiceUser.id, {})
        await TicketCommentFile.softDelete(serviceUser, ticketCommentFileByServiceUser.id)
    })

    describe('Meters domain', () => {
        test('RegisterMetersReadings', async () => {
            const [organization] = await registerNewOrganization(user)

            const [newServiceUser] = await registerNewServiceUserByTestClient(support)
            const serviceUser = await makeLoggedInClient({
                email: newServiceUser.email,
                password: newServiceUser.password,
            })

            const [app] = await createTestB2BApp(support)
            await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
            const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app)

            // B2BApp without permissions
            await expectToThrowAccessDeniedErrorToResult(
                async () => await registerMetersReadingsByTestClient(serviceUser, organization, [])
            )

            // add permissions for B2BApp
            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
                canExecuteRegisterMetersReadings: true,
                canReadMeters: true,
                canReadMeterReadings: true,
                canReadOrganizations: true,
                canReadProperties: true,
            })
            await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })

            // B2BApp with permissions
            const [result] = await registerMetersReadingsByTestClient(serviceUser, organization, [])

            expect(result).toHaveLength(0)
        })

        test('create MeterReading model', async () => {
            const [organization] = await registerNewOrganization(user)
            const [property] = await createTestProperty(user, organization)
            const [source] = await MeterReadingSource.getAll(user, { id: CALL_METER_READING_SOURCE_ID })
            const [resource] = await MeterResource.getAll(user, { id: COLD_WATER_METER_RESOURCE_ID })
            const [meter] = await createTestMeter(user, organization, property, resource, {})

            const [newServiceUser] = await registerNewServiceUserByTestClient(support)
            const serviceUser = await makeLoggedInClient({
                email: newServiceUser.email,
                password: newServiceUser.password,
            })

            const [app] = await createTestB2BApp(support)
            await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
            const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app)

            // B2BApp without permissions
            await expectToThrowAccessDeniedErrorToObj(
                async () => await createTestMeterReading(serviceUser, meter, source)
            )

            // add permissions for B2BApp
            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
                canReadMeters: true,
                canReadMeterReadings: true,
                canManageMeters: true,
                canManageMeterReadings: true,
                canReadOrganizations: true,
                canReadProperties: true,
            })
            await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })

            // B2BApp with permissions
            const [result] = await createTestMeterReading(serviceUser, meter, source)

            expect(result.id).toMatch(UUID_RE)
        })

        test('update MeterReading model', async () => {
            const [organization] = await registerNewOrganization(user)
            const [property] = await createTestProperty(user, organization)
            const [source] = await MeterReadingSource.getAll(user, { id: CALL_METER_READING_SOURCE_ID })
            const [resource] = await MeterResource.getAll(user, { id: COLD_WATER_METER_RESOURCE_ID })
            const [meter] = await createTestMeter(user, organization, property, resource, {})
            const [meterReading] = await createTestMeterReading(user, meter, source)

            const [newServiceUser] = await registerNewServiceUserByTestClient(support)
            const serviceUser = await makeLoggedInClient({
                email: newServiceUser.email,
                password: newServiceUser.password,
            })

            const [app] = await createTestB2BApp(support)
            await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
            const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app)

            // B2BApp without permissions
            await expectToThrowAccessDeniedErrorToObj(
                async () => await updateTestMeterReading(serviceUser, meterReading.id, { billingStatus: 'approved' })
            )

            // add permissions for B2BApp
            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
                canReadMeters: true,
                canReadMeterReadings: true,
                canManageMeters: true,
                canManageMeterReadings: true,
                canReadOrganizations: true,
                canReadProperties: true,
            })
            await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })

            // B2BApp with permissions
            const [result] = await updateTestMeterReading(serviceUser, meterReading.id, { billingStatus: 'approved' })

            expect(result.id).toMatch(UUID_RE)
        })
    })

    describe('Billing domain', () => {
        let admin, support, user
        let integration
        let organization
        let context
        let property
        let account
        let serviceUser
        let b2bApp
        let b2bAppAccessRightSet

        beforeAll(async () => {
            admin = await makeLoggedInAdminClient()
            support = await makeClientWithSupportUser()
            user = await makeClientWithNewRegisteredAndLoggedInUser();
            [integration] = await createTestBillingIntegration(support);
            [organization] = await registerNewOrganization(user);
            [context] = await createTestBillingIntegrationOrganizationContext(user, organization, integration);
            [context] = await updateTestBillingIntegrationOrganizationContext(user, context.id, { status: CONTEXT_FINISHED_STATUS });
            [property] = await createTestBillingProperty(admin, context);
            [account] = await createTestBillingAccount(admin, context, property)
        })

        beforeEach(async () => {
            const [newServiceUser] = await registerNewServiceUserByTestClient(support)
            serviceUser = await makeLoggedInClient({
                email: newServiceUser.email,
                password: newServiceUser.password,
            });

            [b2bApp] = await createTestB2BApp(support)
            await createTestB2BAppContext(support, b2bApp, organization, { status: 'Finished' });
            [b2bAppAccessRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp)
            await createTestB2BAppAccessRight(support, serviceUser.user, b2bApp, b2bAppAccessRightSet)
        })

        test('can create Billing Context', async () => {
            await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canManageBillingIntegrationOrganizationContexts: true, canReadOrganizations: true })
            const createdContext = await createTestBillingIntegrationOrganizationContext(serviceUser, organization, integration)
            expect(createdContext).toBeDefined()
        })

        test('can update Billing Context', async () => {
            await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canManageBillingIntegrationOrganizationContexts: true })
            const [updatedContext] = await updateTestBillingIntegrationOrganizationContext(serviceUser, context.id, { settings: { dv: 1, updated: true } })
            expect(updatedContext).toBeDefined()
            expect(updatedContext.settings.updated).toBeDefined()
        })

        test('can read Billing Context', async () => {
            await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canReadBillingIntegrationOrganizationContexts: false })

            // Without rights
            const contextWithoutRights = await BillingIntegrationOrganizationContext.getOne(serviceUser, { id: context.id })
            expect(contextWithoutRights).not.toBeDefined()

            await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canReadBillingIntegrationOrganizationContexts: true })
            // With rights
            const billingContext = await BillingIntegrationOrganizationContext.getOne(serviceUser, { id: context.id })
            expect(billingContext).toBeDefined()
            expect(billingContext.organization).toBeNull()
        })

        test('cannot create BillingRecipient', async () => {
            await expectToThrowGraphQLRequestError(async () => {
                await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canManageBillingRecipients: true })
            }, 'Field "canManageBillingRecipients" is not defined')

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestBillingRecipient(serviceUser, context)
            })
        })

        test('cannot update BillingRecipient', async () => {
            await expectToThrowGraphQLRequestError(async () => {
                await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canManageBillingRecipients: true })
            }, 'Field "canManageBillingRecipients" is not defined')

            const [recipient] = await createTestBillingRecipient(admin, context)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestBillingRecipient(serviceUser, recipient.id)
            })
        })

        test('can read BillingRecipient with rights', async () => {
            const [recipientCreated] = await createTestBillingRecipient(admin, context)

            // Cannot without rights
            const recipientWithoutRights = await BillingRecipient.getOne(serviceUser, { id: recipientCreated.id })
            expect(recipientWithoutRights).toBeUndefined()

            // Can with rights
            await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canReadBillingRecipients: true })

            const recipient = await BillingRecipient.getOne(serviceUser, { id: recipientCreated.id })

            expect(recipient).toBeDefined()
        })

        test('cannot create BillingReceiptFile', async () => {
            await expectToThrowGraphQLRequestError(async () => {
                await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canManageBillingReceiptFiles: true })
            }, 'Field "canManageBillingReceiptFiles" is not defined')

            const [receipt] = await createTestBillingReceipt(admin, context, property, account)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestBillingReceiptFile(serviceUser, receipt, context)
            })
        })

        test('cannot update BillingReceiptFile', async () => {
            await expectToThrowGraphQLRequestError(async () => {
                await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canManageBillingReceiptFiles: true })
            }, 'Field "canManageBillingReceiptFiles" is not defined')

            const [receipt] = await createTestBillingReceipt(admin, context, property, account)
            const [receiptFile] = await createTestBillingReceiptFile(admin, receipt, context)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestBillingReceiptFile(serviceUser, receiptFile.id)
            })
        })

        test('can read BillingReceiptFile', async () => {
            const [receipt] = await createTestBillingReceipt(admin, context, property, account)
            const [receiptFileCreated] = await createTestBillingReceiptFile(admin, receipt, context)

            // Without rights
            const receiptWithoutRights = await BillingReceiptFile.getOne(serviceUser, { id: receiptFileCreated.id })
            expect(receiptWithoutRights).not.toBeDefined()

            await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canReadBillingReceiptFiles: true })

            // With rights
            const receiptFile = await BillingReceiptFile.getOne(serviceUser, { id: receiptFileCreated.id })
            expect(receiptFile).toBeDefined()
        })

        test('cannot create BillingReceipt', async () => {
            // 'Manage' right is not defined
            await expectToThrowGraphQLRequestError(async () => {
                await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canManageBillingReceipts: true })
            }, 'Field "canManageBillingReceipts" is not defined')
        })

        test('cannot update BillingReceipt', async () => {
            // 'Manage' right is not defined
            await expectToThrowGraphQLRequestError(async () => {
                await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canManageBillingReceipts: true })
            }, 'Field "canManageBillingReceipts" is not defined')
        })

        test('can read BillingReceipt', async () => {
            const [receiptCreated] = await createTestBillingReceipt(admin, context, property, account)

            // Without rights
            const receiptWithoutRights = await BillingReceipt.getOne(serviceUser, { id: receiptCreated.id })
            expect(receiptWithoutRights).not.toBeDefined()

            await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canReadBillingReceipts: true })
            // With rights
            const receipt = await BillingReceipt.getOne(serviceUser, { id: receiptCreated.id })
            expect(receipt).toBeDefined()
            expect(receipt.account).toBeNull()
            expect(receipt.property).toBeNull()
        })

        test('can read BillingProperty and BillingAccount', async () => {
            const [receiptCreated] = await createTestBillingReceipt(admin, context, property, account)

            // Without rights
            const receiptWithoutRights = await BillingReceipt.getOne(serviceUser, { id: receiptCreated.id })
            expect(receiptWithoutRights).not.toBeDefined()

            await updateTestB2BAppAccessRightSet(support, b2bAppAccessRightSet.id, { canReadBillingReceipts: true, canReadBillingProperties: true, canReadBillingAccounts: true })            // With rights
            const receipt = await BillingReceipt.getOne(serviceUser, { id: receiptCreated.id })
            expect(receipt).toBeDefined()
            expect(receipt.account).toBeDefined()
            expect(receipt.property).toBeDefined()
        })

    })

    describe('B2BAccessTokens model', () => {

        let app
        let context
        let serviceUser
        let scopedRightSet
        let accessRightSet

        beforeAll(async () => {
            const [organization] = await registerNewOrganization(user)
            const [newServiceUser] = await registerNewServiceUserByTestClient(support)
            serviceUser = await makeLoggedInClient({ email: newServiceUser.email, password: newServiceUser.password });
            [app] = await createTestB2BApp(support);
            [context] = await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
            const [right] = await createTestB2BAppAccessRight(support, serviceUser.user, app);
            [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
                canReadB2BAccessTokens: true,
                canManageB2BAccessTokens: true,
            });
            [scopedRightSet] = await createTestB2BAppAccessRightSet(support, app, { type: 'SCOPED' })
            await updateTestB2BAppAccessRight(support, right.id, { accessRightSet: { connect: { id: accessRightSet.id } } })
        })

        test('create B2BAccessToken', async () => {
            // can with rights
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, { canManageB2BAccessTokens: true })
            const [token] = await createTestB2BAccessTokenReadonly(serviceUser, context, scopedRightSet)
            expect(token).toBeDefined()

            // can't without rights
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, { canManageB2BAccessTokens: false })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestB2BAccessTokenReadonly(serviceUser, context, scopedRightSet)
            })
        })

        test('update B2BAccessToken', async () => {
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, { canManageB2BAccessTokens: true })
            const [token] = await createTestB2BAccessTokenReadonly(serviceUser, context, scopedRightSet)

            // can with rights
            const [updatedToken] = await updateTestB2BAccessTokenReadonly(serviceUser, token.id, {})
            expect(updatedToken).toBeDefined()

            // can't without rights
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, { canManageB2BAccessTokens: false })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestB2BAccessTokenReadonly(serviceUser, token.id, {})
            })
        })

        test('read B2BAccessToken', async () => {
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, { canReadB2BAccessTokens: true, canManageB2BAccessTokens: true })
            const [token] = await createTestB2BAccessTokenReadonly(serviceUser, context, scopedRightSet)

            // can with rights
            const readToken = await B2BAccessTokenReadonly.getOne(serviceUser, { id: token.id })
            expect(readToken).toBeDefined()
            expect(readToken).toEqual(token)

            // can't without rights
            await updateTestB2BAppAccessRightSet(support, accessRightSet.id, { canReadB2BAccessTokens: false })
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await B2BAccessTokenReadonly.getOne(serviceUser, { id: token.id })
            })
        })

    })
    
    describe('Payment model', () => {
        
        test('create or update Payment', async () => {
            const [app] = await createTestB2BApp(support)
            // right does not exist in set
            await expectToThrowGraphQLRequestError(async () => {
                await createTestB2BAppAccessRightSet(support, app, { canManagePayments: true })
            }, 'Field "canManagePayments" is not defined')
        })
        
        test('read Payment', async () => {
            const { admin, billingReceipts, acquiringContext, organization } = await makePayer()
            const [{ id: paymentForOrganizationId }] = await createTestPayment(admin, organization, billingReceipts[0], acquiringContext)
            const { billingReceipts: anotherBillingReceipts, acquiringContext: anotherAcquiringContext, organization: anotherOrganization } = await makePayer()
            const [{ id: paymentForAnotherOrganizationId }] = await createTestPayment(admin, anotherOrganization, anotherBillingReceipts[0], anotherAcquiringContext)

            const [app] = await createTestB2BApp(support)
            const [anotherApp] = await createTestB2BApp(support)

            const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, { canReadPayments: true })
            const [anotherAccessRightSet] = await createTestB2BAppAccessRightSet(support, anotherApp, { canReadPayments: true })

            const [newServiceUser] = await registerNewServiceUserByTestClient(support)
            const serviceUserClient = await makeLoggedInClient({ email: newServiceUser.email, password: newServiceUser.password })
            await createTestB2BAppAccessRight(support, serviceUserClient.user, app, accessRightSet)

            const [newServiceUser2] = await registerNewServiceUserByTestClient(support)
            const anotherServiceUserClient = await makeLoggedInClient({ email: newServiceUser2.email, password: newServiceUser2.password })
            await createTestB2BAppAccessRight(support, anotherServiceUserClient.user, anotherApp, anotherAccessRightSet)

            // can't without rights
            const paymentWithoutRights = await Payment.getOne(serviceUserClient, { id: paymentForOrganizationId })
            expect(paymentWithoutRights).not.toBeDefined()

            await createTestB2BAppContext(support, app, organization, { status: 'Finished' })
            await createTestB2BAppContext(support, anotherApp, anotherOrganization, { status: 'Finished' })

            const paymentsByServiceUser = await Payment.getAll(serviceUserClient, {})
            expect(paymentsByServiceUser).toHaveLength(1)
            expect(paymentsByServiceUser[0].id).toBe(paymentForOrganizationId)

            const paymentsByAnotherServiceUser = await Payment.getAll(anotherServiceUserClient, {})
            expect(paymentsByAnotherServiceUser).toHaveLength(1)
            expect(paymentsByAnotherServiceUser[0].id).toBe(paymentForAnotherOrganizationId)
        })
    })
})
