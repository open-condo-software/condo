/**
 * Generated by `createschema miniapp.CustomValue 'objectId:Text; data:Json; customField:Relationship:CustomField:PROTECT; sourceType:Text; sourceId:Text; organization:Relationship:Organization:PROTECT;'`
 */

const Ajv = require('ajv')
const { get } = require('lodash')

const { execGqlWithoutAccess } = require('@open-condo/codegen/generate.server.utils')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById, find } = require('@open-condo/keystone/schema')

const { UUID_REGEXP } = require('@condo/domains/common/constants/regexps')
const { UNIT_TYPE_FIELD } = require('@condo/domains/common/schema/fields')
const { getGQLErrorValidator } = require('@condo/domains/common/schema/json.utils')
const access = require('@condo/domains/miniapp/access/CustomValue')

const { ALLOWED_TYPES, ALLOWED_SCHEMAS } = require('./CustomField')

const { generateGqlQueryToOrganizationId } = require('../utils/b2bAppServiceUserAccess/helpers.utils')


const ajv = new Ajv()

const B2B_APP_SOURCE_TYPE = 'B2BApp'

const ALLOWED_SOURCE_TYPES_CONFIG = {
    [B2B_APP_SOURCE_TYPE]: {
        validateSourceId: async (args) => {
            const { context, sourceId: B2BAppSourceId } = args

            const userId = context?.authedItem?.id
            if (!userId || context.authedListKey !== 'User') {
                throw new Error('Cannot check source id for non user authed entity')
            }

            try {
                const b2bApp = await getById('B2BApp', B2BAppSourceId)
                if (!b2bApp || b2bApp.deletedAt) {
                    throw new Error('B2BApp is deleted')
                }

                // Support and admin users can set any b2b apps as source
                if (context?.authedItem?.isSupport || context?.authedItem?.isAdmin) {
                    return true
                }

                // Regular users should have access right to set source
                const [accessRightForUserAndApp] = await find('B2BAppAccessRight', {
                    user: { id: userId, deletedAt: null },
                    app: { id: B2BAppSourceId, deletedAt: null },
                    deletedAt: null,
                })
                if (!accessRightForUserAndApp) {
                    throw new Error('This user cannot set this source id')
                }
                return true
            } catch (err) {
                return false
            }
        },
    },
}

const BAD_OBJECT_ID = 'BAD_OBJECT_ID'
const BAD_SOURCE = 'BAD_SOURCE'
const BAD_DATA = 'BAD_DATA'
const BAD_UNIT = 'BAD_UNIT'
const BAD_ADDRESS_KEY = 'BAD_ADDRESS_KEY'
const ALREADY_EXISTS_UNIQ_KEY = 'ALREADY_EXISTS_UNIQ_KEY'
const ALREADY_EXISTS_CONSTRAINT = 'ALREADY_EXISTS_CONSTRAINT'
const ALREADY_EXISTS_MANY = 'ALREADY_EXISTS_CONSTRAINT'

const ERRORS = {
    BAD_DATA: {
        code: BAD_USER_INPUT,
        type: BAD_DATA,
        message: 'Provided data is wrong',
    },
    BAD_OBJECT_ID: {
        code: BAD_USER_INPUT,
        type: BAD_OBJECT_ID,
        message: 'Provided object id is wrong, or you do not have access to this object',
    },
    BAD_SOURCE: {
        code: BAD_USER_INPUT,
        type: BAD_SOURCE,
        message: 'Provided combination of sourceType and sourceId is wrong, or you do not have rights to set this source',
    },
    BAD_UNIT: {
        code: BAD_USER_INPUT,
        type: BAD_UNIT,
        message: 'Provided combination of unitName and unitType is wrong, check that provided unit belongs to the provided objectId',
    },
    BAD_ADDRESS_KEY: {
        code: BAD_USER_INPUT,
        type: BAD_ADDRESS_KEY,
        message: 'Provided addressKey is wrong, check that provided addressKey belongs to the provided objectId',
    },
    ALREADY_EXISTS_UNIQ_KEY: {
        code: BAD_USER_INPUT,
        type: ALREADY_EXISTS_UNIQ_KEY,
        message: 'Provided combination of sourceType and sourceId is wrong, or you do not have rights to set this source',
    },
    ALREADY_EXISTS_CONSTRAINT: {
        code: BAD_USER_INPUT,
        type: ALREADY_EXISTS_CONSTRAINT,
        message: 'Provided combination of sourceType and sourceId is wrong, or you do not have rights to set this source',
    },
    ALREADY_EXISTS_MANY: {
        code: BAD_USER_INPUT,
        type: ALREADY_EXISTS_MANY,
        message: 'Provided combination of sourceType and sourceId is wrong, or you do not have rights to set this source',
    },
}

const CustomValue = new GQLListSchema('CustomValue', {
    schemaDoc: 'Custom value for CustomField',
    fields: {
        customField: {
            schemaDoc: 'CustomField object that this data refers to ',
            type: 'Relationship',
            ref: 'CustomField',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },

        data: {
            schemaDoc: 'Data of this customValue',
            type: 'Json',
            isRequired: true,
        },

        objectId: {
            schemaDoc: 'What instance of CustomField.schemaName this customValue relates to?',
            type: 'Text',
            isRequired: true,
        },

        filterDataString: {
            schemaDoc: 'String representation of data. Controlled by type field in customValue. Use it for filtering',
            type: 'Text',
            isRequired: false,
            access: {
                create: false,
                update: false,
            },
        },

        sourceType: {
            schemaDoc: 'Type of entity, responsible for the last update of this customField',
            type: 'Select',
            options: Object.keys(ALLOWED_SOURCE_TYPES_CONFIG),
            isRequired: true,
        },

        sourceId: {
            schemaDoc: 'ID of entity, responsible for the last update of this customField',
            type: 'Text',
            isRequired: true,
            hooks: {
                validateInput: async ({ addFieldValidationError, resolvedData, existingItem, operation, context, originalInput }) => {
                    const resultObject = { ...resolvedData, ...existingItem }

                    const sourceType = resultObject.sourceType
                    const sourceId = resultObject.sourceId

                    const sourceIdValidator = ALLOWED_SOURCE_TYPES_CONFIG[sourceType]?.validateSourceId
                    if (typeof sourceIdValidator !== 'function') { addFieldValidationError('Source id cannot be validated') }

                    const sourceIdIsValid = await sourceIdValidator({ context, sourceId })
                    if (!sourceIdIsValid) {
                        addFieldValidationError('Source id is bad')
                    }
                },
            },
        },

        organization: {
            schemaDoc: 'Organization that owns data inside this CustomValue',
            type: 'Relationship',
            ref: 'Organization',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },

        unitName: {
            schemaDoc: 'Flat number / door number of an apartment building (property)',
            type: 'Text',
            isRequired: false,
        },

        unitType: {
            ...UNIT_TYPE_FIELD,
            defaultValue: undefined,
            schemaDoc: 'Type of unit, such as parking lot or flat',
        },

        addressKey: {
            type: 'Text',
            schemaDoc: 'The unique key of the address',
            isRequired: false,
        },

        uniqueConstraintKey: {
            schemaDoc: 'System defined constraint',
            type: 'Text',
            isRequired: false,
            access: {
                create: false,
                update: false,
            },
        },

        uniqKey: {
            schemaDoc: 'User defined custom ID. If set, guaranteed to be unique among single source (sourceType + sourceId)',
            type: 'Text',
            isRequired: false,
        },
    },
    hooks: {
        resolveInput: async ({ resolvedData, existingItem, operation, context, originalInput }) => {
            const resultObject = { ...resolvedData, ...existingItem }

            const customField = await getById('CustomField', resultObject.customField)
            if (!customField || customField.deletedAt) {
                throw new Error('Custom field is bad')
            }

            return resolvedData
        },
        validateInput: async ({ resolvedData, existingItem, operation, context, originalInput }) => {
            const resultObject = { ...resolvedData, ...existingItem }

            const customField = await getById('CustomField', resultObject.customField)
            if (!customField || customField.deletedAt) {
                throw new Error('Custom field is bad')
            }

            const customFieldValidationRules = customField.validationRules

            const customFieldSchemaName = customField.schemaName
            const customFieldSchemaConfig = ALLOWED_SCHEMAS[customFieldSchemaName]

            const customFieldType = customField.type
            const customFieldTypeConfig = ALLOWED_TYPES[customFieldType]

            if (resolvedData.data) {
                // 1. Validate data on field rules
                if (!customFieldTypeConfig.valueIsValid(resolvedData.data)) {
                    throw new GQLError(ERRORS.BAD_DATA, context)
                }

                // 2. Validate data on custom field rules
                const validator = getGQLErrorValidator(ajv.compile(customFieldValidationRules), BAD_DATA)
                validator( { resolvedData, fieldPath: 'data', context } )
            }

            if (resolvedData.objectId || resolvedData.organization) {
                const objectId = resultObject.objectId
                const organizationId = resultObject.organization

                // 1. ObjectId should belong to the same organization as this CustomValue
                const pathToOrganizationId = get(customFieldSchemaConfig, 'pathToOrganizationId', ['organization', 'id'])

                if (!UUID_REGEXP.test(objectId)) {
                    throw new GQLError(ERRORS.BAD_OBJECT_ID, context)
                }

                try {
                    const object = await getById(customFieldSchemaName, objectId)
                    if (!object || object.deletedAt) {
                        throw new Error('ObjectId is not valid')
                    }

                    let objectOrganizationId = null

                    // [id] / [orgId]
                    if (pathToOrganizationId.length === 1) {
                        objectOrganizationId = objectId
                    }

                    // ['organization', 'id'] / ['userOrg', 'id']
                    else if (pathToOrganizationId.length === 2 && pathToOrganizationId[1] === 'id') {
                        objectOrganizationId = object[pathToOrganizationId[0]]
                    }

                    // ['ticket', 'organization', 'id']
                    else {
                        const [objectOrganization] = await execGqlWithoutAccess(context, {
                            query: generateGqlQueryToOrganizationId(customFieldSchemaName, pathToOrganizationId.slice(1)),
                            variables: {
                                where: { id: objectId },
                                first: 1,
                            },
                            dataPath: 'objs',
                        })
                        objectOrganizationId = objectOrganization.id
                    }

                    if (!objectOrganizationId || objectOrganizationId !== organizationId) {
                        throw new Error('ObjectId is not valid: organizations do not match')
                    }
                } catch (err) {
                    throw new GQLError(ERRORS.BAD_OBJECT_ID, context)
                }
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadCustomValues,
        create: access.canManageCustomValues,
        update: access.canManageCustomValues,
        delete: false,
        auth: true,
    },
})

module.exports = {
    CustomValue,
    ALLOWED_SOURCE_TYPES_CONFIG,
    B2B_APP_SOURCE_TYPE,
    ERRORS,
}
