/**
 * Generated by `createschema miniapp.CustomValue 'objectId:Text; data:Json; customField:Relationship:CustomField:PROTECT; sourceType:Text; sourceId:Text; organization:Relationship:Organization:PROTECT;'`
 */

const Ajv = require('ajv')
const { get } = require('lodash')

const { execGqlWithoutAccess } = require('@open-condo/codegen/generate.server.utils')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById, find, itemsQuery } = require('@open-condo/keystone/schema')

const { UUID_REGEXP } = require('@condo/domains/common/constants/regexps')
const { UNIT_TYPE_FIELD } = require('@condo/domains/common/schema/fields')
const { getGQLErrorValidator } = require('@condo/domains/common/schema/json.utils')
const access = require('@condo/domains/miniapp/access/CustomValue')

const { ALLOWED_TYPES, ALLOWED_SCHEMAS } = require('./CustomField')

const { ORGANIZATION_OWNED_FIELD } = require('../../organization/schema/fields')
const { generateGqlQueryToOrganizationId } = require('../utils/b2bAppServiceUserAccess/helpers.utils')


const ajv = new Ajv()

const B2B_APP_SOURCE_TYPE = 'B2BApp'

const ALLOWED_SOURCE_TYPES_CONFIG = {
    [B2B_APP_SOURCE_TYPE]: {
        validateSourceId: async (args) => {
            const { context, sourceId: B2BAppSourceId } = args

            const userId = context?.authedItem?.id
            if (!userId || context.authedListKey !== 'User') {
                return false
            }

            try {
                const b2bApp = await getById('B2BApp', B2BAppSourceId)
                if (!b2bApp || b2bApp.deletedAt) {
                    throw new Error('B2BApp is deleted')
                }

                // Support and admin users can set any b2b app as source
                if (context?.authedItem?.isSupport || context?.authedItem?.isAdmin) {
                    return true
                }

                // Regular users should have access right to set source
                const [accessRightForUserAndApp] = await find('B2BAppAccessRight', {
                    user: { id: userId, deletedAt: null },
                    app: { id: B2BAppSourceId, deletedAt: null },
                    deletedAt: null,
                })
                if (!accessRightForUserAndApp) {
                    throw new Error('This user is not allowed to set this source id')
                }
                return true
            } catch (err) {
                return false
            }
        },
    },
}

const INVALID_OBJECT_ID = 'INVALID_OBJECT_ID'
const INVALID_SOURCE = 'INVALID_SOURCE'
const INVALID_DATA_TYPE = 'INVALID_DATA_TYPE'
const INVALID_DATA = 'INVALID_DATA'
const INVALID_CUSTOM_FIELD = 'INVALID_CUSTOM_FIELD'
const INVALID_UNIT = 'INVALID_UNIT'
const INVALID_ADDRESS_KEY = 'INVALID_ADDRESS_KEY'
const ALREADY_EXISTS_UNIQ_KEY = 'ALREADY_EXISTS_UNIQ_KEY'
const ALREADY_EXISTS_OBJECT_ID = 'ALREADY_EXISTS_OBJECT_ID'
const FAILED_TO_CAST = 'FAILED_TO_CAST'

const ERRORS = {
    INVALID_DATA: {
        type: INVALID_DATA,
    },
    INVALID_DATA_TYPE: {
        code: BAD_USER_INPUT,
        type: INVALID_DATA_TYPE,
        message: 'Type of the provided data is invalid. Check type rules for provided customField',
    },
    INVALID_OBJECT_ID: {
        code: BAD_USER_INPUT,
        type: INVALID_OBJECT_ID,
        message: 'Provided object id does not exist, was deleted, or you do not have access to this object',
    },
    INVALID_SOURCE: {
        code: BAD_USER_INPUT,
        type: INVALID_SOURCE,
        message: 'Provided combination of sourceType and sourceId is invalid, or you do not have rights to set this source',
    },
    INVALID_UNIT: {
        code: BAD_USER_INPUT,
        type: INVALID_UNIT,
        message: 'Provided combination of unitName and unitType is invalid, check that provided unit belongs to the provided objectId',
    },
    INVALID_ADDRESS_KEY: {
        code: BAD_USER_INPUT,
        type: INVALID_ADDRESS_KEY,
        message: 'Provided addressKey is wrong, check that provided addressKey belongs to the provided objectId',
    },
    INVALID_CUSTOM_FIELD: {
        code: BAD_USER_INPUT,
        type: INVALID_CUSTOM_FIELD,
        message: 'Custom field for this value does not exist',
    },
    FAILED_TO_CAST: {
        code: BAD_USER_INPUT,
        type: FAILED_TO_CAST,
        message: 'Failed to cast customValue to another type',
    },
    ALREADY_EXISTS_UNIQ_KEY: {
        code: BAD_USER_INPUT,
        type: ALREADY_EXISTS_UNIQ_KEY,
        message: 'Another object with this uniqKey already exists in this organization',
    },
    ALREADY_EXISTS_OBJECT_ID: {
        code: BAD_USER_INPUT,
        type: ALREADY_EXISTS_OBJECT_ID,
        message: 'Another object linked to provided customField already exists with this objectId. Get this object and update it, instead of creating a new one',
    },
}

const CustomValue = new GQLListSchema('CustomValue', {
    schemaDoc: 'Custom value for CustomField',
    fields: {
        customField: {
            schemaDoc: 'CustomField object that this data refers to ',
            type: 'Relationship',
            ref: 'CustomField',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },

        data: {
            schemaDoc: 'Data of this customValue',
            type: 'Json',
            isRequired: true,
        },

        objectId: {
            schemaDoc: 'What instance of CustomField.schemaName this customValue relates to?',
            type: 'Text',
            isRequired: true,
        },

        filterDataString: {
            schemaDoc: 'String representation of data. Actual logic is controlled by type field in customValue. Use it for filtering',
            type: 'Text',
            isRequired: false,
            access: {
                create: false,
                update: false,
            },
        },

        sourceType: {
            schemaDoc: 'Type of entity, responsible for the last update of this customField',
            type: 'Select',
            options: Object.keys(ALLOWED_SOURCE_TYPES_CONFIG),
            isRequired: true,
        },

        sourceId: {
            schemaDoc: 'ID of entity, responsible for the last update of this customField',
            type: 'Text',
            isRequired: true,
        },

        organization: {
            ...ORGANIZATION_OWNED_FIELD,
            schemaDoc: `Organization that owns data inside this CustomValue. ${ORGANIZATION_OWNED_FIELD.schemaDoc}`,
        },

        unitName: {
            schemaDoc: 'Flat number / door number of an apartment building (property)',
            type: 'Text',
            isRequired: false,
        },

        unitType: {
            ...UNIT_TYPE_FIELD,
            defaultValue: undefined,
            schemaDoc: 'Type of unit, such as parking lot or flat',
        },

        addressKey: {
            type: 'Text',
            schemaDoc: 'The unique key of the address',
            isRequired: false,
        },

        isUniquePerObject: {
            schemaDoc: 'System field, equals to CustomField.isUniquePerObject, used in constraints logic',
            type: 'Checkbox',
            isRequired: true,
        },

        // Todo: (DOMA-11052) add more constraints to CustomValue:
        // isUniquePerUnit, isUniquePerAddress

        uniqKey: {
            schemaDoc: 'User defined custom ID. If set, customValue is guaranteed to be unique among single source (sourceType + sourceId)',
            type: 'Text',
            isRequired: false,
        },
    },
    hooks: {
        resolveInput: async ({ resolvedData, existingItem, operation, context, originalInput }) => {
            const resultObject = { ...resolvedData, ...existingItem }
            const customField = await getById('CustomField', resultObject.customField)
            if (!customField || customField.deletedAt) {
                throw new GQLError(ERRORS.INVALID_CUSTOM_FIELD, context)
            }

            const customFieldType = customField.type
            const customFieldTypeConfig = ALLOWED_TYPES[customFieldType]

            if (customFieldTypeConfig.toStringFilterData) {
                try {
                    resolvedData.filterDataString = customFieldTypeConfig.toStringFilterData(resultObject.data)
                } catch (err) {
                    throw new GQLError(ERRORS.FAILED_TO_CAST, context)
                }
            }

            resolvedData.isUniquePerObject = customField.isUniquePerObject

            return resolvedData
        },
        validateInput: async ({ resolvedData, existingItem, operation, context, originalInput }) => {
            const resultObject = { ...resolvedData, ...existingItem }

            const customField = await getById('CustomField', resultObject.customField)

            const customFieldValidationRules = customField.validationRules

            const customFieldSchemaName = customField.schemaName
            const customFieldSchemaConfig = ALLOWED_SCHEMAS[customFieldSchemaName]

            const customFieldType = customField.type
            const customFieldTypeConfig = ALLOWED_TYPES[customFieldType]
            const customFieldIsUniquePerObject = customField.isUniquePerObject

            if (customFieldIsUniquePerObject) {
                const existingCustomValues = await itemsQuery('CustomValue', {
                    where: {
                        objectId: resultObject.objectId,
                        organization: { id: resultObject.organization },
                        customField: { id: resultObject.customField },
                        deletedAt: null,
                    },
                    first: 1,
                })

                if (existingCustomValues.length > 0) {
                    throw new GQLError(ERRORS.ALREADY_EXISTS_OBJECT_ID, context)
                }
            }

            if (resolvedData.data) {
                if (!customFieldTypeConfig.valueIsValid(resolvedData.data)) {
                    throw new GQLError(ERRORS.INVALID_DATA_TYPE, context)
                }

                if (customFieldValidationRules) {
                    const validator = getGQLErrorValidator(ajv.compile(customFieldValidationRules), ERRORS.INVALID_DATA.type)
                    validator( { resolvedData, fieldPath: 'data', context } )
                }
            }

            if (resolvedData.objectId || resolvedData.organization) {
                const objectId = resultObject.objectId
                const organizationId = resultObject.organization

                // ObjectId should belong to the same organization as this CustomValue
                const pathToOrganizationId = get(customFieldSchemaConfig, 'pathToOrganizationId', ['organization', 'id'])

                if (!UUID_REGEXP.test(objectId)) {
                    throw new GQLError(ERRORS.INVALID_OBJECT_ID, context)
                }

                try {
                    const object = await getById(customFieldSchemaName, objectId)
                    if (!object || object.deletedAt) {
                        throw new Error('ObjectId is not valid: It may have been deleted')
                    }

                    let objectOrganizationId = null

                    // Example: [id] / [orgId]
                    if (pathToOrganizationId.length === 1) {
                        objectOrganizationId = objectId
                    }

                    // Example: ['organization', 'id'] / ['residentOrganization', 'id']
                    else if (pathToOrganizationId.length === 2 && pathToOrganizationId[1] === 'id') {
                        objectOrganizationId = object[pathToOrganizationId[0]]
                    }

                    // Example: ['ticket', 'organization', 'id']
                    else {
                        const [objectOrganization] = await execGqlWithoutAccess(context, {
                            query: generateGqlQueryToOrganizationId(customFieldSchemaName, pathToOrganizationId.slice(1)),
                            variables: {
                                where: { id: objectId },
                                first: 1,
                            },
                            dataPath: 'objs',
                        })
                        objectOrganizationId = objectOrganization.id
                    }

                    if (!objectOrganizationId || objectOrganizationId !== organizationId) {
                        throw new Error('ObjectId is not valid: organizations do not match')
                    }
                } catch (err) {
                    throw new GQLError(ERRORS.INVALID_OBJECT_ID, context)
                }
            }

            const sourceType = resultObject.sourceType
            const sourceId = resultObject.sourceId

            const sourceIdValidator = ALLOWED_SOURCE_TYPES_CONFIG[sourceType]?.validateSourceId
            if (typeof sourceIdValidator !== 'function') {
                throw new GQLError(ERRORS.INVALID_SOURCE, context)
            }

            const sourceIdIsValid = await sourceIdValidator({ context, sourceId })
            if (!sourceIdIsValid) {
                throw new GQLError(ERRORS.INVALID_SOURCE, context)
            }

            if (resolvedData.uniqKey) {
                const objsWithSameUniqKey = await itemsQuery('CustomValue',
                    {
                        where: {
                            organization: { id: resultObject.organization },
                            customField: { id: resultObject.customField },
                            uniqKey: resolvedData.uniqKey,
                            deletedAt: null,
                        },
                        first: 1,
                    })

                if (objsWithSameUniqKey.length > 0) {
                    throw new GQLError(ERRORS.ALREADY_EXISTS_UNIQ_KEY, context)
                }
            }
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['organization', 'customField', 'uniqKey'],
                name: 'unique_organization_customField_uniqKey',
                condition: 'Q(deletedAt__isnull=True)',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['organization', 'customField', 'objectId'],
                name: 'unique_organization_customField_objectId',
                condition: 'Q(deletedAt__isnull=True) & Q(isUniquePerObject=True)',
            },
        ],
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadCustomValues,
        create: access.canManageCustomValues,
        update: access.canManageCustomValues,
        delete: false,
        auth: true,
    },
})

module.exports = {
    CustomValue,
    ALLOWED_SOURCE_TYPES_CONFIG,
    B2B_APP_SOURCE_TYPE,
    ERRORS,
}
