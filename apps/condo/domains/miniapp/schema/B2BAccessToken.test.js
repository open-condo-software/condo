/**
 * Generated by `createschema miniapp.B2BAccessToken 'sessionId:Text; context:Relationship:B2BAppContext:CASCADE; rightSet:Relationship:B2BAppAccessRightSet:CASCADE; expiresAt:Text;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { gql } = require('graphql-tag')
const IORedis = require('ioredis')
const pick = require('lodash/pick')

const conf = require('@open-condo/config')
const {
    makeLoggedInAdminClient, makeClient, expectValuesOfCommonFields,
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowGQLError, expectToThrowAccessDeniedErrorToObjects,
    makeLoggedInClient, expectToThrowAccessDeniedError, expectToThrowInternalError,
} = require('@open-condo/keystone/test.utils')

const { encryptionManager } = require('@condo/domains/common/utils/encryption')
const {
    B2BAccessToken, createTestB2BAccessToken, createTestB2BAppContext,
    createTestB2BAppAccessRightSet, createTestB2BAppAccessRight, createTestB2BAccessTokenReadonly,
    B2BAccessTokenReadonly, B2BAccessTokenReadonlyAdmin, updateTestB2BAppAccessRightSet, createTestB2BApp, updateTestB2BAccessTokenReadonly,
    updateTestB2BAppContext, createTestB2BAccessTokenAdmin,
} = require('@condo/domains/miniapp/utils/testSchema')
const { Organization, registerNewOrganization } = require('@condo/domains/organization/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser,
    registerNewServiceUserByTestClient, makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')



describe('B2BAccessToken', () => {

    let admin
    let support
    let b2bAppContext
    let organization
    let b2bApp
    let scopedRightSet
    let globalRightSet
    let serviceUser

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
    })

    beforeEach(async () => {
        [b2bApp] = await createTestB2BApp(support, {
            name: faker.company.name().replace(/ /, '-').toUpperCase() + ' B2B APP',
            developer: faker.company.name(),
        });
        [organization] = await registerNewOrganization(admin);
        [b2bAppContext] = await createTestB2BAppContext(support, b2bApp, organization, { status: 'Finished' });
        [globalRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp);
        [scopedRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, {
            name: faker.random.alphaNumeric(8),
            type: 'SCOPED',
        });
        [serviceUser] = await registerNewServiceUserByTestClient(support)
        await createTestB2BAppAccessRight(support, serviceUser, b2bApp, globalRightSet)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                expectValuesOfCommonFields(obj, attrs, admin)
            })


            test('support can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BAccessToken(support, b2bAppContext, scopedRightSet)
                })
            })

            test('user can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BAccessTokenReadonly(client, b2bAppContext, scopedRightSet)
                })
            })

            describe('service user', () => {

                let serviceUserClient
                let globalRightSet
                let scopedRightSet
                let b2bAppContext

                beforeAll(async () => {
                    const [b2bApp] = await createTestB2BApp(support, {
                        name: faker.company.name().replace(/ /, '-').toUpperCase() + ' B2B APP',
                        developer: faker.company.name(),
                    })
                    const [organization] = await registerNewOrganization(support);
                    [b2bAppContext] = await createTestB2BAppContext(support, b2bApp, organization, { status: 'Finished' });
                    [globalRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp);
                    [scopedRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, {
                        name: faker.random.alphaNumeric(8),
                        type: 'SCOPED',
                    })
                    serviceUserClient = await makeClientWithServiceUser()
                    await createTestB2BAppAccessRight(admin, serviceUserClient.user, b2bApp, globalRightSet)
                })

                test('can\'t with no rights', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestB2BAccessToken(serviceUserClient, b2bAppContext, scopedRightSet)
                    })
                })

                test('can with rights', async () => {
                    await updateTestB2BAppAccessRightSet(support, globalRightSet.id, { canManageB2BAccessTokens: true })
                    const accessToken = await createTestB2BAccessToken(serviceUserClient, b2bAppContext, scopedRightSet)
                    expect(accessToken).toBeDefined()
                })
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestB2BAccessToken(client, b2bAppContext, scopedRightSet)
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)

                const [obj, attrs] = await updateTestB2BAccessTokenReadonly(admin, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            })

            test('support can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BAccessTokenReadonly(support, objCreated.id)
                })
            })

            describe('service user', () => {

                let serviceUserClient
                let globalRightSet
                let accessToken

                beforeAll(async () => {
                    const [b2bApp] = await createTestB2BApp(support, {
                        name: faker.company.name().replace(/ /, '-').toUpperCase() + ' B2B APP',
                        developer: faker.company.name(),
                    })
                    const [organization] = await registerNewOrganization(support)
                    const [b2bAppContext] = await createTestB2BAppContext(support, b2bApp, organization, { status: 'Finished' });
                    [globalRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp)
                    const [scopedRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, {
                        name: faker.random.alphaNumeric(8),
                        type: 'SCOPED',
                    })
                    serviceUserClient = await makeClientWithServiceUser()
                    await createTestB2BAppAccessRight(admin, serviceUserClient.user, b2bApp, globalRightSet);
                    [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                })

                test('can\'t with no rights', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestB2BAccessTokenReadonly(serviceUserClient, accessToken.id, {})
                    })
                })

                test('can with rights', async () => {
                    await updateTestB2BAppAccessRightSet(support, globalRightSet.id, { canManageB2BAccessTokens: true })
                    const updatedToken = await updateTestB2BAccessTokenReadonly(serviceUserClient, accessToken.id, {})
                    expect(updatedToken).toBeDefined()
                })

            })

            test('user can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BAccessTokenReadonly(client, accessToken.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestB2BAccessTokenReadonly(client, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAccessToken.delete(admin, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAccessToken.delete(support, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAccessToken.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                const objs = await B2BAccessTokenReadonly.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('support can\'t', async () => {
                const [obj] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await B2BAccessToken.getOne(support, { id: obj.id })
                })
            })

            describe('service user', () => {

                let serviceUserClient
                let globalRightSet
                let scopedRightSet
                let b2bAppContext

                beforeAll(async () => {
                    const [b2bApp] = await createTestB2BApp(support, {
                        name: faker.company.name().replace(/ /, '-').toUpperCase() + ' B2B APP',
                        developer: faker.company.name(),
                    })
                    const [organization] = await registerNewOrganization(support);
                    [b2bAppContext] = await createTestB2BAppContext(support, b2bApp, organization, { status: 'Finished' });
                    [globalRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, { canManageB2BAccessTokens: true });
                    [scopedRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, {
                        name: faker.random.alphaNumeric(8),
                        type: 'SCOPED',
                    })
                    serviceUserClient = await makeClientWithServiceUser()
                    await createTestB2BAppAccessRight(admin, serviceUserClient.user, b2bApp, globalRightSet)
                })

                test('can\'t with no rights', async () => {
                    const [{ id: createdId }] = await createTestB2BAccessToken(serviceUserClient, b2bAppContext, scopedRightSet)
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await B2BAccessTokenReadonly.getAll(serviceUserClient, { id: createdId })
                    })
                })

                test('can with rights', async () => {
                    await updateTestB2BAppAccessRightSet(support, globalRightSet.id, { canReadB2BAccessTokens: true })
                    const [{ id: createdId }] = await createTestB2BAccessToken(serviceUserClient, b2bAppContext, scopedRightSet)
                    const accessToken = await B2BAccessTokenReadonly.getOne(serviceUserClient, { id: createdId })
                    expect(accessToken).toBeDefined()
                })

            })

            test('user can\'t', async () => {
                await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await B2BAccessTokenReadonly.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })

            test('anonymous can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await B2BAccessToken.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('Fields update access', () => {
        const updateInput = {}
        const updatableByNonAdminFields = ['deletedAt']
        let accessToken
        let serviceUserClient
        let b2bAppContext
        let scopedRightSet

        beforeAll(async () => {
            const [anotherB2bApp] = await createTestB2BApp(support, {
                name: faker.company.name().replace(/ /, '-').toUpperCase() + ' B2B APP',
                developer: faker.company.name(),
            })
            const [anotherOrganization] = await registerNewOrganization(support);
            [b2bAppContext] = await createTestB2BAppContext(support, anotherB2bApp, anotherOrganization, { status: 'Finished' })
            const [anotherGlobalRightSet] = await createTestB2BAppAccessRightSet(support, anotherB2bApp, { canManageB2BAccessTokens: true });
            [scopedRightSet] = await createTestB2BAppAccessRightSet(support, anotherB2bApp, {
                name: faker.random.alphaNumeric(8),
                type: 'SCOPED',
            })
            serviceUserClient = await makeClientWithServiceUser()
            await createTestB2BAppAccessRight(support, serviceUserClient.user, anotherB2bApp, anotherGlobalRightSet)

            updateInput.sessionId = faker.random.alphaNumeric(8)
            updateInput.user = { connect: { id: serviceUserClient.user.id } }
            updateInput.context = { connect: { id: b2bAppContext.id } }
            updateInput.rightSet = { connect: { id: scopedRightSet.id } }
            updateInput.expiresAt = faker.datatype.datetime({ min: dayjs().valueOf(), max: dayjs().add(1, 'month').valueOf() })
            updateInput.deletedAt = dayjs().toISOString()
        })

        beforeEach(async () => {
            [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
        })

        test('admin can update everything', async () => {
            const [updatedToken] = await updateTestB2BAccessTokenReadonly(admin, accessToken.id, updateInput)
            expect(updatedToken).toBeDefined()
        })

        test(`others can update only ${updatableByNonAdminFields}`, async () => {
            for (const [key, value] of Object.entries(updateInput)) {
                if (updatableByNonAdminFields.includes(key)) {
                    const [updatedToken] = await updateTestB2BAccessTokenReadonly(serviceUserClient, accessToken.id, pick(updateInput, updatableByNonAdminFields))
                    expect(updatedToken).toBeDefined()
                } else {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestB2BAccessTokenReadonly(serviceUserClient, accessToken.id, { [key]: value })
                    })
                }
            }
        })
    })

    describe('Validation tests', () => {
        test('Should have correct dv field (=== 1)', async () => {
            const [obj] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
            expect(obj).toHaveProperty('dv', 1)
        })

        test('Accepts only context and rightSet for same app', async () => {
            const [otherApp1] = await createTestB2BApp(support)
            const [otherApp2] = await createTestB2BApp(support)
            const [otherApp3] = await createTestB2BApp(support)
            await createTestB2BAppAccessRightSet(support, otherApp1)
            await createTestB2BAppAccessRightSet(support, otherApp2)
            await createTestB2BAppAccessRightSet(support, otherApp3)
            const [tokenRightSet1] = await createTestB2BAppAccessRightSet(support, otherApp1, { type: 'SCOPED' })
            const [tokenRightSet2] = await createTestB2BAppAccessRightSet(support, otherApp2, { type: 'SCOPED' })
            const [tokenRightSet3] = await createTestB2BAppAccessRightSet(support, otherApp3, { type: 'SCOPED' })
            const [otherServiceUser1] = await registerNewServiceUserByTestClient(support)
            const [otherServiceUser2] = await registerNewServiceUserByTestClient(support)
            const [otherServiceUser3] = await registerNewServiceUserByTestClient(support)
            await createTestB2BAppAccessRight(support, otherServiceUser1, otherApp1)
            await createTestB2BAppAccessRight(support, otherServiceUser2, otherApp2)
            await createTestB2BAppAccessRight(support, otherServiceUser3, otherApp3)
            await updateTestB2BAppContext(support, b2bAppContext.id, { status: 'Finished' })
            const [otherContext1] = await createTestB2BAppContext(support, otherApp1, organization, { status: 'Finished' })
            const [otherContext2] = await createTestB2BAppContext(support, otherApp2, organization, { status: 'Finished' })

            const badCases = [
                [otherContext2, tokenRightSet1],
                [otherContext1, tokenRightSet2],
                [otherContext1, tokenRightSet3],
            ]

            for (const [context, rightSet] of badCases) {
                await expectToThrowGQLError(async () => {
                    await createTestB2BAccessToken(admin, context, rightSet)
                }, {
                    code: 'BAD_USER_INPUT',
                    type: 'ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET',
                    message: 'B2BAppContext and B2BRightSet connected to different B2BApps',
                }, 'obj')
            }

        })
    })

    describe('Real-life cases', () => {

        test('Can not update deleted access token to store it in redis', async () => {
            const redisClient = new IORedis(conf.REDIS_URL)
            const [createdToken] = await createTestB2BAccessTokenAdmin(admin, b2bAppContext, scopedRightSet)
            expect(createdToken).toBeDefined()
            expect(createdToken).toHaveProperty('sessionId')
            const session = await redisClient.get(`sess:${encryptionManager.decrypt(createdToken.sessionId)}`)
            expect(session).toBeDefined()

            const [anotherB2BApp] = await createTestB2BApp(support)
            const [anotherB2BAppContext] = await createTestB2BAppContext(support, anotherB2BApp, organization, { status: 'Finished' })
            await expectToThrowGQLError(async () => {
                await updateTestB2BAccessTokenReadonly(admin, createdToken.id, {
                    context: { connect: { id: anotherB2BAppContext.id } },
                    deletedAt: new Date().toISOString(),
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET',
                message: 'B2BAppContext and B2BRightSet connected to different B2BApps',
            }, 'obj')

            const sessionCopy = await redisClient.get(`sess:${encryptionManager.decrypt(createdToken.sessionId)}`)
            expect(sessionCopy).toEqual(session)

            await updateTestB2BAccessTokenReadonly(admin, createdToken.id, { deletedAt: new Date().toISOString() })
            const afterDeleteSession = await redisClient.get(`sess:${encryptionManager.decrypt(createdToken.sessionId)}`)
            expect(afterDeleteSession).toBeNull()

            await expectToThrowInternalError(async () => {
                await updateTestB2BAccessTokenReadonly(admin, createdToken.id, {
                    context: { connect: { id: anotherB2BAppContext.id } },
                })
            }, 'Already deleted', ['obj'])
        })

        test('Only admin can filter by sensitive fields', async () => {
            const [b2bApp] = await createTestB2BApp(support)
            const [organization] = await registerNewOrganization(support)
            const [b2bAppContext] = await createTestB2BAppContext(support, b2bApp, organization, { status: 'Finished' })
            const [globalRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, { canManageB2BAccessTokens: true, canReadB2BAccessTokens: true })
            const [scopedRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, { type: 'SCOPED' })

            const serviceUserClient = await makeClientWithServiceUser()
            await createTestB2BAppAccessRight(support, serviceUserClient.user, b2bApp, globalRightSet)
            const [accessToken] = await createTestB2BAccessTokenAdmin(admin, b2bAppContext, scopedRightSet)
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await B2BAccessTokenReadonly.getAll(serviceUserClient, { sessionId: accessToken.sessionId })
            })
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await B2BAccessTokenReadonly.getAll(serviceUserClient, { sessionId_starts_with: accessToken.sessionId })
            })

            const [accessTokenByAdmin] = await B2BAccessTokenReadonlyAdmin.getAll(admin, { sessionId: accessToken.sessionId })
            expect(accessTokenByAdmin.id).toEqual(accessToken.id)
        })
        
        test('SessionId is encrypted', async () => {
            const redisClient = new IORedis(conf.REDIS_URL)
            const [createdToken] = await createTestB2BAccessTokenAdmin(admin, b2bAppContext, scopedRightSet)
            expect(createdToken).toHaveProperty('sessionId')
            const session = await redisClient.get(`sess:${createdToken.sessionId}`)
            const sessionByDecryptedId = await redisClient.get(`sess:${encryptionManager.decrypt(createdToken.sessionId)}`)
            expect(session).toBeNull()
            expect(sessionByDecryptedId).not.toBeNull()
        })

        test('Show token only once after creation', async () => {
            await updateTestB2BAppAccessRightSet(support, globalRightSet.id, { canManageB2BAccessTokens: true, canReadB2BAccessTokens: true })
            const client = await makeLoggedInClient(serviceUser)
            const [createdToken] = await createTestB2BAccessToken(client, b2bAppContext, scopedRightSet)
            expect(createdToken).toHaveProperty('token')
            expect(createdToken.token.length).toBeGreaterThan(0)

            await expectToThrowAccessDeniedError(async () => {
                await B2BAccessToken.getOne(client, { id: createdToken.id })
            }, ['objs', 0, 'token'])
        })
        
        describe('Token', () => {

            let scopedRightSet
            let globalRightSet
            let serviceUserClient
            let b2bApp
            let b2bAppContext
            let originalOrganization

            beforeAll(async () => {
                [originalOrganization] = await registerNewOrganization(support);
                [b2bApp] = await createTestB2BApp(support);
                [b2bAppContext] = await createTestB2BAppContext(support, b2bApp, originalOrganization, { status: 'Finished' });
                [globalRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, {});
                [scopedRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, { type: 'SCOPED' })
                serviceUserClient = await makeClientWithServiceUser()
                await createTestB2BAppAccessRight(support, serviceUserClient.user, b2bApp, globalRightSet)
                await registerNewOrganization(support)
            })

            beforeEach(async () => {
                await updateTestB2BAppAccessRightSet(support, globalRightSet.id, { deletedAt: null, canReadOrganizations: true })
                await updateTestB2BAppAccessRightSet(support, scopedRightSet.id, { deletedAt: null, canReadOrganizations: true })
            })
            
            describe('Authentication', () => {

                test('Can\'t logout with token', async () => {
                    await updateTestB2BAppAccessRightSet(support, scopedRightSet.id, { canReadOrganizations: true })
                    const [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                    const anonymous = await makeClient()
                    anonymous.setHeaders({ 'Authorization': `Bearer ${accessToken.token}` })
                    const { errors, data } = await anonymous.mutate(gql`
                    mutation unauthenticateUser {
                        obj: unauthenticateUser {
                            success
                        }
                    }
                `)
                    expect(data.obj).toBeNull()
                    expect(errors).toEqual([
                        expect.objectContaining({
                            extensions: expect.objectContaining({
                                code: 'FORBIDDEN',
                                message: 'You can not log out with token',
                            }),
                            name: 'GQLError',
                        }),
                    ])
                })

                test('Executes as connected service user', async () => {
                    await updateTestB2BAppAccessRightSet(support, scopedRightSet.id, { canReadOrganizations: true })
                    const [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                    const anonymous = await makeClient()
                    anonymous.setHeaders({ 'Authorization': `Bearer ${accessToken.token}` })
                    const res = await anonymous.query(gql`
                    query {
                        obj: authenticatedUser {
                            id
                            type
                        }
                    }
                `)
                    expect(res.errors).not.toBeDefined()
                    expect(res.data.obj).toEqual(expect.objectContaining({
                        id: serviceUserClient.user.id,
                        type: 'service',
                    }))
                })

            })
            
            test('Can access only connected organization', async () => {
                const [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                const anonymous = await makeClient()
                anonymous.setHeaders({ 'Authorization': `Bearer ${accessToken.token}` })
                const organizations = await Organization.getAll(anonymous, {})
                expect(organizations).toHaveLength(1)
                expect(organizations[0].id).toEqual(originalOrganization.id)
            })

            test('Overrides miniapp B2BAccessRightSet with own right set', async () => {
                await updateTestB2BAppAccessRightSet(support, scopedRightSet.id, { canReadOrganizations: false })
                const [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                const anonymous = await makeClient()
                anonymous.setHeaders({ 'Authorization': `Bearer ${accessToken.token}` })

                const serviceUserOrganizations = await Organization.getAll(serviceUserClient, {})
                expect(serviceUserOrganizations.length).toBeGreaterThanOrEqual(1)

                const accessTokenOrganizations = await Organization.getAll(anonymous, {})
                expect(accessTokenOrganizations).toHaveLength(0)
            })

            test('Updating token B2BAccessRightSet leads to updating created token permissions', async () => {
                const [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                const anonymous = await makeClient()
                anonymous.setHeaders({ 'Authorization': `Bearer ${accessToken.token}` })

                const organizations = await Organization.getAll(anonymous, {})
                expect(organizations).toHaveLength(1)
                expect(organizations[0].id).toEqual(originalOrganization.id)

                await updateTestB2BAppAccessRightSet(support, scopedRightSet.id, { canReadOrganizations: false })
                const repeatOrganizations = await Organization.getAll(anonymous, {})
                expect(repeatOrganizations).toHaveLength(0)
            })
            
            describe('Deleting related objects', () => {

                beforeEach(async () => {
                    await updateTestB2BAppContext(support, b2bAppContext.id, { status: 'Finished', deletedAt: null })
                    await updateTestB2BAppAccessRightSet(support, scopedRightSet.id, { canReadOrganizations: true })
                })

                test('Deleting B2BAppAccessRightSet leads to session removal', async () => {
                    const [anotherScopedRightSet] = await createTestB2BAppAccessRightSet(support, b2bApp, { type: 'SCOPED', canReadOrganizations: true })
                    const [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, anotherScopedRightSet)
                    const anonymous = await makeClient()
                    anonymous.setHeaders({ 'Authorization': `Bearer ${accessToken.token}` })

                    const organizations = await Organization.getAll(anonymous, {})
                    expect(organizations).toHaveLength(1)
                    expect(organizations[0].id).toEqual(originalOrganization.id)

                    await updateTestB2BAppAccessRightSet(support, anotherScopedRightSet.id, { deletedAt: dayjs().toISOString() })
                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await Organization.getAll(anonymous, {})
                    })
                })
            
                test('Deleting B2BAppContext leads to session removal', async () => {
                    const [accessToken] = await createTestB2BAccessToken(admin, b2bAppContext, scopedRightSet)
                    const anonymous = await makeClient()
                    anonymous.setHeaders({ 'Authorization': `Bearer ${accessToken.token}` })

                    const organizations = await Organization.getAll(anonymous, {})
                    expect(organizations).toHaveLength(1)
                    expect(organizations[0].id).toEqual(originalOrganization.id)

                    await updateTestB2BAppContext(support, b2bAppContext.id, { deletedAt: dayjs().toISOString() })
                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await Organization.getAll(anonymous, {})
                    })
                })

            })

        })
    })
})
