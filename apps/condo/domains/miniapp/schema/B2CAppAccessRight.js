/**
 * Generated by `createschema miniapp.B2CAppAccessRight 'user:Relationship:User:PROTECT; app:Relationship:B2CApp:PROTECT;'`
 */

const get = require('lodash/get')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, importable } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getByCondition } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/miniapp/access/B2CAppAccessRight')
const { SERVICE_USER_FIELD } = require('@condo/domains/miniapp/schema/fields/accessRight')

const { ACCESS_RIGHT_SET_NOT_FOR_CONNECTED_B2C_APP } = require('../constants')

const ERRORS = {
    ACCESS_RIGHT_SET_NOT_FOR_CONNECTED_B2B_APP: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_NOT_FOR_CONNECTED_B2C_APP,
        message: '"accessRightSet" must be connected to B2CApp, which specified in "app"',
    },
}

const B2CAppAccessRight = new GQLListSchema('B2CAppAccessRight', {
    schemaDoc: 'Link between service user and B2C App. The existence of this connection means that this user has the rights to perform actions on behalf of the integration and modify some B2CApp-related models',
    fields: {
        user: SERVICE_USER_FIELD,
        app: {
            schemaDoc: 'Link to B2СApp.accessRights',
            type: 'Relationship',
            ref: 'B2CApp.accessRights',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },

        accessRightSet: {
            schemaDoc: 'Link to the set of access rights.' +
                ' This set of access right will be used to check your service user access to schemas that are' +
                ' linked to "B2CAppProperty" schema by addressKey (such as "Property", and others).' +
                '\n These accesses will only apply to entities that exists for Property that connected your app',
            type: 'Relationship',
            ref: 'B2CAppAccessRightSet',
            isRequired: false,
            knexOptions: { isNotNullable: false }, // Required relationship only!
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },
    },
    hooks: {
        validateInput: async ({ existingItem, resolvedData, context }) => {
            const newItem = { ...existingItem, ...resolvedData }
            const accessRightSetId = get(newItem, 'accessRightSet')
            const shouldCheckAccessRight = Boolean(resolvedData['app'] || resolvedData['accessRightSet'])

            if (accessRightSetId && shouldCheckAccessRight) {
                const appId = get(newItem, 'app')
                const accessRightSet = await getByCondition('B2CAppAccessRightSet', {
                    app: { id: appId, deletedAt: null },
                    deletedAt: null,
                    id: accessRightSetId,
                })

                if (!accessRightSet) {
                    throw new GQLError(ERRORS.ACCESS_RIGHT_SET_NOT_FOR_CONNECTED_B2B_APP, context)
                }
            }
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['app'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'b2с_app_access_right_unique_app',
            },
        ],
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), importable(), historical()],
    access: {
        read: access.canReadB2CAppAccessRights,
        create: access.canManageB2CAppAccessRights,
        update: access.canManageB2CAppAccessRights,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2CAppAccessRight,
    ERRORS,
}
