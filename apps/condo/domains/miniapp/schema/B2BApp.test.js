/**
 * Generated by `createschema miniapp.B2BApp 'name:Text;'`
 */

const { faker } = require('@faker-js/faker')

const conf = require('@open-condo/config')
const { makeLoggedInAdminClient, makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowValidationFailureError,
} = require('@open-condo/keystone/test.utils')
const { replaceDomainPrefix } = require('@open-condo/miniapp-utils/helpers/urls')

const {
    MAP_GENERATION_FEATURE,
    GLOBAL_APP_NO_APP_URL_ERROR,
    NON_GLOBAL_APP_WITH_FEATURES_ERROR,
} = require('@condo/domains/miniapp/constants')
const { B2BApp, createTestB2BApp, updateTestB2BApp } = require('@condo/domains/miniapp/utils/testSchema')
const { makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, createTestOidcClient, updateTestOidcClient } = require('@condo/domains/user/utils/testSchema')

function expectedAppDomain (appId, idx) {
    return new URL(replaceDomainPrefix(conf['SERVER_URL'], `${appId}-${idx}.miniapps`)).origin
}

describe('B2BApp', () => {
    let admin
    let support
    let user
    let anonymous
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()
    })
    describe('CRUD', () => {
        describe('Create', () => {
            const createPayload = {
                name: faker.company.name().replace(/ /, '-').toUpperCase() + ' B2B APP',
                developer: faker.company.name(),
            }
            test('Admin can', async () => {
                const [app] = await createTestB2BApp(admin, createPayload)
                expect(app).toBeDefined()
                expect(app).toEqual(expect.objectContaining(createPayload))
            })
            test('Support can', async () => {
                const [app] = await createTestB2BApp(support, createPayload)
                expect(app).toBeDefined()
                expect(app).toEqual(expect.objectContaining(createPayload))
            })
            test('User cannot', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BApp(user)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestB2BApp(anonymous)
                })
            })
        })
        describe('Read', () => {
            let app
            beforeAll(async () => {
                [app] = await createTestB2BApp(admin)
            })
            test('Admin can', async () => {
                const apps = await B2BApp.getAll(admin, {
                    id: app.id,
                })
                expect(apps).toBeDefined()
                expect(apps).toHaveLength(1)
                expect(apps[0]).toHaveProperty('id', app.id)
                expect(apps[0]).toHaveProperty('name', app.name)
            })
            test('Support can', async () => {
                const apps = await B2BApp.getAll(support, {
                    id: app.id,
                })
                expect(apps).toBeDefined()
                expect(apps).toHaveLength(1)
                expect(apps[0]).toHaveProperty('id', app.id)
                expect(apps[0]).toHaveProperty('name', app.name)
            })
            test('User can', async () => {
                const apps = await B2BApp.getAll(user, {
                    id: app.id,
                })
                expect(apps).toBeDefined()
                expect(apps).toHaveLength(1)
                expect(apps[0]).toHaveProperty('id', app.id)
                expect(apps[0]).toHaveProperty('name', app.name)
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await B2BApp.getAll(anonymous, {
                        id: app.id,
                    })
                })
            })
        })
        describe('Update', () => {
            let createdApp
            const updatePayload = {
                name: faker.company.name().replace(/ /, '-').toUpperCase() + ' B2B APP',
            }
            beforeEach(async () => {
                [createdApp] = await createTestB2BApp(admin)
            })
            test('Admin can', async () => {
                const [app] = await updateTestB2BApp(admin, createdApp.id, updatePayload)
                expect(app).toBeDefined()
                expect(app).toEqual(expect.objectContaining(updatePayload))
            })
            test('Support can', async () => {
                const [app] = await updateTestB2BApp(support, createdApp.id, updatePayload)
                expect(app).toBeDefined()
                expect(app).toEqual(expect.objectContaining(updatePayload))
            })
            test('User cannot', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BApp(user, createdApp.id, updatePayload)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestB2BApp(anonymous, createdApp.id, updatePayload)
                })
            })
        })
        describe('Delete', () => {
            let app
            beforeAll(async () => {
                [app] = await createTestB2BApp(admin)
            })
            test('Nobody can', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BApp.delete(admin, app.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BApp.delete(support, app.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BApp.delete(user, app.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BApp.delete(anonymous, app.id)
                })
            })
        })
    })
    describe('Validations', () => {
        test('Each global app must have appUrl', async () => {
            const admin = await makeLoggedInAdminClient()
            await expectToThrowValidationFailureError(async () => {
                await createTestB2BApp(admin, {
                    isGlobal: true,
                    appUrl: null,
                })
            }, GLOBAL_APP_NO_APP_URL_ERROR)
            const [validApp] = await createTestB2BApp(admin, {
                isGlobal: true,
                appUrl: faker.internet.url(),
            })
            await expectToThrowValidationFailureError(async () => {
                await updateTestB2BApp(admin, validApp.id, {
                    appUrl: null,
                })
            }, GLOBAL_APP_NO_APP_URL_ERROR)
        })
        describe('Features', () => {
            let admin
            beforeAll(async () => {
                admin = await makeLoggedInAdminClient()
            })
            test('Global B2B app may have features', async () => {
                const [app] = await createTestB2BApp(admin, {
                    appUrl: faker.internet.url(),
                    isGlobal: true,
                    features: [MAP_GENERATION_FEATURE],
                })

                expect(app).toHaveProperty('features', [MAP_GENERATION_FEATURE])

                const [secondApp] = await createTestB2BApp(admin, {
                    appUrl: faker.internet.url(),
                    isGlobal: true,
                })
                expect(secondApp).toHaveProperty('features', null)
                const [updatedApp] = await updateTestB2BApp(admin, secondApp.id, {
                    features: [MAP_GENERATION_FEATURE],
                })
                expect(updatedApp).toHaveProperty('features', [MAP_GENERATION_FEATURE])
            })
            test('Non-global B2B apps cannot have features', async () => {
                await expectToThrowValidationFailureError(async () => {
                    await createTestB2BApp(admin, {
                        isGlobal: false,
                        features: [MAP_GENERATION_FEATURE],
                    })
                }, NON_GLOBAL_APP_WITH_FEATURES_ERROR)

                const [app] = await createTestB2BApp(admin, { isGlobal: false })
                await expectToThrowValidationFailureError(async () => {
                    await updateTestB2BApp(admin, app.id, {
                        features: [MAP_GENERATION_FEATURE],
                    })
                }, NON_GLOBAL_APP_WITH_FEATURES_ERROR)
            })
            test('Must reset if app stop being global', async () => {
                const [globalApp] = await createTestB2BApp(admin, {
                    appUrl: faker.internet.url(),
                    isGlobal: true,
                    features: [MAP_GENERATION_FEATURE],
                })
                expect(globalApp).toHaveProperty('features', [MAP_GENERATION_FEATURE])
                const [updatedApp] = await updateTestB2BApp(admin, globalApp.id, {
                    isGlobal: false,
                })
                expect(updatedApp).toHaveProperty('features', null)
            })
        })
    })
    describe('Resolvers', () => {
        describe('domains field', () => {
            test('should initially return empty mapping', async () => {
                const [app] = await createTestB2BApp(support)
                const appData = await B2BApp.getOne(support, { id: app.id })
                expect(appData.domains).toEqual({ mapping: [] })
            })

            test('should show correct resolution order', async () => {
                // Step 1: Create app with empty domains
                const [app] = await createTestB2BApp(support)
                let appData = await B2BApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(0)

                // Step 2: Add OIDC client with redirect URIs - expect indexes 2-3 to appear
                const [oidcClient, { payload }] = await createTestOidcClient(support)
                await updateTestB2BApp(support, app.id, {
                    oidcClient: { connect: { id: oidcClient.id } },
                })
                await updateTestOidcClient(support, oidcClient.id, {
                    payload: {
                        ...payload,
                        redirect_uris: ['https://app1.example.com/oidc/callback', 'https://app2.example.com/api/oidc/callback'],
                    },
                })
                appData = await B2BApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(2)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://app2.example.com', to: expectedAppDomain(app.id, 3) },
                ]))

                // Step 3: Add additional domains - expect index 4-5 to appear
                await updateTestB2BApp(support, app.id, {
                    additionalDomains: ['https://cdn.example.com', 'https://api.example.com'],
                })
                appData = await B2BApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(4)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://app2.example.com', to: expectedAppDomain(app.id, 3) },
                    { from: 'https://cdn.example.com', to: expectedAppDomain(app.id, 4) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 5) },
                ]))

                // Step 4: Add appUrl - expect index 1 to appear
                await updateTestB2BApp(support, app.id, {
                    appUrl: 'https://main.example.com/app',
                })
                appData = await B2BApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(5)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://main.example.com', to: expectedAppDomain(app.id, 1) },
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://app2.example.com', to: expectedAppDomain(app.id, 3) },
                    { from: 'https://cdn.example.com', to: expectedAppDomain(app.id, 4) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 5) },
                ]))

                // Step 5: Remove one redirect URI - expect additional domains to shift to 3-4
                await updateTestOidcClient(support, oidcClient.id, {
                    payload: {
                        ...payload,
                        redirect_uris: ['https://app1.example.com/callback'],
                    },
                })
                appData = await B2BApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(4)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://main.example.com', to: expectedAppDomain(app.id, 1) },
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://cdn.example.com', to: expectedAppDomain(app.id, 3) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 4) },
                ]))

                // Step 6: Change appUrl to same domain as remaining redirect_uri - expect index 1 to disappear
                await updateTestB2BApp(support, app.id, {
                    appUrl: 'https://app1.example.com/main',
                })
                appData = await B2BApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(3)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://cdn.example.com', to: expectedAppDomain(app.id, 3) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 4) },
                ]))

                // Step 7: Change one additional domain to same as redirect uri - expect remaining to take its place
                await updateTestB2BApp(support, app.id, {
                    additionalDomains: ['https://app1.example.com', 'https://api.example.com'],
                })
                appData = await B2BApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(2)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 3) },
                ]))
            })

            test('should handle duplicate domains correctly', async () => {
                const [oidcClient] = await createTestOidcClient(support)
                await updateTestOidcClient(support, oidcClient.id, {
                    payload: {
                        ...oidcClient.payload,
                        redirect_uris: ['https://same.example.com/callback1', 'https://same.example.com/callback2'],
                    },
                })

                const [app] = await createTestB2BApp(support, {
                    appUrl: 'https://same.example.com/app',
                    additionalDomains: ['https://same.example.com', 'https://different.example.com'],
                    oidcClient: { connect: { id: oidcClient.id } },
                })

                const appData = await B2BApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(2)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://same.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://different.example.com', to: expectedAppDomain(app.id, 3) },
                ]))
            })
        })
    })
})
