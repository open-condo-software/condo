/**
 * Generated by `createschema miniapp.B2BAccessToken 'sessionId:Text; context:Relationship:B2BAppContext:CASCADE; rightSet:Relationship:B2BAppAccessRightSet:CASCADE; expiresAt:Text;'`
 */

const crypto = require('crypto')

const cookieSignature = require('cookie-signature')
const dayjs = require('dayjs')
const get = require('lodash/get')
const isNil = require('lodash/isNil')

const conf = require('@open-condo/config')
const { userIsAdmin, isSoftDelete } = require('@open-condo/keystone/access')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, find, getByCondition } = require('@open-condo/keystone/schema')
const { setSession, destroySession } = require('@open-condo/keystone/session')

const { encryptionManager } = require('@condo/domains/common/utils/encryption')
const { makeSessionData } = require('@condo/domains/common/utils/session')
const access = require('@condo/domains/miniapp/access/B2BAccessToken')
const {
    ACCESS_TOKEN_SESSION_ID_PREFIX,
    ACCESS_TOKEN_CONTEXT_NOT_EXISTS,
    ACCESS_TOKEN_RIGHT_SET_NOT_EXISTS,
    ACCESS_TOKEN_WRONG_RIGHT_SET_TYPE,
    ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET,
    ACCESS_TOKEN_SERVICE_USER_DOES_NOT_MATCH_CONTEXT,
    ACCESS_TOKEN_NEGATIVE_TTL,
    ACCESS_RIGHT_SET_SCOPED_TYPE,
    CONTEXT_FINISHED_STATUS,
} = require('@condo/domains/miniapp/constants')
const { SERVICE_USER_FIELD } = require('@condo/domains/miniapp/schema/fields/accessRight')
const { getEnabledPermissions } = require('@condo/domains/miniapp/utils/permissions')

const { COOKIE_SECRET } = conf

async function getValidationError (item) {

    const b2bAppContext = await getByCondition('B2BAppContext', {
        id: item.context,
        app: {
            deletedAt: null,
        },
        deletedAt: null,
    })
    if (!b2bAppContext) {
        return ERRORS.CONTEXT_NOT_EXISTS
    }
    const accessRightSet = await getByCondition('B2BAppAccessRightSet', {
        id: item.rightSet,
        app: {
            deletedAt: null,
        },
        deletedAt: null,
    })
    if (!accessRightSet) {
        return ERRORS.RIGHT_SET_NOT_EXISTS
    }
    if (accessRightSet.type !== ACCESS_RIGHT_SET_SCOPED_TYPE) {
        return ERRORS.WRONG_RIGHT_SET_TYPE
    }
    if (accessRightSet.app !== b2bAppContext.app) {
        return ERRORS.CONTEXT_DOES_NOT_MATCH_RIGHT_SET
    }
    const [accessRightForUserAndApp] = await find('B2BAppAccessRight', {
        user: { id: item.user, deletedAt: null },
        app: { id: b2bAppContext.app, deletedAt: null },
        deletedAt: null,
    })
    if (!accessRightForUserAndApp) {
        return ERRORS.SERVICE_USER_DOES_NOT_MATCH_CONTEXT
    }
    return null
}

const ERRORS = {
    CONTEXT_NOT_EXISTS: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_CONTEXT_NOT_EXISTS,
        message: 'B2BAppContext does not exists',
    },
    RIGHT_SET_NOT_EXISTS: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_RIGHT_SET_NOT_EXISTS,
        message: 'B2BAppAccessRightSet does not exists',
    },
    WRONG_RIGHT_SET_TYPE: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_WRONG_RIGHT_SET_TYPE,
        message: 'Wrong B2BAppAccessRightSet type, must be "SCOPED"',
    },
    CONTEXT_DOES_NOT_MATCH_RIGHT_SET: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET,
        message: 'B2BAppContext and B2BRightSet connected to different B2BApps',
    },
    SERVICE_USER_DOES_NOT_MATCH_CONTEXT: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_SERVICE_USER_DOES_NOT_MATCH_CONTEXT,
        message: 'User and B2BAppContext connected to different B2BApps',
    },
    NEGATIVE_TTL: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_NEGATIVE_TTL,
        message: 'TTL can\'t be negative. You provided expiresAt datetime previous to the current one',
    },
}

const B2BAccessToken = new GQLListSchema('B2BAccessToken', {
    schemaDoc: 'Access to service user with additional restrictions by Organization and B2BAppAccessRightSet',
    fields: {
        sessionId: {
            schemaDoc: 'Encrypted sessionId of session',
            type: 'EncryptedText',
            encryptionManager: encryptionManager,
            isRequired: true,
            access: userIsAdmin,
            hooks: {
                resolveInput ({ operation, existingItem, fieldPath }) {
                    if (operation === 'create') {
                        return ACCESS_TOKEN_SESSION_ID_PREFIX + crypto.randomUUID()
                    }
                    return get(existingItem, fieldPath)
                },
            },
        },

        token: {
            schemaDoc: 'Token, ready to be put in Authorization header. Shown only once after creation',
            type: 'Virtual',
            graphQLReturnType: 'String',
            resolver: (item) => {
                const sessionId = encryptionManager.decrypt(item.sessionId)
                return cookieSignature.sign(sessionId, COOKIE_SECRET)
            },
            access: access.readableOnlyOnCreate,
        },

        context: {
            schemaDoc: 'Link to B2BApp and Organization',
            type: 'Relationship',
            ref: 'B2BAppContext',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: access.updatableOnlyForAdmin,
        },

        user: {
            ...SERVICE_USER_FIELD,
            isRequired: true,
            access: access.updatableOnlyForAdmin,
            hooks: {
                ...SERVICE_USER_FIELD.hooks,
                async resolveInput ({ operation, existingItem, resolvedData, fieldPath }) {
                    const newItem = {
                        ...existingItem,
                        ...resolvedData,
                    }
                    if (operation === 'create' && !newItem[fieldPath]) {
                        const contextId = get(resolvedData, 'context')
                        const context = await getByCondition('B2BAppContext', {
                            id: contextId,
                            app: { deletedAt: null },
                            organization: { deletedAt: null },
                            status: CONTEXT_FINISHED_STATUS,
                            deletedAt: null,
                        })
                        if (!context) {
                            return null
                        }
                        const [accessRight] = await find('B2BAppAccessRight', {
                            app: { id: context.app, deletedAt: null },
                            user: { deletedAt: null },
                            deletedAt: null,
                        })
                        if (!accessRight) {
                            return null
                        }
                        return accessRight.user
                    }

                    return newItem.user
                },
            },
        },

        rightSet: {
            schemaDoc: 'Right set for token',
            type: 'Relationship',
            ref: 'B2BAppAccessRightSet',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: access.updatableOnlyForAdmin,
        },

        expiresAt: {
            schemaDoc: 'Date, when access by this token will be restricted',
            type: 'DateTimeUtc',
            isRequired: false,
            access: access.updatableOnlyForAdmin,
            hooks: {
                validateInput ({ resolvedData, fieldPath, context }) {
                    const expiresAt = resolvedData[fieldPath]
                    if (isNil(expiresAt)) {
                        return
                    }
                    if (dayjs(expiresAt).isBefore(dayjs())) {
                        throw new GQLError(ERRORS.NEGATIVE_TTL, context)
                    }
                },
            },
        },
    },
    hooks: {
        async validateInput ({ operation, resolvedData, existingItem, context, originalInput }) {
            const newItem = {
                ...existingItem,
                ...resolvedData,
            }

            if (isSoftDelete(originalInput)) {
                return
            }

            const validationError = await getValidationError(newItem)
            if (validationError) {
                throw new GQLError(validationError, context)
            }
        },
        async afterChange ({ context, operation, existingItem, updatedItem }) {
            const sessionId = encryptionManager.decrypt(updatedItem.sessionId)

            if (updatedItem.deletedAt) {
                await destroySession(context.req.sessionStore, sessionId)
            }

            if (!updatedItem.deletedAt) {
                const rightSet = await getByCondition('B2BAppAccessRightSet', {
                    id: updatedItem.rightSet,
                    app: { deletedAt: null },
                    deletedAt: null,
                })
                if (!rightSet) {
                    throw new GQLError(ERRORS.RIGHT_SET_NOT_EXISTS, context)
                }
                const b2bAppContext = await getByCondition('B2BAppContext', {
                    id: updatedItem.context,
                    app: { deletedAt: null },
                    organization: { deletedAt: null },
                    status: CONTEXT_FINISHED_STATUS,
                    deletedAt: null,
                })
                if (!b2bAppContext) {
                    throw new GQLError(ERRORS.CONTEXT_NOT_EXISTS, context)
                }
                const existingUser = await getByCondition('User', { id: updatedItem.user, deletedAt: null })
                if (!existingUser) {
                    throw new GQLError(ERRORS.SERVICE_USER_DOES_NOT_MATCH_CONTEXT, context)
                }
                const permissions = Object.keys(getEnabledPermissions(rightSet))
                const additionalFields = makeSessionData({
                    allowedOrganizations: [b2bAppContext.organization],
                    enabledB2BAppPermissions: permissions,
                })
                const expiresAt = get(updatedItem, 'expiresAt')
                await setSession(context.req.sessionStore, {
                    sessionId,
                    keystoneItemId: updatedItem.user,
                    expires: expiresAt ? expiresAt.toISOString() : null,
                    additionalFields,
                })
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadB2BAccessTokens,
        create: access.canManageB2BAccessTokens,
        update: access.canManageB2BAccessTokens,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAccessToken,
}
