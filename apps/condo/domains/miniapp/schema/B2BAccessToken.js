/**
 * Generated by `createschema miniapp.B2BAccessToken 'sessionId:Text; context:Relationship:B2BAppContext:CASCADE; rightSet:Relationship:B2BAppAccessRightSet:CASCADE; expiresAt:Text;'`
 */

const crypto = require('crypto')

const cookieSignature = require('cookie-signature')
const dayjs = require('dayjs')
const get = require('lodash/get')
const isNil = require('lodash/isNil')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, find, getById, getByCondition } = require('@open-condo/keystone/schema')
const { setSession, destroySession } = require('@open-condo/keystone/session')

const { encryptionManager } = require('@condo/domains/common/utils/encryption')
const { makeSessionData } = require('@condo/domains/common/utils/session')
const access = require('@condo/domains/miniapp/access/B2BAccessToken')
const {
    ACCESS_TOKEN_SESSION_ID_PREFIX,
    ACCESS_TOKEN_CONTEXT_NOT_EXISTS,
    ACCESS_TOKEN_RIGHT_SET_NOT_EXISTS,
    ACCESS_TOKEN_WRONG_RIGHT_SET_TYPE,
    ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET,
    ACCESS_TOKEN_SERVICE_USER_DOES_NOT_MATCH_CONTEXT,
    ACCESS_TOKEN_NEGATIVE_TTL,
    ACCESS_RIGHT_SET_SCOPED_TYPE,
} = require('@condo/domains/miniapp/constants')
const { SERVICE_USER_FIELD } = require('@condo/domains/miniapp/schema/fields/accessRight')
const { getEnabledPermissions } = require('@condo/domains/miniapp/utils/permissions')

const { COOKIE_SECRET } = conf

async function getValidationError (item) {

    const b2bAppContext = await getByCondition('B2BAppContext', {
        id: item.context,
        deletedAt: null,
    })
    if (!b2bAppContext) {
        return ERRORS.CONTEXT_NOT_EXISTS
    }
    const accessRightSet = await getByCondition('B2BAppAccessRightSet', {
        id: item.rightSet,
        deletedAt: null,
    })
    if (!accessRightSet) {
        return ERRORS.RIGHT_SET_NOT_EXISTS
    }
    if (accessRightSet.type !== ACCESS_RIGHT_SET_SCOPED_TYPE) {
        return ERRORS.WRONG_RIGHT_SET_TYPE
    }
    if (accessRightSet.app && (accessRightSet.app !== b2bAppContext.app)) {
        return ERRORS.CONTEXT_DOES_NOT_MATCH_RIGHT_SET
    }
    const [accessRightForUserAndApp] = await find('B2BAppAccessRight', {
        user: { id: item.user },
        app: { id: b2bAppContext.app },
        deletedAt: null,
    })
    if (!accessRightForUserAndApp) {
        return ERRORS.SERVICE_USER_DOES_NOT_MATCH_CONTEXT
    }
    return null
}

const ERRORS = {
    CONTEXT_NOT_EXISTS: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_CONTEXT_NOT_EXISTS,
        message: 'B2BAppContext does not exists',
    },
    RIGHT_SET_NOT_EXISTS: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_RIGHT_SET_NOT_EXISTS,
        message: 'B2BAppAccessRightSet does not exists',
    },
    WRONG_RIGHT_SET_TYPE: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_WRONG_RIGHT_SET_TYPE,
        message: 'Wrong B2BAppAccessRightSet type, must be "SCOPED"',
    },
    CONTEXT_DOES_NOT_MATCH_RIGHT_SET: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET,
        message: 'B2BAppContext and B2BRightSet connected to different B2BApps',
    },
    SERVICE_USER_DOES_NOT_MATCH_CONTEXT: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_SERVICE_USER_DOES_NOT_MATCH_CONTEXT,
        message: 'User and B2BAppContext connected to different B2BApps',
    },
    NEGATIVE_TTL: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_NEGATIVE_TTL,
        message: 'TTL can\'t be negative. You provided expiresAt datetime previous to the current one',
    },
}

const ERRORS_FOR_DELETION = new Set([
    ERRORS.CONTEXT_NOT_EXISTS,
    ERRORS.RIGHT_SET_NOT_EXISTS,
    ERRORS.NEGATIVE_TTL,
])

const B2BAccessToken = new GQLListSchema('B2BAccessToken', {
    schemaDoc: 'Access to service user with additional restrictions by Organization and B2BAppAccessRightSet',
    fields: {
        sessionId: {
            schemaDoc: 'Encrypted sessionId of session',
            type: 'EncryptedText',
            encryptionManager: encryptionManager,
            isRequired: true,
            access: access.updatableOnlyForAdmin,
            hooks: {
                resolveInput ({ operation, existingItem, fieldPath }) {
                    if (operation === 'create') {
                        return ACCESS_TOKEN_SESSION_ID_PREFIX + crypto.randomUUID()
                    }
                    return get(existingItem, fieldPath)
                },
            },
        },

        token: {
            schemaDoc: 'Token, ready to be put in Authorization header. Shown only once after creation',
            type: 'Virtual',
            graphQLReturnType: 'String',
            resolver: (item) => {
                const sessionId = encryptionManager.decrypt(item.sessionId)
                return cookieSignature.sign(sessionId, COOKIE_SECRET)
            },
            access: access.readableOnlyOnCreate,
        },

        context: {
            schemaDoc: 'Link to B2BApp and Organization',
            type: 'Relationship',
            ref: 'B2BAppContext',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: access.updatableOnlyForAdmin,
        },

        user: {
            ...SERVICE_USER_FIELD,
            isRequired: true,
            access: access.updatableOnlyForAdmin,
            hooks: {
                ...SERVICE_USER_FIELD.hooks,
                async resolveInput ({ operation, existingItem, resolvedData, fieldPath }) {
                    const newItem = {
                        ...existingItem,
                        ...resolvedData,
                    }
                    if (operation === 'create' && !newItem[fieldPath]) {
                        const contextId = get(resolvedData, 'context') || get(existingItem, 'context')
                        const context = await getById('B2BAppContext', contextId)
                        const [accessRight] = await find('B2BAppAccessRight', {
                            app: { id: context.app },
                            deletedAt: null,
                        })
                        return accessRight.user
                    }

                    return resolvedData.user
                },
            },
        },

        rightSet: {
            schemaDoc: 'Right set for token',
            type: 'Relationship',
            ref: 'B2BAppAccessRightSet',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: access.updatableOnlyForAdmin,
        },

        expiresAt: {
            schemaDoc: 'Date, when access by this token will be restricted',
            type: 'DateTimeUtc',
            isRequired: false,
            access: access.updatableOnlyForAdmin,
            hooks: {
                validateInput ({ resolvedData, fieldPath, context }) {
                    const expiresAt = resolvedData[fieldPath]
                    if (isNil(expiresAt)) {
                        return
                    }
                    if (dayjs(expiresAt).isBefore(dayjs())) {
                        throw new GQLError(ERRORS.NEGATIVE_TTL, context)
                    }
                },
            },
        },
    },
    hooks: {
        async validateInput ({ operation, resolvedData, existingItem, context }) {
            const newItem = {
                ...existingItem,
                ...resolvedData,
            }
            const validationError = await getValidationError(newItem)

            if (operation === 'create' && validationError) {
                throw new GQLError(validationError, context)
            }
            if (operation === 'update' && validationError && ERRORS_FOR_DELETION.has(validationError)) {
                resolvedData.deletedAt = resolvedData.deletedAt ? resolvedData.deletedAt : dayjs().toISOString()
            }
        },
        async afterChange ({ context, operation, existingItem, updatedItem }) {
            const softDeleted = operation === 'update' && !existingItem['deletedAt'] && updatedItem['deletedAt']
            const sessionId = encryptionManager.decrypt(updatedItem.sessionId)

            if (softDeleted) {
                await destroySession(context.req.sessionStore, sessionId)
            }

            if (!softDeleted) {
                const rightSet = await getById('B2BAppAccessRightSet', updatedItem.rightSet)
                const b2bAppContext = await getById('B2BAppContext', updatedItem.context)
                const permissions = Object.keys(getEnabledPermissions(rightSet))
                const additionalFields = makeSessionData({
                    allowedOrganizations: [get(b2bAppContext, 'organization')],
                    enabledB2BPermissions: permissions,
                })

                const expiresAt = get(updatedItem, 'expiresAt')

                await setSession(context.req.sessionStore, {
                    sessionId,
                    userId: get(updatedItem, 'user'),
                    expires: expiresAt ? expiresAt.toISOString() : null,
                    additionalFields,
                })
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadB2BAccessTokens,
        create: access.canManageB2BAccessTokens,
        update: access.canManageB2BAccessTokens,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAccessToken,
}
