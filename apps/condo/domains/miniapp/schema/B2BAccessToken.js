/**
 * Generated by `createschema miniapp.B2BAccessToken 'sessionId:Text; context:Relationship:B2BAppContext:CASCADE; rightSet:Relationship:B2BAppAccessRightSet:CASCADE; expiresAt:Text;'`
 */

const cookieSignature = require('cookie-signature')
const dayjs = require('dayjs')
const get = require('lodash/get')
const has = require('lodash/has')
const omit = require('lodash/omit')
const { v4: uuid } = require('uuid')

const conf = require('@open-condo/config')
const { userIsAdmin } = require('@open-condo/keystone/access')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, find, getById, getByCondition } = require('@open-condo/keystone/schema')
const { setSession, destroySession } = require('@open-condo/keystone/session')
const { prepareDefaultKeystoneConfig } = require('@open-condo/keystone/setup.utils')

const { makeSessionData } = require('@condo/domains/common/utils/session')
const access = require('@condo/domains/miniapp/access/B2BAccessToken')
const {
    ACCESS_TOKEN_MAX_TTL_IN_MILLISECONDS,
    ACCESS_TOKEN_SESSION_ID_PREFIX,
    ACCESS_TOKEN_CONTEXT_NOT_EXISTS,
    ACCESS_TOKEN_RIGHT_SET_NOT_EXISTS,
    ACCESS_TOKEN_WRONG_RIGHT_SET_TYPE,
    ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET,
    ACCESS_TOKEN_SERVICE_USER_DOES_NOT_MATCH_CONTEXT,
    ACCESS_TOKEN_TTL_TOO_BIG,
} = require('@condo/domains/miniapp/constants')
const { SERVICE_USER_FIELD } = require('@condo/domains/miniapp/schema/fields/accessRight')

const { cookieSecret } = prepareDefaultKeystoneConfig(conf)

const ERRORS = {
    CONTEXT_NOT_EXISTS: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_CONTEXT_NOT_EXISTS,
        message: 'B2BAppContext does not exists',
    },
    RIGHT_SET_NOT_EXISTS: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_RIGHT_SET_NOT_EXISTS,
        message: 'B2BAppAccessRightSet does not exists',
    },
    WRONG_RIGHT_SET_TYPE: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_WRONG_RIGHT_SET_TYPE,
        message: 'Wrong B2BAppAccessRightSet type, must be "token"',
    },
    CONTEXT_DOES_NOT_MATCH_RIGHT_SET: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET,
        message: 'B2BAppContext and B2BRightSet connected to different B2BApps',
    },
    SERVICE_USER_DOES_NOT_MATCH_CONTEXT: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_SERVICE_USER_DOES_NOT_MATCH_CONTEXT,
        message: 'User and B2BAppContext connected to different B2BApps',
    },
    TTL_TOO_BIG: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_TTL_TOO_BIG,
        message: 'Time to live value is too big. Maximum is {maxExpireMilliseconds} - {maxExpireDate}',
        messageInterpolation: { 
            maxExpireMilliseconds: ACCESS_TOKEN_MAX_TTL_IN_MILLISECONDS,
            maxExpireDate: dayjs().add(ACCESS_TOKEN_MAX_TTL_IN_MILLISECONDS).toISOString(),
        },
    },
}

const B2BAccessToken = new GQLListSchema('B2BAccessToken', {
    schemaDoc: 'Access to service user with additional restrictions by Organization and B2BAppAccessRightSet',
    fields: {
        sessionId: {
            schemaDoc: 'Encoded sessionId of session',
            type: 'Text',
            isRequired: true,
            access: userIsAdmin,
            hooks: {
                resolveInput ({ operation, existingItem, fieldPath }) {
                    if (operation === 'create') {
                        return ACCESS_TOKEN_SESSION_ID_PREFIX + uuid()
                    }
                    return get(existingItem, fieldPath)
                },
            },
        },

        token: {
            schemaDoc: 'Token, ready to be put in Authorization header',
            type: 'Virtual',
            graphQLReturnType: 'String',
            resolver: (parent, args, context, info, extra) => {
                if (info.operation.name.value === 'createB2BAccessToken') {
                    return cookieSignature.sign(parent.sessionId, cookieSecret) // TODO: use decodedSessionId
                }
                return null
            },
        },

        context: {
            schemaDoc: 'Link to B2BApp and Organization',
            type: 'Relationship',
            ref: 'B2BAppContext',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: access.readonlyForNonAdmin,
        },

        user: {
            ...SERVICE_USER_FIELD,
            isRequired: true,
            access: access.readonlyForNonAdmin,
            hooks: {
                ...SERVICE_USER_FIELD.hooks,
                async resolveInput ({ operation, existingItem, resolvedData, fieldPath }) {
                    if (operation === 'create' && !has(resolvedData, fieldPath)) {
                        const contextId = get(resolvedData, 'context') || get(existingItem, 'context')
                        const context = await getById('B2BAppContext', contextId)
                        const [accessRight] = await find('B2BAppAccessRight', {
                            app: { id: context.app },
                            deletedAt: null,
                        })
                        return accessRight.user
                    }

                    return existingItem.user
                },
            },
        },

        rightSet: {
            schemaDoc: 'Right set for token',
            type: 'Relationship',
            ref: 'B2BAppAccessRightSet',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: access.readonlyForNonAdmin,
        },

        expiresAt: {
            schemaDoc: 'Date, when access by this token will be restricted',
            type: 'DateTimeUtc',
            isRequired: true,
            access: access.readonlyForNonAdmin,
        },
    },
    hooks: {
        async validateInput ({ resolvedData, existingItem, context }) {
            const newItem = {
                ...(existingItem || {}),
                ...resolvedData,
            }
            const b2bAppcontext = await getById('B2BAppContext', get(newItem, 'context'))
            const accessRightSet = await getById('B2BAppAccessRightSet', get(newItem, 'rightSet'))

            if (!b2bAppcontext || get(b2bAppcontext, 'deletedAt')) {
                throw new GQLError(ERRORS.CONTEXT_NOT_EXISTS, context)
            }
            if (!accessRightSet || get(accessRightSet, 'deletedAt')) {
                throw new GQLError(ERRORS.RIGHT_SET_NOT_EXISTS, context)
            }
            if (get(accessRightSet, 'type') !== 'token') {
                throw new GQLError(ERRORS.WRONG_RIGHT_SET_TYPE, context)
            }
            
            if (get(accessRightSet, 'app') && (get(accessRightSet, 'app') !== get(b2bAppcontext, 'app'))) {
                throw new GQLError(ERRORS.CONTEXT_DOES_NOT_MATCH_RIGHT_SET, context)
            }

            const [accessRightForUserAndApp] = await find('B2BAppAccessRight', {
                user: { id: get(newItem, 'user') },
                app: { id: get(b2bAppcontext, 'app') },
                deletedAt: null,
            })
            if (!accessRightForUserAndApp) {
                throw new GQLError(ERRORS.SERVICE_USER_DOES_NOT_MATCH_CONTEXT, context)
            }

            const maxExpiresAtInMilliseconds = dayjs().add(ACCESS_TOKEN_MAX_TTL_IN_MILLISECONDS, 'milliseconds').valueOf()
            const newExpiresAtInMilliseconds = dayjs.utc(get(newItem, 'expiresAt')).valueOf()
            if (maxExpiresAtInMilliseconds < newExpiresAtInMilliseconds) {
                throw new GQLError(ERRORS.TTL_TOO_BIG, context)
            }

        },
        beforeChange () {
            // TODO: encode sessionId for saving in db
        },
        async afterChange ({ context, operation, existingItem, updatedItem }) {
            const softDeleted = operation === 'update' && !existingItem['deletedAt'] && updatedItem['deletedAt']
            // TODO: decode sessionId for session manipulations
            if (softDeleted) {
                await destroySession(context, existingItem.sessionId)
            }

            if (!softDeleted) {
                const rightSet = await getById('B2BAppAccessRightSet', updatedItem.rightSet)
                const b2bAppContext = await getById('B2BAppContext', updatedItem.context)
                const permissions = omit(rightSet, ['id', 'app', 'name', 'type', 'createdAt', 'createdBy', 'updatedAt', 'updatedBy', 'deletedAt', 'deletedBy', 'v', 'dv', 'newId', 'sender'])
                const additionalFields = makeSessionData({
                    organizations: [get(b2bAppContext, 'organization')],
                    b2bPermissions: permissions,
                })

                await setSession(context, {
                    sessionId: get(updatedItem, 'sessionId'),
                    userId: get(updatedItem, 'user'),
                    expires: get(updatedItem, 'expiresAt').toISOString(),
                    additionalFields,
                })
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadB2BAccessTokens,
        create: access.canManageB2BAccessTokens,
        update: access.canManageB2BAccessTokens,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAccessToken,
}
