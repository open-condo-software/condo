/**
 * Generated by `createschema miniapp.B2BAccessToken 'sessionId:Text; context:Relationship:B2BAppContext:CASCADE; rightSet:Relationship:B2BAppAccessRightSet:CASCADE; expiresAt:Text;'`
 */

const crypto = require('crypto')

const cookieSignature = require('cookie-signature')
const dayjs = require('dayjs')
const get = require('lodash/get')
const has = require('lodash/has')
const isEmpty = require('lodash/isEmpty')
const isNil = require('lodash/isNil')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, find, getById, getByCondition } = require('@open-condo/keystone/schema')
const { setSession, destroySession } = require('@open-condo/keystone/session')
const { prepareDefaultKeystoneConfig } = require('@open-condo/keystone/setup.utils')

const { encryptionManager } = require('@condo/domains/common/utils/crypto')
const { makeSessionData } = require('@condo/domains/common/utils/session')
const access = require('@condo/domains/miniapp/access/B2BAccessToken')
const {
    ACCESS_TOKEN_SESSION_ID_PREFIX,
    ACCESS_TOKEN_CONTEXT_NOT_EXISTS,
    ACCESS_TOKEN_RIGHT_SET_NOT_EXISTS,
    ACCESS_TOKEN_WRONG_RIGHT_SET_TYPE,
    ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET,
    ACCESS_TOKEN_SERVICE_USER_DOES_NOT_MATCH_CONTEXT,
    ACCESS_TOKEN_NEGATIVE_TTL,
    ACCESS_RIGHT_SET_SCOPED_TYPE,
} = require('@condo/domains/miniapp/constants')
const { SERVICE_USER_FIELD } = require('@condo/domains/miniapp/schema/fields/accessRight')
const { getEnabledPermissions } = require('@condo/domains/miniapp/utils/permissions')

// NOTE(YEgorLu): using deprecated function to get same cookieSecret, that app uses
// otherwise I would need to copy code to get same result
const { cookieSecret } = prepareDefaultKeystoneConfig(conf)

function getValidationError ({
    b2bAppContext,
    accessRightSet,
    accessRightForUserAndApp,
}) {
    if (!b2bAppContext) {
        return ERRORS.CONTEXT_NOT_EXISTS
    }
    if (!accessRightSet) {
        return ERRORS.RIGHT_SET_NOT_EXISTS
    }
    if (get(accessRightSet, 'type') !== ACCESS_RIGHT_SET_SCOPED_TYPE) {
        return ERRORS.WRONG_RIGHT_SET_TYPE
    }
    if (get(accessRightSet, 'app') && (get(accessRightSet, 'app') !== get(b2bAppContext, 'app'))) {
        return ERRORS.CONTEXT_DOES_NOT_MATCH_RIGHT_SET
    }
    if (!accessRightForUserAndApp) {
        return ERRORS.SERVICE_USER_DOES_NOT_MATCH_CONTEXT
    }
    return null
}

const ERRORS = {
    CONTEXT_NOT_EXISTS: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_CONTEXT_NOT_EXISTS,
        message: 'B2BAppContext does not exists',
    },
    RIGHT_SET_NOT_EXISTS: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_RIGHT_SET_NOT_EXISTS,
        message: 'B2BAppAccessRightSet does not exists',
    },
    WRONG_RIGHT_SET_TYPE: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_WRONG_RIGHT_SET_TYPE,
        message: 'Wrong B2BAppAccessRightSet type, must be "SCOPED"',
    },
    CONTEXT_DOES_NOT_MATCH_RIGHT_SET: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_CONTEXT_DOES_NOT_MATCH_RIGHT_SET,
        message: 'B2BAppContext and B2BRightSet connected to different B2BApps',
    },
    SERVICE_USER_DOES_NOT_MATCH_CONTEXT: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_SERVICE_USER_DOES_NOT_MATCH_CONTEXT,
        message: 'User and B2BAppContext connected to different B2BApps',
    },
    NEGATIVE_TTL: {
        code: BAD_USER_INPUT,
        type: ACCESS_TOKEN_NEGATIVE_TTL,
        message: 'TTL can\'t be negative. You provided expiresAt datetime previous to the current one',
    },
}

const ERRORS_FOR_DELETION = new Set([
    ERRORS.CONTEXT_NOT_EXISTS,
    ERRORS.RIGHT_SET_NOT_EXISTS,
    ERRORS.NEGATIVE_TTL,
])

const B2BAccessToken = new GQLListSchema('B2BAccessToken', {
    schemaDoc: 'Access to service user with additional restrictions by Organization and B2BAppAccessRightSet',
    fields: {
        sessionId: {
            schemaDoc: 'Encrypted sessionId of session',
            type: 'EncryptedText',
            isRequired: true,
            access: access.updatableOnlyForAdmin,
            hooks: {
                resolveInput ({ operation, existingItem, fieldPath, originalInput }) {
                    const inputSessionId = get(originalInput, fieldPath)
                    // need to have option to manually set sessionId, so we can migrate already given tokens to this
                    if (!isNil(inputSessionId) && !isEmpty(inputSessionId)) {
                        return inputSessionId
                    }
                    if (operation === 'create') {
                        return ACCESS_TOKEN_SESSION_ID_PREFIX + crypto.randomUUID()
                    }
                    return get(existingItem, fieldPath)
                },
            },
        },

        token: {
            schemaDoc: 'Token, ready to be put in Authorization header. Shown only once after creation',
            type: 'Virtual',
            graphQLReturnType: 'String',
            resolver: (item) => {
                if (!isNil(item.token)) {
                    return item.token
                }
                return null
            },
        },

        context: {
            schemaDoc: 'Link to B2BApp and Organization',
            type: 'Relationship',
            ref: 'B2BAppContext',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: access.updatableOnlyForAdmin,
        },

        user: {
            ...SERVICE_USER_FIELD,
            isRequired: true,
            access: access.updatableOnlyForAdmin,
            hooks: {
                ...SERVICE_USER_FIELD.hooks,
                async resolveInput ({ operation, existingItem, resolvedData, fieldPath }) {
                    if (operation === 'create' && !has(resolvedData, fieldPath)) {
                        const contextId = get(resolvedData, 'context') || get(existingItem, 'context')
                        const context = await getById('B2BAppContext', contextId)
                        const [accessRight] = await find('B2BAppAccessRight', {
                            app: { id: context.app },
                            deletedAt: null,
                        })
                        return accessRight.user
                    }

                    return existingItem.user
                },
            },
        },

        rightSet: {
            schemaDoc: 'Right set for token',
            type: 'Relationship',
            ref: 'B2BAppAccessRightSet',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: access.updatableOnlyForAdmin,
        },

        expiresAt: {
            schemaDoc: 'Date, when access by this token will be restricted',
            type: 'DateTimeUtc',
            isRequired: false,
            access: access.updatableOnlyForAdmin,
            hooks: {
                validateInput ({ resolvedData, fieldPath, context }) {
                    const expiresAt = resolvedData[fieldPath]
                    if (isNil(expiresAt)) {
                        return
                    }
                    if (dayjs(expiresAt).isBefore(dayjs())) {
                        throw new GQLError(ERRORS.NEGATIVE_TTL, context)
                    }
                },
            },
        },
    },
    hooks: {
        async validateInput ({ operation, resolvedData, existingItem, context }) {
            const newItem = {
                ...(existingItem || {}),
                ...resolvedData,
            }

            if (newItem.deletedAt) {
                return
            }

            const b2bAppContext = await getByCondition('B2BAppContext', {
                id: get(newItem, 'context'),
                deletedAt: null,
            })
            const accessRightSet = await getByCondition('B2BAppAccessRightSet', {
                id: get(newItem, 'rightSet'),
                deletedAt: null,
            })
            const [accessRightForUserAndApp] = await find('B2BAppAccessRight', {
                user: { id: get(newItem, 'user') },
                app: { id: get(b2bAppContext, 'app') },
                deletedAt: null,
            })
            
            const validationError = getValidationError({
                b2bAppContext,
                accessRightSet,
                accessRightForUserAndApp,
            })

            if (operation === 'create' && validationError) {
                throw new GQLError(validationError, context)
            }
            if (operation === 'update' && validationError && ERRORS_FOR_DELETION.has(validationError)) {
                resolvedData.deletedAt = dayjs().toISOString()
            }
        },
        async afterChange ({ context, operation, existingItem, updatedItem, originalInput }) {
            const softDeleted = operation === 'update' && !existingItem['deletedAt'] && updatedItem['deletedAt']
            const sessionIdChanged = operation === 'update' && originalInput['sessionId']
            const sessionId = encryptionManager.decrypt(updatedItem.sessionId)

            if (operation === 'create') {
                updatedItem.token = cookieSignature.sign(sessionId, cookieSecret)
            }

            if (softDeleted || sessionIdChanged) {
                const previousSessionId = encryptionManager.decrypt(existingItem.sessionId)
                await destroySession(context, previousSessionId)
            }

            if (!softDeleted) {
                const rightSet = await getById('B2BAppAccessRightSet', updatedItem.rightSet)
                const b2bAppContext = await getById('B2BAppContext', updatedItem.context)
                const permissions = Object.keys(getEnabledPermissions(rightSet))
                const additionalFields = makeSessionData({
                    allowedOrganizations: [get(b2bAppContext, 'organization')],
                    enabledB2BPermissions: permissions,
                })

                const expiresAt = get(updatedItem, 'expiresAt')

                await setSession(context, {
                    sessionId,
                    userId: get(updatedItem, 'user'),
                    expires: expiresAt ? expiresAt.toISOString() : null,
                    additionalFields,
                })
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadB2BAccessTokens,
        create: access.canManageB2BAccessTokens,
        update: access.canManageB2BAccessTokens,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAccessToken,
}
