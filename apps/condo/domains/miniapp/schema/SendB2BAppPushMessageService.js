/**
 * Generated by `createservice miniapp.SendB2BAppPushMessageService '--type=mutations'`
 */

const { get } = require('lodash')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { FORBIDDEN } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, itemsQuery } = require('@open-condo/keystone/schema')

const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/miniapp/access/SendB2BAppPushMessageService')
const {
    CONTEXT_FINISHED_STATUS,
    DEFAULT_NOTIFICATION_WINDOW_DURATION,
    DEFAULT_NOTIFICATIONS_IN_WINDOW_COUNT,
    APP_BLACK_LIST_ERROR,
} = require('@condo/domains/miniapp/constants')
const { AppMessageSetting } = require('@condo/domains/miniapp/utils/serverSchema')
const { B2B_APP_MESSAGE_TYPES } = require('@condo/domains/notification/constants/constants')
const { sendMessage } = require('@condo/domains/notification/utils/serverSchema')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')


const redisGuard = new RedisGuard()
/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    APP_IN_BLACK_LIST: {
        mutation: 'sendB2BAppPushMessage',
        variable: ['data', 'app'],
        code: FORBIDDEN,
        type: APP_BLACK_LIST_ERROR,
        message: 'The notification type is blocked for this app',
    },
    NO_B2B_CONTEXT: {
        mutation: 'sendB2BAppPushMessage',
        variable: ['data', 'app'],
        code: FORBIDDEN,
        type: NOT_FOUND,
        message: 'No completed B2BContext in "Finished" status found for the provided organization and B2BApp.',
    },
    NO_B2B_APP_ACCESS_RIGHT: {
        mutation: 'sendB2BAppPushMessage',
        variable: ['data', 'app'],
        code: FORBIDDEN,
        type: NOT_FOUND,
        message: 'No B2BAppAccessRight found for the provided user and B2BApp.',
    },
    NO_EMPLOYEE_FOR_USER: {
        mutation: 'sendB2BAppPushMessage',
        variable: ['data', 'user'],
        code: FORBIDDEN,
        type: NOT_FOUND,
        message: 'The provided user is not an employee of the specified organization.',
    },
}

const SendB2BAppPushMessageService = new GQLCustomSchema('SendB2BAppPushMessageService', {
    types: [
        {
            access: true,
            type: `enum B2BAppMessageType { ${B2B_APP_MESSAGE_TYPES.join(' ')} }`,
        },
        {
            access: true,
            type: 'input SendB2BAppPushMessageInput { dv: Int!, sender: SenderFieldInput!, user: UserWhereUniqueInput!, organization: OrganizationWhereUniqueInput!, app: B2BAppWhereUniqueInput!, type: MessageType!, meta: JSON!, }',
        },
        {
            access: true,
            type: 'type SendB2BAppPushMessageOutput { status: String!, id: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canSendB2BAppPushMessage,
            schema: 'sendB2BAppPushMessage(data: SendB2BAppPushMessageInput!): SendB2BAppPushMessageOutput',
            resolver: async (parent, args, context) => {
                const {
                    data: {
                        dv,
                        sender,
                        user: userFilter,
                        organization: organizationFilter,
                        app: b2bAppFilter,
                        type,
                        meta,
                    },
                } = args
                const authedItemId = get(context, 'authedItem.id')

                const appSettings = await AppMessageSetting.getOne(
                    context,
                    { b2bApp: { ...b2bAppFilter, deletedAt: null }, type, deletedAt: null },
                    'isBlacklisted notificationWindowSize numberOfNotificationInWindow'
                )
                if (appSettings && appSettings.isBlacklisted) {
                    throw new GQLError(ERRORS.APP_IN_BLACK_LIST, context)
                }

                const [b2bAppContext] = await itemsQuery('B2BAppContext', {
                    where: {
                        organization: { ...organizationFilter, deletedAt: null },
                        app: { ...b2bAppFilter, deletedAt: null },
                        status: CONTEXT_FINISHED_STATUS,
                        deletedAt: null,
                    },
                    first: 1,
                })
                if (!b2bAppContext) {
                    throw new GQLError(ERRORS.NO_B2B_CONTEXT, context)
                }

                const [b2bAppAccessRight] = await itemsQuery('B2BAppAccessRight', {
                    where: {
                        accessRightSet: {
                            app: { ...b2bAppFilter, deletedAt: null },
                            canExecuteSendB2BAppPushMessage: true,
                        },
                        user: { id: authedItemId, deletedAt: null },
                        app: { ...b2bAppFilter, deletedAt: null },
                        deletedAt: null,
                    },
                    first: 1,
                })
                if (!b2bAppAccessRight) {
                    throw new GQLError(ERRORS.NO_B2B_APP_ACCESS_RIGHT, context)
                }

                await redisGuard.checkCustomLimitCounters(
                    `sendB2CAppPushMessage-${type}-${b2bAppFilter.id}-${userFilter.id}`,
                    get(appSettings, 'notificationWindowSize') || DEFAULT_NOTIFICATION_WINDOW_DURATION,
                    get(appSettings, 'numberOfNotificationInWindow') || DEFAULT_NOTIFICATIONS_IN_WINDOW_COUNT,
                    context,
                )

                const [organization] = await itemsQuery('Organization', {
                    where: {
                        ...organizationFilter,
                        deletedAt: null,
                    },
                    first: 1,
                })

                const [employee] = await itemsQuery('OrganizationEmployee', {
                    where: {
                        organization: { ...organizationFilter, deletedAt: null },
                        user: { ...userFilter, deletedAt: null },
                        isAccepted: true,
                        isRejected: false,
                        isBlocked: false,
                        deletedAt: null,
                    },
                    first: 1,
                })
                if (!employee) {
                    throw new GQLError(ERRORS.NO_EMPLOYEE_FOR_USER, context)
                }

                const { id, status } = await sendMessage(context, {
                    to: { user: userFilter },
                    organization: organizationFilter,
                    type,
                    lang: get(organization, ['country', 'locale'], conf.DEFAULT_LOCALE),
                    meta,
                    dv,
                    sender,
                })

                return {
                    id,
                    status,
                }
            },
        },
    ],
    
})

module.exports = {
    SendB2BAppPushMessageService,
    ERRORS,
}
