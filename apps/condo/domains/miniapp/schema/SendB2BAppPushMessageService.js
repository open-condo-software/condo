/**
 * Generated by `createservice miniapp.SendB2BAppPushMessageService '--type=mutations'`
 */
const { get } = require('lodash')
const pick = require('lodash/pick')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { FORBIDDEN, BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, getByCondition } = require('@open-condo/keystone/schema')
const { isSafeUrl } = require('@open-condo/miniapp-utils/helpers/urls')

const { NOT_FOUND, WRONG_VALUE } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/miniapp/access/SendB2BAppPushMessageService')
const {
    CONTEXT_FINISHED_STATUS,
    DEFAULT_NOTIFICATION_WINDOW_DURATION_IN_SECONDS,
    DEFAULT_NOTIFICATION_WINDOW_MAX_COUNT,
} = require('@condo/domains/miniapp/constants')
const { B2B_APP_MESSAGE_TYPES, MESSAGE_META, PASS_TICKET_CREATED_MESSAGE_TYPE, PASS_TICKET_COMMENT_CREATED_MESSAGE_TYPE } = require('@condo/domains/notification/constants/constants')
const { sendMessage } = require('@condo/domains/notification/utils/serverSchema')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')

/**
 * Message types that require automatic URL generation in meta.data.url
 */
const MESSAGE_TYPES_REQUIRING_URL = [
    PASS_TICKET_CREATED_MESSAGE_TYPE,
    PASS_TICKET_COMMENT_CREATED_MESSAGE_TYPE,
]

/**
 * Validates appInitialContext string format
 * Should be a safe string that can be used in URL fragment
 * @param {string} appInitialContext - String to be used as URL fragment
 * @returns {boolean} - true if valid format
 */
function isValidAppInitialContext (appInitialContext) {
    if (typeof appInitialContext !== 'string') {
        return false
    }

    const testUrl = `${conf.SERVER_URL}#${appInitialContext}`
    return isSafeUrl(testUrl)
}

const redisGuard = new RedisGuard()
/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    NO_B2B_CONTEXT: {
        mutation: 'sendB2BAppPushMessage',
        variable: ['data', 'app'],
        code: FORBIDDEN,
        type: NOT_FOUND,
        message: 'No completed B2BContext in "Finished" status found for the provided organization and B2BApp.',
    },
    NO_B2B_APP_ACCESS_RIGHT: {
        mutation: 'sendB2BAppPushMessage',
        variable: ['data', 'app'],
        code: FORBIDDEN,
        type: NOT_FOUND,
        message: 'No B2BAppAccessRight found for the provided user and B2BApp.',
    },
    USER_IS_NOT_AN_EMPLOYEE: {
        mutation: 'sendB2BAppPushMessage',
        variable: ['data', 'user'],
        code: FORBIDDEN,
        type: NOT_FOUND,
        message: 'The provided user is not an employee of the specified organization.',
    },
    NO_B2B_APP_ROLE_FOR_EMPLOYEE_ROLE_AND_B2B_APP: {
        mutation: 'sendB2BAppPushMessage',
        code: FORBIDDEN,
        type: NOT_FOUND,
        message: 'No B2BAppRole found for the provided user, organization and B2BApp',
    },
    INVALID_URL: {
        mutation: 'sendB2BAppPushMessage',
        variable: ['data', 'meta', 'data', 'url'],
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: 'Invalid URL: must start with server url and be safe',
    },
    INVALID_APP_INITIAL_CONTEXT: {
        mutation: 'sendB2BAppPushMessage',
        variable: ['data', 'appInitialContext'],
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: 'Invalid appInitialContext: must be a safe string that can be used in URL fragment',
    },
}

const SendB2BAppPushMessageService = new GQLCustomSchema('SendB2BAppPushMessageService', {
    types: [
        {
            access: true,
            type: `enum B2BAppMessageType { ${B2B_APP_MESSAGE_TYPES.join(' ')} }`,
        },
        {
            access: true,
            type: 'input SendB2BAppPushMessageInput { dv: Int!, sender: SenderFieldInput!, user: UserWhereUniqueInput!, organization: OrganizationWhereUniqueInput!, app: B2BAppWhereUniqueInput!, appInitialContext: String, type: B2BAppMessageType!, meta: JSON!, }',
        },
        {
            access: true,
            type: 'type SendB2BAppPushMessageOutput { status: String!, id: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canSendB2BAppPushMessage,
            schema: 'sendB2BAppPushMessage(data: SendB2BAppPushMessageInput!): SendB2BAppPushMessageOutput',
            doc: {
                summary: 'Sends message of specified type from B2BApp (service user connected to B2BApp) to specified employee (user in organization)',
                description: `
                    B2BApp must has finished context with organization and B2BAccessRight with B2BAccessRightSet with canExecuteSendB2BAppPushMessage right 
                    between service user (who make request) and B2BApp. Employee must has a B2BAppRole with B2BApp. 
                    Settings for each type of message contains in AppMessageSetting schema.
                    Each message type has specific set of required fields which are defined in the meta field: \n\n\`${JSON.stringify(pick(MESSAGE_META, B2B_APP_MESSAGE_TYPES), null, '\t')}\`
                    
                    **appInitialContext** - String that the miniapp will receive when opened via link from the Message.
                    This string will be appended after # in the URL. Can be any safe string format (e.g., "param1=value1&param2=value2" or custom format).
                    These parameters will be passed to the miniapp to provide initial context/state. Empty string is allowed.
                `,
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const {
                    data: {
                        dv,
                        sender,
                        user: userFilter,
                        organization: organizationFilter,
                        app: b2bAppFilter,
                        appInitialContext,
                        type,
                        meta,
                    },
                } = args
                const authedItemId = get(context, 'authedItem.id', null)

                if (appInitialContext !== undefined && !isValidAppInitialContext(appInitialContext)) {
                    throw new GQLError(ERRORS.INVALID_APP_INITIAL_CONTEXT, context)
                }

                const appSettings = await getByCondition('AppMessageSetting', {
                    b2bApp: { ...b2bAppFilter, deletedAt: null },
                    type,
                    deletedAt: null,
                })

                await redisGuard.checkCustomLimitCounters(
                    `sendB2BAppPushMessage:app:${b2bAppFilter.id}:${type}:org:${organizationFilter.id}:user:${userFilter.id}`,
                    get(appSettings, 'notificationWindowSize') ?? DEFAULT_NOTIFICATION_WINDOW_DURATION_IN_SECONDS,
                    get(appSettings, 'numberOfNotificationInWindow') ?? DEFAULT_NOTIFICATION_WINDOW_MAX_COUNT,
                    context,
                )

                const user = await getByCondition('User', {
                    ...userFilter,
                    deletedAt: null,
                })
                if (!user) {
                    throw new GQLError(ERRORS.USER_IS_NOT_AN_EMPLOYEE, context)
                }
                const messageLocale = get(user, 'locale', conf.DEFAULT_LOCALE)

                const b2bAppContext = await getByCondition('B2BAppContext', {
                    organization: { ...organizationFilter, deletedAt: null },
                    app: { ...b2bAppFilter, deletedAt: null },
                    status: CONTEXT_FINISHED_STATUS,
                    deletedAt: null,
                })
                if (!b2bAppContext) {
                    throw new GQLError(ERRORS.NO_B2B_CONTEXT, context)
                }

                const b2bAppAccessRight = await getByCondition('B2BAppAccessRight', {
                    accessRightSet: {
                        app: { ...b2bAppFilter, deletedAt: null },
                        canExecuteSendB2BAppPushMessage: true,
                        deletedAt: null,
                    },
                    user: { id: authedItemId, deletedAt: null },
                    deletedAt: null,
                })
                if (!b2bAppAccessRight) {
                    throw new GQLError(ERRORS.NO_B2B_APP_ACCESS_RIGHT, context)
                }

                const employee = await getByCondition('OrganizationEmployee', {
                    organization: { ...organizationFilter, deletedAt: null },
                    user: { ...userFilter, deletedAt: null },
                    isAccepted: true,
                    isRejected: false,
                    isBlocked: false,
                    deletedAt: null,
                })
                if (!employee) {
                    throw new GQLError(ERRORS.USER_IS_NOT_AN_EMPLOYEE, context)
                }

                const roleId = get(employee, 'role', null)
                const b2bAppRole = await getByCondition('B2BAppRole', {
                    deletedAt: null,
                    app: { ...b2bAppFilter, deletedAt: null },
                    role: { id: roleId, deletedAt: null },
                })
                if (!roleId || !b2bAppRole) {
                    throw new GQLError(ERRORS.NO_B2B_APP_ROLE_FOR_EMPLOYEE_ROLE_AND_B2B_APP, context)
                }

                let finalMeta = meta
                const isUrlNeeded = MESSAGE_TYPES_REQUIRING_URL.includes(type)
                if (isUrlNeeded) {
                    const base = new URL(conf.SERVER_URL)
                    const baseUrl = new URL(`/miniapps/${b2bAppFilter.id}`, base).toString()
                    const urlWithContext = appInitialContext && appInitialContext.length > 0
                        ? `${baseUrl}#${encodeURIComponent(appInitialContext)}`
                        : baseUrl
                        
                    finalMeta = {
                        ...meta,
                        data: {
                            ...(meta?.data || {}),
                            url: urlWithContext,
                        },
                    }
                }

                const { id, status } = await sendMessage(context, {
                    to: { user: userFilter },
                    organization: organizationFilter,
                    type,
                    lang: messageLocale,
                    meta: finalMeta,
                    dv,
                    sender,
                })

                return {
                    id,
                    status,
                }
            },
        },
    ],
    
})

module.exports = {
    SendB2BAppPushMessageService,
    ERRORS,
    MESSAGE_TYPES_REQUIRING_URL,
}