/**
 * Generated by `createschema miniapp.B2CApp 'name:Text;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const conf = require('@open-condo/config')
const { makeLoggedInAdminClient, makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowValidationFailureError,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')
const { replaceDomainPrefix } = require('@open-condo/miniapp-utils/helpers/urls')

const { B2CApp, createTestB2CApp, updateTestB2CApp } = require('@condo/domains/miniapp/utils/testSchema')
const { MANAGING_COMPANY_TYPE } = require('@condo/domains/organization/constants/common')
const { SubscriptionPlan, createTestSubscriptionPlan } = require('@condo/domains/subscription/utils/testSchema')
const { makeClientWithSupportUser, makeClientWithNewRegisteredAndLoggedInUser, createTestOidcClient, updateTestOidcClient } = require('@condo/domains/user/utils/testSchema')

function expectedAppDomain (appId, idx) {
    return new URL(replaceDomainPrefix(conf['SERVER_URL'], `${appId}-${idx}.miniapps`)).origin
}

describe('B2CApp', () => {
    let admin
    let user
    let support
    let anonymous
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()
    })
    describe('CRUD operations', () => {
        describe('Create', () => {
            test('Admin can', async () => {
                const [app] = await createTestB2CApp(admin)
                expect(app).toBeDefined()
                expect(app).toHaveProperty('id')
            })
            test('Support can', async () => {
                const payload = {
                    name: faker.company.name(),
                }
                const [app] = await createTestB2CApp(support, payload)
                expect(app).toBeDefined()
                expect(app).toHaveProperty('id')
                expect(app).toEqual(expect.objectContaining(payload))
            })
            test('User cannot', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2CApp(user)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestB2CApp(anonymous)
                })
            })
        })
        describe('Read', () => {
            let app
            const payload = {
                name: faker.company.name(),
                isHidden: false,
            }
            beforeAll(async () => {
                [app] = await createTestB2CApp(admin, payload)
            })
            test('Admin can', async () => {
                const apps = await B2CApp.getAll(admin, {
                    id: app.id,
                })
                expect(apps).toBeDefined()
                expect(apps).toHaveLength(1)
                expect(apps[0]).toEqual(expect.objectContaining(payload))
            })
            test('Support can', async () => {
                const apps = await B2CApp.getAll(support, {
                    id: app.id,
                })
                expect(apps).toBeDefined()
                expect(apps).toHaveLength(1)
                expect(apps[0]).toEqual(expect.objectContaining(payload))
            })
            test('User can', async () => {
                const apps = await B2CApp.getAll(user, {
                    id: app.id,
                })
                expect(apps).toBeDefined()
                expect(apps).toHaveLength(1)
                expect(apps[0]).toEqual(expect.objectContaining(payload))
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await B2CApp.getAll(anonymous, {
                        id: app.id,
                    })
                })
            })
        })
        describe('Update', () => {
            let app
            let payload
            beforeAll(async () => {
                [app] = await createTestB2CApp(admin)
            })
            beforeEach(() => {
                payload = { name: faker.company.name() }
            })
            describe('Admin', () => {
                test('Can update', async () => {
                    expect(app).toBeDefined()
                    expect(app).toEqual(expect.not.objectContaining(payload))
                    const [updatedApp] = await updateTestB2CApp(admin, app.id, payload)
                    expect(updatedApp).toBeDefined()
                    expect(updatedApp).toEqual(expect.objectContaining(payload))
                })
                test('Can soft-delete', async () => {
                    const [b2cApp] = await createTestB2CApp(admin)
                    expect(b2cApp).toHaveProperty('deletedAt', null)
                    const [deletedApp] = await updateTestB2CApp(admin, b2cApp.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    expect(deletedApp).toBeDefined()
                    expect(deletedApp).toHaveProperty('deletedAt')
                    expect(deletedApp.deletedAt).not.toBeNull()
                })
            })
            describe('Support', () => {
                test('Can update', async () => {
                    expect(app).toBeDefined()
                    expect(app).toEqual(expect.not.objectContaining(payload))
                    const [updatedApp] = await updateTestB2CApp(support, app.id, payload)
                    expect(updatedApp).toBeDefined()
                    expect(updatedApp).toEqual(expect.objectContaining(payload))
                })
                test('Can soft-delete', async () => {
                    const [b2cApp] = await createTestB2CApp(support)
                    expect(b2cApp).toHaveProperty('deletedAt', null)
                    const [deletedApp] = await updateTestB2CApp(support, b2cApp.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    expect(deletedApp).toBeDefined()
                    expect(deletedApp).toHaveProperty('deletedAt')
                    expect(deletedApp.deletedAt).not.toBeNull()
                })
            })
            test('User cannot', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2CApp(user, app.id, payload)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestB2CApp(anonymous, app.id, payload)
                })
            })
        })
        describe('Delete', () => {
            let app
            beforeAll(async () => {
                [app] = await createTestB2CApp(admin)
            })
            test('Nobody can', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2CApp.delete(admin, app.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2CApp.delete(support, app.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2CApp.delete(user, app.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2CApp.delete(anonymous, app.id)
                })
            })
        })
    })
    describe('Validations', () => {
        describe('colorSchema field', () => {
            const correctColors = [['#333'], ['#AcB'], ['#fff'], ['#AAA'], ['#f1F2f3']]
            const incorrectColors = [['fff'], ['#GGG'], ['#1215G2']]
            let admin
            beforeAll(async () => {
                admin = await makeLoggedInAdminClient()
            })
            describe('Should pass with correct colors', () => {
                test.each(correctColors)('%p', async (color) => {
                    const payload = { colorSchema: { main: color, secondary: color } }
                    const [app] = await createTestB2CApp(admin, payload)
                    expect(app).toBeDefined()
                    expect(app).toEqual(expect.objectContaining(payload))
                })
            })
            describe('Should fail with incorrect colors', () => {
                test.each(incorrectColors)('%p', async (color) => {
                    await expectToThrowValidationFailureError(async () => {
                        await createTestB2CApp(admin, {
                            colorSchema: { main: color, secondary: color },
                        })
                    }, 'colorSchema field validation error')
                })
            })
        })
        describe('additionalDomains field', () => {
            test('should accept array of URLs', async () => {
                const payload = {
                    additionalDomains: [
                        'https://api.my-domain.com',
                        'https://cdn.example.com',
                    ],
                }
                const [app] = await createTestB2CApp(support, payload)
                expect(app).toBeDefined()
                expect(app.additionalDomains).toEqual(payload.additionalDomains)
            })

            describe('should reject invalid URLs', () => {
                const invalidUrls = [
                    // Non-URLs (strings)
                    'not-a-url',
                    'another-string',
                    'plain-text',
                    
                    // Invalid protocols
                    'javascript:alert(1)',
                    'ftp://files.example.com',
                    'data:text/plain;base64,SGVsbG8=',
                    'mailto:user@example.com',
                    
                    // HTTP URLs (not HTTPS)
                    'http://example.com',
                    'http://api.example.com/path',
                    'http://localhost:3000',
                    
                    // Malformed URLs
                    'https://',
                    'https:///',
                    '://example.com',
                    'example.com',
                ]

                test.each(invalidUrls)('should reject: %p', async (invalidUrl) => {
                    await expectToThrowGQLError(async () => {
                        await createTestB2CApp(support, {
                            additionalDomains: [invalidUrl],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'INVALID_MINIAPP_DOMAINS',
                        message: '"additionalDomains" field validation error. JSON was not in the correct format',
                    })
                })
            })

            test('should accept empty array', async () => {
                const payload = { additionalDomains: [] }
                const [app] = await createTestB2CApp(support, payload)
                expect(app).toBeDefined()
                expect(app.additionalDomains).toEqual([])
            })
        })
    })
    describe('Resolvers', () => {
        describe('domains field', () => {
            test('should initially return empty mapping', async () => {
                const [app] = await createTestB2CApp(support)
                const appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.domains).toEqual({ mapping: [] })
            })

            test('should show correct resolution order', async () => {
                // Step 1: Create app with empty domains
                const [app] = await createTestB2CApp(support)
                let appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(0)

                // Step 2: Add OIDC client with redirect URIs - expect indexes 2-3 to appear
                const [oidcClient, { payload }] = await createTestOidcClient(support)
                await updateTestB2CApp(support, app.id, {
                    oidcClient: { connect: { id: oidcClient.id } },
                })
                await updateTestOidcClient(support, oidcClient.id, {
                    payload: {
                        ...payload,
                        redirect_uris: ['https://app1.example.com/oidc/callback', 'https://app2.example.com/api/oidc/callback'],
                    },
                })
                appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(2)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://app2.example.com', to: expectedAppDomain(app.id, 3) },
                ]))

                // Step 3: Add additional domains - expect index 4-5 to appear
                await updateTestB2CApp(support, app.id, {
                    additionalDomains: ['https://cdn.example.com', 'https://api.example.com'],
                })
                appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(4)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://app2.example.com', to: expectedAppDomain(app.id, 3) },
                    { from: 'https://cdn.example.com', to: expectedAppDomain(app.id, 4) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 5) },
                ]))

                // Step 4: Add appUrl - expect index 1 to appear
                await updateTestB2CApp(support, app.id, {
                    appUrl: 'https://main.example.com/app',
                })
                appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(5)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://main.example.com', to: expectedAppDomain(app.id, 1) },
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://app2.example.com', to: expectedAppDomain(app.id, 3) },
                    { from: 'https://cdn.example.com', to: expectedAppDomain(app.id, 4) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 5) },
                ]))

                // Step 5: Remove one redirect URI - expect additional domains to shift to 3-4
                await updateTestOidcClient(support, oidcClient.id, {
                    payload: {
                        ...payload,
                        redirect_uris: ['https://app1.example.com/callback'],
                    },
                })
                appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(4)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://main.example.com', to: expectedAppDomain(app.id, 1) },
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://cdn.example.com', to: expectedAppDomain(app.id, 3) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 4) },
                ]))

                // Step 6: Change appUrl to same domain as remaining redirect_uri - expect index 1 to disappear
                await updateTestB2CApp(support, app.id, {
                    appUrl: 'https://app1.example.com/main',
                })
                appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(3)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://cdn.example.com', to: expectedAppDomain(app.id, 3) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 4) },
                ]))

                // Step 7: Change one additional domain to same as redirect uri - expect remaining to take its place
                await updateTestB2CApp(support, app.id, {
                    additionalDomains: ['https://app1.example.com', 'https://api.example.com'],
                })
                appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(2)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://app1.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://api.example.com', to: expectedAppDomain(app.id, 3) },
                ]))
            })

            test('should handle duplicate domains correctly', async () => {
                const [oidcClient] = await createTestOidcClient(support)
                await updateTestOidcClient(support, oidcClient.id, {
                    payload: {
                        ...oidcClient.payload,
                        redirect_uris: ['https://same.example.com/callback1', 'https://same.example.com/callback2'],
                    },
                })

                const [app] = await createTestB2CApp(support, {
                    appUrl: 'https://same.example.com/app',
                    additionalDomains: ['https://same.example.com', 'https://different.example.com'],
                    oidcClient: { connect: { id: oidcClient.id } },
                })

                const appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.domains.mapping).toHaveLength(2)
                expect(appData.domains.mapping).toEqual(expect.arrayContaining([
                    { from: 'https://same.example.com', to: expectedAppDomain(app.id, 2) },
                    { from: 'https://different.example.com', to: expectedAppDomain(app.id, 3) },
                ]))
            })
        })

        describe('subscriptionPlans field', () => {
            test('returns empty array when app is not in any plan', async () => {
                const [app] = await createTestB2CApp(support)
                const appData = await B2CApp.getOne(support, { id: app.id })
                expect(Array.isArray(appData.subscriptionPlans)).toBe(true)
                expect(appData.subscriptionPlans).toHaveLength(0)
            })

            test('returns plan object when app is in active plan', async () => {
                const [app] = await createTestB2CApp(support)
                const [plan] = await createTestSubscriptionPlan(admin, {
                    name: 'Test Plan',
                    organizationType: MANAGING_COMPANY_TYPE,
                    isHidden: false,
                    enabledB2CApps: [app.id],
                })

                const appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.subscriptionPlans).toHaveLength(1)
                expect(appData.subscriptionPlans[0].id).toBe(plan.id)
                expect(appData.subscriptionPlans[0].name).toBe('Test Plan')
                expect(appData.subscriptionPlans[0].organizationType).toBe(MANAGING_COMPANY_TYPE)
            })

            test('returns empty array when app is only in hidden plan', async () => {
                const [app] = await createTestB2CApp(support)
                await createTestSubscriptionPlan(admin, {
                    name: 'Hidden Plan',
                    organizationType: MANAGING_COMPANY_TYPE,
                    isHidden: true,
                    enabledB2CApps: [app.id],
                })

                const appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.subscriptionPlans).toEqual([])
            })

            test('returns only active plans when app is in multiple plans', async () => {
                const [app] = await createTestB2CApp(support)
                await createTestSubscriptionPlan(admin, {
                    name: 'Hidden Plan',
                    organizationType: MANAGING_COMPANY_TYPE,
                    isHidden: true,
                    enabledB2CApps: [app.id],
                })
                const [activePlan] = await createTestSubscriptionPlan(admin, {
                    name: 'Active Plan',
                    organizationType: MANAGING_COMPANY_TYPE,
                    isHidden: false,
                    enabledB2CApps: [app.id],
                })

                const appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.subscriptionPlans).toHaveLength(1)
                expect(appData.subscriptionPlans[0].id).toBe(activePlan.id)
            })

            test('returns empty array when app is in deleted plan', async () => {
                const [app] = await createTestB2CApp(support)
                const [plan] = await createTestSubscriptionPlan(admin, {
                    name: 'Deleted Plan',
                    organizationType: MANAGING_COMPANY_TYPE,
                    isHidden: false,
                    enabledB2CApps: [app.id],
                })
                
                await SubscriptionPlan.softDelete(admin, plan.id)

                const appData = await B2CApp.getOne(support, { id: app.id })
                expect(appData.subscriptionPlans).toEqual([])
            })
        })
    })
})
