/**
 * Generated by `createservice miniapp.SendB2CAppPushMessageService --type mutations`
 */
const get = require('lodash/get')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT, FORBIDDEN } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { WRONG_FORMAT, DV_VERSION_MISMATCH } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/miniapp/access/SendB2CAppPushMessageService')
const {
    USER_NOT_FOUND_ERROR, RESIDENT_NOT_FOUND_ERROR,
    APP_NOT_FOUND_ERROR, APP_BLACK_LIST_ERROR,
    DEFAULT_NOTIFICATION_WINDOW_MAX_COUNT,
    DEFAULT_NOTIFICATION_WINDOW_DURATION_IN_SECONDS,
} = require('@condo/domains/miniapp/constants')
const { AppMessageSetting } = require('@condo/domains/miniapp/utils/serverSchema')
const { B2CApp } = require('@condo/domains/miniapp/utils/serverSchema')
const {
    MESSAGE_META,
    VOIP_INCOMING_CALL_MESSAGE_TYPE,
    CANCELED_CALL_MESSAGE_PUSH_TYPE,
    B2C_APP_MESSAGE_PUSH_TYPE,
} = require('@condo/domains/notification/constants/constants')
const { sendMessage } = require('@condo/domains/notification/utils/serverSchema')
const { Resident } = require('@condo/domains/resident/utils/serverSchema')
const { User } = require('@condo/domains/user/utils/serverSchema')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')

const CACHE_TTL = {
    DEFAULT: DEFAULT_NOTIFICATION_WINDOW_DURATION_IN_SECONDS,
    [VOIP_INCOMING_CALL_MESSAGE_TYPE]: 2,
    [CANCELED_CALL_MESSAGE_PUSH_TYPE]: 2,
    [B2C_APP_MESSAGE_PUSH_TYPE]: 3600,
}

const ALLOWED_PUSH_TYPES = [
    VOIP_INCOMING_CALL_MESSAGE_TYPE,
    CANCELED_CALL_MESSAGE_PUSH_TYPE,
    B2C_APP_MESSAGE_PUSH_TYPE,
]

/**
 * If debug app is set and debug app settings are configured, then user can send push messages without creating B2CApp first.
 * This is useful for testing and development, but it should be turned off on production
 */
const DEBUG_APP_ID = conf.MINIAPP_PUSH_MESSAGE_DEBUG_APP_ID
const DEBUG_APP_ENABLED = !!DEBUG_APP_ID
const DEBUG_APP_SETTINGS = DEBUG_APP_ENABLED ? Object.freeze(JSON.parse(conf.MINIAPP_PUSH_MESSAGE_DEBUG_APP_SETTINGS)) : {}

//TODO(Kekmus) Better to use existing redisGuard if possible
const redisGuard = new RedisGuard()

const SERVICE_NAME = 'sendB2CAppPushMessage'
const ERRORS = {
    USER_NOT_FOUND: {
        mutation: SERVICE_NAME,
        code: BAD_USER_INPUT,
        type: USER_NOT_FOUND_ERROR,
        message: 'Unable to find user by provided id.',
        messageForUser: `api.miniapp.${SERVICE_NAME}.USER_NOT_FOUND`,
    },
    RESIDENT_NOT_FOUND: {
        mutation: SERVICE_NAME,
        code: BAD_USER_INPUT,
        type: RESIDENT_NOT_FOUND_ERROR,
        message: 'Unable to find resident by provided id.',
        messageForUser: `api.miniapp.${SERVICE_NAME}.RESIDENT_NOT_FOUND`,
    },
    APP_NOT_FOUND: {
        mutation: SERVICE_NAME,
        code: BAD_USER_INPUT,
        type: APP_NOT_FOUND_ERROR,
        message: 'Unable to find app by provided id.',
        messageForUser: `api.miniapp.${SERVICE_NAME}.APP_NOT_FOUND`,
    },
    DV_VERSION_MISMATCH: {
        mutation: SERVICE_NAME,
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
        messageForUser: `api.miniapp.${SERVICE_NAME}.DV_VERSION_MISMATCH`,
    },
    WRONG_SENDER_FORMAT: {
        mutation: SERVICE_NAME,
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value. {details}',
        correctExample: '{ "dv": 1, "fingerprint": "uniq-device-or-container-id" }',
        messageInterpolation: { details: 'Please, check the example for details' },
        messageForUser: `api.miniapp.${SERVICE_NAME}.WRONG_SENDER_FORMAT`,
    },
    APP_IN_BLACK_LIST: {
        mutation: SERVICE_NAME,
        code: FORBIDDEN,
        type: APP_BLACK_LIST_ERROR,
        message: 'Could not send notifications for the blacklisted app',
        messageForUser: `api.miniapp.${SERVICE_NAME}.APP_IN_BLACK_LIST`,
    },
}

const SendB2CAppPushMessageService = new GQLCustomSchema('SendB2CAppPushMessageService', {
    types: [
        {
            access: true,
            type: `enum SendB2CAppPushMessageType { ${ALLOWED_PUSH_TYPES.join(' ')} }`,
        },
        {
            // TODO(YEgorLu): I couldn't find out about every field. Need to get to the people and add documentation for every undocumented field.
            access: true,
            type: 'input SendB2CAppPushMessageData { ' +
            '"""' +
            'Text that will appear in the body of notification' +
            '"""' +
            'body: String!, ' + 
            '"""' +
            'Text that will appear in the title of notification' +
            '"""' +
            'title: String, ' + 
            'B2CAppContext: String, ' +
            '"""' +
            'Unique value for each call session between panel and resident (means same for different devices also). ' +
            'Must be provided for correct work with multiple devices that use same voip call.' +
            'F.e. to cancel calls with CANCELED_CALL_MESSAGE_PUSH messages' +
            '"""' +
            'callId: String, ' + 
            '"""' +
            '"id" field of "Message" with type VOIP_INCOMING_CALL_MESSAGE (message which was sent with this mutation for call start).' +
            'Used to cancel calls with CANCELED_CALL_MESSAGE_PUSH messages' +
            '"""' +
            'voipIncomingCallId: String @deprecated(reason: "This field will be removed, you should use both this field and \\"callId\\" before that"), ' +
            '"""' +
            'If "sip" was passed, mobile device will try to start native call. Info about other values will be added later' +
            '"""' +
            'voipType: String, ' + 
            '"""' +
            'Address of sip server, which device should connect to' +
            '"""' +
            'voipAddress: String, ' + 
            '"""' +
            'Login for connection to sip server' +
            '"""' +
            'voipLogin: String, ' + 
            '"""' +
            'Password for connection to sip server' +
            '"""' +
            'voipPassword: String, ' + 
            'voipDtfmCommand: String, ' + 
            'stun: String, ' + 
            'codec: String ' +
            '}',
        },
        {
            access: true,
            type: 'input SendB2CAppPushMessageInput { ' +
                    'dv: Int!, ' +
                    'sender: SenderFieldInput!, ' +
                    'app: B2CAppWhereUniqueInput!, ' +
                    '"""' +
                    'Should be same user, as the one who is calling mutation' +
                    '"""' +
                    'user: UserWhereUniqueInput!, ' +
                    '"""' +
                    'Resident should be for same user, which was passed in "user" field' +
                    '"""' +
                    'resident: ResidentWhereUniqueInput!, ' +
                    'type: SendB2CAppPushMessageType!, ' +
                    'data: SendB2CAppPushMessageData! ' +
                '}',
        },
        {
            access: true,
            type: 'type SendB2CAppPushMessageOutput { ' + 
                  '"""' +
                  'Id of a created Message' +
                  '"""' +
                  'id: String!, ' +
                  '"""' +
                  'Status of a created Message' +
                  '"""' + 
                  'status: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canSendB2CAppPushMessage,
            schema: 'sendB2CAppPushMessage(data: SendB2CAppPushMessageInput!): SendB2CAppPushMessageOutput',
            resolver: async (parent, args, context) => {
                const { data: argsData } = args
                const { dv, sender, app, user, resident, type, uniqKey, data: { title, body } } = argsData

                checkDvAndSender(argsData, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                const userExisted = await User.getOne(context, { id: user.id, deletedAt: null })

                if (!userExisted) throw new GQLError(ERRORS.USER_NOT_FOUND, context)

                const b2cAppId = app.id
                const residentId = resident.id

                /** resident must belong to the user */
                const residentWhere = {
                    id: residentId,
                    user: { id: user.id },
                    deletedAt: null,
                }
                const residentExisted = await Resident.getOne(context, residentWhere)

                if (!residentExisted) throw new GQLError(ERRORS.RESIDENT_NOT_FOUND, context)

                let B2CAppName = 'Debug app'
                let appSettings = {}

                // App requested to send notification to is not a DEBUG one
                if (!DEBUG_APP_ENABLED || b2cAppId !== DEBUG_APP_ID) {
                    const appExisted = await B2CApp.getOne(context, { id: b2cAppId, deletedAt: null }, 'id name')

                    if (!appExisted) throw new GQLError(ERRORS.APP_NOT_FOUND, context)

                    const where = { b2cApp: { id: b2cAppId }, type, deletedAt: null }
                    appSettings = await AppMessageSetting.getOne(context, where, 'notificationWindowSize numberOfNotificationInWindow')

                    B2CAppName = appExisted.name
                }

                else {
                    appSettings = { ...DEBUG_APP_SETTINGS }
                }

                const searchKey = `${type}-${b2cAppId}-${user.id}`
                const ttl = CACHE_TTL[type] || CACHE_TTL['DEFAULT']

                await redisGuard.checkCustomLimitCounters(
                    `${SERVICE_NAME}-${searchKey}`,
                    get(appSettings, 'notificationWindowSize') ?? ttl,
                    get(appSettings, 'numberOfNotificationInWindow') ?? DEFAULT_NOTIFICATION_WINDOW_MAX_COUNT,
                    context,
                )

                const requiredMetaData = get(MESSAGE_META[type], 'data', {})
                const metaData = Object.fromEntries(
                    Object.keys(requiredMetaData).map((key) => [key, argsData.data[key]])
                )
                Object.assign(metaData, { B2CAppName, B2CAppId: b2cAppId, residentId })


                const messageAttrs = {
                    uniqKey,
                    sender,
                    type,
                    to: { user: { id: user.id } },
                    meta: {
                        dv,
                        title,
                        body,
                        data: metaData,
                    },
                }

                const sendingResult = await sendMessage(context, messageAttrs)

                return {
                    id: sendingResult.id,
                    status: sendingResult.status,
                }
            },
        },
    ],
    
})

module.exports = {
    SendB2CAppPushMessageService,
    ERRORS,
    CACHE_TTL,
}
