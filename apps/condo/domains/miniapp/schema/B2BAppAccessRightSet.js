/**
 * Generated by `createschema miniapp.B2BAppAccessRightSet 'app:Relationship:B2BApp:CASCADE;'`
 */

const get = require('lodash/get')
const has = require('lodash/has')
const isEmpty = require('lodash/isEmpty')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, find } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/miniapp/access/B2BAppAccessRightSet')
const { ACCESS_RIGHT_SET_TOO_MANY_OF_TYPE, NAME_REQUIRED } = require('@condo/domains/miniapp/constants')
const {
    ACCESS_TOKEN_SCOPE_TYPES, ACCESS_TOKEN_MINIAPP_SCOPE_TYPE, ACCESS_TOKEN_MAX_ITEMS_FOR_SCOPE,
    ACCESS_RIGHT_SET_MINIAPP_SCOPE_RIGHT_SET_REQUIRED, ACCESS_RIGHT_SET_TOO_MANY_PERMISSIONS,
} = require('@condo/domains/miniapp/constants')
const { B2B_APP_SERVICE_USER_ACCESS_AVAILABLE_SCHEMAS } = require('@condo/domains/miniapp/utils/b2bAppServiceUserAccess/config')
const { generatePermissionFields } = require('@condo/domains/miniapp/utils/b2bAppServiceUserAccess/schema.utils')
const { B2BAppAccessRightSet: B2BAppAccessRightSetAPI } = require('@condo/domains/miniapp/utils/serverSchema')

const PERMISSION_FIELDS_KEYS = Object.keys(generatePermissionFields({ config: B2B_APP_SERVICE_USER_ACCESS_AVAILABLE_SCHEMAS }))


/** Get fields, which set to false in rightSet1 and false in rightSet2 */
function getRightsDifference (rightSet1, rightSet2) {
    const diff = []
    for (const permissionField of PERMISSION_FIELDS_KEYS)
        if (!rightSet1[permissionField] && rightSet2[permissionField]) {
            diff.push(permissionField)
        }
    return diff
}

const ERRORS = {
    TOO_MANY_ITEMS_OF_TYPE: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_TOO_MANY_OF_TYPE,
        message: 'Too many items of type "{type}". Maximum is "{maximum}"',
    },
    NAME_REQUIRED: {
        code: BAD_USER_INPUT,
        type: NAME_REQUIRED,
        message: 'Name is required',
    },
    MINIAPP_SCOPE_RIGHT_SET_REQUIRED: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_MINIAPP_SCOPE_RIGHT_SET_REQUIRED,
        message: 'You need to have "miniapp" type right before other types',
    },
    TOO_MANY_PERMISSIONS: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_TOO_MANY_PERMISSIONS,
        message: 'You trying to give to right set more permissions, than "miniapp" right set has',
    },
}

const B2BAppAccessRightSet = new GQLListSchema('B2BAppAccessRightSet', {
    schemaDoc: 'A set of access rights for a service user integrated with your B2BApp' +
        ' (exist B2BAppAccessRight with links to your service user and your B2BApp).' +
        '\nThis set of access right will be used to check your service user access to schemas that are linked to' +
        ' "Organization" schema (such as "Organization", "Ticket" and others).' +
        '\nThese accesses will only apply to entities that belong to organizations that connected your app.' +
        '\nThis schema contains fields corresponding to "can<Action><Scheme name in plural>" format' +
        ' (e.g. "canReadOrganizations", "canManageContacts" and etc.)' +
        '\nNOTE: Some schemas have links with other models.' +
        ' Therefore, it is necessary to take this into account when specifying the necessary rights.' +
        '\nFor example, to create a contact, in addition to having access to managing properties, you also need to have access to read organization',

    resolveLabel (item) {
        // do not let empty "name" break things in admin ui
        return item.id
    },

    fields: {

        app: {
            schemaDoc: 'Link to B2BApp',
            type: 'Relationship',
            ref: 'B2BApp',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: {
                update: false,
            },
        },

        name: {
            schemaDoc: 'Name for right set to distinguish it',
            type: 'Text',
            isRequired: false,
            hooks: {
                resolveInput ({ operation, existingItem, resolvedData, fieldPath, originalInput, context }) {
                    const nextItem = {
                        ...(existingItem || {}),
                        ...resolvedData,
                    }
                    const name = get(nextItem, fieldPath)
                    const type = get(nextItem, 'type')
                    if (operation === 'create' && type === ACCESS_TOKEN_MINIAPP_SCOPE_TYPE && isEmpty(name)) {
                        return 'default'
                    }

                    return get(resolvedData, fieldPath)
                },
                validateInput ({ resolvedData, existingItem, context }) {
                    const nextItem = {
                        ...(existingItem || {}),
                        ...resolvedData,
                    }
                    const name = get(nextItem, 'name')
                    if (isEmpty(name)) {
                        throw new GQLError(ERRORS.NAME_REQUIRED, context)
                    }
                },
            },
        },

        type: {
            schemaDoc: 'Scope type of right set',
            type: 'Select',
            options: ACCESS_TOKEN_SCOPE_TYPES,
            access: {
                update: false,
            },
            hooks: {
                // TODO(YEgorLu): migrate all existing rightSets to have type: 'miniapp', then make field required and remove this hook
                resolveInput ({ operation, existingItem, fieldPath, resolvedData, originalInput }) {
                    if (operation === 'update' && !get(existingItem, fieldPath)) {
                        return ACCESS_TOKEN_MINIAPP_SCOPE_TYPE
                    }

                    if (operation === 'create' && !has(originalInput, fieldPath)) {
                        throw new GQLError()
                    }

                    return get(operation === 'create' ? resolvedData : existingItem, fieldPath)
                },
            },
        },

        ...generatePermissionFields({ config: B2B_APP_SERVICE_USER_ACCESS_AVAILABLE_SCHEMAS }),

    },
    hooks: {
        async validateInput ({ operation, resolvedData, existingItem, context }) {
            if (operation === 'create' && resolvedData.type !== ACCESS_TOKEN_MINIAPP_SCOPE_TYPE) {
                const rightSetsForApp = await find('B2BAppAccessRightSet', {
                    app: { id: resolvedData.app },
                    deletedAt: null,
                })
                
                const miniappRightSet = rightSetsForApp.find(set => set.type === ACCESS_TOKEN_MINIAPP_SCOPE_TYPE)
                if (!miniappRightSet) {
                    throw new GQLError(ERRORS.MINIAPP_SCOPE_RIGHT_SET_REQUIRED, context)
                }
                const sameTypeRightSets = rightSetsForApp.filter(set => set.type === resolvedData.type)
                if (sameTypeRightSets.length >= ACCESS_TOKEN_MAX_ITEMS_FOR_SCOPE[resolvedData.type]) {
                    throw new GQLError({
                        ...ERRORS.TOO_MANY_ITEMS_OF_TYPE,
                        messageInterpolation: { type: resolvedData.type, maximum: ACCESS_TOKEN_MAX_ITEMS_FOR_SCOPE[resolvedData.type] },
                    }, context)
                }

                if (resolvedData.type !== ACCESS_TOKEN_MINIAPP_SCOPE_TYPE) {
                    const permissionDiff = getRightsDifference(miniappRightSet, resolvedData)
                    if (permissionDiff.length) {
                        throw new GQLError(ERRORS.TOO_MANY_PERMISSIONS, context)
                    }
                }
            }
        },
        async afterChange ({ operation, updatedItem, context }) {
            if (operation !== 'update' || updatedItem.type !== ACCESS_TOKEN_MINIAPP_SCOPE_TYPE) return
            const otherTypeRightSets = await find('B2BAppAccessRightSet', {
                app: { id: updatedItem.app },
                type_not: ACCESS_TOKEN_MINIAPP_SCOPE_TYPE,
                deletedAt: null,
            })
            for (const rightSet of otherTypeRightSets) {
                const diffPermissions = getRightsDifference(updatedItem, rightSet)
                if (diffPermissions.length) {
                    const updateInput = Object.fromEntries(diffPermissions.map(permissionField => [permissionField, false]))
                    await B2BAppAccessRightSetAPI.update(context, updateInput)
                }
            }
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['app'],
                condition: `Q(deletedAt__isnull=True) & Q(type='${ACCESS_TOKEN_MINIAPP_SCOPE_TYPE}')`,
                name: 'b2b_app_access_right_set_unique_app',
            },
        ],
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadB2BAppAccessRightSets,
        create: access.canManageB2BAppAccessRightSets,
        update: access.canManageB2BAppAccessRightSets,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAppAccessRightSet,
}
