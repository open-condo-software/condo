/**
 * Generated by `createschema miniapp.B2BAppAccessRightSet 'app:Relationship:B2BApp:CASCADE;'`
 */

const chunk = require('lodash/chunk')
const get = require('lodash/get')
const isEmpty = require('lodash/isEmpty')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, find } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/miniapp/access/B2BAppAccessRightSet')
const {
    ACCESS_RIGHT_SET_TOO_MANY_OF_TYPE, ACCESS_RIGHT_SET_NAME_REQUIRED, ACCESS_RIGHT_SET_SCOPED_TYPE,
    ACCESS_RIGHT_SET_TYPES, ACCESS_RIGHT_SET_GLOBAL_TYPE, ACCESS_RIGHT_SET_MAX_ITEMS_FOR_TYPE,
    ACCESS_RIGHT_SET_GLOBAL_RIGHT_SET_REQUIRED, ACCESS_RIGHT_SET_TOO_MANY_PERMISSIONS,
    ACCESS_TOKEN_UPDATE_MANY_CHUNK_SIZE,
} = require('@condo/domains/miniapp/constants')
const { B2B_PERMISSION_FIELDS } = require('@condo/domains/miniapp/schema/fields/b2bAccessRightSet')
const { getPermissionsDiff, getEnabledPermissions } = require('@condo/domains/miniapp/utils/permissions')
const { B2BAppAccessRightSet: B2BAppAccessRightSetAPI, B2BAccessToken } = require('@condo/domains/miniapp/utils/serverSchema')



const ERRORS = {
    TOO_MANY_ITEMS_OF_TYPE: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_TOO_MANY_OF_TYPE,
        message: 'Too many items of type "{type}". Maximum is "{maximum}"',
    },
    NAME_REQUIRED: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_NAME_REQUIRED,
        message: 'Name is required',
    },
    GLOBAL_RIGHT_SET_REQUIRED: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_GLOBAL_RIGHT_SET_REQUIRED,
        message: 'You need to have "GLOBAL" type right before other types',
    },
    TOO_MANY_PERMISSIONS: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_TOO_MANY_PERMISSIONS,
        message: 'You trying to give to right set more permissions, than "GLOBAL" right set has',
    },
}

const B2BAppAccessRightSet = new GQLListSchema('B2BAppAccessRightSet', {
    schemaDoc: 'A set of access rights for a service user integrated with your B2BApp' +
        ' (exist B2BAppAccessRight with links to your service user and your B2BApp).' +
        '\nThis set of access right will be used to check your service user access to schemas that are linked to' +
        ' "Organization" schema (such as "Organization", "Ticket" and others).' +
        '\nThese accesses will only apply to entities that belong to organizations that connected your app.' +
        '\nThis schema contains fields corresponding to "can<Action><Scheme name in plural>" format' +
        ' (e.g. "canReadOrganizations", "canManageContacts" and etc.)' +
        '\nNOTE: Some schemas have links with other models.' +
        ' Therefore, it is necessary to take this into account when specifying the necessary rights.' +
        '\nFor example, to create a contact, in addition to having access to managing properties, you also need to have access to read organization',

    labelResolver (item) {
        // do not let empty "name" break things in admin ui
        return item.id
    },

    fields: {

        app: {
            schemaDoc: 'Link to B2BApp',
            type: 'Relationship',
            ref: 'B2BApp',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: {
                update: false,
            },
        },

        name: {
            schemaDoc: 'Name for right set to distinguish it',
            type: 'Text',
            isRequired: true,
            defaultValue: 'default',
            hooks: {
                resolveInput ({ existingItem, resolvedData }) {
                    const nextItem = {
                        ...existingItem,
                        ...resolvedData,
                    }
                    return get(nextItem, 'name', '').trim()
                },
                validateInput ({ resolvedData, existingItem, context }) {
                    const nextItem = {
                        ...existingItem,
                        ...resolvedData,
                    }
                    const name = get(nextItem, 'name', '')
                    if (isEmpty(name)) {
                        throw new GQLError(ERRORS.NAME_REQUIRED, context)
                    }
                },
            },
        },

        type: {
            schemaDoc: 'Scope type of right set',
            type: 'Select',
            options: ACCESS_RIGHT_SET_TYPES,
            defaultValue: ACCESS_RIGHT_SET_GLOBAL_TYPE,
            access: {
                update: false,
            },
        },

        ...B2B_PERMISSION_FIELDS,

    },
    hooks: {
        async validateInput ({ resolvedData, existingItem, context }) {
            const nextItem = {
                ...existingItem,
                ...resolvedData,
            }
            if (nextItem.type !== ACCESS_RIGHT_SET_GLOBAL_TYPE) {
                const rightSetsForApp = await find('B2BAppAccessRightSet', {
                    app: { id: nextItem.app },
                    deletedAt: null,
                    type_in: [ACCESS_RIGHT_SET_GLOBAL_TYPE, nextItem.type],
                })
                
                const globalRightSet = rightSetsForApp.find(set => set.type === ACCESS_RIGHT_SET_GLOBAL_TYPE)
                if (!globalRightSet && !nextItem['deletedAt']) {
                    throw new GQLError(ERRORS.GLOBAL_RIGHT_SET_REQUIRED, context)
                }
                const sameTypeRightSets = rightSetsForApp.filter(set => set.type === nextItem.type)
                if (sameTypeRightSets.length >= ACCESS_RIGHT_SET_MAX_ITEMS_FOR_TYPE[nextItem.type] && !nextItem['deletedAt']) {
                    throw new GQLError({
                        ...ERRORS.TOO_MANY_ITEMS_OF_TYPE,
                        messageInterpolation: { type: nextItem.type, maximum: ACCESS_RIGHT_SET_MAX_ITEMS_FOR_TYPE[nextItem.type] },
                    }, context)
                }
                
                const permissionDiff = getPermissionsDiff(globalRightSet, nextItem)
                const enabledPermissionsDiff = getEnabledPermissions(permissionDiff)
                if (Object.keys(enabledPermissionsDiff).length) {
                    throw new GQLError(ERRORS.TOO_MANY_PERMISSIONS, context)
                }
            }
        },
        async beforeChange ({ operation, existingItem, resolvedData, context }) {
            const nextItem = {
                ...existingItem,
                ...resolvedData,
            }
            if (operation === 'update' && nextItem.type === ACCESS_RIGHT_SET_GLOBAL_TYPE && nextItem.deletedAt) {
                const otherTypeRightSets = await find('B2BAppAccessRightSet', {
                    app: { id: nextItem.app },
                    type_not: ACCESS_RIGHT_SET_GLOBAL_TYPE,
                    deletedAt: null,
                })
                await B2BAppAccessRightSetAPI.softDeleteMany(context, otherTypeRightSets.map(set => set.id), 'id', {
                    dv: 1, sender: resolvedData.sender,
                })
            }
            if (operation === 'update' && nextItem.type === ACCESS_RIGHT_SET_SCOPED_TYPE && nextItem.deletedAt) {
                const accessTokens = await find('B2BAccessToken', {
                    rightSet: { id: nextItem.id },
                    deletedAt: null,
                })
                const tokenIdsChunks = chunk(accessTokens.map(token => token.id), ACCESS_TOKEN_UPDATE_MANY_CHUNK_SIZE)
                for (const tokenIdsChunk of tokenIdsChunks) {
                    await B2BAccessToken.softDeleteMany(context, tokenIdsChunk, 'id', {
                        dv: 1, sender: { dv: 1, fingerprint: nextItem.sender.fingerprint },
                    })
                }
            }
        },
        async afterChange ({ operation, updatedItem, context }) {
            if (operation === 'update' && updatedItem.type === ACCESS_RIGHT_SET_GLOBAL_TYPE && !updatedItem.deletedAt) {
                const otherTypeRightSets = await find('B2BAppAccessRightSet', {
                    app: { id: updatedItem.app },
                    type_not: ACCESS_RIGHT_SET_GLOBAL_TYPE,
                    deletedAt: null,
                })
                const updateInputs = []
                for (const rightSet of otherTypeRightSets) {
                    const dvSender = { dv: rightSet.dv, sender: updatedItem.sender }
                    const diffPermissions = getPermissionsDiff(updatedItem, rightSet)
                    const permissionsToDisable = getEnabledPermissions(diffPermissions)
                    const disabledPermissions = Object.fromEntries(Object.keys(permissionsToDisable).map((perm) => [perm, false]))
                    let updateInput = {}
                    if (Object.keys(disabledPermissions).length) {
                        updateInput.data = {
                            ...disabledPermissions,
                            ...dvSender,
                        }
                    }
                    if (updateInput.data) {
                        updateInput.id = rightSet.id
                        updateInputs.push(updateInput)
                    }
                }
                await B2BAppAccessRightSetAPI.updateMany(context, updateInputs, 'id')
            }

            if (operation === 'update' && updatedItem.type === ACCESS_RIGHT_SET_SCOPED_TYPE && !updatedItem.deletedAt) {
                const accessTokens = await find('B2BAccessToken', {
                    rightSet: { id: updatedItem.id },
                    deletedAt: null,
                })
                
                const updateInputs = accessTokens.map(token => ({ id: token.id, data: { dv: 1, sender: { dv: 1, fingerprint: updatedItem.sender.fingerprint } } }))
                // NOTE(YEgorLu): Update trigger is required to update sessions in B2BAccessToken afterChange hook
                for (const chunkUpdateInputs of chunk(updateInputs, ACCESS_TOKEN_UPDATE_MANY_CHUNK_SIZE))
                    await B2BAccessToken.updateMany(context, chunkUpdateInputs, 'id')
            }

        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['app'],
                condition: `Q(deletedAt__isnull=True) & Q(type='${ACCESS_RIGHT_SET_GLOBAL_TYPE}')`,
                name: 'b2b_app_access_right_set_unique_app',
            },
        ],
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadB2BAppAccessRightSets,
        create: access.canManageB2BAppAccessRightSets,
        update: access.canManageB2BAppAccessRightSets,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAppAccessRightSet,
}
