/**
 * Generated by `createschema miniapp.B2BAppAccessRightSet 'app:Relationship:B2BApp:CASCADE;'`
 */

const get = require('lodash/get')
const isEmpty = require('lodash/isEmpty')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, find } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/miniapp/access/B2BAppAccessRightSet')
const { ACCESS_RIGHT_SET_TOO_MANY_OF_TYPE, NAME_REQUIRED, ACCESS_RIGHT_SET_TOKEN_SCOPE_TYPE } = require('@condo/domains/miniapp/constants')
const {
    ACCESS_RIGHT_SET_SCOPE_TYPES, ACCESS_RIGHT_SET_MINIAPP_SCOPE_TYPE, ACCESS_RIGHT_SET_MAX_ITEMS_FOR_SCOPE,
    ACCESS_RIGHT_SET_MINIAPP_SCOPE_RIGHT_SET_REQUIRED, ACCESS_RIGHT_SET_TOO_MANY_PERMISSIONS,
} = require('@condo/domains/miniapp/constants')
const { B2B_APP_SERVICE_USER_ACCESS_AVAILABLE_SCHEMAS } = require('@condo/domains/miniapp/utils/b2bAppServiceUserAccess/config')
const { generatePermissionFields } = require('@condo/domains/miniapp/utils/b2bAppServiceUserAccess/schema.utils')
const { getPermissionsDiff, getEnabledPermissions } = require('@condo/domains/miniapp/utils/permissions')
const { B2BAppAccessRightSet: B2BAppAccessRightSetAPI, B2BAccessToken } = require('@condo/domains/miniapp/utils/serverSchema')



const ERRORS = {
    TOO_MANY_ITEMS_OF_TYPE: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_TOO_MANY_OF_TYPE,
        message: 'Too many items of type "{type}". Maximum is "{maximum}"',
    },
    NAME_REQUIRED: {
        code: BAD_USER_INPUT,
        type: NAME_REQUIRED,
        message: 'Name is required',
    },
    MINIAPP_SCOPE_RIGHT_SET_REQUIRED: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_MINIAPP_SCOPE_RIGHT_SET_REQUIRED,
        message: 'You need to have "miniapp" type right before other types',
    },
    TOO_MANY_PERMISSIONS: {
        code: BAD_USER_INPUT,
        type: ACCESS_RIGHT_SET_TOO_MANY_PERMISSIONS,
        message: 'You trying to give to right set more permissions, than "miniapp" right set has',
    },
}

const B2BAppAccessRightSet = new GQLListSchema('B2BAppAccessRightSet', {
    schemaDoc: 'A set of access rights for a service user integrated with your B2BApp' +
        ' (exist B2BAppAccessRight with links to your service user and your B2BApp).' +
        '\nThis set of access right will be used to check your service user access to schemas that are linked to' +
        ' "Organization" schema (such as "Organization", "Ticket" and others).' +
        '\nThese accesses will only apply to entities that belong to organizations that connected your app.' +
        '\nThis schema contains fields corresponding to "can<Action><Scheme name in plural>" format' +
        ' (e.g. "canReadOrganizations", "canManageContacts" and etc.)' +
        '\nNOTE: Some schemas have links with other models.' +
        ' Therefore, it is necessary to take this into account when specifying the necessary rights.' +
        '\nFor example, to create a contact, in addition to having access to managing properties, you also need to have access to read organization',

    resolveLabel (item) {
        // do not let empty "name" break things in admin ui
        return item.id
    },

    fields: {

        app: {
            schemaDoc: 'Link to B2BApp',
            type: 'Relationship',
            ref: 'B2BApp',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: {
                update: false,
            },
        },

        name: {
            schemaDoc: 'Name for right set to distinguish it',
            type: 'Text',
            isRequired: true,
            defaultValue: 'default',
            hooks: {
                validateInput ({ resolvedData, existingItem, context }) {
                    const nextItem = {
                        ...(existingItem || {}),
                        ...resolvedData,
                    }
                    const name = get(nextItem, 'name')
                    if (isEmpty(name)) {
                        throw new GQLError(ERRORS.NAME_REQUIRED, context)
                    }
                },
            },
        },

        type: {
            schemaDoc: 'Scope type of right set',
            type: 'Select',
            options: ACCESS_RIGHT_SET_SCOPE_TYPES,
            defaultValue: ACCESS_RIGHT_SET_MINIAPP_SCOPE_TYPE,
            access: {
                update: false,
            },
        },

        ...generatePermissionFields({ config: B2B_APP_SERVICE_USER_ACCESS_AVAILABLE_SCHEMAS }),

    },
    hooks: {
        async validateInput ({ resolvedData, existingItem, context }) {
            const nextItem = {
                ...(existingItem || {}),
                ...resolvedData,
            }
            if (nextItem.type !== ACCESS_RIGHT_SET_MINIAPP_SCOPE_TYPE) {
                const rightSetsForApp = await find('B2BAppAccessRightSet', {
                    app: { id: nextItem.app },
                    deletedAt: null,
                })
                
                const miniappRightSet = rightSetsForApp.find(set => set.type === ACCESS_RIGHT_SET_MINIAPP_SCOPE_TYPE)
                if (!miniappRightSet) {
                    throw new GQLError(ERRORS.MINIAPP_SCOPE_RIGHT_SET_REQUIRED, context)
                }
                const sameTypeRightSets = rightSetsForApp.filter(set => set.type === nextItem.type)
                if (sameTypeRightSets.length >= ACCESS_RIGHT_SET_MAX_ITEMS_FOR_SCOPE[nextItem.type]) {
                    throw new GQLError({
                        ...ERRORS.TOO_MANY_ITEMS_OF_TYPE,
                        messageInterpolation: { type: nextItem.type, maximum: ACCESS_RIGHT_SET_MAX_ITEMS_FOR_SCOPE[nextItem.type] },
                    }, context)
                }

                if (nextItem.type !== ACCESS_RIGHT_SET_MINIAPP_SCOPE_TYPE) {
                    const permissionDiff = getPermissionsDiff(miniappRightSet, nextItem)
                    const enabledPermissionsDiff = getEnabledPermissions(permissionDiff)
                    if (Object.keys(enabledPermissionsDiff).length) {
                        throw new GQLError(ERRORS.TOO_MANY_PERMISSIONS, context)
                    }
                }
            }
        },
        async afterChange ({ operation, updatedItem, context }) {
            if (operation === 'update' && updatedItem.type === ACCESS_RIGHT_SET_MINIAPP_SCOPE_TYPE) {
                const otherTypeRightSets = await find('B2BAppAccessRightSet', {
                    app: { id: updatedItem.app },
                    type_not: ACCESS_RIGHT_SET_MINIAPP_SCOPE_TYPE,
                    deletedAt: null,
                })
                for (const rightSet of otherTypeRightSets) {
                    const diffPermissions = getPermissionsDiff(updatedItem, rightSet)
                    const permissionsToDisable = getEnabledPermissions(diffPermissions)
                    const disabledPermissions = Object.fromEntries(Object.keys(permissionsToDisable).map((perm) => [perm, false]))
                    if (Object.keys(disabledPermissions).length) {
                        await B2BAppAccessRightSetAPI.update(context, rightSet.id, {
                            dv: rightSet.dv,
                            sender: updatedItem.sender,
                            ...disabledPermissions,
                        }, 'id')
                    }
                }
            }

            if (operation === 'update' && updatedItem.type === ACCESS_RIGHT_SET_TOKEN_SCOPE_TYPE) {
                const accessTokens = await find('B2BAccessToken', {
                    rightSet: { id: updatedItem.id },
                    deletedAt: null,
                })
                for (const accessToken of accessTokens) {
                    await B2BAccessToken.update(context, accessToken.id, {
                        dv: 1,
                        sender: updatedItem.sender,
                    }, 'id')
                }
            }
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['app'],
                condition: `Q(deletedAt__isnull=True) & Q(type='${ACCESS_RIGHT_SET_MINIAPP_SCOPE_TYPE}')`,
                name: 'b2b_app_access_right_set_unique_app',
            },
        ],
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadB2BAppAccessRightSets,
        create: access.canManageB2BAppAccessRightSets,
        update: access.canManageB2BAppAccessRightSets,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAppAccessRightSet,
}
