/**
 * Generated by `createschema miniapp.AppMessageSetting 'app?:Relationship:B2CApp:CASCADE; blockReason:Text; blockedNotificationTypes:Text; throttlingTime:Integer;'`
 */

const {
    makeLoggedInAdminClient, makeClient, expectValuesOfCommonFields,
    expectToThrowUniqueConstraintViolationError, expectToThrowGQLError, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { AppMessageSetting, createTestAppMessageSetting, updateTestAppMessageSetting,
    createTestB2CApp, createTestB2BApp, createTestB2BAppContext } = require('@condo/domains/miniapp/utils/testSchema')
const { B2C_APP_MESSAGE_PUSH_TYPE, B2B_APP_MESSAGE_PUSH_TYPE, VOIP_INCOMING_CALL_MESSAGE_TYPE, TICKET_CREATED_TYPE } = require('@condo/domains/notification/constants/constants')
const { registerNewOrganization, createTestOrganizationEmployeeRole, inviteNewOrganizationEmployee, acceptOrRejectOrganizationInviteById } = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

const { ERRORS } = require('./AppMessageSetting')


describe('AppMessageSetting', () => {
    let admin, support, anonymous, user, b2cApp, b2bApp

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()
    })

    beforeEach(async () => {
        const [testB2cApp] = await createTestB2CApp(support)
        b2cApp = testB2cApp
        const [testB2bApp] = await createTestB2BApp(support)
        b2bApp = testB2bApp
    })


    describe('B2CApp', () => {
        describe('Access', () => {
            describe('Admin', () => {
                test('can create', async () => {
                    const notificationWindowSize = 30000
                    const numberOfNotificationInWindow = 5
                    const [obj, attrs] = await createTestAppMessageSetting(admin, {
                        notificationWindowSize,
                        numberOfNotificationInWindow,
                        b2cApp,
                    })

                    expectValuesOfCommonFields(obj, attrs, admin)
                    expect(obj.type).toEqual(B2C_APP_MESSAGE_PUSH_TYPE)
                    expect(obj.notificationWindowSize).toEqual(notificationWindowSize)
                    expect(obj.numberOfNotificationInWindow).toEqual(numberOfNotificationInWindow)
                })

                test('can update', async () => {
                    const [objCreated] = await createTestAppMessageSetting(admin, {
                        b2cApp,
                    })

                    const [obj, attrs] = await updateTestAppMessageSetting(admin, objCreated.id)

                    expect(obj.dv).toEqual(1)
                    expect(obj.sender).toEqual(attrs.sender)
                    expect(obj.v).toEqual(2)
                    expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                })

                test('can\'t delete', async () => {
                    const [appMessageSetting] = await createTestAppMessageSetting(admin, {
                        b2cApp,
                    })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await AppMessageSetting.delete(admin, appMessageSetting.id)
                    })
                })

                test('can read', async () => {
                    const [obj] = await createTestAppMessageSetting(admin, {
                        b2cApp,
                    })

                    const appSetting = await AppMessageSetting.getOne(admin, {
                        id: obj.id,
                    })

                    expect(appSetting).toBeDefined()
                    expect(appSetting.id).toEqual(obj.id)
                    expect(appSetting.type).toEqual(B2C_APP_MESSAGE_PUSH_TYPE)
                })
            })

            describe('Support', () => {
                test('can create', async () => {
                    const [obj, attrs] = await createTestAppMessageSetting(support, {
                        b2cApp,
                    })

                    expectValuesOfCommonFields(obj, attrs, support)
                    expect(obj.type).toEqual(B2C_APP_MESSAGE_PUSH_TYPE)
                })

                test('can update', async () => {
                    const [objCreated] = await createTestAppMessageSetting(support, {
                        b2cApp,
                    })

                    const [obj, attrs] = await updateTestAppMessageSetting(support, objCreated.id)

                    expect(obj.dv).toEqual(1)
                    expect(obj.sender).toEqual(attrs.sender)
                    expect(obj.v).toEqual(2)
                    expect(obj.updatedBy).toEqual(expect.objectContaining({ id: support.user.id }))
                })

                test('can\'t delete', async () => {
                    const [appMessageSetting] = await createTestAppMessageSetting(admin, {
                        b2cApp,
                    })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await AppMessageSetting.delete(support, appMessageSetting.id)
                    })
                })

                test('can read', async () => {
                    const [obj] = await createTestAppMessageSetting(support, {
                        b2cApp,
                    })

                    const appSetting = await AppMessageSetting.getOne(support, {
                        id: obj.id,
                    })

                    expect(appSetting).toBeDefined()
                    expect(appSetting.id).toEqual(obj.id)
                    expect(appSetting.type).toEqual(B2C_APP_MESSAGE_PUSH_TYPE)
                })
            })

            describe('User', () => {
                test('can\'t create', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestAppMessageSetting(user, { b2cApp })
                    })
                })

                test('can\'t update', async () => {
                    const [appMessageSetting] = await createTestAppMessageSetting(support, {
                        b2cApp,
                    })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestAppMessageSetting(user, appMessageSetting.id)
                    })
                })

                test('can\'t delete', async () => {
                    const [appMessageSetting] = await createTestAppMessageSetting(support, {
                        b2cApp,
                    })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await AppMessageSetting.delete(user, appMessageSetting.id)
                    })
                })

                test('can\'t read', async () => {
                    const [appMessageSetting] = await createTestAppMessageSetting(support, {
                        b2cApp,
                    })

                    const readAppMessageSetting = await AppMessageSetting.getOne(user, {
                        id: appMessageSetting.id,
                    })

                    expect(readAppMessageSetting).toBeUndefined()
                })

                test('Staff user can read settings for connected B2BApps if he has "B2BAppRole" connected to his "OrganizationEmployeeRole"', async () => {
                    const staffUser = await makeClientWithNewRegisteredAndLoggedInUser()

                    const [organization] = await registerNewOrganization(staffUser)
                    const [app] = await createTestB2BApp(support)

                    await createTestB2BAppContext(staffUser, app, organization, {
                        status: CONTEXT_FINISHED_STATUS,
                    })
                    const [setting] = await createTestAppMessageSetting(support, {
                        b2bApp: app,
                    })

                    const readSetting = await AppMessageSetting.getOne(staffUser, { id: setting.id })

                    expect(readSetting).toBeDefined()
                    expect(readSetting.id).toEqual(setting.id)
                    expect(readSetting.type).toBeDefined()
                    expect(readSetting.type).toEqual(setting.type)
                    expect(readSetting.b2bApp.id).toEqual(setting.b2bApp.id)
                })

                test('user with employee without b2bAppRole can not read', async () => {
                    const staffUser = await makeClientWithNewRegisteredAndLoggedInUser()
                    const [organization] = await registerNewOrganization(staffUser)
                    const [app] = await createTestB2BApp(support)
                    await createTestB2BAppContext(staffUser, app, organization, {
                        status: CONTEXT_FINISHED_STATUS,
                    })
                    const [setting] = await createTestAppMessageSetting(support, {
                        b2bApp: app,
                    })

                    const staffWithoutB2BAppRole = await makeClientWithNewRegisteredAndLoggedInUser()
                    const [role] = await createTestOrganizationEmployeeRole(staffUser, organization)
                    const [invitedEmployee] = await inviteNewOrganizationEmployee(staffUser, organization, staffWithoutB2BAppRole.userAttrs, role)
                    await acceptOrRejectOrganizationInviteById(staffWithoutB2BAppRole, invitedEmployee)

                    const readSetting = await AppMessageSetting.getOne(staffWithoutB2BAppRole, { id: setting.id })

                    expect(readSetting).toBeUndefined()
                })
            })

            describe('Anonymous', () => {
                test('can\'t create', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await createTestAppMessageSetting(anonymous, { b2cApp })
                    })
                })

                test('can\'t update', async () => {
                    const [appMessageSetting] = await createTestAppMessageSetting(support, {
                        b2cApp,
                    })

                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestAppMessageSetting(anonymous, appMessageSetting.id)
                    })
                })

                test('can\'t delete', async () => {
                    const [appMessageSetting] = await createTestAppMessageSetting(support, {
                        b2cApp,
                    })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await AppMessageSetting.delete(anonymous, appMessageSetting.id)
                    })
                })

                test('can\'t read', async () => {
                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await AppMessageSetting.getAll(anonymous, {})
                    })
                })
            })
        })
    })

    describe('Validations', () => {
        test('can not create AppMessageSetting with b2bApp and b2cApp together', async () => {
            await expectToThrowGQLError(async () => {
                await createTestAppMessageSetting(support, {
                    b2cApp,
                    b2bApp,
                })
            }, ERRORS.APP_MESSAGE_SETTING_MUST_HAVE_ONLY_B2B_OR_B2C_APP_FIELD)
        })

        test('can not create AppMessageSetting without b2bApp or b2cApp', async () => {
            await expectToThrowGQLError(async () => {
                await createTestAppMessageSetting(support, {
                    type: TICKET_CREATED_TYPE,
                })
            }, ERRORS.APP_MESSAGE_SETTING_MUST_HAVE_ONLY_B2B_OR_B2C_APP_FIELD)
        })

        test('can not update b2bApp and b2cApp fields', async () => {
            const [settingWithB2CApp] = await createTestAppMessageSetting(support, {
                b2cApp,
            })
            const [settingWithB2BApp] = await createTestAppMessageSetting(support, {
                b2bApp,
            })

            const [otherB2cApp] = await createTestB2CApp(support)
            const [otherB2bApp] = await createTestB2BApp(support)

            await catchErrorFrom(async () => {
                await updateTestAppMessageSetting(support, settingWithB2CApp.id, {
                    b2cApp: { connect: { id: otherB2cApp.id } },
                })
            }, (e) => {
                expect(e.errors[0].message).toContain('Field "b2cApp" is not defined by type "AppMessageSettingUpdateInput"')
            })

            await catchErrorFrom(async () => {
                await updateTestAppMessageSetting(support, settingWithB2BApp.id, {
                    b2bApp: { connect: { id: otherB2bApp.id } },
                })
            }, (e) => {
                expect(e.errors[0].message).toContain('Field "b2bApp" is not defined by type "AppMessageSettingUpdateInput"')
            })

            await catchErrorFrom(async () => {
                await updateTestAppMessageSetting(support, settingWithB2BApp.id, {
                    b2cApp: { connect: { id: otherB2cApp.id } },
                })
            }, (e) => {
                expect(e.errors[0].message).toContain('Field "b2cApp" is not defined by type "AppMessageSettingUpdateInput"')
            })

            await catchErrorFrom(async () => {
                await updateTestAppMessageSetting(support, settingWithB2CApp.id, {
                    b2bApp: { connect: { id: otherB2bApp.id } },
                })
            }, (e) => {
                expect(e.errors[0].message).toContain('Field "b2bApp" is not defined by type "AppMessageSettingUpdateInput"')
            })
        })

        test('can update AppMessageSetting fields', async () => {
            const [setting] = await createTestAppMessageSetting(support, {
                b2bApp,
            })

            const [updatedSetting] = await updateTestAppMessageSetting(support, setting.id, {
                numberOfNotificationInWindow: 0,
            })

            expect(updatedSetting.numberOfNotificationInWindow).toEqual(0)
        })

        test('can not create two records with same message type and B2CApp', async () => {
            await createTestAppMessageSetting(support, {
                b2cApp,
            })

            await expectToThrowUniqueConstraintViolationError(async () => {
                await createTestAppMessageSetting(support, {
                    b2cApp,
                })
            }, 'app_message_setting_unique_b2c_app_and_type')
        })

        test('can not create two records with same message type and B2BApp', async () => {
            await createTestAppMessageSetting(support, {
                b2bApp,
            })

            await expectToThrowUniqueConstraintViolationError(async () => {
                await createTestAppMessageSetting(support, {
                    b2bApp,
                })
            }, 'app_message_setting_unique_b2b_app_and_type')
        })

        test('can create two records with different message types and same B2CApp', async () => {
            const [obj1] = await createTestAppMessageSetting(support, {
                b2cApp,
            })

            const [obj2] = await createTestAppMessageSetting(support, {
                b2cApp,
                type: VOIP_INCOMING_CALL_MESSAGE_TYPE,
            })

            expect(obj1.type).toEqual(B2C_APP_MESSAGE_PUSH_TYPE)
            expect(obj2.type).toEqual(VOIP_INCOMING_CALL_MESSAGE_TYPE)
            expect(obj1.b2cApp.id).toEqual(obj2.b2cApp.id)
        })

        test('can create two records with different message types and same B2BApp', async () => {
            const [obj1] = await createTestAppMessageSetting(support, {
                b2bApp,
            })

            const [obj2] = await createTestAppMessageSetting(support, {
                b2bApp,
                type: TICKET_CREATED_TYPE,
            })

            expect(obj1.type).toEqual(B2B_APP_MESSAGE_PUSH_TYPE)
            expect(obj2.type).toEqual(TICKET_CREATED_TYPE)
            expect(obj1.b2bApp.id).toEqual(obj2.b2bApp.id)
        })

        test('can create two records with same message type and different app types', async () => {
            const [obj1] = await createTestAppMessageSetting(support, {
                b2cApp,
                type: TICKET_CREATED_TYPE,
            })
            const [obj2] = await createTestAppMessageSetting(support, {
                b2bApp,
                type: TICKET_CREATED_TYPE,
            })

            expect(obj1.type).toEqual(TICKET_CREATED_TYPE)
            expect(obj1.b2cApp.id).toEqual(b2cApp.id)
            expect(obj2.type).toEqual(TICKET_CREATED_TYPE)
            expect(obj2.b2bApp.id).toEqual(b2bApp.id)
        })

        test('can create two records with same message type and different B2CApp', async () => {
            const [b2cApp1] = await createTestB2CApp(support)
            const [b2cApp2] = await createTestB2CApp(support)
            const [obj1] = await createTestAppMessageSetting(support, {
                b2cApp: b2cApp1,
            })

            const [obj2] = await createTestAppMessageSetting(support, {
                b2cApp: b2cApp2,
            })

            expect(obj1.b2cApp.id).toEqual(b2cApp1.id)
            expect(obj2.b2cApp.id).toEqual(b2cApp2.id)
            expect(obj1.type).toEqual(obj2.type)
        })
    })
})
