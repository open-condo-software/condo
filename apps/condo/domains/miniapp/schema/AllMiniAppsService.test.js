/**
 * Generated by `createservice miniapp.AllOrganizationAppsService --type queries`
 */

const path = require('path')

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const conf = require('@open-condo/config')
const { makeLoggedInAdminClient, makeClient, waitFor, UploadingFile } = require('@open-condo/keystone/test.utils')
const { expectToThrowAuthenticationErrorToObjects, expectToThrowAccessDeniedErrorToObjects } = require('@open-condo/keystone/test.utils')

const { PROPERTIES_CATEGORY } = require('@condo/domains/common/constants/menuCategories')
const {
    OTHER_CATEGORY,
    SMART_HOME_CATEGORY,
    CONTEXT_FINISHED_STATUS,
    CONTEXT_IN_PROGRESS_STATUS,
    APP_NEW_LABEL,
} = require('@condo/domains/miniapp/constants')
const {
    allMiniAppsByTestClient,
    createTestB2BApp,
    createTestB2BAppContext,
    updateTestB2BAppContext,
    updateTestB2BApp,
    createTestB2BAppRole,
    B2BAppRole,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    registerNewOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithNewRegisteredAndLoggedInUser,
} = require('@condo/domains/user/utils/testSchema')

function expectFilterSeparation (filteredApps, expectedIncludedApps, expectedExcludedApps) {
    expect(filteredApps).toEqual(expect.arrayContaining(expectedIncludedApps.map(app => expect.objectContaining({
        id: app.id,
    }))))
    for (const app of expectedExcludedApps) {
        expect(filteredApps).not.toEqual(expect.arrayContaining([expect.objectContaining({ id: app.id })]))
    }
}

describe('AllMiniAppsService', () => {
    let admin
    let support
    let anonymous
    let manager
    let employee
    let organization
    let connectedCommonApp
    let connectedPartialApp
    let frozenApp
    let nonFinishedApp
    let nonConnectedApp
    let expectedOrder
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
        manager = await makeClientWithNewRegisteredAndLoggedInUser()
        employee = await makeClientWithNewRegisteredAndLoggedInUser();
        [organization] = await registerNewOrganization(manager)
        const [employeeRole] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageB2BApps: false,
        })
        await createTestOrganizationEmployee(admin, organization, employee.user, employeeRole, {
            isAccepted: true,
            isBlocked: false,
            isRejected: false,
        });

        [connectedCommonApp] = await createTestB2BApp(support, {
            contextDefaultStatus: CONTEXT_FINISHED_STATUS,
            isHidden: false,
            displayPriority: 6,
            category: OTHER_CATEGORY,
        });
        [connectedPartialApp] = await createTestB2BApp(support, {
            contextDefaultStatus: CONTEXT_FINISHED_STATUS,
            isHidden: false,
            displayPriority: 3,
            category: SMART_HOME_CATEGORY,
        });
        [nonFinishedApp] = await createTestB2BApp(support, {
            contextDefaultStatus: CONTEXT_IN_PROGRESS_STATUS,
            isHidden: false,
            displayPriority: 4,
            category: SMART_HOME_CATEGORY,
        });
        [nonConnectedApp] = await createTestB2BApp(support, {
            isHidden: false,
            displayPriority: 3,
            category: OTHER_CATEGORY,
        });
        [frozenApp] = await createTestB2BApp(support, {
            contextDefaultStatus: CONTEXT_FINISHED_STATUS,
            isHidden: false,
        })

        expectedOrder = [connectedCommonApp.id, nonFinishedApp.id, nonConnectedApp.id, connectedPartialApp.id]

        await createTestB2BAppContext(manager, connectedCommonApp, organization)
        await createTestB2BAppContext(manager, connectedPartialApp, organization)
        await createTestB2BAppContext(manager, nonFinishedApp, organization)
        const [frozenContext] = await createTestB2BAppContext(manager, frozenApp, organization)
        await createTestB2BAppRole(manager, connectedCommonApp, employeeRole)

        await waitFor(async () => {
            const roles = await B2BAppRole.getAll(admin, {
                app: { id_in: [connectedCommonApp.id, connectedPartialApp.id, frozenApp.id] },
                role: { organization: { id: organization.id } },
            })
            expect(roles).toHaveLength(4)
        })
        await updateTestB2BAppContext(support, frozenContext.id, { status: CONTEXT_IN_PROGRESS_STATUS })
    })
    describe('Execute access rights', () => {
        test('Admin can for any organization', async () => {
            const [data] = await allMiniAppsByTestClient(admin, organization)
            expect(data).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: connectedCommonApp.id, connected: true, accessible: false }),
                expect.objectContaining({ id: connectedPartialApp.id, connected: true, accessible: false }),
                expect.objectContaining({ id: nonConnectedApp.id, connected: false, accessible: false }),
            ]))
        })
        test('Support can for any organization', async () => {
            const [data] = await allMiniAppsByTestClient(support, organization)
            expect(data).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: connectedCommonApp.id, connected: true, accessible: false }),
                expect.objectContaining({ id: connectedPartialApp.id, connected: true, accessible: false }),
                expect.objectContaining({ id: nonConnectedApp.id, connected: false, accessible: false }),
            ]))
        })
        describe('Employee', () => {
            test('Can for his organization', async () => {
                const [data] = await allMiniAppsByTestClient(employee, organization)
                expect(data).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: connectedCommonApp.id, connected: true, accessible: true }),
                    expect.objectContaining({ id: connectedPartialApp.id, connected: true, accessible: false }),
                    expect.objectContaining({ id: nonConnectedApp.id, connected: false, accessible: false }),
                ]))
            })
            test('Cannot for others', async () => {
                const anotherManager = await makeClientWithNewRegisteredAndLoggedInUser()
                const [anotherOrganization] = await registerNewOrganization(anotherManager)
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await allMiniAppsByTestClient(manager, anotherOrganization)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await allMiniAppsByTestClient(anonymous, organization)
                })
            })
        })
    })
    describe('Data shown', () => {
        test('Must include all necessary fields', async () => {
            const [app, appAttrs] = await createTestB2BApp(support, {
                isHidden: false,
                category: SMART_HOME_CATEGORY,
                icon: 'House',
                label: APP_NEW_LABEL,
                menuCategory: PROPERTIES_CATEGORY,
                logo: new UploadingFile(path.resolve(conf.PROJECT_ROOT, 'apps/condo/domains/common/test-assets/dino.png')),
            })
            const [data] = await allMiniAppsByTestClient(employee, organization)
            expect(data).toEqual(expect.arrayContaining([
                {
                    id: app.id,
                    connected: false,
                    accessible: false,
                    name: appAttrs.name,
                    shortDescription: appAttrs.shortDescription,
                    category: appAttrs.category,
                    icon: appAttrs.icon,
                    label: appAttrs.label,
                    menuCategory: appAttrs.menuCategory,
                    logo: expect.stringContaining(''),
                },
            ]))
        })
        test(`App is connected only if organization has existing context in ${CONTEXT_FINISHED_STATUS} status`, async () => {
            const [anotherApp] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS, isHidden: false })
            const [context] = await createTestB2BAppContext(manager, anotherApp, organization)

            const [data] = await allMiniAppsByTestClient(employee, organization)

            expect(data).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: connectedCommonApp.id, connected: true }),
                expect.objectContaining({ id: connectedPartialApp.id, connected: true }),
                expect.objectContaining({ id: nonFinishedApp.id, connected: false }),
                expect.objectContaining({ id: nonConnectedApp.id, connected: false }),
                expect.objectContaining({ id: anotherApp.id, connected: true }),
            ]))

            await updateTestB2BAppContext(support, context.id, {
                deletedAt: dayjs().toISOString(),
            })

            const [newData] = await allMiniAppsByTestClient(employee, organization)
            expect(newData).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: anotherApp.id, connected: false }),
            ]))
        })
        test('Deleted apps is not shown', async () => {
            const [anotherApp] = await createTestB2BApp(support, { isHidden: false })
            const [data] = await allMiniAppsByTestClient(manager, organization)
            expect(data).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: anotherApp.id }),
            ]))
            await updateTestB2BApp(support, anotherApp.id, { deletedAt: dayjs().toISOString() })
            const [newData] = await allMiniAppsByTestClient(manager, organization)
            expect(newData).toBeDefined()
            expect(newData).not.toEqual(expect.arrayContaining([
                expect.objectContaining({ id: anotherApp.id }),
            ]))
        })
        test('Hidden apps is not shown', async () => {
            const [anotherApp] = await createTestB2BApp(support, { isHidden: false })
            const [data] = await allMiniAppsByTestClient(manager, organization)
            expect(data).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: anotherApp.id }),
            ]))
            await updateTestB2BApp(support, anotherApp.id, { isHidden: true })
            const [newData] = await allMiniAppsByTestClient(manager, organization)
            expect(newData).toBeDefined()
            expect(newData).not.toEqual(expect.arrayContaining([
                expect.objectContaining({ id: anotherApp.id }),
            ]))
        })
        test('Global apps is not shown', async () => {
            const [anotherApp] = await createTestB2BApp(support, { isHidden: false, isGlobal: true, appUrl: faker.internet.url() })
            const [data] = await allMiniAppsByTestClient(manager, organization)
            expect(data).toBeDefined()
            expect(data).not.toEqual(expect.arrayContaining([
                expect.objectContaining({ id: anotherApp.id }),
            ]))
        })
        test('Miniapps must be sorted by descending displayPriority, then by descending createdAt by default', async () => {
            const [data] = await allMiniAppsByTestClient(employee, organization)
            expect(data).toBeDefined()

            const indexedApps = data.filter(el => expectedOrder.includes(el.id))
            const actualOrder = indexedApps.map(el => el.id)
            expect(actualOrder).toEqual(expectedOrder)
        })
        test('B2BAppRoles must affect accessible property', async () => {
            const [managerData] = await allMiniAppsByTestClient(manager, organization)
            expect(managerData).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: connectedCommonApp.id, connected: true,  accessible: true }),
                expect.objectContaining({ id: connectedPartialApp.id, connected: true,  accessible: true }),
                expect.objectContaining({ id: nonFinishedApp.id, connected: false,  accessible: false }),
                expect.objectContaining({ id: frozenApp.id, connected: false,  accessible: true }),
                expect.objectContaining({ id: nonConnectedApp.id, connected: false,  accessible: false }),
            ]))
            const [employeeData] = await allMiniAppsByTestClient(employee, organization)
            expect(employeeData).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: connectedCommonApp.id, connected: true,  accessible: true }),
                expect.objectContaining({ id: connectedPartialApp.id, connected: true,  accessible: false }),
                expect.objectContaining({ id: nonFinishedApp.id, connected: false,  accessible: false }),
                expect.objectContaining({ id: frozenApp.id, connected: false,  accessible: false }),
                expect.objectContaining({ id: nonConnectedApp.id, connected: false,  accessible: false }),
            ]))
        })
    })
    describe('Filtering', () => {
        beforeAll(async () => {
            const [allApps] = await allMiniAppsByTestClient(employee, organization)
            expect(allApps).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: connectedCommonApp.id, connected: true, accessible: true, category: OTHER_CATEGORY }),
                expect.objectContaining({ id: connectedPartialApp.id, connected: true, accessible: false, category: SMART_HOME_CATEGORY }),
                expect.objectContaining({ id: nonFinishedApp.id, connected: false, accessible: false, category: SMART_HOME_CATEGORY }),
                expect.objectContaining({ id: nonConnectedApp.id, connected: false, accessible: false, category: OTHER_CATEGORY }),
            ]))
        })
        test('Filtering by connection status must work', async () => {
            const [connectedApps] = await allMiniAppsByTestClient(employee, organization, { where: { connected: true } })
            expectFilterSeparation(connectedApps,
                [connectedCommonApp, connectedPartialApp],
                [nonFinishedApp, nonConnectedApp]
            )
            const [unconnectedApps] = await allMiniAppsByTestClient(employee, organization, { where: { connected: false } })
            expectFilterSeparation(unconnectedApps,
                [nonFinishedApp, nonConnectedApp],
                [connectedCommonApp, connectedPartialApp]
            )
        })
        test('Filtering by accessibility must work', async () => {
            const [accessibleApps] = await allMiniAppsByTestClient(employee, organization, { where: { accessible: true } })
            expectFilterSeparation(accessibleApps,
                [connectedCommonApp],
                [nonFinishedApp, nonConnectedApp, connectedPartialApp]
            )
            const [nonAccessibleApps] = await allMiniAppsByTestClient(employee, organization, { where: { accessible: false } })
            expectFilterSeparation(nonAccessibleApps,
                [nonFinishedApp, nonConnectedApp, connectedPartialApp],
                [connectedCommonApp]
            )
        })
        test('Filtering by category must work', async () => {
            const [otherApps] = await allMiniAppsByTestClient(employee, organization, { where: { app:{ category: OTHER_CATEGORY } } })
            expectFilterSeparation(otherApps,
                [connectedCommonApp, nonConnectedApp],
                [connectedPartialApp, nonFinishedApp],
            )
            const [smartHomeApps] = await allMiniAppsByTestClient(employee, organization, { where: { app:{ category: SMART_HOME_CATEGORY } } })
            expectFilterSeparation(smartHomeApps,
                [connectedPartialApp, nonFinishedApp],
                [connectedCommonApp, nonConnectedApp]
            )
        })
        test('Filtering by id_not must work', async () => {
            const [filteredApps] = await allMiniAppsByTestClient(employee, organization, { where: { app: { id_not: connectedCommonApp.id } } })
            expectFilterSeparation(filteredApps,
                [connectedPartialApp, nonFinishedApp, nonConnectedApp],
                [connectedCommonApp]
            )
        })
        test('Combined filters must work', async () => {
            const [filteredApps] = await allMiniAppsByTestClient(employee, organization, { where: { connected: true, accessible: true } })
            expectFilterSeparation(filteredApps,
                [connectedCommonApp],
                [connectedPartialApp, nonFinishedApp, nonConnectedApp]
            )
            const [excludedFilteredApps] = await allMiniAppsByTestClient(employee, organization, { where: { connected: true, accessible: true, app: { id_not: connectedCommonApp.id } } })
            expectFilterSeparation(excludedFilteredApps,
                [],
                [connectedCommonApp, connectedPartialApp, nonFinishedApp, nonConnectedApp]
            )
        })
    })
    describe('Sorting', () => {
        test('Sorting must work', async () => {
            const [firstApp] = await createTestB2BApp(support, {
                isHidden: false,
                contextDefaultStatus: CONTEXT_FINISHED_STATUS,
                displayPriority: 6,
            })
            const [secondApp] = await createTestB2BApp(support, {
                isHidden: false,
                contextDefaultStatus: CONTEXT_FINISHED_STATUS,
                displayPriority: 1,
            })

            await createTestB2BAppContext(manager, secondApp, organization)
            await createTestB2BAppContext(manager, firstApp, organization)

            const [defaultSortedData] = await allMiniAppsByTestClient(employee, organization, {
                where: { app: { id_in: [firstApp.id, secondApp.id] } },
            })

            expect(defaultSortedData).toEqual([
                expect.objectContaining({ id: firstApp.id }),
                expect.objectContaining({ id: secondApp.id }),
            ])

            const [connectedAscSortedData] = await allMiniAppsByTestClient(employee, organization, {
                where: { app: { id_in: [firstApp.id, secondApp.id] } },
                sortBy: 'connectedAt_ASC',
            })

            expect(connectedAscSortedData).toEqual([
                expect.objectContaining({ id: secondApp.id }),
                expect.objectContaining({ id: firstApp.id }),
            ])

            const [priorityDescSortedData] = await allMiniAppsByTestClient(employee, organization, {
                where: { app: { id_in: [firstApp.id, secondApp.id] } },
                sortBy: 'displayPriority_DESC',
            })

            expect(priorityDescSortedData).toEqual(defaultSortedData)
        })
    })
})