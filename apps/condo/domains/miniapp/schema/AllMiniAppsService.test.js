/**
 * Generated by `createservice miniapp.AllOrganizationAppsService --type queries`
 */

const dayjs = require('dayjs')
const faker = require('faker')

const { makeLoggedInAdminClient, makeClient } = require('@open-condo/keystone/test.utils')
const { expectToThrowAuthenticationErrorToObjects, expectToThrowAccessDeniedErrorToObjects } = require('@open-condo/keystone/test.utils')

const { createTestAcquiringIntegration, createTestAcquiringIntegrationContext, updateTestAcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBillingIntegration, createTestBillingIntegrationOrganizationContext, updateTestBillingIntegrationOrganizationContext } = require('@condo/domains/billing/utils/testSchema')
const {
    BILLING_APP_TYPE,
    ACQUIRING_APP_TYPE,
    B2B_APP_TYPE,
    APP_NEW_LABEL,
    OTHER_CATEGORY,
    CONTEXT_FINISHED_STATUS,
    CONTEXT_IN_PROGRESS_STATUS,
    ACCRUALS_AND_PAYMENTS_CATEGORY,
} = require('@condo/domains/miniapp/constants')
const { allMiniAppsByTestClient, createTestB2BApp, createTestB2BAppContext, updateTestB2BAppContext, updateTestB2BApp } = require('@condo/domains/miniapp/utils/testSchema')
const { createTestOrganization, makeEmployeeUserClientWithAbilities } = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

describe('AllMiniAppsService', () => {
    describe('Execute', () => {
        describe('User', () => {
            test('Can for his organization', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
            })
            test('Cannot for other organizations', async () => {
                const admin = await makeLoggedInAdminClient()
                const [organization] = await createTestOrganization(admin)
                const client = await makeEmployeeUserClientWithAbilities()
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await allMiniAppsByTestClient(client, organization.id)
                })
            })
        })
        test('Admin can', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeEmployeeUserClientWithAbilities()
            const [data] = await allMiniAppsByTestClient(admin, client.organization.id)
            expect(data).toBeDefined()
        })
        test('Support can', async () => {
            const support = await makeClientWithSupportUser()
            const client = await makeEmployeeUserClientWithAbilities()
            const [data] = await allMiniAppsByTestClient(support, client.organization.id)
            expect(data).toBeDefined()
        })
        test('Anonymous cannot', async () => {
            const client = await makeClient()
            const admin = await makeLoggedInAdminClient()
            const [organization] = await createTestOrganization(admin)
            await expectToThrowAuthenticationErrorToObjects(async () => {
                await allMiniAppsByTestClient(client, organization.id)
            })
        })
    })
    describe('Functionality', () => {
        describe('Billing integration', () => {
            let integration
            let admin
            beforeAll(async () => {
                admin = await makeLoggedInAdminClient()
            })
            beforeEach(async () => {
                [integration] = await createTestBillingIntegration(admin, { isHidden: false })
            })
            test('Shows unconnected without context', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([expect.objectContaining({
                    id: integration.id,
                    type: BILLING_APP_TYPE,
                    connected: false,
                    name: integration.name,
                    shortDescription: integration.shortDescription,
                    category: ACCRUALS_AND_PAYMENTS_CATEGORY,
                })]))
            })
            test(`Shows connected with context in ${CONTEXT_FINISHED_STATUS} status`, async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [context] = await createTestBillingIntegrationOrganizationContext(admin, client.organization, integration, {
                    status: CONTEXT_IN_PROGRESS_STATUS,
                })
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: integration.id,
                        type: BILLING_APP_TYPE,
                        connected: false,
                    }),
                ]))
                await updateTestBillingIntegrationOrganizationContext(admin, context.id, {
                    status: CONTEXT_FINISHED_STATUS,
                })
                const [newData] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(newData).toBeDefined()
                expect(newData).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: integration.id,
                        type: BILLING_APP_TYPE,
                        connected: true,
                    }),
                ]))
            })
            test('Shows unconnected with deleted context', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [context] = await createTestBillingIntegrationOrganizationContext(admin, client.organization, integration, {
                    status: CONTEXT_FINISHED_STATUS,
                })
                await updateTestBillingIntegrationOrganizationContext(admin, context.id, {
                    deletedAt: dayjs().toISOString(),
                })
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: integration.id,
                        type: BILLING_APP_TYPE,
                        connected: false,
                    }),
                ]))
            })
            test('Doesn\'t shows if hidden integration', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [hiddenIntegration] = await createTestBillingIntegration(admin, { isHidden: true })
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).not.toEqual(expect.arrayContaining([{
                    id: hiddenIntegration.id,
                    type: BILLING_APP_TYPE,
                }]))
            })
        })
        describe('Acquiring integration', () => {
            let integration
            let billings
            let admin
            beforeAll(async () => {
                admin = await makeLoggedInAdminClient()
                const [billing] = await createTestBillingIntegration(admin)
                billings = [billing]
            })
            beforeEach(async () => {
                [integration] = await createTestAcquiringIntegration(admin, billings)
            })
            test('Shows unconnected without context', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([expect.objectContaining({
                    id: integration.id,
                    type: ACQUIRING_APP_TYPE,
                    connected: false,
                    name: integration.name,
                    shortDescription: integration.shortDescription,
                    category: ACCRUALS_AND_PAYMENTS_CATEGORY,
                })]))
            })
            test(`Shows connected with context in ${CONTEXT_FINISHED_STATUS} status`, async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [context] = await createTestAcquiringIntegrationContext(admin, client.organization, integration, {
                    status: CONTEXT_IN_PROGRESS_STATUS,
                })
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: integration.id,
                        type: ACQUIRING_APP_TYPE,
                        connected: false,
                    }),
                ]))
                await updateTestAcquiringIntegrationContext(admin, context.id, {
                    status: CONTEXT_FINISHED_STATUS,
                })
                const [newData] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(newData).toBeDefined()
                expect(newData).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: integration.id,
                        type: ACQUIRING_APP_TYPE,
                        connected: true,
                    }),
                ]))
            })
            test('Shows unconnected with deleted context', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [context] = await createTestAcquiringIntegrationContext(admin, client.organization, integration, {
                    status: CONTEXT_FINISHED_STATUS,
                })
                await updateTestAcquiringIntegrationContext(admin, context.id, {
                    deletedAt: dayjs().toISOString(),
                })
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: integration.id,
                        type: ACQUIRING_APP_TYPE,
                        connected: false,
                    }),
                ]))
            })
            test('Doesn\'t shows if hidden integration', async () => {
                const [hiddenIntegration] = await createTestAcquiringIntegration(admin, billings, { isHidden: true })
                const client = await makeEmployeeUserClientWithAbilities()
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).not.toEqual(expect.arrayContaining([{
                    id: hiddenIntegration.id,
                    type: ACQUIRING_APP_TYPE,
                }]))
            })
        })
        describe('B2B App', () => {
            let app
            let admin
            beforeAll(async () => {
                admin = await makeLoggedInAdminClient()
            })
            beforeEach(async () => {
                [app] = await createTestB2BApp(admin, { isHidden: false })
            })
            test('Shows unconnected without context', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([expect.objectContaining({
                    id: app.id,
                    type: B2B_APP_TYPE,
                    connected: false,
                    name: app.name,
                    shortDescription: app.shortDescription,
                    category: app.category,
                })]))
            })
            test(`Shows connected with context in ${CONTEXT_FINISHED_STATUS} status`, async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [context] = await createTestB2BAppContext(admin, app, client.organization, {
                    status: CONTEXT_IN_PROGRESS_STATUS,
                })
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: app.id,
                        type: B2B_APP_TYPE,
                        connected: false,
                    }),
                ]))
                await updateTestB2BAppContext(admin, context.id, {
                    status: CONTEXT_FINISHED_STATUS,
                })
                const [newData] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(newData).toBeDefined()
                expect(newData).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: app.id,
                        type: B2B_APP_TYPE,
                        connected: true,
                    }),
                ]))
            })
            test('Shows unconnected with deleted context', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [context] = await createTestB2BAppContext(admin, app, client.organization)
                await updateTestB2BAppContext(admin, context.id, {
                    deletedAt: dayjs().toISOString(),
                })
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: app.id,
                        type: B2B_APP_TYPE,
                        connected: false,
                    }),
                ]))
            })
            test('Doesn\'t shows if app is hidden', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [hiddenIntegration] = await updateTestB2BApp(admin, app.id, { isHidden: true })
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).not.toEqual(expect.arrayContaining([{
                    id: hiddenIntegration.id,
                    type: B2B_APP_TYPE,
                }]))
            })
            test('Doesn\'t shows if app is global', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [globalIntegration] = await updateTestB2BApp(admin, app.id, {
                    appUrl: faker.internet.url(),
                    isGlobal: true,
                    isHidden: false,
                })
                const [data] = await allMiniAppsByTestClient(client, client.organization.id)
                expect(data).toBeDefined()
                expect(data).not.toEqual(expect.arrayContaining([{
                    id: globalIntegration.id,
                    type: B2B_APP_TYPE,
                }]))
            })
        })
        describe('Display priority and labeling', () => {
            test('All miniapps must be ordered by displayPriority', async () => {
                const admin = await makeLoggedInAdminClient()
                const [firstApp] = await createTestB2BApp(admin, { isHidden: false, displayPriority: 6 })
                const [billing] = await createTestBillingIntegration(admin, { isHidden: false, displayPriority: 3 })
                const [acquiring] = await createTestAcquiringIntegration(admin, [billing], { isHidden: false, displayPriority: 4 })
                const [secondApp] = await createTestB2BApp(admin, { isHidden: false, displayPriority: 3, label: APP_NEW_LABEL })

                const client = await makeEmployeeUserClientWithAbilities()
                const [data] = await allMiniAppsByTestClient(admin, client.organization.id)
                expect(data).toBeDefined()
                expect(data).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: firstApp.id, type: B2B_APP_TYPE, label: null }),
                    expect.objectContaining({ id: secondApp.id, type: B2B_APP_TYPE, label: APP_NEW_LABEL }),
                    expect.objectContaining({ id: billing.id, type: BILLING_APP_TYPE, label: null }),
                    expect.objectContaining({ id: acquiring.id, type: ACQUIRING_APP_TYPE, label: null }),
                ]))

                const expectedOrder = [firstApp.id, acquiring.id, secondApp.id, billing.id]
                const indexedApps = data.filter(el => expectedOrder.includes(el.id))
                const actualOrder = indexedApps.map(el => el.id)
                expect(actualOrder).toEqual(expectedOrder)
            })
        })
        describe('Filtering', () => {
            test('Connected, id_not and category should work', async () => {
                const admin = await makeLoggedInAdminClient()
                const [app] = await createTestB2BApp(admin, { isHidden: false })
                const [billing] = await createTestBillingIntegration(admin, { isHidden: false })
                const [acquiring] = await createTestAcquiringIntegration(admin, [billing], { isHidden: false })

                const client = await makeEmployeeUserClientWithAbilities()
                const [apps] = await allMiniAppsByTestClient(client, client.organization.id)

                expect(apps).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: app.id }),
                    expect.objectContaining({ id: billing.id }),
                    expect.objectContaining({ id: acquiring.id }),
                ]))

                await createTestB2BAppContext(admin, app, client.organization, { status: CONTEXT_FINISHED_STATUS })
                await createTestBillingIntegrationOrganizationContext(admin, client.organization, billing, { status: CONTEXT_FINISHED_STATUS })
                await createTestAcquiringIntegrationContext(admin, client.organization, acquiring, { status: CONTEXT_FINISHED_STATUS })
                const [connectedApps] = await allMiniAppsByTestClient(client, client.organization.id, {
                    where: { connected: true },
                })
                const [notConnectedApps] = await allMiniAppsByTestClient(client, client.organization.id, {
                    where: { connected: false },
                })
                expect(connectedApps).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: app.id }),
                    expect.objectContaining({ id: billing.id }),
                    expect.objectContaining({ id: acquiring.id }),
                ]))
                expect(notConnectedApps).not.toEqual(expect.arrayContaining([expect.objectContaining({ id: app.id })]))
                expect(notConnectedApps).not.toEqual(expect.arrayContaining([expect.objectContaining({ id: billing.id })]))
                expect(notConnectedApps).not.toEqual(expect.arrayContaining([expect.objectContaining({ id: acquiring.id })]))

                const [noBillingApps] = await allMiniAppsByTestClient(client, client.organization.id, {
                    where: { connected: true, id_not: billing.id },
                })
                expect(noBillingApps).not.toEqual(expect.arrayContaining([expect.objectContaining({ id: billing.id })]))

                const [noAcquiringApps] = await allMiniAppsByTestClient(client, client.organization.id, {
                    where: { connected: true, id_not: acquiring.id },
                })
                expect(noAcquiringApps).not.toEqual(expect.arrayContaining([expect.objectContaining({ id: acquiring.id })]))

                const [noB2BApps] = await allMiniAppsByTestClient(client, client.organization.id, {
                    where: { connected: true, id_not: app.id },
                })
                expect(noB2BApps).not.toEqual(expect.arrayContaining([expect.objectContaining({ id: app.id })]))

                const [otherApps] = await allMiniAppsByTestClient(client, client.organization.id, {
                    where: { category: OTHER_CATEGORY },
                })
                expect(otherApps).not.toEqual(expect.arrayContaining([
                    expect.not.objectContaining({ category: OTHER_CATEGORY }),
                ]))
            })
        })
    })
})