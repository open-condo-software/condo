/**
 * Generated by `createschema miniapp.B2BAppPermission 'app:Relationship:B2BApp:PROTECT; key:Text'`
 */

const get = require('lodash/get')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const { ROLE_PERMISSION_REGEX } = require('@condo/domains/common/constants/regexps')
const access = require('@condo/domains/miniapp/access/B2BAppPermission')
const {
    PERMISSION_KEY_WRONG_FORMAT_ERROR,
    PERMISSION_NAME_INVALID_LENGTH_ERROR,
    MAX_PERMISSION_NAME_LENGTH,
    MIN_PERMISSION_NAME_LENGTH,
} = require('@condo/domains/miniapp/constants')
const { updateB2BAppRolesPermissions } = require('@condo/domains/miniapp/tasks')

const ERRORS = {
    PERMISSION_KEY_WRONG_FORMAT: {
        code: BAD_USER_INPUT,
        type: PERMISSION_KEY_WRONG_FORMAT_ERROR,
        message: 'Incorrect key format. The key must start with the prefix "can", have lowerCamelCase and answer the question: "what is allowed to the user with this key?". Example: canManagePasses, canReadConfig, etc.',
    },
    PERMISSION_NAME_INVALID_LENGTH: {
        code: BAD_USER_INPUT,
        type: PERMISSION_NAME_INVALID_LENGTH_ERROR,
        message: 'Permission name was too long. Make sure its following the guidelines provided in the field docs',
    },
}

const B2BAppPermission = new GQLListSchema('B2BAppPermission', {
    schemaDoc: 'B2BApp permissions that describe additional capabilities within the mini-application ' +
        'and allow the organization administration to manage accesses within the miniapp ' +
        'depending on the employee\'s role ' +
        'by toggling the B2BAppPermissions of a particular application for each role. ' +
        'By default, for all employees with "canManageB2BApps" in their role, all permissions will be set to True. ' +
        'For all other roles with access to the application the default value is False.',
    fields: {
        app: {
            schemaDoc: 'Link to the application to which the permission belongs',
            type: 'Relationship',
            ref: 'B2BApp',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: {
                create: true,
                read: true,
                update: false,
            },
        },
        key: {
            schemaDoc: 'The permission key. ' +
                'Must be written in lowerCamelCase, start with the prefix "can", ' +
                'and answer the question, "What can a user with this permission do?". ' +
                'Examples: "canManagePasses", "canReadPrivateData", etc.',
            type: 'Text',
            isRequired: true,
            hooks: {
                validateInput: ({ resolvedData, fieldPath, context }) => {
                    const key = resolvedData[fieldPath]
                    if (!ROLE_PERMISSION_REGEX.test(key)) {
                        throw new GQLError(ERRORS.PERMISSION_KEY_WRONG_FORMAT, context)
                    }
                },
            },
        },
        name: {
            schemaDoc: 'Name of permission. ' +
                `Must be very brief (from ${MIN_PERMISSION_NAME_LENGTH} to ${MAX_PERMISSION_NAME_LENGTH} characters) ` +
                'and describe the capabilities that the employee will get with this permission. ' +
                'Must use nouns that indicate actions with objects or sections of the mini-application. ' +
                'Examples: "Passes management", "Access to settings", "Contacts viewing".',
            type: 'Text',
            isRequired: true,
            hooks: {
                resolveInput: ({ resolvedData, fieldPath }) => {
                    if (fieldPath in resolvedData) {
                        return resolvedData[fieldPath].trim()
                    }

                    return undefined
                },
                validateInput: ({ resolvedData, fieldPath, context }) => {
                    const inputLength = resolvedData[fieldPath].length
                    if (inputLength > MAX_PERMISSION_NAME_LENGTH || inputLength < MIN_PERMISSION_NAME_LENGTH) {
                        throw new GQLError(ERRORS.PERMISSION_NAME_INVALID_LENGTH, context)
                    }
                },
            },
        },
    },
    hooks: {
        afterChange: async ({ existingItem, updatedItem }) => {
            const oldDeletedAt = get(existingItem, 'deletedAt')
            const newDeletedAt = get(updatedItem, 'deletedAt')
            const oldKey = get(existingItem, 'key', null)
            const newKey = get(updatedItem, 'key', null)
            const appId = get(updatedItem, 'app', null)

            const isSoftDeletedHappened = newDeletedAt && !oldDeletedAt

            if (isSoftDeletedHappened) {
                await updateB2BAppRolesPermissions.delay(appId, oldKey, null)
            } else if (newKey !== oldKey) {
                await updateB2BAppRolesPermissions.delay(appId, oldKey, newKey)
            }

        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['app', 'key'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'b2bAppPermission_unique_key_app',
            },
        ],
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), analytical()],
    access: {
        read: access.canReadB2BAppPermissions,
        create: access.canManageB2BAppPermissions,
        update: access.canManageB2BAppPermissions,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAppPermission,
}
