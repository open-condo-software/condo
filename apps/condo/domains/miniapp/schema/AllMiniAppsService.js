/**
 * Generated by `createservice miniapp.AllOrganizationAppsService --type queries`
 */

const dayjs = require('dayjs')
const get = require('lodash/get')

const { GQLCustomSchema } = require('@open-condo/keystone/schema')
const { find, getByCondition } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/miniapp/access/AllMiniAppsService')
const {
    B2B_APP_CATEGORIES,
    CONTEXT_FINISHED_STATUS,
} = require('@condo/domains/miniapp/constants')
const { APPS_FILE_ADAPTER } = require('@condo/domains/miniapp/schema/fields/integration')

const PRIORITY_DESC_SORT = 'displayPriority_DESC'
const CONNECTED_ASC_SORT = 'connectedAt_ASC'

function datePropertyCompare (lhs, rhs, property = 'createdAt', order = 'DESC') {
    const lhsDateString = get(lhs, property)
    if (!lhsDateString) {
        return order === 'DESC' ? 1 : -1
    }
    const rhsDateString = get(rhs, property)
    if (!rhsDateString) {
        return order === 'DESC' ? 1 : -1
    }

    const lhsDate = dayjs(lhsDateString)
    const rhsDate = dayjs(rhsDateString)

    if (lhsDate.isAfter(rhsDate)) {
        return order === 'DESC' ? -1 : 1
    } else if (lhsDate.isBefore(rhsDate)) {
        return order === 'DESC' ? 1 : -1
    } else {
        return 0
    }
}

function priorityDescCompare (lhs, rhs) {
    const diff = rhs.displayPriority - lhs.displayPriority
    if (diff !== 0) {
        return diff
    } else {
        return datePropertyCompare(lhs, rhs, 'createdAt', 'DESC')
    }
}

function connectedAscCompare (lhs, rhs) {
    return datePropertyCompare(lhs, rhs, 'connectedAt', 'ASC')
}

/**
 * Aggregates information about all B2BApps from user's employee perspective
 * Including resolving connection status, accessibility by employee role and so on
 * @type {GQLCustomSchema}
 */
const AllMiniAppsService = new GQLCustomSchema('AllMiniAppsService', {
    types: [
        {
            access: true,
            type: `enum AppCategory { ${B2B_APP_CATEGORIES.join(' ')} }`,
        },
        {
            access: true,
            type: 'input AllMiniAppsWhereInput { app: B2BAppWhereInput, connected: Boolean, accessible: Boolean }',
        },
        {
            access: true,
            type: `enum SortAllMiniAppsBy { ${PRIORITY_DESC_SORT}, ${CONNECTED_ASC_SORT} }`,
        },
        {
            access: true,
            type: 'input AllMiniAppsInput { dv: Int!, sender: SenderFieldInput!, organization: OrganizationWhereUniqueInput!, where: AllMiniAppsWhereInput, sortBy: SortAllMiniAppsBy }',
        },
        {
            access: true,
            type: 'type MiniAppOutput { id: ID!, connected: Boolean!, accessible: Boolean!, name: String!, shortDescription: String!, category: AppCategory!, logo: String, label: String, icon: String, menuCategory: String }',
        },
    ],
    queries: [
        {
            access: access.canExecuteAllMiniApps,
            schema: 'allMiniApps (data: AllMiniAppsInput!): [MiniAppOutput!]',
            resolver: async (parent, args, context) => {
                const { data: { organization, where: { connected, accessible, app } = {}, sortBy } } = args
                const { authedItem: user } = context

                let services = []

                const employee = await getByCondition('OrganizationEmployee', {
                    organization,
                    user: { id: user.id },
                    deletedAt: null,
                })
                const employeeRoleId = get(employee, 'role', null)
                const appRoles = await find('B2BAppRole', {
                    role: { id: employeeRoleId },
                    deletedAt: null,
                })
                const accessibleB2BApps = new Set(appRoles.map(role => role.app))

                const B2BApps = await find('B2BApp', {
                    ...app,
                    isHidden: false,
                    isGlobal: false,
                    deletedAt: null,
                })
                const B2BAppContexts = await find('B2BAppContext', {
                    organization,
                    deletedAt: null,
                    status: CONTEXT_FINISHED_STATUS,
                })
                const connectedB2BApps = Object.assign({}, ...B2BAppContexts.map(ctx => ({ [ctx.app]: ctx.createdAt })))
                for (const app of B2BApps) {
                    const logoUrl = app.logo ? APPS_FILE_ADAPTER.publicUrl({ filename: app.logo.filename }) : null
                    const connected = app.id in connectedB2BApps
                    services.push({
                        id: app.id,
                        name: app.name,
                        shortDescription: app.shortDescription,
                        connected,
                        accessible: accessibleB2BApps.has(app.id),
                        category: app.category,
                        logo: logoUrl,
                        label: app.label,
                        icon: app.icon,
                        menuCategory: app.menuCategory,
                        // NOTE: Extra props for sort that will be omitted
                        displayPriority: app.displayPriority,
                        createdAt: app.createdAt,
                        connectedAt: get(connectedB2BApps, app.id, null),
                    })
                }
                if (connected !== undefined) {
                    services = services.filter(service => service.connected === connected)
                }
                if (accessible !== undefined) {
                    services = services.filter(service => service.accessible === accessible)
                }

                if (sortBy === CONNECTED_ASC_SORT) {
                    services.sort(connectedAscCompare)
                } else {
                    services.sort(priorityDescCompare)
                }

                return services
            },
        },
    ],
    
})

module.exports = {
    AllMiniAppsService,
}
