/**
 * Generated by `createschema miniapp.B2BAppRole 'app:Relationship:B2BApp:CASCADE; role:Relationship:OrganizationEmployeeRole:CASCADE; permissions:Json;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const {
    makeLoggedInAdminClient,
    makeClient,
    catchErrorFrom,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowGQLError,
    waitFor,
} = require('@open-condo/keystone/test.utils')

const {
    B2BAppRole,
    createTestB2BAppRole,
    updateTestB2BAppRole,
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRight,
    createTestB2BAppPermission,
    updateTestB2BAppContext,
    updateTestB2BAppPermission,
    generatePermissionKey,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    makeEmployeeUserClientWithAbilities,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    registerNewOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

const {
    CONTEXT_FINISHED_STATUS,
    APP_NOT_CONNECTED_ERROR,
    INVALID_PERMISSIONS_ERROR,
    CONTEXT_IN_PROGRESS_STATUS,
} = require('../constants')


describe('B2BAppRole', () => {
    let admin
    let support
    let manager
    let employee
    let anotherManager
    let serviceUser
    let anonymous
    let connectedApp
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        manager = await makeEmployeeUserClientWithAbilities({
            canManageB2BApps: true,
            canManageRoles: true,
        })

        const [anotherRole] = await createTestOrganizationEmployeeRole(admin, manager.organization, {
            canManageRoles: false,
        })
        employee = await makeClientWithNewRegisteredAndLoggedInUser()
        const [emp] = await createTestOrganizationEmployee(admin, manager.organization, employee.user, anotherRole)
        employee.employee = emp
        employee.organization = manager.organization
        employee.role = anotherRole

        anotherManager = await makeEmployeeUserClientWithAbilities({
            canManageB2BApps: true,
            canManageRoles: true,
        });
        

        [connectedApp] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
        await createTestB2BAppContext(manager, connectedApp, manager.organization)
        await createTestB2BAppContext(anotherManager, connectedApp, anotherManager.organization)

        serviceUser = await makeClientWithServiceUser()
        await createTestB2BAppAccessRight(support, serviceUser.user, connectedApp)

        anonymous = await makeClient()
    })
    afterAll( () => {
        if (global.gc) {
            global.gc()
        }
    })
    describe('CRUD tests', () => {
        describe('Create', () => {
            let role
            afterEach(async () => {
                if (role) {
                    await updateTestB2BAppRole(admin, role.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    role = undefined
                }
            })
            test('Admin can', async () => {
                [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
                expect(role).toHaveProperty('id')
            })
            test('Support can', async () => {
                [role] = await createTestB2BAppRole(support, connectedApp, employee.role)
                expect(role).toHaveProperty('id')
            })
            describe('Organization employee', () => {
                test('Can if has "canManageRole" in his role', async () => {
                    [role] = await createTestB2BAppRole(manager, connectedApp, employee.role)
                    expect(role).toHaveProperty('id')
                })
                test('Cannot otherwise', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestB2BAppRole(employee, connectedApp, employee.role)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestB2BAppRole(anotherManager, connectedApp, employee.role)
                    })
                })
            })
            test('App account cannot', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BAppRole(serviceUser, connectedApp, employee.role)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestB2BAppRole(anonymous, connectedApp, employee.role)
                })
            })
        })
        describe('Update', () => {
            let role
            beforeEach(async () => {
                [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
            })
            afterEach(async () => {
                if (role) {
                    await updateTestB2BAppRole(admin, role.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    role = undefined
                }
            })
            test('Admin can', async () => {
                const [updated] = await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
                expect(updated).toHaveProperty('deletedAt')
                expect(updated.deletedAt).not.toBeNull()
                // Prevent cleanup re-deletion
                role = undefined
            })
            test('Support can', async () => {
                const [updated] = await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
                expect(updated).toHaveProperty('deletedAt')
                expect(updated.deletedAt).not.toBeNull()
                // Prevent cleanup re-deletion
                role = undefined
            })
            describe('Organization employee', () => {
                test('Can if has "canManageRole" in his role', async () => {
                    const [updated] = await updateTestB2BAppRole(manager, role.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    expect(updated).toHaveProperty('deletedAt')
                    expect(updated.deletedAt).not.toBeNull()
                    // Prevent cleanup re-deletion
                    role = undefined
                })
                test('Cannot otherwise', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestB2BAppRole(employee, role.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestB2BAppRole(anotherManager, role.id)
                    })
                })
            })
            test('App account cannot', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BAppRole(serviceUser, role.id)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestB2BAppRole(anonymous, role.id)
                })
            })
        })
        describe('Read', () => {
            let role
            let anotherRole
            beforeAll(async () => {
                [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
                const [anotherOrgRole] = await createTestOrganizationEmployeeRole(admin, manager.organization);
                [anotherRole] = await createTestB2BAppRole(admin, connectedApp, anotherOrgRole)
            })
            afterAll(async () => {
                await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await updateTestB2BAppRole(admin, anotherRole.id, {
                    deletedAt: dayjs().toISOString(),
                })
            })
            test('Admin can', async () => {
                const roles = await B2BAppRole.getAll(admin, { id_in: [role.id, anotherRole.id] })
                expect(roles).toHaveLength(2)
                expect(roles).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: role.id }),
                    expect.objectContaining({ id: anotherRole.id }),
                ]))
            })
            test('Support can', async () => {
                const roles = await B2BAppRole.getAll(support, { id_in: [role.id, anotherRole.id] })
                expect(roles).toHaveLength(2)
                expect(roles).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: role.id }),
                    expect.objectContaining({ id: anotherRole.id }),
                ]))
            })
            describe('Organization employee', () => {
                test('Can read all B2BAppRoles related to organization if has "canManageRoles" in OrganizationEmployee role', async () => {
                    const roles = await B2BAppRole.getAll(manager, { id_in: [role.id, anotherRole.id] })
                    expect(roles).toHaveLength(2)
                    expect(roles).toEqual(expect.arrayContaining([
                        expect.objectContaining({ id: role.id }),
                        expect.objectContaining({ id: anotherRole.id }),
                    ]))
                })
                test('Can read only B2BAppRoles related to OrganizationEmployeeRoles of existing employees otherwise', async () => {
                    const roles = await B2BAppRole.getAll(employee, { id_in: [role.id, anotherRole.id] })
                    expect(roles).toHaveLength(1)
                    expect(roles).toEqual([expect.objectContaining({ id: role.id })])
                })
                test('Cannot see roles from other organizations', async () => {
                    const roles = await B2BAppRole.getAll(anotherManager, { id_in: [role.id, anotherRole.id] })
                    expect(roles).toHaveLength(0)
                })
            })
            test('App account can read all B2BAppRoles related to accessed app', async () => {
                const [anotherApp] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
                await createTestB2BAppContext(manager, anotherApp, manager.organization)
                const [anotherAppRole] = await createTestB2BAppRole(manager, anotherApp, employee.role)

                const roles = await B2BAppRole.getAll(serviceUser, { id_in: [role.id, anotherRole.id, anotherAppRole.id] })
                expect(roles).toHaveLength(2)
                expect(roles).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: role.id }),
                    expect.objectContaining({ id: anotherRole.id }),
                ]))
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await B2BAppRole.getAll(anonymous, {})
                })
            })
        })
        describe('Delete', () => {
            test('Hard-deleted is prohibited', async () => {
                const [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(admin, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(support, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(manager, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(employee, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(serviceUser, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(anonymous, role.id)
                })

                // Cleanup
                await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
            })
        })
    })
    describe('Constraints', () => {
        test('Each OrganizationEmployeeRole can have a maximum of 1 existing B2BAppRole for each B2BApp', async () => {
            const [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
            expect(role).toHaveProperty('id')

            await catchErrorFrom(async () => {
                await createTestB2BAppRole(admin, connectedApp, employee.role)
            }, (caught) => {
                expect(caught.errors[0].message).toContain('duplicate key value violates unique constraint "b2bAppRole_unique_app_role"')
            })

            await updateTestB2BAppRole(admin, role.id, {
                deletedAt: dayjs().toISOString(),
            })

            const [newRole] = await createTestB2BAppRole(admin, connectedApp, employee.role)
            expect(role).toHaveProperty('id')

            // Cleanup
            await updateTestB2BAppRole(admin, newRole.id, {
                deletedAt: dayjs().toISOString(),
            })
        })
    })
    describe('Fields', () => {
        describe('app', () => {
            test('Field cannot be changed', async () => {
                const [role] = await createTestB2BAppRole(manager, connectedApp, employee.role)
                const [anotherApp] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })

                await catchErrorFrom(async () => {
                    await updateTestB2BAppRole(admin, role.id, {
                        app: { connect: { id: anotherApp.id } },
                    })
                }, (caught) => {
                    expect(caught.errors[0].message).toContain('Field "app" is not defined by type "B2BAppRoleUpdateInput"')
                })

                // Cleanup
                await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
            })
        })
        describe('role', () => {
            test('Field cannot be changed', async () => {
                const [role] = await createTestB2BAppRole(manager, connectedApp, employee.role)
                const [anotherOrgRole] = await createTestOrganizationEmployeeRole(admin, manager.organization)

                await catchErrorFrom(async () => {
                    await updateTestB2BAppRole(admin, role.id, {
                        role: { connect: { id: anotherOrgRole.id } },
                    })
                }, (caught) => {
                    expect(caught.errors[0].message).toContain('Field "role" is not defined by type "B2BAppRoleUpdateInput"')
                })

                // Cleanup
                await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
            })
        })
        describe('permissions', () => {
            describe('Must contains all keys from app\'s B2BAppPermissions',  () => {
                let app
                const firstPermissionKey = generatePermissionKey()
                const secondPermissionKey = generatePermissionKey()
                beforeAll(async () => {
                    [app] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
                    await createTestB2BAppContext(manager, app, manager.organization)
                    await createTestB2BAppPermission(admin, app, { key: firstPermissionKey })
                    await createTestB2BAppPermission(admin, app, { key: secondPermissionKey })
                    const [permissionToDelete] = await createTestB2BAppPermission(admin, app)
                    await updateTestB2BAppPermission(admin, permissionToDelete.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                })

                const invalidCases = [
                    ['Not all keys', { [firstPermissionKey]: true }],
                    ['Additional keys', { [firstPermissionKey]: true, [secondPermissionKey]: false, [generatePermissionKey()]: true }],
                    ['Invalid datatype (1)', ['some array valid JSON']],
                    ['Invalid datatype (2)', 'string is also valid JSON'],
                    ['Invalid key values', { [firstPermissionKey]: true, [secondPermissionKey]: 'that\'s not boolean' }],
                ]

                test.each(invalidCases)('%p', async (_, payload) => {
                    await expectToThrowGQLError(async () => {
                        await createTestB2BAppRole(manager, connectedApp, employee.role, {
                            permissions: payload,
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: INVALID_PERMISSIONS_ERROR,
                    })

                    const correctPayload = {
                        [firstPermissionKey]: faker.datatype.boolean(),
                        [secondPermissionKey]: faker.datatype.boolean(),
                    }
                    const [role] = await createTestB2BAppRole(manager, app, employee.role, {
                        permissions: correctPayload,
                    })
                    expect(role).toHaveProperty('permissions', correctPayload)

                    await expectToThrowGQLError(async () => {
                        await updateTestB2BAppRole(manager, role.id, {
                            permissions: payload,
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: INVALID_PERMISSIONS_ERROR,
                    })

                    const [deleted] = await updateTestB2BAppRole(manager, role.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    expect(deleted).toHaveProperty('deletedAt')
                    expect(deleted.deletedAt).not.toBeNull()
                })
            })
        })
    })
    describe('Validations', () => {
        test('Miniapp from "app" field must be connected organization from "role" field', async () => {
            const [anotherApp] = await createTestB2BApp(support)
            await expectToThrowGQLError(async () => {
                await createTestB2BAppRole(manager, anotherApp, employee.role)
            }, {
                code: 'BAD_USER_INPUT',
                type: APP_NOT_CONNECTED_ERROR,
            })
            const [inProgressCtx] = await createTestB2BAppContext(support, anotherApp, manager.organization, {
                status: CONTEXT_IN_PROGRESS_STATUS,
            })
            await expectToThrowGQLError(async () => {
                await createTestB2BAppRole(manager, anotherApp, employee.role)
            }, {
                code: 'BAD_USER_INPUT',
                type: APP_NOT_CONNECTED_ERROR,
            })
            await updateTestB2BAppContext(support, inProgressCtx.id, {
                status: CONTEXT_FINISHED_STATUS,
                deletedAt: dayjs().toISOString(),
            })
            await expectToThrowGQLError(async () => {
                await createTestB2BAppRole(manager, anotherApp, employee.role)
            }, {
                code: 'BAD_USER_INPUT',
                type: APP_NOT_CONNECTED_ERROR,
            })
        })
    })
    describe('Tasks', () => {
        describe('createDefaultB2BAppRoles', () => {
            let user
            let managerRole
            let anotherManagerRole
            let nonManagerRole
            let organization
            beforeAll(async () => {
                user = await makeClientWithNewRegisteredAndLoggedInUser();
                [organization] = await registerNewOrganization(user);
                [managerRole] = await createTestOrganizationEmployeeRole(admin, organization, {
                    canManageB2BApps: true,
                });
                [anotherManagerRole] = await createTestOrganizationEmployeeRole(admin, organization, {
                    canManageB2BApps: true,
                });
                [nonManagerRole] = await createTestOrganizationEmployeeRole(admin, organization, {
                    canManageB2BApps: false,
                })
            })
            describe('Must create default B2BAppRole for all roles with "canManageB2BApps" flag', () => {
                test('Self-connection', async () => {
                    const [app] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
                    const [ctx] = await createTestB2BAppContext(user, app, organization)
                    expect(ctx).toHaveProperty('status', CONTEXT_FINISHED_STATUS)

                    await waitFor(async () => {
                        const roles = await B2BAppRole.getAll(user, {
                            app: { id: app.id },
                            role: { id_in: [managerRole.id, anotherManagerRole.id, nonManagerRole.id] },
                        })
                        expect(roles).toHaveLength(2)
                        expect(roles).toEqual(expect.arrayContaining([
                            expect.objectContaining({ role: { id: managerRole.id }, app: { id: app.id } }),
                            expect.objectContaining({ role: { id: anotherManagerRole.id }, app: { id: app.id } }),
                        ]))
                    })
                })
                test('Connection with support', async () => {
                    const [app] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_IN_PROGRESS_STATUS })
                    const [ctx] = await createTestB2BAppContext(user, app, organization)
                    expect(ctx).toHaveProperty('status', CONTEXT_IN_PROGRESS_STATUS)

                    // Creating role after connection is requested, but before its finished
                    const [newRole] = await createTestOrganizationEmployeeRole(admin, organization, {
                        canManageB2BApps: true,
                    })

                    await waitFor(async () => {
                        const roles = await B2BAppRole.getAll(user, {
                            app: { id: app.id },
                            role: { id_in: [managerRole.id, anotherManagerRole.id, nonManagerRole.id, newRole.id] },
                        })
                        expect(roles).toHaveLength(0)
                    })

                    await updateTestB2BAppContext(support, ctx.id, {
                        status: CONTEXT_FINISHED_STATUS,
                    })

                    await waitFor(async () => {
                        const roles = await B2BAppRole.getAll(user, {
                            app: { id: app.id },
                            role: { id_in: [managerRole.id, anotherManagerRole.id, nonManagerRole.id, newRole.id] },
                        })
                        expect(roles).toHaveLength(3)
                        expect(roles).toEqual(expect.arrayContaining([
                            expect.objectContaining({ role: { id: managerRole.id }, app: { id: app.id } }),
                            expect.objectContaining({ role: { id: anotherManagerRole.id }, app: { id: app.id } }),
                            expect.objectContaining({ role: { id: newRole.id }, app: { id: app.id } }),
                        ]))
                    })
                })
            })
            test('Must not re-create roles if some exist', async () => {
                const [app] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
                const [ctx] = await createTestB2BAppContext(user, app, organization)
                expect(ctx).toHaveProperty('status', CONTEXT_FINISHED_STATUS)

                let rolesInitialIds = []

                await waitFor(async () => {
                    const roles = await B2BAppRole.getAll(user, {
                        app: { id: app.id },
                        role: { id_in: [managerRole.id, anotherManagerRole.id, nonManagerRole.id] },
                    })
                    expect(roles).toHaveLength(2)
                    expect(roles).toEqual(expect.arrayContaining([
                        expect.objectContaining({ role: { id: managerRole.id }, app: { id: app.id } }),
                        expect.objectContaining({ role: { id: anotherManagerRole.id }, app: { id: app.id } }),
                    ]))
                    rolesInitialIds = roles.map(role => role.id)
                })

                expect(rolesInitialIds).toHaveLength(2)
                // Support temporally disconnect app (for example for debts)
                await updateTestB2BAppContext(support, ctx.id, {
                    status: CONTEXT_IN_PROGRESS_STATUS,
                })
                // Meanwhile new role was created
                const [newRole] = await createTestOrganizationEmployeeRole(admin, organization, {
                    canManageB2BApps: true,
                })
                // Support resume app usage by setting status
                await updateTestB2BAppContext(support, ctx.id, {
                    status: CONTEXT_FINISHED_STATUS,
                })

                await waitFor(async () => {
                    const roles = await B2BAppRole.getAll(user, {
                        app: { id: app.id },
                        role: { id_in: [managerRole.id, anotherManagerRole.id, nonManagerRole.id, newRole.id] },
                    })
                    expect(roles).toHaveLength(3)
                    expect(roles).toEqual(expect.arrayContaining([
                        ...rolesInitialIds.map(id => expect.objectContaining({ id })),
                        expect.objectContaining({ role: { id: newRole.id }, app: { id: app.id } }),
                    ]))
                })
            })
            test('All created roles should have all permissions to apps', async () => {
                const [app] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
                const firstKey = generatePermissionKey()
                const secondKey = generatePermissionKey()
                await createTestB2BAppPermission(support, app, {
                    key: firstKey,
                })
                await createTestB2BAppPermission(support, app, {
                    key: secondKey,
                })
                const [permissionToDelete] = await createTestB2BAppPermission(support, app)
                await updateTestB2BAppPermission(support, permissionToDelete.id, {
                    deletedAt: dayjs().toISOString(),
                })

                const expectedRolePermissions = {
                    [firstKey]: true,
                    [secondKey]: true,
                }

                await createTestB2BAppContext(user, app, organization)

                await waitFor(async () => {
                    const roles = await B2BAppRole.getAll(user, {
                        app: { id: app.id },
                        role: { id_in: [managerRole.id, anotherManagerRole.id] },
                    })
                    expect(roles).toHaveLength(2)
                    expect(roles).toEqual(expect.arrayContaining([
                        expect.objectContaining({ role: { id: managerRole.id }, app: { id: app.id }, permissions: expectedRolePermissions }),
                        expect.objectContaining({ role: { id: anotherManagerRole.id }, app: { id: app.id }, permissions: expectedRolePermissions }),
                    ]))
                })
            })
        })
        describe('deleteB2BAppRoles', () => {
            test('Must delete all relative B2BAppRoles when B2BAppContext is deleted', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await registerNewOrganization(user)
                const  [managerRole] = await createTestOrganizationEmployeeRole(admin, organization, {
                    canManageB2BApps: true,
                })
                const [app] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
                const [context] = await createTestB2BAppContext(user, app, organization)

                await waitFor(async () => {
                    const roles = await B2BAppRole.getAll(user, { app: { id: app.id }, role: { id: managerRole.id } })
                    expect(roles).toHaveLength(1)
                    expect(roles).toEqual(expect.arrayContaining([
                        expect.objectContaining({ app: { id: app.id }, role: { id: managerRole.id } }),
                    ]))
                })

                const [deletedCtx] = await updateTestB2BAppContext(support, context.id, {
                    deletedAt: dayjs().toISOString(),
                })
                expect(deletedCtx).toHaveProperty('deletedAt')
                expect(deletedCtx.deletedAt).not.toBeNull()

                await waitFor(async () => {
                    const roles = await B2BAppRole.getAll(user, { app: { id: app.id } })
                    expect(roles).toHaveLength(0)
                })
            })
        })
        describe('updateB2BAppRolesPermissions', () => {
            test('Must update app-related B2BAppRoles when B2BAppPermission is created, updated or soft-deleted', async () => {
                const [app] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
                await createTestB2BAppAccessRight(support, serviceUser.user, app)
                await createTestB2BAppContext(manager, app, manager.organization)
                const [employeeRole] = await createTestB2BAppRole(manager, app, employee.role)

                await waitFor(async () => {
                    const roles = await B2BAppRole.getAll(manager, {
                        app: { id: app.id },
                        role: { id_in: [employee.role.id, manager.role.id] },
                    })
                    expect(roles).toHaveLength(2)
                    expect(roles).toEqual(expect.arrayContaining([
                        expect.objectContaining({
                            app: { id: app.id },
                            role: { id: manager.role.id },
                            permissions: {},
                        }),
                        expect.objectContaining({
                            app: { id: app.id },
                            role: { id: employee.role.id },
                            permissions: {},
                        }),
                    ]))
                })

                // Permission created -> manager receive access, employee - not
                const firstKey = generatePermissionKey()
                const secondKey = generatePermissionKey()
                const [firstPermission] = await createTestB2BAppPermission(serviceUser, app, { key: firstKey })
                await createTestB2BAppPermission(serviceUser, app, { key: secondKey })

                await waitFor(async () => {
                    const roles = await B2BAppRole.getAll(manager, {
                        app: { id: app.id },
                        role: { id_in: [employee.role.id, manager.role.id] },
                    })
                    expect(roles).toHaveLength(2)
                    expect(roles).toEqual(expect.arrayContaining([
                        expect.objectContaining({
                            app: { id: app.id },
                            role: { id: manager.role.id },
                            permissions: { [firstKey]: true, [secondKey]: true },
                        }),
                        expect.objectContaining({
                            app: { id: app.id },
                            role: { id: employee.role.id },
                            permissions: { [firstKey]: false, [secondKey]: false },
                        }),
                    ]))
                })

                // Manager granted access to some features
                const [updatedRole] = await updateTestB2BAppRole(manager, employeeRole.id, {
                    permissions: { [firstKey]: true, [secondKey]: false },
                })
                expect(updatedRole).toHaveProperty('permissions', { [firstKey]: true, [secondKey]: false })

                // Miniapp decided to expand feature functionality, so it rename key to be more verbose
                // Expected keys to be renamed, but values to be the same as before
                const newKey = generatePermissionKey()
                await updateTestB2BAppPermission(serviceUser, firstPermission.id, {
                    key: newKey,
                })

                await waitFor(async () => {
                    const roles = await B2BAppRole.getAll(manager, {
                        app: { id: app.id },
                        role: { id_in: [employee.role.id, manager.role.id] },
                    })
                    expect(roles).toHaveLength(2)
                    expect(roles).toEqual(expect.arrayContaining([
                        expect.objectContaining({
                            app: { id: app.id },
                            role: { id: manager.role.id },
                            permissions: { [newKey]: true, [secondKey]: true },
                        }),
                        expect.objectContaining({
                            app: { id: app.id },
                            role: { id: employee.role.id },
                            permissions: { [newKey]: true, [secondKey]: false },
                        }),
                    ]))
                })

                // Miniapp decided to cut off feature, since it has no usage, so it deletes related permission
                // Expected deleted permission to be deleted from roles as well
                await updateTestB2BAppPermission(serviceUser, firstPermission.id, {
                    deletedAt: dayjs().toISOString(),
                })

                await waitFor(async () => {
                    const roles = await B2BAppRole.getAll(manager, {
                        app: { id: app.id },
                        role: { id_in: [employee.role.id, manager.role.id] },
                    })
                    expect(roles).toHaveLength(2)
                    expect(roles).toEqual(expect.arrayContaining([
                        expect.objectContaining({
                            app: { id: app.id },
                            role: { id: manager.role.id },
                            permissions: { [secondKey]: true },
                        }),
                        expect.objectContaining({
                            app: { id: app.id },
                            role: { id: employee.role.id },
                            permissions: { [secondKey]: false },
                        }),
                    ]))
                })
            })
        })
    })
})
