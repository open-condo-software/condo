/**
 * Generated by `createschema miniapp.B2BAppRole 'app:Relationship:B2BApp:CASCADE; role:Relationship:OrganizationEmployeeRole:CASCADE; permissions:Json;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const {
    makeLoggedInAdminClient,
    makeClient,
    catchErrorFrom,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowGQLError,
    expectToThrowValidationFailureError,
} = require('@open-condo/keystone/test.utils')

const {
    B2BAppRole,
    createTestB2BAppRole,
    updateTestB2BAppRole,
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRight,
    createTestB2BAppPermission,
    updateTestB2BAppContext,
    generatePermissionKey,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    makeEmployeeUserClientWithAbilities,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

const {
    CONTEXT_FINISHED_STATUS,
    APP_NOT_CONNECTED_ERROR,
    CONTEXT_IN_PROGRESS_STATUS,
} = require('../constants')


describe('B2BAppRole', () => {
    let admin
    let support
    let manager
    let employee
    let anotherManager
    let serviceUser
    let anonymous
    let connectedApp
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        manager = await makeEmployeeUserClientWithAbilities({
            canManageIntegrations: true,
            canManageRoles: true,
        })

        const [anotherRole] = await createTestOrganizationEmployeeRole(admin, manager.organization, {
            canManageRoles: false,
        })
        employee = await makeClientWithNewRegisteredAndLoggedInUser()
        const [emp] = await createTestOrganizationEmployee(admin, manager.organization, employee.user, anotherRole)
        employee.employee = emp
        employee.organization = manager.organization
        employee.role = anotherRole

        anotherManager = await makeEmployeeUserClientWithAbilities({
            canManageIntegrations: true,
            canManageRoles: true,
        });
        

        [connectedApp] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
        await createTestB2BAppContext(manager, connectedApp, manager.organization)
        await createTestB2BAppContext(anotherManager, connectedApp, anotherManager.organization)

        serviceUser = await makeClientWithServiceUser()
        await createTestB2BAppAccessRight(support, serviceUser.user, connectedApp)

        anonymous = await makeClient()
    })
    describe('CRUD tests', () => {
        describe('Create', () => {
            let role
            afterEach(async () => {
                if (role) {
                    await updateTestB2BAppRole(admin, role.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    role = undefined
                }
            })
            test('Admin can', async () => {
                [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
                expect(role).toHaveProperty('id')
            })
            test('Support can', async () => {
                [role] = await createTestB2BAppRole(support, connectedApp, employee.role)
                expect(role).toHaveProperty('id')
            })
            describe('Organization employee', () => {
                test('Can if has "canManageRole" in his role', async () => {
                    [role] = await createTestB2BAppRole(manager, connectedApp, employee.role)
                    expect(role).toHaveProperty('id')
                })
                test('Cannot otherwise', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestB2BAppRole(employee, connectedApp, employee.role)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestB2BAppRole(anotherManager, connectedApp, employee.role)
                    })
                })
            })
            test('App account cannot', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BAppRole(serviceUser, connectedApp, employee.role)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestB2BAppRole(anonymous, connectedApp, employee.role)
                })
            })
        })
        describe('Update', () => {
            let role
            beforeEach(async () => {
                [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
            })
            afterEach(async () => {
                if (role) {
                    await updateTestB2BAppRole(admin, role.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    role = undefined
                }
            })
            test('Admin can', async () => {
                const [updated] = await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
                expect(updated).toHaveProperty('deletedAt')
                expect(updated.deletedAt).not.toBeNull()
                // Prevent cleanup re-deletion
                role = undefined
            })
            test('Support can', async () => {
                const [updated] = await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
                expect(updated).toHaveProperty('deletedAt')
                expect(updated.deletedAt).not.toBeNull()
                // Prevent cleanup re-deletion
                role = undefined
            })
            describe('Organization employee', () => {
                test('Can if has "canManageRole" in his role', async () => {
                    const [updated] = await updateTestB2BAppRole(manager, role.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    expect(updated).toHaveProperty('deletedAt')
                    expect(updated.deletedAt).not.toBeNull()
                    // Prevent cleanup re-deletion
                    role = undefined
                })
                test('Cannot otherwise', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestB2BAppRole(employee, role.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestB2BAppRole(anotherManager, role.id)
                    })
                })
            })
            test('App account cannot', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BAppRole(serviceUser, role.id)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestB2BAppRole(anonymous, role.id)
                })
            })
        })
        describe('Read', () => {
            let role
            let anotherRole
            beforeAll(async () => {
                [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
                const [anotherOrgRole] = await createTestOrganizationEmployeeRole(admin, manager.organization);
                [anotherRole] = await createTestB2BAppRole(admin, connectedApp, anotherOrgRole)
            })
            afterAll(async () => {
                await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
                await updateTestB2BAppRole(admin, anotherRole.id, {
                    deletedAt: dayjs().toISOString(),
                })
            })
            test('Admin can', async () => {
                const roles = await B2BAppRole.getAll(admin, { id_in: [role.id, anotherRole.id] })
                expect(roles).toHaveLength(2)
                expect(roles).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: role.id }),
                    expect.objectContaining({ id: anotherRole.id }),
                ]))
            })
            test('Support can', async () => {
                const roles = await B2BAppRole.getAll(support, { id_in: [role.id, anotherRole.id] })
                expect(roles).toHaveLength(2)
                expect(roles).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: role.id }),
                    expect.objectContaining({ id: anotherRole.id }),
                ]))
            })
            describe('Organization employee', () => {
                test('Can read all B2BAppRoles related to organization if has "canManageRoles" in OrganizationEmployee role', async () => {
                    const roles = await B2BAppRole.getAll(manager, { id_in: [role.id, anotherRole.id] })
                    expect(roles).toHaveLength(2)
                    expect(roles).toEqual(expect.arrayContaining([
                        expect.objectContaining({ id: role.id }),
                        expect.objectContaining({ id: anotherRole.id }),
                    ]))
                })
                test('Can read only B2BAppRoles related to OrganizationEmployeeRoles of existing employees otherwise', async () => {
                    const roles = await B2BAppRole.getAll(employee, { id_in: [role.id, anotherRole.id] })
                    expect(roles).toHaveLength(1)
                    expect(roles).toEqual([expect.objectContaining({ id: role.id })])
                })
                test('Cannot see roles from other organizations', async () => {
                    const roles = await B2BAppRole.getAll(anotherManager, { id_in: [role.id, anotherRole.id] })
                    expect(roles).toHaveLength(0)
                })
            })
            test('App account can read all B2BAppRoles related to accessed app', async () => {
                const [anotherApp] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
                await createTestB2BAppContext(manager, anotherApp, manager.organization)
                const [anotherAppRole] = await createTestB2BAppRole(manager, anotherApp, employee.role)

                const roles = await B2BAppRole.getAll(serviceUser, { id_in: [role.id, anotherRole.id, anotherAppRole.id] })
                expect(roles).toHaveLength(2)
                expect(roles).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: role.id }),
                    expect.objectContaining({ id: anotherRole.id }),
                ]))
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await B2BAppRole.getAll(anonymous, {})
                })
            })
        })
        describe('Delete', () => {
            test('Hard-deleted is prohibited', async () => {
                const [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(admin, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(support, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(manager, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(employee, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(serviceUser, role.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAppRole.delete(anonymous, role.id)
                })

                // Cleanup
                await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
            })
        })
    })
    describe('Constraints', () => {
        test('Each OrganizationEmployeeRole can have a maximum of 1 existing B2BAppRole for each B2BApp', async () => {
            const [role] = await createTestB2BAppRole(admin, connectedApp, employee.role)
            expect(role).toHaveProperty('id')

            await catchErrorFrom(async () => {
                await createTestB2BAppRole(admin, connectedApp, employee.role)
            }, (caught) => {
                expect(caught.errors[0].message).toContain('duplicate key value violates unique constraint "b2bAppRole_unique_app_role"')
            })

            await updateTestB2BAppRole(admin, role.id, {
                deletedAt: dayjs().toISOString(),
            })

            const [newRole] = await createTestB2BAppRole(admin, connectedApp, employee.role)
            expect(role).toHaveProperty('id')

            // Cleanup
            await updateTestB2BAppRole(admin, newRole.id, {
                deletedAt: dayjs().toISOString(),
            })
        })
    })
    describe('Fields', () => {
        describe('app', () => {
            test('Field cannot be changed', async () => {
                const [role] = await createTestB2BAppRole(manager, connectedApp, employee.role)
                const [anotherApp] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })

                await catchErrorFrom(async () => {
                    await updateTestB2BAppRole(admin, role.id, {
                        app: { connect: { id: anotherApp.id } },
                    })
                }, (caught) => {
                    expect(caught.errors[0].message).toContain('Field "app" is not defined by type "B2BAppRoleUpdateInput"')
                })

                // Cleanup
                await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
            })
        })
        describe('role', () => {
            test('Field cannot be changed', async () => {
                const [role] = await createTestB2BAppRole(manager, connectedApp, employee.role)
                const [anotherOrgRole] = await createTestOrganizationEmployeeRole(admin, manager.organization)

                await catchErrorFrom(async () => {
                    await updateTestB2BAppRole(admin, role.id, {
                        role: { connect: { id: anotherOrgRole.id } },
                    })
                }, (caught) => {
                    expect(caught.errors[0].message).toContain('Field "role" is not defined by type "B2BAppRoleUpdateInput"')
                })

                // Cleanup
                await updateTestB2BAppRole(admin, role.id, {
                    deletedAt: dayjs().toISOString(),
                })
            })
        })
        describe('permissions', () => {
            describe('Must contains all keys from app\'s B2BAppPermissions',  () => {
                let app
                const firstPermissionKey = generatePermissionKey()
                const secondPermissionKey = generatePermissionKey()
                beforeAll(async () => {
                    [app] = await createTestB2BApp(support, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
                    await createTestB2BAppContext(manager, app, manager.organization)
                    await createTestB2BAppPermission(admin, app, { key: firstPermissionKey })
                    await createTestB2BAppPermission(admin, app, { key: secondPermissionKey })
                })

                const invalidCases = [
                    ['Not all keys', { [firstPermissionKey]: true }],
                    ['Additional keys', { [firstPermissionKey]: true, [secondPermissionKey]: false, [generatePermissionKey()]: true }],
                    ['Invalid datatype (1)', ['some array valid JSON']],
                    ['Invalid datatype (2)', 'string is also valid JSON'],
                    ['Invalid key values', { [firstPermissionKey]: true, [secondPermissionKey]: 'that\'s not boolean' }],
                ]

                test.each(invalidCases)('%p', async (_, payload) => {
                    await expectToThrowValidationFailureError(async () => {
                        await createTestB2BAppRole(manager, connectedApp, employee.role, {
                            permissions: payload,
                        })
                    }, 'permissions field validation error. JSON not in the correct format')

                    const correctPayload = {
                        [firstPermissionKey]: faker.datatype.boolean(),
                        [secondPermissionKey]: faker.datatype.boolean(),
                    }
                    const [role] = await createTestB2BAppRole(manager, app, employee.role, {
                        permissions: correctPayload,
                    })
                    expect(role).toHaveProperty('permissions', correctPayload)

                    await expectToThrowValidationFailureError(async () => {
                        await updateTestB2BAppRole(manager, role.id, {
                            permissions: payload,
                        })
                    }, 'permissions field validation error. JSON not in the correct format')

                    const [deleted] = await updateTestB2BAppRole(manager, role.id, {
                        deletedAt: dayjs().toISOString(),
                    })
                    expect(deleted).toHaveProperty('deletedAt')
                    expect(deleted.deletedAt).not.toBeNull()
                })
            })
        })
    })
    describe('Validations', () => {
        test('Miniapp from "app" field must be connected organization from "role" field', async () => {
            const [anotherApp] = await createTestB2BApp(support)
            await expectToThrowGQLError(async () => {
                await createTestB2BAppRole(manager, anotherApp, employee.role)
            }, {
                code: 'BAD_USER_INPUT',
                type: APP_NOT_CONNECTED_ERROR,
            })
            const [inProgressCtx] = await createTestB2BAppContext(support, anotherApp, manager.organization, {
                status: CONTEXT_IN_PROGRESS_STATUS,
            })
            await expectToThrowGQLError(async () => {
                await createTestB2BAppRole(manager, anotherApp, employee.role)
            }, {
                code: 'BAD_USER_INPUT',
                type: APP_NOT_CONNECTED_ERROR,
            })
            await updateTestB2BAppContext(support, inProgressCtx.id, {
                status: CONTEXT_FINISHED_STATUS,
                deletedAt: dayjs().toISOString(),
            })
            await expectToThrowGQLError(async () => {
                await createTestB2BAppRole(manager, anotherApp, employee.role)
            }, {
                code: 'BAD_USER_INPUT',
                type: APP_NOT_CONNECTED_ERROR,
            })
        })
    })
})
