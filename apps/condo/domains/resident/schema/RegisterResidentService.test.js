/**
 * Generated by `createservice property.RegisterResidentService --type mutations`
 */

const { faker } = require('@faker-js/faker')
const sample = require('lodash/sample')

const {
    makeLoggedInAdminClient, makeClient, UUID_RE, waitFor,
    expectToThrowAuthenticationErrorToResult, expectToThrowAccessDeniedErrorToResult,
    expectToThrowGQLErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { MANAGING_COMPANY_TYPE, SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const {
    registerNewOrganization,
    makeClientWithRegisteredOrganization,
} = require('@condo/domains/organization/utils/testSchema/Organization')
const { FLAT_UNIT_TYPE, PARKING_UNIT_TYPE, UNIT_TYPES } = require('@condo/domains/property/constants/common')
const { buildingMapJson } = require('@condo/domains/property/constants/property')
const {
    createTestProperty,
    updateTestProperty,
    makeClientWithResidentAccessAndProperty,
    Property,
} = require('@condo/domains/property/utils/testSchema')
const { buildFakeAddressAndMeta } = require('@condo/domains/property/utils/testSchema/factories')
const { registerResidentByTestClient, Resident } = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithResidentUser,
    makeClientWithSupportUser,
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithStaffUser,
} = require('@condo/domains/user/utils/testSchema')

describe('manageResidentToPropertyAndOrganizationConnections worker task tests', () => {
    let propertyPayload
    let residentAddress
    let residentAddressMeta
    beforeEach(() => {
        const { address, addressMeta } = buildFakeAddressAndMeta(true)
        residentAddress = address
        residentAddressMeta = addressMeta
        propertyPayload = { address, addressMeta: { ...addressMeta, value: address, map: buildingMapJson } }
    })
    it('Must connect existing residents with no property relation to newly create property', async () => {
        const residentUser = await makeClientWithResidentUser()
        const [newResident] = await registerResidentByTestClient(residentUser, { address: residentAddress, addressMeta: residentAddressMeta })
        const staffUser = await makeClientWithRegisteredOrganization()
        const [property] = await createTestProperty(staffUser, staffUser.organization, propertyPayload)

        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: newResident.id })
            expect(resident.organization).not.toBeNull()
            expect(resident.organization.id).toEqual(staffUser.organization.id)
            expect(resident.property.id).toEqual(property.id)
        })
    })
    it(`Must connect resident to the oldest existing property from organization with type "${MANAGING_COMPANY_TYPE}"`, async () => {
        const residentUser = await makeClientWithResidentUser()
        const support = await makeClientWithSupportUser()

        const deletedPropClient = await makeClientWithRegisteredOrganization()
        const serviceProviderClient = await makeClientWithNewRegisteredAndLoggedInUser()
        const [serviceOrg] = await registerNewOrganization(serviceProviderClient, { type: SERVICE_PROVIDER_TYPE })
        const organizationClient = await makeClientWithRegisteredOrganization()
        const newerClient = await makeClientWithRegisteredOrganization()

        // Delete older property
        const [propertyToDelete] = await createTestProperty(deletedPropClient, deletedPropClient.organization, propertyPayload)
        const [deletedProperty] = await Property.softDelete(deletedPropClient, propertyToDelete.id)
        expect(deletedProperty).toHaveProperty('deletedAt')
        expect(deletedProperty.deletedAt).not.toBeNull()

        // Non-managing property
        const [serviceProperty] = await createTestProperty(serviceProviderClient, serviceOrg, propertyPayload)
        expect(serviceProperty).toBeDefined()

        // Target property
        const [targetProperty] = await createTestProperty(organizationClient, organizationClient.organization, propertyPayload)
        expect(targetProperty).toBeDefined()

        const [registeredResident] = await registerResidentByTestClient(residentUser, { address: residentAddress, addressMeta: residentAddressMeta })

        // NOTE: Should connect to target
        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: registeredResident.id })

            expect(resident.organization.id).toEqual(organizationClient.organization.id)
            expect(resident.property.id).toEqual(targetProperty.id)
        })

        // Create newer property
        const [newerProperty] = await createTestProperty(newerClient, newerClient.organization, propertyPayload)
        expect(newerProperty).toBeDefined()

        // NOTE: Should still be connected to target
        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: registeredResident.id })

            expect(resident.organization.id).toEqual(organizationClient.organization.id)
            expect(resident.property.id).toEqual(targetProperty.id)
        })

        // Restore older property
        await updateTestProperty(support, deletedProperty.id, { deletedAt: null })

        // NOTE: Should reconnect to old one
        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: registeredResident.id })

            expect(resident.organization.id).toEqual(deletedPropClient.organization.id)
            expect(resident.property.id).toEqual(deletedProperty.id)
        })

        // Delete old and target again
        await Property.softDelete(organizationClient, targetProperty.id)
        await Property.softDelete(deletedPropClient, deletedProperty.id)

        // NOTE: Should reconnect to newer one
        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: registeredResident.id })

            expect(resident.organization.id).toEqual(newerClient.organization.id)
            expect(resident.property.id).toEqual(newerProperty.id)
        })

        // Delete newer property, so only service provider one exists
        await Property.softDelete(newerClient, newerProperty.id)

        // NOTE: Should disconnect property and organization
        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: registeredResident.id })

            expect(resident.organization).toBeNull()
            expect(resident.property).toBeNull()
        })
    })
    it('Must prioritize approved properties, even if they are newer', async () => {
        const support = await makeClientWithSupportUser()
        const residentUser = await makeClientWithResidentUser()

        const olderPropertyClient = await makeClientWithRegisteredOrganization()
        const newerPropertyClient = await makeClientWithRegisteredOrganization()

        const [olderProperty] = await createTestProperty(olderPropertyClient, olderPropertyClient.organization, propertyPayload)
        const [newerProperty] = await createTestProperty(newerPropertyClient, newerPropertyClient.organization, propertyPayload)

        const [registeredResident] = await registerResidentByTestClient(residentUser, { address: residentAddress, addressMeta: residentAddressMeta })

        // NOTE: Should connect to older property
        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: registeredResident.id })

            expect(resident.organization.id).toEqual(olderPropertyClient.organization.id)
            expect(resident.property.id).toEqual(olderProperty.id)
        })

        // The newer property company requests support for ownership approval by providing a document of management rights
        const [approvedProperty] = await updateTestProperty(support, newerProperty.id, { isApproved: true })
        expect(approvedProperty).toHaveProperty('isApproved', true)

        // NOTE: After that all residents reconnect to newer property, since it's approved now
        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: registeredResident.id })

            expect(resident.organization.id).toEqual(newerPropertyClient.organization.id)
            expect(resident.property.id).toEqual(newerProperty.id)
        })
    })
    it('Must relink residents on property address change', async () => {
        const { address, addressMeta } = buildFakeAddressAndMeta(true)
        const anotherResidentAddress = address
        const anotherResidentAddressMeta = addressMeta
        const anotherPropertyPayload = { address, addressMeta: { ...addressMeta, value: address, map: buildingMapJson } }

        const residentUser = await makeClientWithResidentUser()
        const anotherResidentUser = await makeClientWithResidentUser()

        const olderPropertyClient = await makeClientWithRegisteredOrganization()
        const newerPropertyClient = await makeClientWithRegisteredOrganization()

        const [olderProperty] = await createTestProperty(olderPropertyClient, olderPropertyClient.organization, propertyPayload)
        const [newerProperty] = await createTestProperty(newerPropertyClient, newerPropertyClient.organization, propertyPayload)

        const [registeredResident] = await registerResidentByTestClient(residentUser, { address: residentAddress, addressMeta: residentAddressMeta })
        const [anotherRegisteredResident] = await registerResidentByTestClient(anotherResidentUser, { address: anotherResidentAddress, addressMeta: anotherResidentAddressMeta })

        // NOTE: First resident should connect to the oldest property, another to nothing, since no properties found
        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: registeredResident.id })
            const anotherResident = await Resident.getOne(anotherResidentUser, { id: anotherRegisteredResident.id })

            expect(resident.organization.id).toEqual(olderPropertyClient.organization.id)
            expect(resident.property.id).toEqual(olderProperty.id)
            expect(anotherResident.organization).toBeNull()
            expect(anotherResident.property).toBeNull()
        })

        // The oldest property change address
        await updateTestProperty(olderPropertyClient, olderProperty.id, anotherPropertyPayload)

        // NOTE: First resident now should be relinked to newer property, another should be linked to older one which addresses now has a match
        await waitFor(async () => {
            const resident = await Resident.getOne(residentUser, { id: registeredResident.id })
            const anotherResident = await Resident.getOne(anotherResidentUser, { id: anotherRegisteredResident.id })

            expect(resident.organization.id).toEqual(newerPropertyClient.organization.id)
            expect(resident.property.id).toEqual(newerProperty.id)
            expect(anotherResident.organization.id).toEqual(olderPropertyClient.organization.id)
            expect(anotherResident.property.id).toEqual(olderProperty.id)
        })
    })

    // Skip this test because it takes a long time
    test.skip('Must relink many residents after approve new properties', async () => {
        // Create admin for making Resident.getAll requests to fetch all residents in a single query
        // instead of making 101 separate requests from resident clients.
        const admin = await makeLoggedInAdminClient()
        const support = await makeClientWithSupportUser()
        const staffUserClient = await makeClientWithNewRegisteredAndLoggedInUser()

        const [organization] = await registerNewOrganization(staffUserClient)
        const [organization1] = await registerNewOrganization(staffUserClient)

        const [olderProperty] = await createTestProperty(staffUserClient, organization, propertyPayload)
        const [newerProperty] = await createTestProperty(staffUserClient, organization1, propertyPayload)

        const residentsInProperty = 101

        const residentIds = await Promise.all(
            Array.from({ length: residentsInProperty }).map(async () => {
                const residentUserClient = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUserClient, { address: residentAddress, addressMeta: residentAddressMeta })

                return resident.id
            })
        )

        // NOTE: Should connect to older property
        await waitFor(async () => {
            const residents = await Resident.getAll(admin, { id_in: residentIds }, { first: residentsInProperty })

            for (const resident of residents) {
                expect(resident.organization?.id).toEqual(organization.id)
                expect(resident.property?.id).toEqual(olderProperty.id)
            }
        })

        // The newer property company requests support for ownership approval by providing a document of management rights
        const [approvedProperty] = await updateTestProperty(support, newerProperty.id, { isApproved: true })
        expect(approvedProperty).toHaveProperty('isApproved', true)

        // // NOTE: After that all residents reconnect to newer property, since it's approved now
        await waitFor(async () => {
            const residents = await Resident.getAll(admin, { id_in: residentIds }, { first: residentsInProperty })

            for (const resident of residents) {
                expect(resident.organization?.id).toEqual(organization1.id)
                expect(resident.property?.id).toEqual(newerProperty.id)
            }
        }, { timeout: 1000 * 60 })
    })
})

describe('RegisterResidentService', () => {
    test('can be executed by user with "resident" type', async () => {
        const userClient = await makeClientWithResidentUser()
        const [obj, attrs] = await registerResidentByTestClient(userClient)
        expect(obj.id).toMatch(UUID_RE)
        expect(obj.dv).toEqual(1)
        expect(obj.sender).toEqual(attrs.sender)
        expect(obj.v).toEqual(1)
        expect(obj.address).toEqual(attrs.address)
        expect(obj.user.id).toEqual(userClient.user.id)
        expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
    })

    test('cannot be executed by user', async () => {
        const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
        await expectToThrowAccessDeniedErrorToResult(async () => {
            await registerResidentByTestClient(userClient)
        })
    })

    test('anonymous: execute', async () => {
        const client = await makeClient()
        await expectToThrowAuthenticationErrorToResult(async () => {
            await registerResidentByTestClient(client)
        })
    })

    test('admin: execute', async () => {
        const adminClient = await makeLoggedInAdminClient()
        const [obj, attrs] = await registerResidentByTestClient(adminClient)
        expect(obj.id).toMatch(UUID_RE)
        expect(obj.dv).toEqual(1)
        expect(obj.sender).toEqual(attrs.sender)
        expect(obj.v).toEqual(1)
        expect(obj.address).toEqual(attrs.address)
        expect(obj.user.id).toEqual(adminClient.user.id)
        expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
    })

    it('connects property with matched address to resident', async () => {
        const adminClient = await makeLoggedInAdminClient()

        const [organization] = await registerNewOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization, { map: buildingMapJson })

        const payload = {
            address: property.address,
            addressMeta: property.addressMeta,
        }

        const [obj, attrs] = await registerResidentByTestClient(adminClient, payload)
        expect(obj.id).toMatch(UUID_RE)
        expect(obj.dv).toEqual(1)
        expect(obj.sender).toEqual(attrs.sender)
        expect(obj.v).toEqual(1)
        expect(obj.address).toEqual(attrs.address)
        expect(obj.user.id).toEqual(adminClient.user.id)
        expect(obj.property.id).toEqual(property.id)
        expect(obj.organization.id).toEqual(organization.id)
        expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
    })

    it('connects property with matched address to resident, prefers isApproved == true', async () => {
        const adminClient = await makeLoggedInAdminClient()

        const [organization] = await registerNewOrganization(adminClient)
        const [OlderProperty] = await createTestProperty(adminClient, organization, {
            map: buildingMapJson,
        })

        const [organization2] = await registerNewOrganization(adminClient)
        const [newerButApprovedProperty] = await createTestProperty(adminClient, organization2, {
            map: buildingMapJson,
            address: OlderProperty.address,
            addressMeta: OlderProperty.addressMeta,
            isApproved: true,
        })

        const payload = {
            address: OlderProperty.address,
            addressMeta: OlderProperty.addressMeta,
        }

        const [obj, attrs] = await registerResidentByTestClient(adminClient, payload)
        expect(obj.id).toMatch(UUID_RE)
        expect(obj.dv).toEqual(1)
        expect(obj.sender).toEqual(attrs.sender)
        expect(obj.v).toEqual(1)
        expect(obj.address).toEqual(attrs.address)
        expect(obj.user.id).toEqual(adminClient.user.id)
        expect(obj.property.id).toEqual(newerButApprovedProperty.id)
        expect(obj.organization.id).toEqual(organization2.id)
        expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
    })

    it('does not connects to deleted property with matched address to resident', async () => {
        const adminClient = await makeLoggedInAdminClient()

        const [organization] = await registerNewOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization, { map: buildingMapJson })
        await Property.softDelete(adminClient, property.id)

        const payload = {
            address: property.address,
            addressMeta: property.addressMeta,
        }

        const [obj, attrs] = await registerResidentByTestClient(adminClient, payload)
        await Property.softDelete(adminClient, property.id, { deletedAt: null })

        expect(obj.address).toEqual(attrs.address)
        expect(obj.user.id).toEqual(adminClient.user.id)
        expect(obj.property).toEqual(null)
        expect(obj.organization).toEqual(null)
        expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
    })

    it('does not connects to old deleted property with matched address', async () => {
        const adminClient = await makeLoggedInAdminClient()
        const { address, addressMeta } = buildFakeAddressAndMeta(false)

        const [organization1] = await registerNewOrganization(adminClient)
        const [organization2] = await registerNewOrganization(adminClient)
        const [property1] = await createTestProperty(adminClient, organization1, { address, addressMeta, map: buildingMapJson })
        const [property2] = await createTestProperty(adminClient, organization2, { address, addressMeta, map: buildingMapJson })

        await Property.softDelete(adminClient, property1.id)

        const payload = { address, addressMeta }

        const [obj, attrs] = await registerResidentByTestClient(adminClient, payload)

        expect(obj.address).toEqual(attrs.address)
        expect(obj.user.id).toEqual(adminClient.user.id)
        expect(obj.property.id).toEqual(property2.id)
        expect(obj.organization.id).toEqual(organization2.id)
        expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
    })

    it('does not connects to new property with matched address', async () => {
        const adminClient = await makeLoggedInAdminClient()
        const { address, addressMeta } = buildFakeAddressAndMeta(false)

        const [organization1] = await registerNewOrganization(adminClient)
        const [organization2] = await registerNewOrganization(adminClient)
        const [property1] = await createTestProperty(adminClient, organization1, { address, addressMeta, map: buildingMapJson })
        await createTestProperty(adminClient, organization2, { address, addressMeta, map: buildingMapJson })

        const payload = { address, addressMeta }

        const [obj, attrs] = await registerResidentByTestClient(adminClient, payload)

        expect(obj.address).toEqual(attrs.address)
        expect(obj.user.id).toEqual(adminClient.user.id)
        expect(obj.property.id).toEqual(property1.id)
        expect(obj.organization.id).toEqual(organization1.id)
        expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
    })

    test('cannot be executed for staff', async () => {
        const staffClient = await makeClientWithStaffUser()
        await expectToThrowAccessDeniedErrorToResult(async () => {
            await registerResidentByTestClient(staffClient)
        })
    })

    it('restore deleted Resident for the same address and unitName creates new record (property not exists)', async () => {
        const userClient = await makeClientWithResidentAccessAndProperty()
        const [resident, attrs] = await registerResidentByTestClient(userClient)
        const [softDeletedResident] = await Resident.softDelete(userClient, resident.id)

        const [restoredResident] = await registerResidentByTestClient(userClient, {
            address: attrs.address,
            unitName: attrs.unitName,
        })
        expect(restoredResident.id).not.toEqual(softDeletedResident.id)
        expect(restoredResident.deletedAt).toBeNull()
        expect(restoredResident.organization).toBeNull()
        expect(restoredResident.property).toBeNull()
    })

    it('restore deleted Resident for the same address and unitName creates new record (property exists)', async () => {
        const adminClient = await makeLoggedInAdminClient()
        const userClient = await makeClientWithResidentAccessAndProperty()

        const [resident, attrs] = await registerResidentByTestClient(userClient)
        const [deletedResident] = await Resident.softDelete(userClient, resident.id)
        expect(deletedResident.id).toEqual(resident.id)
        expect(deletedResident.deletedAt).not.toBeNull()
        expect(deletedResident.organization).toEqual(null)
        expect(deletedResident.property).toEqual(null)

        const [organization] = await registerNewOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization, {
            address: attrs.address,
            addressMeta: attrs.addressMeta,
            map: buildingMapJson,
        })

        const [restoredResident] = await registerResidentByTestClient(userClient, {
            address: attrs.address,
            addressMeta: attrs.addressMeta,
            unitName: attrs.unitName,
        })
        expect(restoredResident.id).not.toEqual(resident.id)
        expect(restoredResident.deletedAt).toBeNull()
        expect(restoredResident.organization.id).toEqual(organization.id)
        expect(restoredResident.property.id).toEqual(property.id)
    })


    it('restore deleted Resident for the same address and unitName creates record with new unitName', async () => {
        const userClient = await makeClientWithResidentAccessAndProperty()
        const testUnitName = faker.random.numeric(3) + faker.random.alpha(5).toUpperCase()

        const [resident, attrs] = await registerResidentByTestClient(userClient, {
            unitName: testUnitName,
        })
        const [softDeletedResident] = await Resident.softDelete(userClient, resident.id)

        const [restoredResident, restoredAttrs] = await registerResidentByTestClient(userClient, {
            address: attrs.address,
            unitName: attrs.unitName.toLowerCase(),
        })

        expect(restoredResident.id).not.toEqual(softDeletedResident.id)
        expect(softDeletedResident.deletedAt).not.toBeNull()
        expect(restoredAttrs.unitName).toEqual(attrs.unitName.toLowerCase())
    })

    it('can not register same resident twice', async () => {
        const userClient = await makeClientWithResidentAccessAndProperty()
        const testUnitName = faker.random.numeric(3) + faker.random.alpha(5).toUpperCase()

        const [_, attrs] = await registerResidentByTestClient(userClient, {
            unitName: testUnitName,
        })

        await expectToThrowGQLErrorToResult(async () => {
            await registerResidentByTestClient(userClient, {
                address: attrs.address,
                unitName: testUnitName,
            })
        }, {
            code: 'BAD_USER_INPUT',
            type: 'ALREADY_REGISTERED',
        })
    })

    it('should set unitType field if it was passed', async () => {
        const userClient = await makeClientWithResidentUser()
        const unitType = sample(UNIT_TYPES)
        const [obj, attrs] = await registerResidentByTestClient(userClient, { unitType })

        expect(obj.id).toMatch(UUID_RE)
        expect(obj.dv).toEqual(1)
        expect(obj.sender).toEqual(attrs.sender)
        expect(obj.v).toEqual(1)
        expect(obj.address).toEqual(attrs.address)
        expect(obj.user.id).toEqual(userClient.user.id)
        expect(obj.unitType).toEqual(unitType)
    })

    it('should create new resident object if another unitType was passed to input', async () => {
        const userClient = await makeClientWithResidentUser()
        const [obj, attrs] = await registerResidentByTestClient(userClient, { unitType: FLAT_UNIT_TYPE })
        const [obj1] = await registerResidentByTestClient(userClient, {
            ...attrs,
            unitType: PARKING_UNIT_TYPE,
        })

        expect(obj.id).not.toEqual(obj1.id)
        expect(obj.address).toEqual(obj1.address)
        expect(obj.user.id).toEqual(obj1.user.id)
        expect(obj.unitName).toEqual(obj1.unitName)
        expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
        expect(obj1.unitType).toEqual(PARKING_UNIT_TYPE)
        expect(obj.unitName).toEqual(obj1.unitName)
    })
})
