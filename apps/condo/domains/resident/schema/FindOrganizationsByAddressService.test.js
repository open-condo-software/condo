/**
 * Generated by `createservice resident.FindOrganizationsByAddressService --type queries`
 */
/**
 * Generated by `createservice resident.RegisterServiceConsumerService --type mutations`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const express = require('express')

const { initTestExpressApp, getTestExpressApp, setFeatureFlag } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/acquiring/constants/context')
const { createTestAcquiringIntegrationContext, createTestAcquiringIntegration } = require('@condo/domains/acquiring/utils/testSchema')
const { HOUSING_CATEGORY_ID, REPAIR_CATEGORY_ID } = require('@condo/domains/billing/constants/constants')
const {
    ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS,
    ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS,
} = require('@condo/domains/billing/constants/onlineInteraction')
const {
    createTestBillingIntegrationOrganizationContext,
    createTestBillingIntegration,
    updateTestBillingIntegrationOrganizationContext,
} = require('@condo/domains/billing/utils/testSchema')
const { createTestBillingIntegrationAccessRight } = require('@condo/domains/billing/utils/testSchema')
const {
    TestUtils,
    BillingTestMixin,
    AcquiringTestMixin,
    ResidentTestMixin,
    MeterTestMixin,
} = require('@condo/domains/billing/utils/testSchema/testUtils')
const { DISABLE_DISCOVER_SERVICE_CONSUMERS } = require('@condo/domains/common/constants/featureflags')
const {
    CALL_METER_READING_SOURCE_ID,
} = require('@condo/domains/meter/constants/constants')
const { COLD_WATER_METER_RESOURCE_ID, ELECTRICITY_METER_RESOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { MeterReadingSource, MeterResourceOwner } = require('@condo/domains/meter/utils/testSchema')
const { createTestMeterResourceOwner } = require('@condo/domains/meter/utils/testSchema')
const { SERVICE_PROVIDER_TYPE, MANAGING_COMPANY_TYPE } = require('@condo/domains/organization/constants/common')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { updateTestProperty } = require('@condo/domains/property/utils/testSchema')
const { findOrganizationsByAddressByTestClient } = require('@condo/domains/resident/utils/testSchema')


function getOnlyResourceMeterTest (resource) {
    return {
        resource: resource,
        accountNumber: null,
        number: null,
        address: null,
    }
}

function getOnlyCategoryReceiptTest (category){
    return {
        accountNumber: null,
        category: category,
        balance: null,
        routingNumber: null,
        bankAccount: null,
        address: null,
    }
}

async function initBillingTestMixin (utils) {
    await utils.createEmployee('billing', {
        canManageIntegrations: true,
        canReadBillingReceipts: true,
        canReadPayments: true,
    })
    const [billingIntegration] = await createTestBillingIntegration(utils.clients.admin)
    const [billingContext] = await createTestBillingIntegrationOrganizationContext(utils.clients.admin, utils.organization, billingIntegration, {
        status: CONTEXT_FINISHED_STATUS,
    })
    await createTestBillingIntegrationAccessRight(utils.clients.admin, billingIntegration, utils.clients.service.user)
    utils.billingIntegration = billingIntegration
    utils.billingContext = billingContext
}

describe('FindOrganizationsByAddress', () => {

    const utils = new TestUtils([BillingTestMixin])

    beforeAll(async () => {
        await utils.init()
    })

    describe('Unified flow', () => {
        describe('General behaviour', () => {
            test('Should not return organization if acquiring context is not in finished status', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const [foundOrganizationsOnFinishedContext] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                const foundForFinishedContext = foundOrganizationsOnFinishedContext.find(({ id }) => id === utils.organization.id)
                expect(foundForFinishedContext).not.toBeUndefined()
                await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })
                const [foundOrganizationsOnInProgressContext] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                const foundForInProgressContext = foundOrganizationsOnInProgressContext.find(({ id }) => id === utils.organization.id)
                expect(foundForInProgressContext).toBeUndefined()
            })
        
            test('Should return empty array if no properties', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const wrongAddressKey = faker.datatype.uuid()
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: wrongAddressKey,
                })
                expect(foundOrganizations).toHaveLength(0)
            })

            test('Should return empty array if no meters and acquiring', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const [organization] = await createTestOrganization(utils.clients.admin)
                const [property] = await createTestProperty(utils.clients.admin, organization)
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: property.addressKey,
                })
                expect(foundOrganizations).toHaveLength(0)
            })
        })

        describe('addressKey', () => {
            test('Should return organization', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.meters).toHaveLength(0)
                expect(found.receipts).toHaveLength(0)
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return organization and receipt category', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                const utilsWithAnotherBillingContext = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                await utilsWithAnotherBillingContext.init()
                utilsWithAnotherBillingContext.organization = utils.organization
                await initBillingTestMixin(utilsWithAnotherBillingContext)
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        category: { id: HOUSING_CATEGORY_ID },
                    }),
                ])
                await utilsWithAnotherBillingContext.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        category: { id: REPAIR_CATEGORY_ID },
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found).toBeDefined()
                expect(found.meters).toHaveLength(0)
                expect(found.receipts).toHaveLength(2)
                expect(found.receipts).toEqual(expect.arrayContaining([
                    expect.objectContaining(getOnlyCategoryReceiptTest(HOUSING_CATEGORY_ID)),
                    expect.objectContaining(getOnlyCategoryReceiptTest(REPAIR_CATEGORY_ID)),
                ]))
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return organization and meter resource', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const [organization] = await createTestOrganization(utils.clients.admin)
                const [property] = await createTestProperty(utils.clients.admin, organization)
                const [meter] = await utils.createMeter({ resource: COLD_WATER_METER_RESOURCE_ID })
                await createTestMeterResourceOwner(utils.clients.admin, organization, meter.resource, {
                    address: property.address,
                })
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: property.addressKey,
                })
                const found = foundOrganizations.find(({ id }) => id === organization.id)
                expect(found.receipts).toHaveLength(0)
                expect(found.meters).toContainEqual(getOnlyResourceMeterTest(COLD_WATER_METER_RESOURCE_ID))
                expect(found.id).toEqual(organization.id)
                expect(found.name).toEqual(organization.name)
                expect(found.tin).toEqual(organization.tin)
                expect(found.type).toEqual(organization.type)
            })

            test('Should return several organizations', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const [organization] = await createTestOrganization(utils.clients.admin)
                const [billingIntegration] = await createTestBillingIntegration(utils.clients.admin)
                const [acquiringIntegration] = await createTestAcquiringIntegration(utils.clients.admin)
                await createTestAcquiringIntegrationContext(utils.clients.admin, organization, acquiringIntegration, { status: CONTEXT_FINISHED_STATUS })
                await createTestBillingIntegrationOrganizationContext(utils.clients.admin, organization, billingIntegration, { status: CONTEXT_FINISHED_STATUS })
                await createTestProperty(utils.clients.admin, organization, {
                    address: utils.property.address,
                })

                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                expect(foundOrganizations).toHaveLength(2)
            })
        })

        describe('addressKey unitName unitType', () => {
            setFeatureFlag(DISABLE_DISCOVER_SERVICE_CONSUMERS, false)

            test('Should return meter only if org is resource owner', async () => {
                const utils = new TestUtils([BillingTestMixin, AcquiringTestMixin, ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const anotherUtils = new TestUtils([BillingTestMixin, AcquiringTestMixin, ResidentTestMixin, MeterTestMixin])
                await anotherUtils.init()
                await updateTestProperty(anotherUtils.clients.admin, anotherUtils.property.id, {
                    address: utils.property.address,
                    addressMeta: utils.property.addressMeta,
                })
                const accountNumber = faker.random.alphaNumeric(16)
                const unitName = faker.random.alphaNumeric(16)
                const unitType = 'flat'
                await utils.createMeter({ unitName, accountNumber, resourceId: COLD_WATER_METER_RESOURCE_ID })
                await utils.createMeter({ unitName, accountNumber, resourceId: ELECTRICITY_METER_RESOURCE_ID })
                const meterResourceOwner = await MeterResourceOwner.getOne(utils.clients.admin, { organization: { id: utils.organization.id }, resource: { id: ELECTRICITY_METER_RESOURCE_ID } })
                await MeterResourceOwner.softDelete(utils.clients.admin, meterResourceOwner.id)
                await anotherUtils.createMeter({ unitName, accountNumber, resourceId: ELECTRICITY_METER_RESOURCE_ID })

                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    unitName,
                    unitType,
                })

                expect(foundOrganizations).toHaveLength(2)
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                const antoherFound = foundOrganizations.find(({ id }) => id === anotherUtils.organization.id)
                expect(found.receipts).toHaveLength(0)
                expect(found.meters).toHaveLength(1)
                expect(found.meters[0]).toMatchObject({
                    resource: COLD_WATER_METER_RESOURCE_ID,
                    accountNumber: accountNumber,
                    number: expect.any(String),
                    address: utils.property.address,
                })
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)

                expect(antoherFound.receipts).toHaveLength(0)
                expect(antoherFound.meters).toHaveLength(1)
                expect(antoherFound.meters[0]).toMatchObject({
                    resource: ELECTRICITY_METER_RESOURCE_ID,
                    accountNumber: accountNumber,
                    number: expect.any(String),
                    address: utils.property.address,
                })
                expect(antoherFound.id).toEqual(anotherUtils.organization.id)
                expect(antoherFound.name).toEqual(anotherUtils.organization.name)
                expect(antoherFound.tin).toEqual(anotherUtils.organization.tin)
                expect(antoherFound.type).toEqual(anotherUtils.organization.type)
            })

            test('Should return receipt if unitName and unitType matches', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const unitName = faker.random.alphaNumeric(16)
                const unitType = 'flat'
                const accountNumber = faker.random.alphaNumeric(16)
                const toPay = '1000'
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber,
                        addressMeta: { unitName, unitType },
                        toPay,
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    unitName,
                    unitType,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.receipts[0]).toMatchObject({
                    accountNumber: expect.stringMatching(accountNumber),
                    category: expect.any(String),
                    balance: expect.stringMatching(Big(toPay).toFixed(8)),
                    routingNumber: expect.any(String),
                    bankAccount: expect.any(String),
                    address: utils.property.address,
                })
            })

            test('Should return receipts from all billing contexts if unitName and unitType matches', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                const utilsWithAnotherBillingContext = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                await utilsWithAnotherBillingContext.init()
                utilsWithAnotherBillingContext.organization = utils.organization
                await initBillingTestMixin(utilsWithAnotherBillingContext)

                const unitName = faker.random.alphaNumeric(16)
                const unitType = 'flat'
                const accountNumber = faker.random.alphaNumeric(16)
                const anotherAccountNumber = faker.random.alphaNumeric(16)
                const toPay = '1000'

                // NOTE(YEgorLu): if receipts have same category, they will be squashed into one receipt
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber,
                        addressMeta: { unitName, unitType },
                        category: { id: HOUSING_CATEGORY_ID },
                        toPay,
                    }),
                ])
                await utilsWithAnotherBillingContext.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber: anotherAccountNumber,
                        category: { id: REPAIR_CATEGORY_ID },
                        addressMeta: { unitName, unitType },
                        toPay,
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    unitName,
                    unitType,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found).toBeDefined()
                expect(found.receipts).toHaveLength(2)
                expect(found.receipts).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        accountNumber: expect.stringMatching(accountNumber),
                        category: expect.any(String),
                        balance: expect.stringMatching(Big(toPay).toFixed(8)),
                        routingNumber: expect.any(String),
                        bankAccount: expect.any(String),
                        address: utils.property.address,
                    }),
                    expect.objectContaining({
                        accountNumber: expect.stringMatching(anotherAccountNumber),
                        category: expect.any(String),
                        balance: expect.stringMatching(Big(toPay).toFixed(8)),
                        routingNumber: expect.any(String),
                        bankAccount: expect.any(String),
                        address: utils.property.address,
                    }),
                ]))
            })

            test('Should return meter if unitName and unitType matches', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const accountNumber = faker.random.alphaNumeric(16)
                const unitName = faker.random.alphaNumeric(16)
                const unitType = 'flat'
                await MeterReadingSource.getAll(utils.clients.admin, { id: CALL_METER_READING_SOURCE_ID })
                const [ meter ] = await utils.createMeter({ unitName, accountNumber })
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    unitName,
                    unitType,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.receipts).toHaveLength(0)
                expect(found.meters[0]).toMatchObject({
                    resource: meter.resource.id,
                    accountNumber: accountNumber,
                    number: meter.number,
                    address: utils.property.address,
                })
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return receipt category if receipts have duplicates', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const unitName = faker.random.alphaNumeric(16)
                const unitType = 'flat'
                const accountNumber1 = faker.random.alphaNumeric(16)
                const accountNumber2 = faker.random.alphaNumeric(16)
                const toPay = '1000'
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber: accountNumber1,
                        addressMeta: { unitName, unitType },
                        toPay,
                        category: { id: HOUSING_CATEGORY_ID },
                    }),
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber: accountNumber2,
                        addressMeta: { unitName, unitType },
                        toPay,
                        category: { id: HOUSING_CATEGORY_ID },
                    }),
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber: accountNumber1,
                        addressMeta: { unitName, unitType },
                        toPay,
                        category: { id: REPAIR_CATEGORY_ID },
                    }),
                ])

                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    unitName,
                    unitType,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.receipts).toHaveLength(2)
                expect(found.receipts).toContainEqual(getOnlyCategoryReceiptTest(HOUSING_CATEGORY_ID))
                expect(found.receipts).toContainEqual({
                    accountNumber: accountNumber1,
                    category: REPAIR_CATEGORY_ID,
                    balance: Big(toPay).toFixed(8),
                    routingNumber: expect.any(String),
                    bankAccount: expect.any(String),
                    address: utils.property.address,
                })
            })

            test('Should return meter resource and receipt category if organization in black list', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                setFeatureFlag(DISABLE_DISCOVER_SERVICE_CONSUMERS, true)
                const unitName = faker.random.alphaNumeric(8)
                const unitType = 'flat'
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        category: { id: HOUSING_CATEGORY_ID },
                        address: utils.property.address,
                        addressMeta: { unitName, unitType },
                    }),
                ])
                await utils.createMeter({ unitName, unitType })
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    unitName,
                    unitType,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.meters[0]).toMatchObject({ resource: expect.any(String) })
                expect(found.receipts[0]).toMatchObject({ category: expect.any(String) })
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
                setFeatureFlag(DISABLE_DISCOVER_SERVICE_CONSUMERS, false)
            })
        })

        describe('addressKey tin accountNumber', () => {
            describe('Online interaction', () => {
                // nosemgrep: javascript.express.security.audit.express-check-csurf-middleware-usage.express-check-csurf-middleware-usage
                const app = express()
                const apiHandler = jest.fn()
                const CHECK_URL_PATH = '/check-account-number'
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                app.get(CHECK_URL_PATH, async (req, res) => {
                    return res.json(await apiHandler())
                })

                initTestExpressApp('OnlineInteraction', app)

                beforeAll(async () => {
                    await utils.init()
                    const baseUrl = getTestExpressApp('OnlineInteraction').baseUrl + CHECK_URL_PATH
                    await utils.updateBillingIntegration({ checkAccountNumberUrl: baseUrl })
                })

                afterAll(async () => {
                    await utils.updateBillingIntegration({ checkAccountNumberUrl: null })
                })

                afterEach(() => {
                    jest.clearAllMocks()
                })

                test('Should not return organization if accountNumber is not found', async () => {
                    const notExistingAccountNumber = faker.random.alphaNumeric(16)
                    apiHandler.mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS })
                    const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                        addressKey: utils.property.addressKey,
                        accountNumber: notExistingAccountNumber,
                        tin: utils.organization.tin,
                    })

                    expect(foundOrganizations).toHaveLength(0)
                })

                test('Should return organization and receipt if accountNumber is found', async () => {
                    const existingAccountNumber = faker.random.alphaNumeric(16)
                    const toPay = '1000'
                    const address = `${faker.address.cityName()} ${faker.address.streetAddress(true)}`
                    apiHandler.mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS, services: [{
                        category: HOUSING_CATEGORY_ID,
                        account: { number: existingAccountNumber },
                        bankAccount: {
                            number: faker.random.alphaNumeric(16),
                            routingNumber: faker.random.alphaNumeric(16),
                        },
                        receipt: {
                            sum: toPay,
                            address: address,
                        },
                    }] })
                    const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                        addressKey: utils.property.addressKey,
                        accountNumber: existingAccountNumber,
                        tin: utils.organization.tin,
                    })

                    const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                    expect(found.receipts[0]).toMatchObject({
                        category: HOUSING_CATEGORY_ID,
                        balance: toPay,
                        accountNumber: existingAccountNumber,
                        routingNumber: expect.any(String),
                        bankAccount: expect.any(String),
                        address: address,
                    })
                    expect(found.id).toEqual(utils.organization.id)
                    expect(found.name).toEqual(utils.organization.name)
                    expect(found.tin).toEqual(utils.organization.tin)
                    expect(found.type).toEqual(utils.organization.type)
                })

                test('Should return serviceProvider for tin and account number if service provider has no properties', async () => {
                    await utils.updateOrganization({ type: SERVICE_PROVIDER_TYPE })
                    await updateTestProperty(utils.clients.support, utils.property.id, { deletedAt: new Date().toISOString() })

                    const existingAccountNumber = faker.random.alphaNumeric(16)
                    const toPay = '1000'
                    const address = `${faker.address.cityName()} ${faker.address.streetAddress(true)}`

                    apiHandler.mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS, services: [{
                        category: HOUSING_CATEGORY_ID,
                        account: { number: existingAccountNumber },
                        bankAccount: {
                            number: faker.random.alphaNumeric(16),
                            routingNumber: faker.random.alphaNumeric(16),
                        },
                        receipt: {
                            sum: toPay,
                            address: address,
                        },
                    }] })

                    const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                        addressKey: utils.property.addressKey, // or any address key,
                        accountNumber: existingAccountNumber,
                        tin: utils.organization.tin,
                    })

                    const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                    expect(found.meters).toHaveLength(0)
                    expect(found.receipts[0]).toMatchObject({
                        category: expect.stringMatching(HOUSING_CATEGORY_ID),
                        balance: expect.stringMatching(toPay),
                        accountNumber: expect.stringMatching(existingAccountNumber),
                        routingNumber: expect.any(String),
                        bankAccount: expect.any(String),
                        address: address,
                    })
                    expect(found.id).toEqual(utils.organization.id)
                    expect(found.name).toEqual(utils.organization.name)
                    expect(found.tin).toEqual(utils.organization.tin)
                    expect(found.type).toEqual(utils.organization.type)

                    // Does not work with other types
                    await utils.updateOrganization({ type: MANAGING_COMPANY_TYPE })
                    const [foundManagingCompanies] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                        addressKey: utils.property.addressKey, // or any address key,
                        accountNumber: existingAccountNumber,
                        tin: utils.organization.tin,
                    })
                    expect(foundManagingCompanies).toHaveLength(0)
                })
            })

            test('Should not fall if no billing context and return empty receipts', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const accountNumber = faker.random.alphaNumeric(16)
                await updateTestBillingIntegrationOrganizationContext(utils.clients.admin, utils.billingContext.id, {
                    deletedAt: new Date().toISOString(),
                })
                await utils.createMeter({ accountNumber })
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber,
                    tin: utils.organization.tin,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.receipts).toHaveLength(0)
                expect(found.meters[0]).toMatchObject({
                    resource: expect.any(String),
                    accountNumber: accountNumber,
                    number: expect.any(String),
                    address: utils.property.address,
                })
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should not return organization without receipts and meters', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const accountNumber = faker.random.alphaNumeric(16)
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber,
                    tin: utils.organization.tin,
                })
                expect(foundOrganizations).toHaveLength(0)
            })

            test('Should return organization and receipt', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const accountNumber = faker.random.alphaNumeric(16)
                const toPay = '1000'
                const unitName = faker.random.alphaNumeric(16)
                const unitType = 'flat'
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        addressMeta: { unitName, unitType },
                        category: { id: HOUSING_CATEGORY_ID },
                        accountNumber,
                        toPay,
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber,
                    tin: utils.organization.tin,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.meters).toHaveLength(0)
                expect(found.receipts[0]).toMatchObject({
                    category: expect.stringMatching(HOUSING_CATEGORY_ID),
                    balance: expect.stringMatching(Big(toPay).toFixed(8)),
                    accountNumber: expect.stringMatching(accountNumber),
                    routingNumber: expect.any(String),
                    bankAccount: expect.any(String),
                    address: utils.property.address,
                })
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return organization and two receipts', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const accountNumber = faker.random.alphaNumeric(16)
                const toPay1 = '1000'
                const toPay2 = '2000'
                const unitName = faker.random.alphaNumeric(16)
                const unitType = 'flat'
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        addressMeta: { unitName, unitType },
                        category: { id: HOUSING_CATEGORY_ID },
                        accountNumber,
                        toPay: toPay1,
                    }),
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        category: { id: REPAIR_CATEGORY_ID },
                        accountNumber,
                        toPay: toPay2,
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber,
                    tin: utils.organization.tin,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.meters).toHaveLength(0)
                expect(found.receipts).toHaveLength(2)
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return organization and meter', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const accountNumber = faker.random.alphaNumeric(16)
                await utils.createMeter({ accountNumber })
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber,
                    tin: utils.organization.tin,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.receipts).toHaveLength(0)
                expect(found.meters[0]).toMatchObject({
                    resource: expect.any(String),
                    accountNumber: accountNumber,
                    number: expect.any(String),
                    address: utils.property.address,
                })
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return organization and two receipts from different billing contexts', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                const utilsWithAnotherBillingContext = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                await utilsWithAnotherBillingContext.init()
                utilsWithAnotherBillingContext.organization = utils.organization
                await initBillingTestMixin(utilsWithAnotherBillingContext)

                const accountNumber1 = faker.random.alphaNumeric(16)
                const accountNumber2 =  faker.random.alphaNumeric(16)
                const accountNumber3 =  faker.random.alphaNumeric(16)
                const toPay1 = '1000'
                const toPay2 = '2000'
                const unitName = faker.random.alphaNumeric(16)
                const unitType = 'flat'
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        addressMeta: { unitName, unitType },
                        category: { id: HOUSING_CATEGORY_ID },
                        accountNumber: accountNumber1,
                        toPay: toPay1,
                    }),
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        addressMeta: { unitName, unitType },
                        category: { id: HOUSING_CATEGORY_ID },
                        accountNumber: accountNumber2,
                        toPay: toPay1,
                    }),
                ])

                await utilsWithAnotherBillingContext.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        addressMeta: { unitName, unitType },
                        category: { id: REPAIR_CATEGORY_ID },
                        accountNumber: accountNumber1,
                        toPay: toPay2,
                    }),
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        addressMeta: { unitName, unitType },
                        category: { id: HOUSING_CATEGORY_ID },
                        accountNumber: accountNumber3,
                        toPay: toPay1,
                    }),
                ])

                // Finding receipts with same accountNumber from different billing contexts
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber: accountNumber1,
                    tin: utils.organization.tin,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found).toBeDefined()
                expect(found.meters).toHaveLength(0)
                expect(found.receipts).toHaveLength(2) // should be "2"
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)

                // Finding receipt from older billing context (was default behaviour before)
                const [foundOrganizationsForAccountNumber2] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber: accountNumber2,
                    tin: utils.organization.tin,
                })
                const found2 = foundOrganizationsForAccountNumber2.find(({ id }) => id === utils.organization.id)
                expect(found2).toBeDefined()
                expect(found2.meters).toHaveLength(0)
                expect(found2.receipts).toHaveLength(1)
                expect(found2.id).toEqual(utils.organization.id)
                expect(found2.name).toEqual(utils.organization.name)
                expect(found2.tin).toEqual(utils.organization.tin)
                expect(found2.type).toEqual(utils.organization.type)

                // Finding receipt from newer billing context (was impossible before)
                const [foundOrganizationsForAccountNumber3] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber: accountNumber3,
                    tin: utils.organization.tin,
                })
                const found3 = foundOrganizationsForAccountNumber3.find(({ id }) => id === utils.organization.id)
                expect(found3).toBeDefined()
                expect(found3.meters).toHaveLength(0)
                expect(found3.receipts).toHaveLength(1)
                expect(found3.id).toEqual(utils.organization.id)
                expect(found3.name).toEqual(utils.organization.name)
                expect(found3.tin).toEqual(utils.organization.tin)
                expect(found3.type).toEqual(utils.organization.type)
            })

        })
    })

    describe('Permission check', () => {
        const utils = new TestUtils([ResidentTestMixin])

        beforeAll(async () => {
            await utils.init()
        })

        test('anonymous: can not execute', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await findOrganizationsByAddressByTestClient(utils.clients.anonymous, {
                    addressKey: utils.property.addressKey,
                })
            })
        })
        test('user: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await findOrganizationsByAddressByTestClient(utils.clients.user, {
                    addressKey: utils.property.addressKey,
                })
            })
        })
        test('employee: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await findOrganizationsByAddressByTestClient(utils.clients.employee.billing, {
                    addressKey: utils.property.addressKey,
                })
            })
        })
        test('service user: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await findOrganizationsByAddressByTestClient(utils.clients.service, {
                    addressKey: utils.property.addressKey,
                })
            })
        })
        test('admin: can execute', async () => {
            const [organizations] = await findOrganizationsByAddressByTestClient(utils.clients.admin, {
                addressKey: utils.property.addressKey,
            })
            expect(organizations).not.toHaveLength(0)
        })
        test('support: can not execute', async () => {
            const [organizations] = await findOrganizationsByAddressByTestClient(utils.clients.support, {
                addressKey: utils.property.addressKey,
            })
            expect(organizations).not.toHaveLength(0)
        })
        test('resident: can execute', async () => {
            const [organizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                addressKey: utils.property.addressKey,
            })
            expect(organizations).not.toHaveLength(0)
        })
    })
})