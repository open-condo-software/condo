/**
 * Generated by `createservice resident.FindOrganizationsByAddressService --type queries`
 */
/**
 * Generated by `createservice resident.RegisterServiceConsumerService --type mutations`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const express = require('express')

const { initTestExpressApp, getTestExpressApp, setFeatureFlag } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/acquiring/constants/context')
const { createTestAcquiringIntegrationContext, createTestAcquiringIntegration } = require('@condo/domains/acquiring/utils/testSchema')
const { HOUSING_CATEGORY_ID, REPAIR_CATEGORY_ID } = require('@condo/domains/billing/constants/constants')
const {
    ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS,
    ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS,
} = require('@condo/domains/billing/constants/onlineInteraction')
const { createTestBillingIntegrationOrganizationContext, createTestBillingIntegration } = require('@condo/domains/billing/utils/testSchema')
const {
    TestUtils,
    ResidentTestMixin,
    MeterTestMixin,
} = require('@condo/domains/billing/utils/testSchema/testUtils')
const { DISABLE_DISCOVER_SERVICE_CONSUMERS } = require('@condo/domains/common/constants/featureflags')
const {
    CALL_METER_READING_SOURCE_ID,
} = require('@condo/domains/meter/constants/constants')
const { COLD_WATER_METER_RESOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { createTestMeterReading, MeterReadingSource } = require('@condo/domains/meter/utils/testSchema')
const { createTestMeterResourceOwner } = require('@condo/domains/meter/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { findOrganizationsByAddressByTestClient } = require('@condo/domains/resident/utils/testSchema')

function getOnlyResourceMeterTest (resource) {
    return {
        resource: resource,
        account: null,
        number: null,
        value: null,
    }
}

function getOnlyCategoryReceiptTest (category){
    return {
        number: null,
        category: category,
        balance: null,
        routingNumber: null,
        bankAccount: null,
    }
}

describe('FindOrganizationsByAddress', () => {

    let utils

    beforeAll(async () => {
        utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
        await utils.init()
    })

    describe('Unified flow', () => {
        describe('General behaviour', () => {
            test('Should not return organization if acquiring context is not in finished status', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                const [foundOrganizationsOnFinishedContext] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                const foundForFinishedContext = foundOrganizationsOnFinishedContext.find(({ id }) => id === utils.organization.id)
                expect(foundForFinishedContext).not.toBeUndefined()
                await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })
                const [foundOrganizationsOnInProgressContext] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                const foundForInProgressContext = foundOrganizationsOnInProgressContext.find(({ id }) => id === utils.organization.id)
                expect(foundForInProgressContext).toBeUndefined()
            })
        
            test('Should return empty array if no properties', async () => {
                const wrongAddressKey = faker.datatype.uuid()
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: wrongAddressKey,
                })
                expect(foundOrganizations).toHaveLength(0)
            })

            test('Should return empty array if no meters and acquiring', async () => {
                const [organization] = await createTestOrganization(utils.clients.admin)
                const [property] = await createTestProperty(utils.clients.admin, organization)
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: property.addressKey,
                })
                expect(foundOrganizations).toHaveLength(0)
            })
        })

        describe('addressKey', () => {
            test('Should return organization', async () => {
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.meters).toBeNull()
                expect(found.receipts).toBeNull()
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return organization and receipt category', async () => {
                const utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
                await utils.init()
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        category: { id: HOUSING_CATEGORY_ID },
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                console.log(foundOrganizations)
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.meters).toBeNull()
                expect(found.receipts).toContainEqual(getOnlyCategoryReceiptTest(HOUSING_CATEGORY_ID))
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return organization and meter resource', async () => {
                const [organization] = await createTestOrganization(utils.clients.admin)
                const [property] = await createTestProperty(utils.clients.admin, organization)
                const [meter] = await utils.createMeter({ resource: COLD_WATER_METER_RESOURCE_ID })
                await createTestMeterResourceOwner(utils.clients.admin, organization, meter.resource, {
                    address: property.address,
                })
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: property.addressKey,
                })
                const found = foundOrganizations.find(({ id }) => id === organization.id)
                expect(found.receipts).toBeNull()
                expect(found.meters).toContainEqual(getOnlyResourceMeterTest(COLD_WATER_METER_RESOURCE_ID))
                expect(found.id).toEqual(organization.id)
                expect(found.name).toEqual(organization.name)
                expect(found.tin).toEqual(organization.tin)
                expect(found.type).toEqual(organization.type)
            })

            test('Should return several organizations', async () => {
                const [organization] = await createTestOrganization(utils.clients.admin)
                const [billingIntegration] = await createTestBillingIntegration(utils.clients.admin)
                const [acquiringIntegration] = await createTestAcquiringIntegration(utils.clients.admin)
                await createTestAcquiringIntegrationContext(utils.clients.admin, organization, acquiringIntegration, { status: CONTEXT_FINISHED_STATUS })
                await createTestBillingIntegrationOrganizationContext(utils.clients.admin, organization, billingIntegration, { status: CONTEXT_FINISHED_STATUS })
                await createTestProperty(utils.clients.admin, organization, {
                    address: utils.property.address,
                })

                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                })
                expect(foundOrganizations).toHaveLength(2)
            })
        })

        describe('addressKey unitName unitType', () => {
            setFeatureFlag(DISABLE_DISCOVER_SERVICE_CONSUMERS, false)

            test('Should return receipt if unitName and unitType matches', async () => {
                const unitName = utils.randomNumber(10).toString()
                const unitType = 'flat'
                const accountNumber = utils.randomNumber(10).toString()
                const toPay = utils.randomNumber(5).toString()
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber,
                        addressMeta: { unitName, unitType },
                        toPay,
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    unitName,
                    unitType,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                console.log(foundOrganizations)
                expect(found.receipts[0]).toMatchObject({
                    number: expect.stringMatching(accountNumber),
                    category: expect.any(String),
                    balance: expect.stringMatching(Big(toPay).toFixed(8)),
                    routingNumber: expect.any(String),
                    bankAccount: expect.any(String),
                })
            })

            test('Should return receipt category if receipts have duplicates', async () => {
                const unitName = utils.randomNumber(10).toString()
                const unitType = 'flat'
                const accountNumber1 = utils.randomNumber(10).toString()
                const accountNumber2 = utils.randomNumber(10).toString()
                const toPay = utils.randomNumber(5).toString()
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber: accountNumber1,
                        addressMeta: { unitName, unitType },
                        toPay,
                        category: { id: HOUSING_CATEGORY_ID },
                    }),
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber: accountNumber2,
                        addressMeta: { unitName, unitType },
                        toPay,
                        category: { id: HOUSING_CATEGORY_ID },
                    }),
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        accountNumber: accountNumber1,
                        addressMeta: { unitName, unitType },
                        toPay,
                        category: { id: REPAIR_CATEGORY_ID },
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    unitName,
                    unitType,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.receipts).toHaveLength(2)
                expect(found.receipts).toContainEqual(getOnlyCategoryReceiptTest(HOUSING_CATEGORY_ID))
                expect(found.receipts).toContainEqual({
                    number: accountNumber1,
                    category: REPAIR_CATEGORY_ID,
                    balance: Big(toPay).toFixed(8),
                    routingNumber: expect.any(String),
                    bankAccount: expect.any(String),
                })
            })

            test('Should return meter resource and receipt category if organization in black list', async () => {
                setFeatureFlag(DISABLE_DISCOVER_SERVICE_CONSUMERS, true)
                const unitName = utils.randomNumber(10).toString()
                const unitType = 'flat'
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        category: { id: HOUSING_CATEGORY_ID },
                        address: utils.property.address,
                        addressMeta: { unitName, unitType },
                    }),
                ])
                await utils.createMeter({ unitName, unitType })
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    unitName,
                    unitType,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                console.log(found)
                expect(found.meters[0]).toMatchObject({ resource: expect.any(String) })
                expect(found.receipts[0]).toMatchObject({ category: expect.any(String) })
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
                setFeatureFlag(DISABLE_DISCOVER_SERVICE_CONSUMERS, false)
            })
        })

        describe('addressKey tin accountNumber', () => {
            describe('Online interaction', () => {
                // nosemgrep: javascript.express.security.audit.express-check-csurf-middleware-usage.express-check-csurf-middleware-usage
                const app = express()
                const apiHandler = jest.fn()
                const CHECK_URL_PATH = '/check-account-number'

                app.get(CHECK_URL_PATH, async (req, res) => {
                    return res.json(await apiHandler())
                })

                initTestExpressApp('OnlineInteraction', app)

                beforeAll(async () => {
                    const baseUrl = getTestExpressApp('OnlineInteraction').baseUrl + CHECK_URL_PATH
                    await utils.updateBillingIntegration({ checkAccountNumberUrl: baseUrl })
                })

                afterAll(async () => {
                    await utils.updateBillingIntegration({ checkAccountNumberUrl: null })
                })

                afterEach(() => {
                    jest.clearAllMocks()
                })

                test('Should not return organization if accountNumber is not found', async () => {
                    const notExistingAccountNumber = faker.random.alphaNumeric(16)
                    apiHandler.mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS })
                    const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                        addressKey: utils.property.addressKey,
                        accountNumber: notExistingAccountNumber,
                        tin: utils.organization.tin,
                    })

                    expect(foundOrganizations).toHaveLength(0)
                })

                test('Should return organization and receipt if accountNumber is found', async () => {
                    const existingAccountNumber = faker.random.alphaNumeric(16)
                    apiHandler.mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS, services: [{
                        category: HOUSING_CATEGORY_ID,
                        account: { number: existingAccountNumber },
                        bankAccount: {
                            number: faker.random.alphaNumeric(16),
                            routingNumber: faker.random.alphaNumeric(16),
                        },
                    }] })
                    const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                        addressKey: utils.property.addressKey,
                        accountNumber: existingAccountNumber,
                        tin: utils.organization.tin,
                    })
                    console.log(foundOrganizations)
                    const foundResult = foundOrganizations.find(({ id }) => id === utils.organization.id)
                    expect(foundResult.receipts).toBeDefined()
                    //TODO: change this line when eps has balance field
                    // expect(foundResult.receipts.balance).toBeNull()
                    expect(apiHandler).toHaveBeenCalledTimes(1)
                })

            })

            test('Should not return organization without receipts and meters', async () => {
                const accountNumber = utils.randomNumber(10).toString()
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber,
                    tin: utils.organization.tin,
                })
                expect(foundOrganizations).toHaveLength(0)
            })

            test('Should return organization and receipt', async () => {
                const accountNumber = utils.randomNumber(10).toString()
                const toPay = utils.randomNumber(5).toString()
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        category: { id: HOUSING_CATEGORY_ID },
                        accountNumber,
                        toPay,
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber,
                    tin: utils.organization.tin,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                console.log(found)
                expect(found.meters).toBeNull()
                expect(found.receipts[0]).toMatchObject({
                    category: expect.stringMatching(HOUSING_CATEGORY_ID),
                    balance: expect.stringMatching(Big(toPay).toFixed(8)),
                    number: expect.stringMatching(accountNumber),
                    routingNumber: expect.any(String),
                    bankAccount: expect.any(String),
                })
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return organization and two receipts', async () => {
                const accountNumber = utils.randomNumber(10).toString()
                const toPay1 = utils.randomNumber(5).toString()
                const toPay2 = utils.randomNumber(5).toString()
                await utils.createReceipts([
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        category: { id: HOUSING_CATEGORY_ID },
                        accountNumber,
                        toPay: toPay1,
                    }),
                    utils.createJSONReceipt({
                        address: utils.property.address,
                        category: { id: REPAIR_CATEGORY_ID },
                        accountNumber,
                        toPay: toPay2,
                    }),
                ])
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber,
                    tin: utils.organization.tin,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                console.log(found)
                expect(found.meters).toBeNull()
                expect(found.receipts).toHaveLength(2)
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })

            test('Should return organization and meter', async () => {
                const accountNumber = utils.randomNumber(10).toString()
                const [source] = await MeterReadingSource.getAll(utils.clients.admin, { id: CALL_METER_READING_SOURCE_ID })
                const [ meter ] = await utils.createMeter({ accountNumber })
                const [meterReading] = await createTestMeterReading(utils.clients.admin, meter, source)
                const [foundOrganizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                    addressKey: utils.property.addressKey,
                    accountNumber,
                    tin: utils.organization.tin,
                })
                const found = foundOrganizations.find(({ id }) => id === utils.organization.id)
                expect(found.receipts).toBeNull()
                expect(found.meters[0]).toMatchObject({
                    resource: expect.any(String),
                    account: expect.stringMatching(accountNumber),
                    number: expect.any(String),
                    value: expect.stringMatching(Big(meterReading.value1).toFixed(4)),
                })
                expect(found.id).toEqual(utils.organization.id)
                expect(found.name).toEqual(utils.organization.name)
                expect(found.tin).toEqual(utils.organization.tin)
                expect(found.type).toEqual(utils.organization.type)
            })
        })
    })

    describe('Permission check', () => {
        test('anonymous: can not execute', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await findOrganizationsByAddressByTestClient(utils.clients.anonymous, {
                    addressKey: utils.property.addressKey,
                })
            })
        })
        test('user: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await findOrganizationsByAddressByTestClient(utils.clients.user, {
                    addressKey: utils.property.addressKey,
                })
            })
        })
        test('employee: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await findOrganizationsByAddressByTestClient(utils.clients.employee.billing, {
                    addressKey: utils.property.addressKey,
                })
            })
        })
        test('service user: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await findOrganizationsByAddressByTestClient(utils.clients.service, {
                    addressKey: utils.property.addressKey,
                })
            })
        })
        test('admin: can execute', async () => {
            const [organizations] = await findOrganizationsByAddressByTestClient(utils.clients.admin, {
                addressKey: utils.property.addressKey,
            })
            expect(organizations).not.toHaveLength(0)
        })
        test('support: can not execute', async () => {
            const [organizations] = await findOrganizationsByAddressByTestClient(utils.clients.support, {
                addressKey: utils.property.addressKey,
            })
            expect(organizations).not.toHaveLength(0)
        })
        test('resident: can execute', async () => {
            const [organizations] = await findOrganizationsByAddressByTestClient(utils.clients.resident, {
                addressKey: utils.property.addressKey,
            })
            expect(organizations).not.toHaveLength(0)
        })
    })
})