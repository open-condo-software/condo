/**
 * Generated by `createservice resident.RegisterServiceConsumerService --type mutations`
 */

const { faker } = require('@faker-js/faker')

const { fetch }  = require('@open-condo/keystone/fetch')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS,
    ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS, 
} = require('@condo/domains/billing/utils/serverSchema/checkBillingAccountNumberForOrganization')
const {
    AcquiringTestMixin,
    TestUtils,
    OrganizationTestMixin,
    PropertyTestMixin,
    BillingTestMixin,
    ResidentTestMixin,
    MeterTestMixin,
} = require('@condo/domains/billing/utils/testSchema/testUtils')
const { ERRORS: { BILLING_ACCOUNT_NOT_FOUND, ACCOUNT_NUMBER_IS_NOT_SPECIFIED } } = require('@condo/domains/resident/schema/RegisterServiceConsumerService')
const {
    registerServiceConsumerByTestClient,
} = require('@condo/domains/resident/utils/testSchema')

describe('RegisterServiceConsumer', () => {

    let utils

    beforeAll(async () => {
        utils = new TestUtils([OrganizationTestMixin, PropertyTestMixin, AcquiringTestMixin, BillingTestMixin, ResidentTestMixin, MeterTestMixin])
        await utils.init()
    })

    describe('Common cases', () => {

        test('allows to create service consumers with same resident and accountNumber for multiple organizations', async () => {
            const resident = await utils.createResident()
            const anotherUtils = new TestUtils([OrganizationTestMixin, PropertyTestMixin, BillingTestMixin, AcquiringTestMixin])
            await anotherUtils.init()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ])
            await anotherUtils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ])
            const [consumer1] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            const [consumer2] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: anotherUtils.organization.id,
            })
            expect(consumer1).toHaveProperty('id')
            expect(consumer2).toHaveProperty('id')
            expect(consumer1.id).not.toEqual(consumer2.id)
        })

        test('does not create same service consumer twice', async () => {
            const resident = await utils.createResident()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber }),
            ])
            const createInput = { residentId: resident.id, accountNumber, organizationId: utils.organization.id }
            const [initialConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, createInput)
            const [duplicatedConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, createInput)
            expect(initialConsumer.id).toEqual(duplicatedConsumer.id)
        })

        test('cannot be invoked by anonymous', async () => {
            const payload = { residentId: 'test-id', accountNumber: 'test-number', organizationId: utils.organization.id }
            await expectToThrowAuthenticationErrorToObj(async () => {
                await registerServiceConsumerByTestClient(utils.clients.anonymous, payload)
            })
        })

        test('cannot be invoked by non-resident user', async () => {
            const payload = { residentId: 'test-id', accountNumber: 'test-number', organizationId: utils.organization.id }
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await registerServiceConsumerByTestClient(utils.clients.employee.billing, payload)
            })
        })

        test('fails with error when creating serviceConsumer for empty accountNumber', async () => {
            const resident = await utils.createResident()
            const accountNumber = ' '
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber,
                    organizationId: utils.organization.id,
                })
            }, ACCOUNT_NUMBER_IS_NOT_SPECIFIED)
        })

        test('fails with error when billingAccount not found, and Meters are not found', async () => {
            const resident = await utils.createResident()
            const notExistingAccountNumber = faker.random.alphaNumeric(16)
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: notExistingAccountNumber,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })

        it('creates serviceConsumer with billingAccount and Meters', async () => {
            const resident = await utils.createResident()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber }),
            ])
            await utils.createMeter({ accountNumber })
            const [serviceConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(serviceConsumer).toHaveProperty('id')
        })

    })


    describe('contexts statuses', () => {

        afterEach(async () => {
            await utils.updateBillingContext({ status: CONTEXT_FINISHED_STATUS })
            await utils.updateAcquiringContext({ status: CONTEXT_FINISHED_STATUS })
        })

        test('should throw an error if billingContext is not in Finished status', async () => {
            const resident = await utils.createResident()
            const accountNumberForSuccess = faker.random.alphaNumeric(16)
            const accountNumberForFailure = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: accountNumberForSuccess }),
                utils.createJSONReceipt({ accountNumber: accountNumberForFailure }),
            ])
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumberForSuccess,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
            await utils.updateBillingContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: accountNumberForFailure,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })

        test('should throw an error if acquiringContext is not in Finished status', async () => {
            const resident = await utils.createResident()
            const accountNumberForSuccess = faker.random.alphaNumeric(16)
            const accountNumberForFailure = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: accountNumberForSuccess }),
                utils.createJSONReceipt({ accountNumber: accountNumberForFailure }),
            ])
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumberForSuccess,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
            await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: accountNumberForFailure,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })

        test('should work if no billingContext in Finished status, but organization has Meter with the same accountNumber', async () => {
            const resident = await utils.createResident()
            await utils.updateBillingContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createMeter({ accountNumber })
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
        })

        test('should work if no acquiringContext in Finished status, but organization has Meter with the same accountNumber', async () => {
            const resident = await utils.createResident()
            await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createMeter({ accountNumber })
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
        })

        test('should throw an error if no billingAccount found', async () => {
            const resident = await utils.createResident()
            const accountNumberForSuccess = faker.random.alphaNumeric(16)
            const accountNumberForFailure = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: accountNumberForSuccess }),
            ])
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumberForSuccess,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: accountNumberForFailure,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })
    })

})

