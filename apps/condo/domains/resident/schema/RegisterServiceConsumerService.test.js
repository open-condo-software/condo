/**
 * Generated by `createservice resident.RegisterServiceConsumerService --type mutations`
 */

const { faker } = require('@faker-js/faker')
const express = require('express')

const { initTestExpressApp, getTestExpressApp } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS: BILLING_CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS: BILLING_CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/billing/constants/constants')
const {
    ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS,
    ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS,
} = require('@condo/domains/billing/constants/onlineInteraction')
const {
    createTestBillingIntegrationOrganizationContext,
    updateTestBillingIntegrationOrganizationContext,
} = require('@condo/domains/billing/utils/testSchema')
const {
    TestUtils,
    BillingTestMixin,
    ResidentTestMixin,
    MeterTestMixin,
} = require('@condo/domains/billing/utils/testSchema/testUtils')
const { ERRORS: {
    BILLING_ACCOUNT_NOT_FOUND,
    ACCOUNT_NUMBER_IS_NOT_SPECIFIED,
} } = require('@condo/domains/resident/schema/RegisterServiceConsumerService')
const {
    registerServiceConsumerByTestClient,
} = require('@condo/domains/resident/utils/testSchema')

describe('RegisterServiceConsumer', () => {

    let utils

    beforeAll(async () => {
        utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
        await utils.init()
    })

    describe('Online interaction', () => {

        // nosemgrep: javascript.express.security.audit.express-check-csurf-middleware-usage.express-check-csurf-middleware-usage
        const app = express()
        const apiHandler = jest.fn()
        const CHECK_URL_PATH = '/check-account-number'

        app.get(CHECK_URL_PATH, async (req, res) => {
            return res.json(await apiHandler())
        })

        initTestExpressApp('OnlineInteraction', app)

        beforeAll(async () => {
            const baseUrl = getTestExpressApp('OnlineInteraction').baseUrl + CHECK_URL_PATH
            await utils.updateBillingIntegration({ checkAccountNumberUrl: baseUrl })
        })

        afterAll(async () => {
            await utils.updateBillingIntegration({ checkAccountNumberUrl: null })
        })

        afterEach(() => {
            jest.clearAllMocks()
        })

        test('should throw an error if no billingAccount found and check for online interaction failed', async () => {
            const resident = await utils.createResident()
            const notExistingAccountNumber = faker.random.alphaNumeric(16)
            apiHandler.mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS })
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: notExistingAccountNumber,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })

        test('should work if no billingAccount in condo, but check for online interaction succeeded', async () => {
            const resident = await utils.createResident()
            apiHandler.mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS })
            const notExistingInCondoAccount = faker.random.alphaNumeric(16)
            const [newConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: notExistingInCondoAccount,
                organizationId: utils.organization.id,
            })
            expect(newConsumer).toHaveProperty('id')
        })

        test('should not call online interaction if account already exists in condo', async () => {
            const resident = await utils.createResident()
            const existingAccount = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: existingAccount }),
            ])
            apiHandler.mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS })
            const [newConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: existingAccount,
                organizationId: utils.organization.id,
            })
            expect(newConsumer).toHaveProperty('id')
            expect(apiHandler).toHaveBeenCalledTimes(0)
        })
    })

    describe('Common cases', () => {

        test('allows to create service consumers with same resident and accountNumber for multiple organizations', async () => {
            const resident = await utils.createResident()
            const anotherUtils = new TestUtils([BillingTestMixin])
            await anotherUtils.init()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ])
            await anotherUtils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ])
            const [consumer1] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            const [consumer2] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: anotherUtils.organization.id,
            })
            expect(consumer1).toHaveProperty('id')
            expect(consumer2).toHaveProperty('id')
            expect(consumer1.id).not.toEqual(consumer2.id)
        })

        test('Admin can create consumer for any resident', async () => {
            const resident = await utils.createResident()
            const anotherUtils = new TestUtils()
            await anotherUtils.init()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ])
            const [consumer] = await registerServiceConsumerByTestClient(anotherUtils.clients.admin, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(consumer).toHaveProperty('id')
        })

        test('does not allow to create service consumer for user and resident mismatch', async () => {
            const resident = await utils.createResident()
            const anotherUtils = new TestUtils([BillingTestMixin, ResidentTestMixin])
            await anotherUtils.init()
            await anotherUtils.createResident()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ])
            await anotherUtils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ])
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await registerServiceConsumerByTestClient(anotherUtils.clients.resident, {
                    residentId: resident.id,
                    accountNumber,
                    organizationId: utils.organization.id,
                })
            })
        })

        test('does not create same service consumer twice', async () => {
            const resident = await utils.createResident()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber }),
            ])
            const createInput = { residentId: resident.id, accountNumber, organizationId: utils.organization.id }
            const [initialConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, createInput)
            const [duplicatedConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, createInput)
            expect(initialConsumer.id).toEqual(duplicatedConsumer.id)
        })

        test('cannot be invoked by anonymous', async () => {
            const payload = { residentId: 'test-id', accountNumber: 'test-number', organizationId: utils.organization.id }
            await expectToThrowAuthenticationErrorToObj(async () => {
                await registerServiceConsumerByTestClient(utils.clients.anonymous, payload)
            })
        })

        test('cannot be invoked by non-resident user', async () => {
            const payload = { residentId: 'test-id', accountNumber: 'test-number', organizationId: utils.organization.id }
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await registerServiceConsumerByTestClient(utils.clients.employee.billing, payload)
            })
        })

        test('fails with error when creating serviceConsumer for empty accountNumber', async () => {
            const resident = await utils.createResident()
            const accountNumber = ' '
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber,
                    organizationId: utils.organization.id,
                })
            }, ACCOUNT_NUMBER_IS_NOT_SPECIFIED)
        })

        test('fails with error when billingAccount not found, and Meters are not found', async () => {
            const resident = await utils.createResident()
            const notExistingAccountNumber = faker.random.alphaNumeric(16)
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: notExistingAccountNumber,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })

        it('creates serviceConsumer with billingAccount and Meters', async () => {
            const resident = await utils.createResident()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber }),
            ])
            await utils.createMeter({ accountNumber })
            const [serviceConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(serviceConsumer).toHaveProperty('id')
        })
    })

    describe('Support for several billing contexts in one organization', () => {
        let anotherIntegrationUtils = null

        beforeAll(async () => {
            anotherIntegrationUtils = new TestUtils([BillingTestMixin])
            await anotherIntegrationUtils.init()
            const [anotherBillingContext] = await createTestBillingIntegrationOrganizationContext(anotherIntegrationUtils.clients.support, utils.organization, anotherIntegrationUtils.billingIntegration, { status: BILLING_CONTEXT_FINISHED_STATUS })
            anotherIntegrationUtils.billingContext = anotherBillingContext
        })

        afterAll(async () => {
            await updateTestBillingIntegrationOrganizationContext(utils.clients.support, anotherIntegrationUtils.billingContext.id, { deletedAt: new Date().toISOString() })
        })

        test('Can register for same accountNumber in both contexts', async  () => {
            const resident = await utils.createResident()
            const accountNumber = faker.random.alphaNumeric(16)
            await Promise.all([
                utils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ]),
                anotherIntegrationUtils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ]),
            ])
            const [serviceConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(serviceConsumer).toHaveProperty('id')
        })

        test('Can register if contexts have different account numbers', async  () => {
            const resident = await utils.createResident()
            const accountNumber1 = faker.random.alphaNumeric(16)
            const accountNumber2 = faker.random.alphaNumeric(16)
            await Promise.all([
                utils.createReceipts([ utils.createJSONReceipt({ accountNumber: accountNumber1 }) ]),
                anotherIntegrationUtils.createReceipts([ utils.createJSONReceipt({ accountNumber: accountNumber2 }) ]),
            ])
            const [serviceConsumer1] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumber1,
                organizationId: utils.organization.id,
            })
            expect(serviceConsumer1).toHaveProperty('id')
            const [serviceConsumer2] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumber2,
                organizationId: utils.organization.id,
            })
            expect(serviceConsumer2).toHaveProperty('id')
        })
    })


    describe('contexts statuses', () => {

        afterEach(async () => {
            await utils.updateBillingContext({ status: BILLING_CONTEXT_FINISHED_STATUS })
        })

        test('should throw an error if billingContext is not in Finished status', async () => {
            const resident = await utils.createResident()
            const accountNumberForSuccess = faker.random.alphaNumeric(16)
            const accountNumberForFailure = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: accountNumberForSuccess }),
                utils.createJSONReceipt({ accountNumber: accountNumberForFailure }),
            ])
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumberForSuccess,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
            await utils.updateBillingContext({ status: BILLING_CONTEXT_IN_PROGRESS_STATUS })
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: accountNumberForFailure,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })

        test('should work if no billingContext in Finished status, but organization has Meter with the same accountNumber', async () => {
            const resident = await utils.createResident()
            await utils.updateBillingContext({ status: BILLING_CONTEXT_IN_PROGRESS_STATUS })
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createMeter({ accountNumber })
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
        })


        test('should throw an error if no billingAccount found', async () => {
            const resident = await utils.createResident()
            const accountNumberForSuccess = faker.random.alphaNumeric(16)
            const accountNumberForFailure = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: accountNumberForSuccess }),
            ])
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumberForSuccess,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: accountNumberForFailure,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })
    })

})