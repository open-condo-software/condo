/**
 * Generated by `createservice resident.RegisterServiceConsumerService --type mutations`
 */

const { faker } = require('@faker-js/faker')

const { fetch }  = require('@open-condo/keystone/fetch')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/acquiring/constants/context')
const { AcquiringTestMixin } = require('@condo/domains/acquiring/utils/testSchema/acquiringTestMixin')
const { 
    ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS,
    ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS, 
} = require('@condo/domains/billing/utils/serverSchema/checkBillingAccountNumberForOrganization')
const { BillingTestUtils } = require('@condo/domains/billing/utils/testSchema/utils')
const { MeterTestMixin } = require('@condo/domains/meter/utils/testSchema/meterTestMixin')
const { PropertyTestMixin } = require('@condo/domains/property/utils/testSchema/propertyTestMixin')
const { ERRORS: { BILLING_ACCOUNT_NOT_FOUND, ACCOUNT_NUMBER_IS_NOT_SPECIFIED } } = require('@condo/domains/resident/schema/RegisterServiceConsumerService')
const {
    registerServiceConsumerByTestClient,
} = require('@condo/domains/resident/utils/testSchema')
const { ResidentTestMixin } = require('@condo/domains/resident/utils/testSchema/residentTestMixin')

describe('RegisterServiceConsumer', () => {

    let utils

    beforeAll(async () => {
        utils = new BillingTestUtils([AcquiringTestMixin, PropertyTestMixin, ResidentTestMixin, MeterTestMixin])
        await utils.init()
    })

    describe('Common cases', () => {

        test('allows to create service consumers with same resident and accountNumber for multiple organizations', async () => {
            const resident = await utils.createResident()
            const anotherUtils = new BillingTestUtils([AcquiringTestMixin])
            await anotherUtils.init()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ])
            await anotherUtils.createReceipts([ utils.createJSONReceipt({ accountNumber }) ])
            const [consumer1] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            const [consumer2] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: anotherUtils.organization.id,
            })
            expect(consumer1).toHaveProperty('id')
            expect(consumer2).toHaveProperty('id')
            expect(consumer1.id).not.toEqual(consumer2.id)
        })

        test('does not create same service consumer twice', async () => {
            const resident = await utils.createResident()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber }),
            ])
            const createInput = { residentId: resident.id, accountNumber, organizationId: utils.organization.id }
            const [initialConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, createInput)
            const [duplicatedConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, createInput)
            expect(initialConsumer.id).toEqual(duplicatedConsumer.id)
        })

        test('cannot be invoked by anonymous', async () => {
            const payload = { residentId: 'test-id', accountNumber: 'test-number', organizationId: utils.organization.id }
            await expectToThrowAuthenticationErrorToObj(async () => {
                await registerServiceConsumerByTestClient(utils.clients.anonymous, payload)
            })
        })

        test('cannot be invoked by non-resident user', async () => {
            const payload = { residentId: 'test-id', accountNumber: 'test-number', organizationId: utils.organization.id }
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await registerServiceConsumerByTestClient(utils.clients.employee, payload)
            })
        })

        test('fails with error when creating serviceConsumer for empty accountNumber', async () => {
            const resident = await utils.createResident()
            const accountNumber = ' '
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber,
                    organizationId: utils.organization.id,
                })
            }, ACCOUNT_NUMBER_IS_NOT_SPECIFIED)
        })

        test('fails with error when billingAccount not found, and Meters are not found', async () => {
            const resident = await utils.createResident()
            const notExistingAccountNumber = faker.random.alphaNumeric(16)
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: notExistingAccountNumber,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })

        it('creates serviceConsumer with billingAccount and Meters', async () => {
            const resident = await utils.createResident()
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber }),
            ])
            await utils.createMeter({ accountNumber })
            const [serviceConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(serviceConsumer).toHaveProperty('id')
        })

    })

    describe('BillingIntegration with online interaction', () => {

        const TEST_INTERACTION_URL = 'https://external-integration.com/api/check?token=some_securitey_token'

        beforeAll(async () => {
            await utils.updateBillingIntegration({ checkAccountNumberUrl: TEST_INTERACTION_URL })
        })

        afterAll(async () => {
            await utils.updateBillingIntegration({ checkAccountNumberUrl: null })
        })

        afterEach(() => {
            jest.clearAllMocks()
        })

        test('should throw an error if no billingAccount found and check for online interaction failed', async () => {
            const resident = await utils.createResident()
            const notExistingAccountNumber = faker.random.alphaNumeric(16)
            const mockResponse = {
                ok: true,
                json: jest.fn().mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS }),
            }
            fetch.mockResolvedValueOnce(mockResponse)
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: notExistingAccountNumber,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
            expect(fetch).toHaveBeenCalledTimes(1)
        })

        test('should work if no billingAccount in condo, but check for online interaction succeeded', async () => {
            const resident = await utils.createResident()
            const existingAccount = faker.random.alphaNumeric(16)
            const mockResponse = {
                ok: true,
                json: jest.fn().mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS }),
            }
            fetch.mockResolvedValueOnce(mockResponse)
            const [newConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: existingAccount,
                organizationId: utils.organization.id,
            })
            expect(newConsumer).toHaveProperty('id')
            expect(fetch).toHaveBeenCalledTimes(1)
        })

        test('should not call online interaction if account already presence in condo', async () => {
            const resident = await utils.createResident()
            const existingAccount = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: existingAccount }),
            ])
            const mockResponse = {
                ok: true,
                json: jest.fn().mockResolvedValue({ status: ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS }),
            }
            fetch.mockResolvedValueOnce(mockResponse)
            const [newConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: existingAccount,
                organizationId: utils.organization.id,
            })
            expect(newConsumer).toHaveProperty('id')
            expect(fetch).toHaveBeenCalledTimes(0)
        })
    })

    describe('contexts statuses', () => {

        afterEach(async () => {
            await utils.updateBillingContext({ status: CONTEXT_FINISHED_STATUS })
            await utils.updateAcquiringContext({ status: CONTEXT_FINISHED_STATUS })
        })

        test('should throw an error if billingContext is not in Finished status', async () => {
            const resident = await utils.createResident()
            const accountNumberForSuccess = faker.random.alphaNumeric(16)
            const accountNumberForFailure = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: accountNumberForSuccess }),
                utils.createJSONReceipt({ accountNumber: accountNumberForFailure }),
            ])
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumberForSuccess,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
            await utils.updateBillingContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: accountNumberForFailure,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })

        test('should throw an error if acquiringContext is not in Finished status', async () => {
            const resident = await utils.createResident()
            const accountNumberForSuccess = faker.random.alphaNumeric(16)
            const accountNumberForFailure = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: accountNumberForSuccess }),
                utils.createJSONReceipt({ accountNumber: accountNumberForFailure }),
            ])
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumberForSuccess,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
            await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: accountNumberForFailure,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })

        test('should work if no billingContext in Finished status, but organization has Meter with the same accountNumber', async () => {
            const resident = await utils.createResident()
            await utils.updateBillingContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createMeter({ accountNumber })
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
        })

        test('should work if no acquiringContext in Finished status, but organization has Meter with the same accountNumber', async () => {
            const resident = await utils.createResident()
            await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            const accountNumber = faker.random.alphaNumeric(16)
            await utils.createMeter({ accountNumber })
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
        })

        test('should throw an error if no billingAccount found', async () => {
            const resident = await utils.createResident()
            const accountNumberForSuccess = faker.random.alphaNumeric(16)
            const accountNumberForFailure = faker.random.alphaNumeric(16)
            await utils.createReceipts([
                utils.createJSONReceipt({ accountNumber: accountNumberForSuccess }),
            ])
            const [successConsumer] = await registerServiceConsumerByTestClient(utils.clients.resident, {
                residentId: resident.id,
                accountNumber: accountNumberForSuccess,
                organizationId: utils.organization.id,
            })
            expect(successConsumer).toHaveProperty('id')
            await expectToThrowGQLError(async () => {
                await registerServiceConsumerByTestClient(utils.clients.resident, {
                    residentId: resident.id,
                    accountNumber: accountNumberForFailure,
                    organizationId: utils.organization.id,
                })
            }, BILLING_ACCOUNT_NOT_FOUND)
        })
    })

})

