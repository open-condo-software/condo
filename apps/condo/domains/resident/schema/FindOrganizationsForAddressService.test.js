/**
 * Generated by `createservice resident.FindOrganizationsForAddressService --type queries`
 */
/**
 * Generated by `createservice resident.RegisterServiceConsumerService --type mutations`
 */

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const express = require('express')

const { initTestExpressApp, getTestExpressApp } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    ONLINE_INTERACTION_CHECK_ACCOUNT_NOT_FOUND_STATUS,
    ONLINE_INTERACTION_CHECK_ACCOUNT_SUCCESS_STATUS,
} = require('@condo/domains/billing/constants/onlineInteraction')
const {
    TestUtils,
    BillingTestMixin,
    ResidentTestMixin,
    MeterTestMixin,
} = require('@condo/domains/billing/utils/testSchema/testUtils')
const { findOrganizationsForAddressByTestClient } = require('@condo/domains/resident/utils/testSchema')
describe('FindOrganizationsForAddress', () => {

    let utils

    beforeAll(async () => {
        utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
        await utils.init()
    })

    describe('Online interaction', () => {

        // nosemgrep: javascript.express.security.audit.express-check-csurf-middleware-usage.express-check-csurf-middleware-usage
        const app = express()
        const apiHandler = jest.fn()
        const CHECK_URL_PATH = '/check-account-number'

        app.get(CHECK_URL_PATH, async (req, res) => {
            return res.json(await apiHandler())
        })

        initTestExpressApp('OnlineInteraction', app)

        beforeAll(async () => {
            const baseUrl = getTestExpressApp('OnlineInteraction').baseUrl + CHECK_URL_PATH
            await utils.updateBillingIntegration({ checkAccountNumberUrl: baseUrl })
        })

        afterAll(async () => {
            await utils.updateBillingIntegration({ checkAccountNumberUrl: null })
        })

        afterEach(() => {
            jest.clearAllMocks()
        })

        test('', async () => {

        })

    })

    describe('Common cases', () => {

        test('Find organization if only addressKey is specified', async () => {
            const [foundOrganizations] = await findOrganizationsForAddressByTestClient(utils.clients.resident, {
                addressKey: utils.property.addressKey,
            })
            const found = foundOrganizations.find(({ organization: { id } }) => id === utils.organization.id)
            expect(found.account).toBeNull()
            expect(found.hasMeters).toBeFalsy()
            expect(found.hasBillingData).toBeTruthy()
            expect(found.organization).toMatchObject({
                id: expect.any(String),
                name: expect.any(String),
                tin: expect.any(String),
                type: expect.any(String),
            })
        })

        test('Find account and receipt if unitName and unitType matches', async () => {
            const unitName = utils.randomNumber(10).toString()
            const unitType = 'flat'
            const accountNumber = utils.randomNumber(10).toString()
            const toPay = utils.randomNumber(5).toString()
            await utils.createReceipts([
                utils.createJSONReceipt({
                    address: utils.property.address,
                    accountNumber,
                    addressMeta: { unitName, unitType },
                    toPay,
                }),
            ])
            const [foundOrganizations] = await findOrganizationsForAddressByTestClient(utils.clients.resident, {
                addressKey: utils.property.addressKey,
                unitName,
                unitType,
            })
            const found = foundOrganizations.find(({ organization: { id } }) => id === utils.organization.id)
            expect(found.account).toMatchObject({
                number: expect.stringMatching(accountNumber),
                category: expect.any(String),
                balance: expect.stringMatching(Big(toPay).toFixed(2)),
                routingNumber: expect.any(String),
                bankAccountNumber: expect.any(String),
            })
        })

    })


    describe('contexts statuses', () => {

        afterEach(async () => {
            await utils.updateBillingContext({ status: CONTEXT_FINISHED_STATUS })
        })

        test('should throw an error if billingContext is not in Finished status', async () => {

        })

    })

    describe('access checks', () => {

    })

})