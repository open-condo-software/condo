/**
 * Generated by `createservice resident.SendMessageToResidentScopesService --type mutations`
 */

const { faker } = require('@faker-js/faker')
const { isEmpty } = require('lodash')

const {
    makeLoggedInAdminClient, makeClient,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowGQLError, waitFor, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')


const { SUCCESS_STATUS } = require('@condo/domains/common/constants')
const { getStartDates } = require('@condo/domains/common/utils/date')
const {
    CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
    BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
    DEVICE_PLATFORM_ANDROID, APP_MASTER_ID_ANDROID, MESSAGE_SENT_STATUS,
} = require('@condo/domains/notification/constants/constants')
const { syncRemoteClientWithPushTokenByTestClient, Message } = require('@condo/domains/notification/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { renderTemplateString } = require('@condo/domains/resident/tasks/helpers/messageTools')
const { sendMessageToResidentScopesByTestClient } = require('@condo/domains/resident/utils/testSchema')
const { registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

const { ERRORS } = require('./SendMessageToResidentScopesService')

// Billing categories are constants within DB and added via migration 0121, so it's safe to use this value
const CATEGORY_HOUSING = '928c97ef-5289-4daa-b80e-4b9fed50c629'
const CATEGORY_HOUSING_I18_KEY = 'billing.category.housing.name.declined'

describe('SendMessageToResidentScopesService', () => {
    let adminClient, supportClient, serviceClient,
        anonymousClient, userClient, residentClient,
        property, organization, period

    beforeAll(async () => {
        const { thisMonthStart } = getStartDates()

        period = thisMonthStart
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        userClient = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymousClient = await makeClient()
        const organizationData = await createTestOrganization(adminClient)
        organization = organizationData[0]
        const propertyData = await createTestProperty(adminClient, organization)
        property = propertyData[0]
        residentClient = await makeClientWithResidentUser()
        serviceClient = await makeClientWithServiceUser()

    })
    afterAll( () => {
        if (global.gc) {
            global.gc()
        }
    })
    describe('sendScopeResidentMessage tests', () => {
        describe('check access', () => {
            test('admin can', async () => {
                const payload = {
                    type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
                    scopes: [{ property: { id: property.id } }],
                }
                const [data] = await sendMessageToResidentScopesByTestClient(adminClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)
            })

            test('service user can not', async () => {
                const payload = {
                    type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
                    scopes: [{ property: { id: property.id } }],
                }
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendMessageToResidentScopesByTestClient(serviceClient, payload)
                })
            })

            test('support can not', async () => {
                const payload = {
                    type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
                    scopes: [{ property: { id: property.id } }],
                }

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendMessageToResidentScopesByTestClient(supportClient, payload)
                })
            })

            test('random user can not', async () => {
                const payload = {
                    type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
                    scopes: [{ property: { id: property.id } }],
                }

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendMessageToResidentScopesByTestClient(userClient, payload)
                })
            })

            test('resident user can not', async () => {
                const payload = {
                    type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
                    scopes: [{ property: { id: property.id } }],
                }

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendMessageToResidentScopesByTestClient(residentClient, payload)
                })
            })

            test('anonymous user can not', async () => {
                const payload = {
                    type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
                    scopes: [{ property: { id: property.id } }],
                }

                await expectToThrowAuthenticationErrorToResult(async () => {
                    await sendMessageToResidentScopesByTestClient(anonymousClient, payload)
                })
            })
        })

        describe('validations', () => {
            test('throws on non existent notification type', async () => {
                const payload = {
                    type: faker.datatype.uuid(),
                    scopes: [{ property: { id: property.id } }],
                }
                const expectedErrorMessage = `Variable "$data" got invalid value "${payload.type}" at "data.type"; Value "${payload.type}" does not exist in "SendMessageType" enum.`

                await catchErrorFrom(
                    async () => { await sendMessageToResidentScopesByTestClient(adminClient, payload) },
                    ({ errors, data }) => {
                        expect(errors).toMatchObject([{ message: expectedErrorMessage }])
                        expect(data).toBeUndefined()
                    }
                )
            })

            test('throws on empty scopes', async () => {
                const payload = {
                    type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
                    scopes: [],
                }

                await expectToThrowGQLError(
                    async () => { await sendMessageToResidentScopesByTestClient(adminClient, payload) },
                    { ...ERRORS.SCOPES_IS_EMPTY },
                    'result'
                )
            })

            test('throws on missing property id', async () => {
                const payload = {
                    type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
                    scopes: [{ property: { id: property.id } }, {}],
                }
                const expectedErrorMessage = 'Variable "$data" got invalid value {} at "data.scopes[1]"; Field "property" of required type "PropertyWhereUniqueInput!" was not provided.'

                await catchErrorFrom(
                    async () => { await sendMessageToResidentScopesByTestClient(adminClient, payload) },
                    ({ errors, data }) => {
                        expect(errors).toMatchObject([{ message: expectedErrorMessage }])
                        expect(data).toBeUndefined()
                    }
                )
            })
        })

        describe('messages', () => {
            test('sends messages with proper contents to all residents of a property', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentsCount = Math.floor(Math.random() * 2) + 2
                let residentUsers = [], residents = []
                for (let i = 0; i < residentsCount; i++) {
                    residentUsers[i] = await makeClientWithResidentUser()

                    const [residentData] = await registerResidentByTestClient(residentUsers[i], residentPayload)

                    residents[i] = residentData
                    await syncRemoteClientWithPushTokenByTestClient(residentUsers[i], remoteClientPayload)
                }

                const sendMessagePayload = {
                    type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
                    scopes: [{ property: { id: property.id } }],
                    meta: {
                        categoryName: CATEGORY_HOUSING_I18_KEY,
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING}&organizationTIN=${organization.tin}`,
                            period,
                        },
                    },
                    uniqKeyTemplate: [CATEGORY_HOUSING, period, '{residentId}' ].join(':'),
                }
                const [data] = await sendMessageToResidentScopesByTestClient(adminClient, sendMessagePayload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const residentUserIds = residents.map(resident => resident.user.id)
                const messageWhere = { user: { id_in: residentUserIds }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(residentUsers.length)

                    for (const message of messages) {
                        const residentId = message.meta.data.residentId
                        const url = `payments/addaccount/?residentId=${residentId}&categoryId=${CATEGORY_HOUSING}&organizationTIN=${organization.tin}`
                        const uniqKey = [CATEGORY_HOUSING, period, residentId ].join(':')

                        expect(message.status).toEqual(MESSAGE_SENT_STATUS)
                        expect(message.meta.data.url).toEqual(url)
                        expect(message.uniqKey).toEqual(uniqKey)
                        expect(message.processingMeta.messageContext.notification.body).not.toContain(sendMessagePayload.meta.categoryName)
                    }

                })
            })

            test('properly fills urlTemplate and uniqKeyTemplate using meta.data values', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentUser = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUser, residentPayload)

                await syncRemoteClientWithPushTokenByTestClient(residentUser, remoteClientPayload)

                const sendMessagePayload = {
                    type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
                    scopes: [{ property: { id: property.id } }],
                    meta: {
                        title: faker.datatype.uuid(),
                        message: faker.datatype.uuid(),
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING}&organizationTIN=${organization.tin}`,
                            period,
                            categoryId: CATEGORY_HOUSING,
                        },
                    },
                    uniqKeyTemplate: ['{categoryId}', '{period}', '{residentId}' ].join(':'),
                }
                const [data] = await sendMessageToResidentScopesByTestClient(adminClient, sendMessagePayload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const messageWhere = { user: { id_in: [resident.user.id] }, type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE }
                const url = `payments/addaccount/?residentId=${resident.id}&categoryId=${CATEGORY_HOUSING}&organizationTIN=${organization.tin}`
                const uniqKey = [CATEGORY_HOUSING, period, resident.id ].join(':')

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(1)

                    const [message] = messages

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message.uniqKey).toEqual(uniqKey)
                    expect(message.meta.data.url).toEqual(url)
                })
            })


            test('no duplicate notifications sent', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentUser = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUser, residentPayload)

                await syncRemoteClientWithPushTokenByTestClient(residentUser, remoteClientPayload)

                const sendMessagePayload = {
                    type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE,
                    scopes: [{ property: { id: property.id } }],
                    meta: {
                        title: faker.datatype.uuid(),
                        message: faker.datatype.uuid(),
                        data: {
                            categoryId: CATEGORY_HOUSING,
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING}&organizationTIN=${organization.tin}`,
                            period,
                        },
                    },
                    uniqKeyTemplate: [CATEGORY_HOUSING, period, '{residentId}' ].join(':'),
                }
                const [data] = await sendMessageToResidentScopesByTestClient(adminClient, sendMessagePayload)

                await sendMessageToResidentScopesByTestClient(adminClient, sendMessagePayload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const messageWhere = { user: { id_in: [resident.user.id] }, type: CUSTOM_CONTENT_MESSAGE_PUSH_TYPE }

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(1)
                    expect(messages[0].status).toEqual(MESSAGE_SENT_STATUS)
                })
            })

            test('properly fills payload for BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE message type', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentUser = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUser, residentPayload)

                await syncRemoteClientWithPushTokenByTestClient(residentUser, remoteClientPayload)

                const sendMessagePayload = {
                    type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
                    scopes: [{ property: { id: property.id } }],
                    meta: {
                        title: faker.datatype.uuid(),
                        message: faker.datatype.uuid(),
                        categoryName: CATEGORY_HOUSING_I18_KEY,
                        data: {
                            categoryId: CATEGORY_HOUSING,
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING}&organizationTIN=${organization.tin}`,
                            period,
                        },
                    },
                    uniqKeyTemplate: [CATEGORY_HOUSING, period, '{residentId}' ].join(':'),
                }

                const [data] = await sendMessageToResidentScopesByTestClient(adminClient, sendMessagePayload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const messageWhere = { user: { id_in: [resident.user.id] }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }
                const uniqKey = renderTemplateString(sendMessagePayload.uniqKeyTemplate, { residentId: resident.id })
                const url = renderTemplateString(sendMessagePayload.meta.data.urlTemplate, { residentId: resident.id })

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(1)

                    const [message] = messages

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message.uniqKey).toEqual(uniqKey)
                    expect(message.meta.data.url).toEqual(url)
                    expect(message.meta.categoryName).toEqual(sendMessagePayload.meta.categoryName)
                })
            })
        })
    })
})