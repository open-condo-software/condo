/**
 * Generated by `createservice property.RegisterResidentService --type mutations`
 */
const { get } = require('lodash')

const {
    createInstance: createAddressServiceClientInstance,
} = require('@open-condo/clients/address-service-client')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { getLogger } = require('@open-condo/keystone/logging')
const { getById, GQLCustomSchema } = require('@open-condo/keystone/schema')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { BillingAccount } = require('@condo/domains/billing/utils/serverSchema')
const { MANAGING_COMPANY_TYPE } = require('@condo/domains/organization/constants/common')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { Property: PropertyAPI } = require('@condo/domains/property/utils/serverSchema')
const access = require('@condo/domains/resident/access/RegisterResidentService')
const {
    RESIDENT_DISCOVER_CONSUMERS_WINDOW_SEC,
    MAX_RESIDENT_DISCOVER_CONSUMERS_BY_WINDOW_SEC,
} = require('@condo/domains/resident/constants/constants')
const { ADDRESS_NOT_FOUND_ERROR, ALREADY_REGISTERED_ERROR } = require('@condo/domains/resident/constants/errors')
const { Resident: ResidentAPI } = require('@condo/domains/resident/utils/serverSchema')
const { discoverServiceConsumers } = require('@condo/domains/resident/utils/serverSchema')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')
const redisGuard = new RedisGuard()

const logger = getLogger()

const checkLimits = async (uniqueField, context) => {
    await redisGuard.checkCustomLimitCounters(
        `discover-service-consumers-${uniqueField}`,
        RESIDENT_DISCOVER_CONSUMERS_WINDOW_SEC,
        MAX_RESIDENT_DISCOVER_CONSUMERS_BY_WINDOW_SEC,
        context,
    )
}

const ERRORS = {
    ADDRESS_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: ADDRESS_NOT_FOUND_ERROR,
        message: 'The specified address is not found in the address service',
        messageForUser: 'api.resident.registerResident.ADDRESS_NOT_FOUND',
    },
    ALREADY_REGISTERED: {
        code: BAD_USER_INPUT,
        type: ALREADY_REGISTERED_ERROR,
        message: 'The specified resident is already registered',
        messageForUser: 'api.resident.registerResident.ALREADY_REGISTERED',
    },
}

const RegisterResidentService = new GQLCustomSchema('RegisterResidentService', {
    types: [
        {
            access: true,
            // TODO(DOMA-6063): we need to remove `addressMeta` attribute here! We can work only with the `address` argument and request all data from addressService by addressKey or raw address string
            type: 'input RegisterResidentInput { dv: Int!, sender: SenderFieldInput!, address: String!, addressMeta: AddressMetaFieldInput, unitName: String!, unitType: BuildingUnitSubType }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterResident,
            schema: 'registerResident(data: RegisterResidentInput!): Resident',
            resolver: async (parent, args, context) => {
                const { data: { dv, sender, address, unitName, unitType } } = args

                const attrs = {
                    dv,
                    sender,
                    address,
                    unitName,
                    unitType,
                    user: { connect: { id: context.authedItem.id } },
                }

                const client = createAddressServiceClientInstance({ address })

                const addressItem = await client.search(address)

                if (!addressItem || !addressItem.addressKey || !addressItem.address) {
                    throw new GQLError(ERRORS.ADDRESS_NOT_FOUND, context)
                }

                const [existingResident] = await ResidentAPI.getAll(context, {
                    // Keep searching by address string and additionally search by addressKey
                    addressKey: addressItem.addressKey,
                    unitName_i: unitName,
                    unitType,
                    deletedAt: null,
                    user: { id: context.authedItem.id },
                }, 'id', {
                    first: 1,
                })

                const [property] = await PropertyAPI.getAll(context, {
                    addressKey: addressItem.addressKey,
                    organization: { type: MANAGING_COMPANY_TYPE },
                    deletedAt: null,
                },
                'id',
                { sortBy: ['isApproved_DESC', 'createdAt_ASC'], first: 1 },
                )

                if (property) {
                    attrs.property = { connect: { id: property.id } }
                }

                if (!attrs.unitType) {
                    attrs.unitType = FLAT_UNIT_TYPE
                }

                if (existingResident) {
                    throw new GQLError(ERRORS.ALREADY_REGISTERED, context)
                }

                const residentAttrs = { ...attrs, address: addressItem.address }
                const resident = await ResidentAPI.create(context, residentAttrs)

                const id = resident.id

                try {
                    await checkLimits(context.authedItem.id, context)
                    const billingAccounts = await BillingAccount.getAll(
                        context,
                        {
                            context: { status: CONTEXT_FINISHED_STATUS, deletedAt: null },
                            property: { address, deletedAt: null },
                            unitType,
                            unitName,
                        },
                    )

                    try {
                        if (billingAccounts.length > 0) {
                            // Call the mutation directly (without task) to make the resident see receipts immediately
                            const discoveringResult = await discoverServiceConsumers(context, {
                                dv,
                                sender,
                                billingAccountsIds: billingAccounts.map(({ id }) => id),
                                filters: { residentsIds: [id] },
                            })
                            logger.info({
                                msg: 'discoverServiceConsumers done',
                                data: {
                                    result: discoveringResult,
                                    residentId: id,
                                },
                                entityId: context.authedItem.id,
                                entity: 'User',
                            })
                        }
                    } catch (err) {
                        logger.error({
                            msg: 'discoverServiceConsumers fail',
                            entityId: context.authedItem.id,
                            entity: 'User',
                            data: {
                                residentId: id,
                            },
                            err,
                        })
                    }
                } catch (err) {
                    logger.warn({
                        msg: 'discoverServiceConsumers limit error',
                        entityId: context.authedItem.id,
                        entity: 'User',
                        data: {
                            residentId: id,
                        },
                        err,
                    })
                }

                // Hack that helps to resolve all subfields in result of this mutation
                return await getById('Resident', id)
            },
        },
    ],

})

module.exports = {
    RegisterResidentService,
}
