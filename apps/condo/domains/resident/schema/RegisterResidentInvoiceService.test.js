/**
 * Generated by `createservice marketplace.RegisterInvoiceService '--type=mutations' 'resident: ResidentWhereUniqueInput!, rows:[InvoiceRowSchemaFieldInput!]!'`
 */

const { faker } = require('@faker-js/faker')
const { pick } = require('lodash')

const {
    makeClient,
    makeLoggedInAdminClient, UUID_RE,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult, expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { createTestAcquiringIntegration, createTestAcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/testSchema')
const {
    INVOICE_STATUS_DRAFT,
    INVOICE_STATUS_PUBLISHED,
} = require('@condo/domains/marketplace/constants')
const {
    createTestMarketPriceScope, createTestMarketItem,
    createTestMarketCategory, createTestMarketItemPrice, generatePriceRow, Invoice,
} = require('@condo/domains/marketplace/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { registerResidentByTestClient, registerResidentInvoiceByTestClient } = require('@condo/domains/resident/utils/testSchema')
const { Ticket } = require('@condo/domains/ticket/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithResidentUser, makeClientWithStaffUser,
} = require('@condo/domains/user/utils/testSchema')

const MOBILE_APP_RESIDENT_TICKET_SOURCE_ID = '3068d49a-a45c-4c3a-a02d-ea1a53e1febb'

let adminClient
let organization, acquiringIntegration

describe('RegisterResidentInvoiceService', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        ;[acquiringIntegration] = await createTestAcquiringIntegration(adminClient)
        ;[organization] = await createTestOrganization(adminClient)
        await createTestAcquiringIntegrationContext(adminClient, organization, acquiringIntegration, { invoiceStatus: CONTEXT_FINISHED_STATUS })
    })

    test('admin can execute', async () => {
        const [property] = await createTestProperty(adminClient, organization)

        const unitType = FLAT_UNIT_TYPE
        const unitName = faker.lorem.word()
        const [resident] = await registerResidentByTestClient(
            adminClient,
            {
                address: property.address,
                addressMeta: property.addressMeta,
                unitType,
                unitName,
            })

        const [marketCategory] = await createTestMarketCategory(adminClient)
        const [marketItem] = await createTestMarketItem(adminClient, marketCategory, organization)
        const [itemPrice] = await createTestMarketItemPrice(adminClient, marketItem)
        const [priceScope] = await createTestMarketPriceScope(adminClient, itemPrice, property)

        const [invoice] = await registerResidentInvoiceByTestClient(
            adminClient,
            pick(resident, 'id'),
            [{
                priceScope: pick(priceScope, 'id'),
                count: 1,
            }],
        )

        expect(invoice).toBeTruthy()

        expect(invoice.id).toMatch(UUID_RE)
        expect(invoice.ticket).toBeTruthy()
        expect(invoice.ticket.id).toMatch(UUID_RE)
    })

    test('user can\'t execute', async () => {
        const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

        await expectToThrowAccessDeniedErrorToResult(async () => {
            await registerResidentInvoiceByTestClient(userClient, { id: faker.datatype.uuid() }, [])
        })
    })

    test('anonymous can\'t execute', async () => {
        const client = await makeClient()
        await expectToThrowAuthenticationErrorToResult(async () => {
            await registerResidentInvoiceByTestClient(client, { id: faker.datatype.uuid() }, [])
        })
    })

    describe('resident', () => {
        test('resident can execute, staff can see', async () => {
            const [property] = await createTestProperty(adminClient, organization)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const [marketCategory] = await createTestMarketCategory(adminClient)
            const [marketItem] = await createTestMarketItem(adminClient, marketCategory, organization)
            const [itemPrice] = await createTestMarketItemPrice(adminClient, marketItem)
            const [priceScope] = await createTestMarketPriceScope(adminClient, itemPrice, property)

            const [invoice] = await registerResidentInvoiceByTestClient(
                residentClient,
                pick(resident, 'id'),
                [{
                    priceScope: pick(priceScope, 'id'),
                    count: 1,
                }],
            )

            expect(invoice).toBeTruthy()

            expect(invoice.id).toMatch(UUID_RE)
            expect(invoice.context).toBeFalsy() // resident can't read invoice context
            expect(invoice.status).toBe(INVOICE_STATUS_PUBLISHED)
            expect(invoice.client).toBeTruthy()
            expect(invoice.client.id).toBe(residentClient.user.id)
            expect(invoice.ticket).toBeTruthy()
            expect(invoice.ticket.id).toMatch(UUID_RE)

            const ticket = await Ticket.getOne(residentClient, { id: invoice.ticket.id })

            expect(ticket.isResidentTicket).toBe(true)
            expect(ticket.property).toBeTruthy()
            expect(ticket.property.id).toBe(property.id)
            expect(ticket.isPayable).toBe(true)
            expect(ticket.source.id).toBe(MOBILE_APP_RESIDENT_TICKET_SOURCE_ID)
            expect(ticket.source.type).toBe('mobile_app')

            const staffClient = await makeClientWithStaffUser()
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, { canReadInvoices: true })
            await createTestOrganizationEmployee(adminClient, organization, staffClient.user, role)

            const objs = await Invoice.getAll(staffClient, {}, { sortBy: ['updatedAt_DESC'] })

            expect(objs).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    id: invoice.id,
                }),
            ]))
        })

        test('can\'t create invoice if no finished acquiring context', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            await createTestAcquiringIntegrationContext(adminClient, o10n, acquiringIntegration)

            const [property] = await createTestProperty(adminClient, o10n)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const [marketCategory] = await createTestMarketCategory(adminClient)
            const [marketItem] = await createTestMarketItem(adminClient, marketCategory, o10n)
            const [itemPrice] = await createTestMarketItemPrice(adminClient, marketItem)
            const [priceScope] = await createTestMarketPriceScope(adminClient, itemPrice, property)

            await expectToThrowGQLError(async () => await registerResidentInvoiceByTestClient(
                residentClient,
                pick(resident, 'id'),
                [{
                    priceScope: pick(priceScope, 'id'),
                    count: 1,
                }],
            ), {
                code: 'BAD_USER_INPUT',
                type: 'NO_ACQUIRING_CONTEXT',
                message: 'The organization hasn\'t set up the marketplace',
                messageForUser: 'api.marketplace.registerInvoice.error.noAcquiringContext',
            }, 'result')
        })

        test('can\'t create invoice with items from other organization', async () => {
            const [o10n1] = await createTestOrganization(adminClient)
            const [o10n2] = await createTestOrganization(adminClient)

            await createTestAcquiringIntegrationContext(adminClient, o10n1, acquiringIntegration, { invoiceStatus: CONTEXT_FINISHED_STATUS })
            await createTestAcquiringIntegrationContext(adminClient, o10n2, acquiringIntegration, { invoiceStatus: CONTEXT_FINISHED_STATUS })

            const [property1] = await createTestProperty(adminClient, o10n1)
            const [property2] = await createTestProperty(adminClient, o10n2)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property1.address,
                    addressMeta: property1.addressMeta,
                    unitType,
                    unitName,
                })

            const [marketCategory] = await createTestMarketCategory(adminClient)
            const [marketItem] = await createTestMarketItem(adminClient, marketCategory, o10n2)
            const [itemPrice] = await createTestMarketItemPrice(adminClient, marketItem)
            const [priceScope] = await createTestMarketPriceScope(adminClient, itemPrice, property2)

            await expectToThrowGQLError(async () => await registerResidentInvoiceByTestClient(
                residentClient,
                pick(resident, 'id'),
                [{
                    priceScope: pick(priceScope, 'id'),
                    count: 1,
                }],
            ), {
                code: 'BAD_USER_INPUT',
                type: 'ITEM_FROM_OTHER_ORGANIZATION',
                message: 'Item from other organization. Check line 1',
                messageForUser: 'api.marketplace.registerInvoice.error.itemFromOtherOrganization',
                messageInterpolation: { rowNumber: 1 },
            }, 'result')
        })

        test('Create draft invoice if one of rows has isMin=true for price, resident can see draft of him', async () => {
            const [property] = await createTestProperty(adminClient, organization)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            const [marketCategory] = await createTestMarketCategory(adminClient)
            const [marketItem] = await createTestMarketItem(adminClient, marketCategory, organization)
            const [itemPrice] = await createTestMarketItemPrice(adminClient, marketItem, { price: [generatePriceRow({ isMin: true })] })
            const [priceScope] = await createTestMarketPriceScope(adminClient, itemPrice, property)

            const [invoice] = await registerResidentInvoiceByTestClient(
                residentClient,
                pick(resident, 'id'),
                [{
                    priceScope: pick(priceScope, 'id'),
                    count: 1,
                }],
            )

            expect(invoice).toBeTruthy()

            expect(invoice.status).toBe(INVOICE_STATUS_DRAFT)

            const invoices = await Invoice.getAll(residentClient, {})

            expect(invoices).toHaveLength(1)
            expect(invoices[0].id).toBe(invoice.id)
            expect(invoices[0].client.id).toBe(residentClient.user.id)
            expect(invoices[0].status).toBe(INVOICE_STATUS_DRAFT)
        })

        test('can\'t create invoice with no rows', async () => {
            const [property] = await createTestProperty(adminClient, organization)

            const residentClient = await makeClientWithResidentUser()
            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: property.address,
                    addressMeta: property.addressMeta,
                    unitType,
                    unitName,
                })

            await expectToThrowGQLError(async () => await registerResidentInvoiceByTestClient(
                residentClient,
                pick(resident, 'id'),
                [],
            ), {
                code: 'BAD_USER_INPUT',
                type: 'EMPTY_ROWS',
                message: 'The invoice contains no rows',
                messageForUser: 'api.marketplace.invoice.error.emptyRows',
            }, 'result')

            await expectToThrowGQLError(async () => await registerResidentInvoiceByTestClient(
                residentClient,
                pick(resident, 'id'),
                [{
                    priceScope: { id: faker.datatype.uuid() }, // try to pass some non-existing uuid
                    count: 1,
                }],
            ), {
                code: 'BAD_USER_INPUT',
                type: 'EMPTY_ROWS',
                message: 'The invoice contains no rows',
                messageForUser: 'api.marketplace.invoice.error.emptyRows',
            }, 'result')
        })
    })
})
