/**
 * Generated by `createservice organization.SuggestServiceProviderService --type queries`
 */

const {
    expectToThrowAuthenticationErrorToResult,
    expectToThrowAccessDeniedErrorToResult,
} = require('@open-condo/keystone/test.utils')


const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    TestUtils,
    ResidentTestMixin,
    MeterTestMixin,
    AcquiringTestMixin,
} = require('@condo/domains/billing/utils/testSchema/testUtils')
const { RUSSIAN_COUNTRY } = require('@condo/domains/common/constants/countries')
const { COLD_WATER_METER_RESOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { createTestMeterResourceOwner, updateTestMeterResourceOwner, MeterResource, MeterResourceOwner } = require('@condo/domains/meter/utils/testSchema')
const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const { generateTin } = require('@condo/domains/organization/utils/testSchema')
const { suggestServiceProviderByTestClient } = require('@condo/domains/resident/utils/testSchema')


const addMeterResourceOwner = async (utils) => {
    const resource = await MeterResource.getOne(utils.clients.admin, { id: COLD_WATER_METER_RESOURCE_ID })
    return createTestMeterResourceOwner(utils.clients.admin, utils.organization, resource, {
        address: utils.property.address,
    })
}
const removeMeterResourceOwners = async (utils) => {
    const owners = await MeterResourceOwner.getAll(utils.clients.admin, { organization: { id: utils.organization.id } })
    for (const owner of owners) {
        await updateTestMeterResourceOwner(utils.clients.admin, owner.id, { deletedAt: new Date().toISOString() })
    }
}

describe('SuggestServiceProviderService', () => {

    let utils

    beforeAll(async () => {
        utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
        await utils.init()
        await utils.updateOrganization({ type: SERVICE_PROVIDER_TYPE })
    })

    describe('Permissions check', () => {

        describe('Can not execute', () => {

            test('anonymous: can not execute', async () => {
                await expectToThrowAuthenticationErrorToResult(async () => {
                    await suggestServiceProviderByTestClient(utils.clients.anonymous, {
                        search: String(generateTin(RUSSIAN_COUNTRY)),
                    })
                })
            })
            test('user: can not execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await suggestServiceProviderByTestClient(utils.clients.user, {
                        search: String(generateTin(RUSSIAN_COUNTRY)),
                    })
                })
            })
            test('employee: can not execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await suggestServiceProviderByTestClient(utils.clients.employee['billing'], {
                        search: String(generateTin(RUSSIAN_COUNTRY)),
                    })
                })
            })
            test('service user: can not execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await suggestServiceProviderByTestClient(utils.clients.service, {
                        search: String(generateTin(RUSSIAN_COUNTRY)),
                    })
                })
            })

        })

        describe('Can execute', () => {
            test('admin: can execute', async () => {
                const [organizations] = await suggestServiceProviderByTestClient(utils.clients.admin, {
                    search: utils.organization.tin.substr(0, 5),
                })
                expect(organizations).not.toHaveLength(0)
            })
            test('support: can execute', async () => {
                const [organizations] = await suggestServiceProviderByTestClient(utils.clients.support, {
                    search: utils.organization.tin.substr(0, 5),
                })
                expect(organizations).not.toHaveLength(0)
            })
            test('resident: can execute', async () => {
                const [organizations] = await suggestServiceProviderByTestClient(utils.clients.resident, {
                    search: utils.organization.tin.substr(0, 5),
                })
                expect(organizations).not.toHaveLength(0)
            })
        })
    })

    describe('Filtering options', () => {

        beforeEach(async () => {
            await utils.updateAcquiringContext({ status: CONTEXT_FINISHED_STATUS })
            await removeMeterResourceOwners(utils)
        })

        const getPartialTinAndName = () => {
            const tin = utils.organization.tin.substr(0, 5)
            const name = utils.organization.name.substr(0, utils.organization.name.length / 2)
            return [tin, name]
        }

        describe('Should find', () => {

            test('should find organization with finished acquiring context', async () => {
                for (const tinOrName of getPartialTinAndName()) {
                    const [organizations] = await suggestServiceProviderByTestClient(utils.clients.resident, {
                        search: tinOrName,
                    })
                    expect(organizations).toContainEqual({
                        tin: utils.organization.tin,
                        name: utils.organization.name,
                    })
                }
            })

            test('should find organization with meter resource owning', async () => {
                await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })
                await addMeterResourceOwner(utils)

                for (const tinOrName of getPartialTinAndName()) {
                    const [organizations] = await suggestServiceProviderByTestClient(utils.clients.resident, {
                        search: tinOrName,
                    })
                    expect(organizations).toContainEqual({
                        tin: utils.organization.tin,
                        name: utils.organization.name,
                    })
                }
            })

            test('should find organization with finished acquiring context and meter resource owning', async () => {
                await addMeterResourceOwner(utils)

                for (const tinOrName of getPartialTinAndName()) {
                    const [organizations] = await suggestServiceProviderByTestClient(utils.clients.resident, {
                        search: tinOrName,
                    })
                    expect(organizations).toContainEqual({
                        tin: utils.organization.tin,
                        name: utils.organization.name,
                    })
                }
            })


        })

        describe('Should not find', () => {

            test('should not find organization without acquiring context in Finished status and without meter owning', async () => {
                await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })

                for (const tinOrName of getPartialTinAndName()) {
                    const [organizations] = await suggestServiceProviderByTestClient(utils.clients.resident, {
                        search: tinOrName,
                    })
                    expect(organizations).not.toContainEqual({
                        tin: utils.organization.tin,
                        name: utils.organization.name,
                    })
                }
            })

        })

        describe('Duplicates', () => {

            test('should merge organizations with same tin', async () => {
                const utils2 = new TestUtils([AcquiringTestMixin])
                await utils2.init()
                await utils2.updateOrganization({
                    tin: utils.organization.tin,
                    type: SERVICE_PROVIDER_TYPE,
                })
                await utils2.updateAcquiringContext({ status: CONTEXT_FINISHED_STATUS })

                const [suggestedProviders] = await suggestServiceProviderByTestClient(utils.clients.resident, {
                    search: utils.organization.tin,
                })
                expect(utils.organization.tin).toEqual(utils2.organization.tin)
                expect(utils.organization.id).not.toEqual(utils2.organization.id)
                expect(suggestedProviders).toHaveLength(1)
            })

        })

    })

})
