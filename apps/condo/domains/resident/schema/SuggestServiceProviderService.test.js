/**
 * Generated by `createservice organization.SuggestServiceProviderService --type queries`
 */

const { faker } = require('@faker-js/faker')
const { values } = require('lodash')

const {
    expectToThrowAuthenticationErrorToResult,
    expectToThrowAccessDeniedErrorToResult,
} = require('@open-condo/keystone/test.utils')


const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    TestUtils,
    ResidentTestMixin,
    MeterTestMixin,
} = require('@condo/domains/billing/utils/testSchema/testUtils')
const { RUSSIAN_COUNTRY, DEFAULT_ENGLISH_COUNTRY } = require('@condo/domains/common/constants/countries')
const { COLD_WATER_METER_RESOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { createTestMeterResourceOwner, updateTestMeterResourceOwner, MeterResource, MeterResourceOwner } = require('@condo/domains/meter/utils/testSchema')
const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const { createTestOrganization, updateTestOrganization, generateTin } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty, updateTestProperty } = require('@condo/domains/property/utils/testSchema')
const { suggestProviderByTestClient } = require('@condo/domains/resident/utils/testSchema')


const addMeterResourceOwner = async (utils) => {
    const resource = await MeterResource.getOne(utils.clients.admin, { id: COLD_WATER_METER_RESOURCE_ID })
    return createTestMeterResourceOwner(utils.clients.admin, utils.organization, resource, {
        address: utils.property.address,
    })
}
const removeMeterResourceOwners = async (utils) => {
    const owners = await MeterResourceOwner.getAll(utils.clients.admin, { organization: { id: utils.organization.id } })
    for (const owner of owners) {
        await updateTestMeterResourceOwner(utils.clients.admin, owner.id, { deletedAt: new Date().toISOString() })
    }
}

const generateServiceProviders = async (client, count, extraAttrs) => {
    const serviceProviders = []
    const attrs = {
        type: SERVICE_PROVIDER_TYPE,
        ...extraAttrs,
    }
    for (let i = 0; i < count; i++) {
        const serviceProvider = createTestOrganization(client, attrs).then(pair => pair[0])
        serviceProviders.push(serviceProvider)
    }
    return Promise.all(serviceProviders)
}

describe('SuggestServiceProviderService', () => {

    let utils

    beforeAll(async () => {
        utils = new TestUtils([ResidentTestMixin, MeterTestMixin])
        await utils.init()
        await utils.updateOrganization({ type: SERVICE_PROVIDER_TYPE })
    })

    describe('Permissions check', () => {
        test('anonymous: can not execute', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await suggestProviderByTestClient(utils.clients.anonymous, {
                    tinOrName: String(generateTin(RUSSIAN_COUNTRY)),
                })
            })
        })
        test('user: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await suggestProviderByTestClient(utils.clients.user, {
                    tinOrName: String(generateTin(RUSSIAN_COUNTRY)),
                })
            })
        })
        test('employee: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await suggestProviderByTestClient(utils.clients.employee['billing'], {
                    tinOrName: String(generateTin(RUSSIAN_COUNTRY)),
                })
            })
        })
        test('service user: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await suggestProviderByTestClient(utils.clients.service, {
                    tinOrName: String(generateTin(RUSSIAN_COUNTRY)),
                })
            })
        })
        test('admin: can execute', async () => {
            const [organizations] = await suggestProviderByTestClient(utils.clients.admin, {
                tinOrName: utils.organization.tin.substr(0, 5),
            })
            expect(organizations).not.toHaveLength(0)
        })
        test('support: can execute', async () => {
            const [organizations] = await suggestProviderByTestClient(utils.clients.support, {
                tinOrName: utils.organization.tin.substr(0, 5),
            })
            expect(organizations).not.toHaveLength(0)
        })
        test('resident: can execute', async () => {
            const [organizations] = await suggestProviderByTestClient(utils.clients.resident, {
                tinOrName: utils.organization.tin.substr(0, 5),
            })
            expect(organizations).not.toHaveLength(0)
        })
    })

    describe('Filtering options', () => {

        beforeEach(async () => {
            await utils.updateAcquiringContext({ status: CONTEXT_FINISHED_STATUS })
            await removeMeterResourceOwners(utils)
        })

        const getPartialTinAndName = () => {
            const tin = utils.organization.tin.substr(0, 5)
            const name = utils.organization.name.substr(0, utils.organization.name.length / 2)
            return [tin, name]
        }

        test('should find organization with finished acquiring context', async () => {
            for (const tinOrName of getPartialTinAndName()) {
                const [organizations] = await suggestProviderByTestClient(utils.clients.resident, {
                    tinOrName: tinOrName,
                })
                expect(organizations).toContainEqual({
                    tin: utils.organization.tin,
                    name: utils.organization.name,
                })
            }
        })

        test('should find organization with meter resource owning', async () => {
            await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            await addMeterResourceOwner(utils)

            for (const tinOrName of getPartialTinAndName()) {
                const [organizations] = await suggestProviderByTestClient(utils.clients.resident, {
                    tinOrName: tinOrName,
                })
                expect(organizations).toContainEqual({
                    tin: utils.organization.tin,
                    name: utils.organization.name,
                })
            }
        })

        test('should find organization with finished acquiring context and meter resource owning', async () => {
            await addMeterResourceOwner(utils)

            for (const tinOrName of getPartialTinAndName()) {
                const [organizations] = await suggestProviderByTestClient(utils.clients.resident, {
                    tinOrName: tinOrName,
                })
                expect(organizations).toContainEqual({
                    tin: utils.organization.tin,
                    name: utils.organization.name,
                })
            }
        })

        test('should not find organization without acquiring context in Finished status and without meter owning', async () => {
            await utils.updateAcquiringContext({ status: CONTEXT_IN_PROGRESS_STATUS })

            for (const tinOrName of getPartialTinAndName()) {
                const [organizations] = await suggestProviderByTestClient(utils.clients.resident, {
                    tinOrName: tinOrName,
                })
                expect(organizations).not.toContainEqual({
                    tin: utils.organization.tin,
                    name: utils.organization.name,
                })
            }
        })

        test('should merge organizations with same tin', async () => {
            const tin = generateTin(faker.helpers.arrayElement([RUSSIAN_COUNTRY, DEFAULT_ENGLISH_COUNTRY]))
            const serviceProviders = await generateServiceProviders(utils.clients.admin, 5, { tin: tin })
            const names = serviceProviders.map(provider => provider.name)
            
            const toCleanup = {
                organizations: {
                    items: [...serviceProviders],
                    cleanupFn: (id) => updateTestOrganization(utils.clients.admin, id, { deletedAt: new Date().toISOString() }),
                },
                properties: {
                    items: [],
                    cleanupFn: (id) => updateTestProperty(utils.clients.admin, id, { deletedAt: new Date().toISOString() }),
                },
                meterResourceOwners: {
                    items: [],
                    cleanupFn: (id) => updateTestMeterResourceOwner(utils.clients.admin, id, { deletedAt: new Date().toISOString() }),
                },
            }
            
            try {
                const resource = await MeterResource.getOne(utils.clients.admin, { id: COLD_WATER_METER_RESOURCE_ID })
                for (const serviceProvider of serviceProviders) {
                    const [organization] = await createTestOrganization(utils.clients.admin)
                    const [property] = await createTestProperty(utils.clients.admin, organization)
                    const [meterResourceOwner] = await createTestMeterResourceOwner(utils.clients.admin, serviceProvider, resource, {
                        address: property.address,
                    })

                    toCleanup.organizations.items.push(organization)
                    toCleanup.properties.items.push(property)
                    toCleanup.meterResourceOwners.items.push(meterResourceOwner)
                }

                const searchParams = [
                    tin.substring(0, 5),
                    names[0].substring(0, names[0].length / 2),
                ]

                for (const searchParam of searchParams) {
                    const [suggestedProviders] = await suggestProviderByTestClient(utils.clients.resident, {
                        tinOrName: searchParam,
                    })
                    const uniqueTins = new Set(suggestedProviders.map((provider) => provider.tin))

                    expect(uniqueTins.size).toBeGreaterThanOrEqual(1)
                    expect(uniqueTins).toContain(tin)
                }
                
            } finally {
                const cleanupPromises = values(toCleanup)
                    .flatMap(category =>
                        category.items.map(item => category.cleanupFn(item.id))
                    )
                await Promise.all(cleanupPromises)
                    .catch(err => console.error('could not cleanup properly', err))
            }
        })
    })
})
