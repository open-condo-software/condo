/**
 * Generated by `createschema resident.Resident 'user:Relationship:User:CASCADE; organization:Relationship:Organization:PROTECT; property:Relationship:Property:PROTECT; billingAccount?:Relationship:BillingAccount:SET_NULL; unitName:Text;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const cloneDeep = require('lodash/cloneDeep')


const { generateGqlQueries } = require('@open-condo/codegen/generate.gql')
const { generateGQLTestUtils } = require('@open-condo/codegen/generate.test.utils')
const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, waitFor, expectToThrowValidationFailureError } = require('@open-condo/keystone/test.utils')
const {
    catchErrorFrom,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAccessDeniedErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { DEFAULT_ACQUIRING_INTEGRATION_NAME } = require('@condo/domains/acquiring/constants/integration')
const {
    createTestAcquiringIntegration,
    createTestAcquiringIntegrationContext,
    createTestRecurrentPaymentContext,
    RecurrentPaymentContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const { DEFAULT_BILLING_INTEGRATION_NAME } = require('@condo/domains/billing/constants/constants')
const {
    createTestBillingIntegrationOrganizationContext,
    createTestBillingIntegration,
    createTestBillingAccount,
    createTestBillingProperty,
    makeContextWithOrganizationAndIntegrationAsAdmin,
    createTestBillingCategory,
} = require('@condo/domains/billing/utils/testSchema')
const {
    createTestContact,
    updateTestContact,
    createTestContactRole,
    updateTestContactRole,
} = require('@condo/domains/contact/utils/testSchema')
const { COLD_WATER_METER_RESOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { MeterResource } = require('@condo/domains/meter/utils/testSchema')
const { createTestMeter } = require('@condo/domains/meter/utils/testSchema')
const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const { createTestOrganization, registerNewOrganization } = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE, COMMERCIAL_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { buildingMapJson } = require('@condo/domains/property/constants/property')
const {
    createTestProperty,
    makeClientWithResidentAccessAndProperty,
    makeClientWithProperty,
} = require('@condo/domains/property/utils/testSchema')
const { buildFakeAddressMeta, buildFakeAddressAndMeta } = require('@condo/domains/property/utils/testSchema/factories')
const {
    Resident,
    createTestResident,
    updateTestResident,
    makeClientWithServiceConsumer,
    registerResidentByTestClient,
} = require('@condo/domains/resident/utils/testSchema')
const {
    createTestTicketFile,
    updateTestTicketFile,
    createTestTicket,
    updateTestTicket,
} = require('@condo/domains/ticket/utils/testSchema')
const {
    makeClientWithResidentUser,
    makeClientWithNewRegisteredAndLoggedInUser,
    addResidentAccess,
    createTestPhone,
    updateTestUser,
    createTestUserRightsSet,
} = require('@condo/domains/user/utils/testSchema')

describe('Resident', () => {

    describe('resolveInput', () => {
        it('resolves address to address up to building, if flat is presented in address string', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const addressMetaWithFlat = cloneDeep(userClient.property.addressMeta)
            addressMetaWithFlat.data.flat = '123'
            addressMetaWithFlat.data.flat_type = 'кв.'
            addressMetaWithFlat.value = addressMetaWithFlat.value + ', кв. 123'

            const attrs = {
                address: addressMetaWithFlat.value,
                unitName: faker.random.alphaNumeric(3),
                addressMeta: addressMetaWithFlat,
            }

            const [objCreated] = await createTestResident(adminClient, userClient.user, userClient.property, attrs)
            expect(objCreated.address).toEqual(userClient.property.addressMeta.value)
        })

        describe('unitType and unitName', () => {
            let admin, user

            beforeAll(async () => {
                admin = await makeLoggedInAdminClient()
            })

            beforeEach(async () => {
                user = await makeClientWithProperty()
            })

            test('unitName is required field', async () => {
                await expectToThrowValidationFailureError(async () => {
                    await createTestResident(admin, user.user, user.property, {
                        unitType: COMMERCIAL_UNIT_TYPE,
                        unitName: null,
                    })
                }, 'Required field "unitName" is null or undefined.')

                const [resident] = await createTestResident(admin, user.user, user.property, {
                    unitType: COMMERCIAL_UNIT_TYPE,
                    unitName: faker.random.alphaNumeric(5),
                })
                await expectToThrowValidationFailureError(async () => {
                    await updateTestResident(admin, resident.id, {
                        unitName: null,
                    })
                }, 'Required field "unitName" is null or undefined.')
            })

            describe('create', () => {
                test('unitType must be set to default values if pass unitName and not pass unitType', async () => {
                    const [resident, attrs] = await createTestResident(admin, user.user, user.property, {
                        unitType: null,
                        unitName: faker.random.alphaNumeric(5),
                    })
                    expect(resident).toHaveProperty('unitType', FLAT_UNIT_TYPE)
                    expect(resident).toHaveProperty('unitName', attrs.unitName)
                })

                test('unitType and unitName must not be empty if they were passed', async () => {
                    const [resident, attrs] = await createTestResident(admin, user.user, user.property, {
                        unitType: COMMERCIAL_UNIT_TYPE,
                        unitName: faker.random.alphaNumeric(5),
                    })
                    expect(resident).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    expect(resident).toHaveProperty('unitName', attrs.unitName)
                })
            })

            describe('update', () => {
                test('unitType must not be update if unitName is not null and unitType try update to null', async () => {
                    const [resident] = await createTestResident(admin, user.user, user.property, { unitType: COMMERCIAL_UNIT_TYPE })
                    expect(resident).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    const [updatedResident] = await updateTestResident(admin, resident.id, {
                        unitType: null,
                    })
                    expect(updatedResident).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    expect(updatedResident).toHaveProperty('unitName', resident.unitName)
                })

                test('unitType must be updatable', async () => {
                    const [resident] = await createTestResident(admin, user.user, user.property, { unitType: FLAT_UNIT_TYPE })
                    const [updatedResident] = await updateTestResident(admin, resident.id, {
                        unitType: COMMERCIAL_UNIT_TYPE,
                    })
                    expect(updatedResident).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    expect(updatedResident).toHaveProperty('unitName', resident.unitName)
                })
            })
        })
    })

    describe('validations', () => {
        it('throws error on create record with same set of fields: "address", "unitName" for current user', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const duplicatedFields = {
                address: userClient.property.address,
                unitName: faker.random.alphaNumeric(3),
            }
            await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)

            // TODO(pahaz): DOMA-10368 use expectToThrow Validation
            await catchErrorFrom(async () => {
                await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Cannot create resident, because another resident with the same provided "address" and "unitName" already exists for current user')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('throws error on create record with same set of fields: "address", "unitName" (in different case) for current user', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const fields = {
                address: userClient.property.address,
                unitName: '123a',
            }
            await createTestResident(adminClient, userClient.user, userClient.property, fields)

            const duplicatedFields = {
                address: fields.address.toUpperCase(),
                unitName: fields.unitName.toUpperCase(),
            }

            // TODO(pahaz): DOMA-10368 use expectToThrow Validation
            await catchErrorFrom(async () => {
                await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Cannot create resident, because another resident with the same provided "address" and "unitName" already exists for current user')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('throws error on create record with same set of fields: "address", "unitName" for current user, ignoring flat part in "address"', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const duplicatedFields = {
                address: userClient.property.address,
                unitName: faker.random.alphaNumeric(3),
            }
            await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)

            const addressMetaWithFlat = cloneDeep(userClient.property.addressMeta)
            addressMetaWithFlat.data.flat = '123'
            addressMetaWithFlat.data.flat_type = 'кв.'
            addressMetaWithFlat.value = addressMetaWithFlat.value + ', кв. 123'

            const duplicatedFieldsWithFlatInAddress = {
                address: addressMetaWithFlat.value,
                unitName: duplicatedFields.unitName,
                addressMeta: addressMetaWithFlat,
            }

            // TODO(pahaz): DOMA-10368 use expectToThrow Validation or GQLError
            await catchErrorFrom(async () => {
                await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFieldsWithFlatInAddress)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Cannot create resident, because another resident with the same provided "address" and "unitName" already exists for current user')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('allows to create record with same set of fields: "property", "unitName" for different user', async () => {
            const userClient = await makeClientWithProperty()
            const userClient2 = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const duplicatedFields = {
                property: { connect: { id: userClient.property.id } },
                unitName: faker.random.alphaNumeric(3),
            }
            await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)
            const [obj] = await createTestResident(adminClient, userClient2.user, userClient.property, duplicatedFields)
            expect(obj.id).toMatch(UUID_RE)
        })

        describe('comparsion of resident and property address', () => {
            it('throws error, when trying to connect new resident to property with another address', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [propertyWithAnotherAddress] = await createTestProperty(userClient, userClient.organization, { map: buildingMapJson })

                const attrs = {
                    address: userClient.property.address,
                    addressMeta: userClient.property.addressMeta,
                }

                await expectToThrowValidationFailureError(
                    async () => await createTestResident(adminClient, userClient.user, propertyWithAnotherAddress, attrs),
                    'Cannot connect property, because its address differs from address of resident',
                )
            })

            it('allows to connect new resident to property having the same address in different character case', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const { address, addressMeta } = userClient.property

                const extraAttrs = {
                    address: address.toUpperCase(),
                    addressMeta: {
                        ...addressMeta,
                        value: addressMeta.value.toUpperCase(),
                    },
                }

                const [obj, attrs] = await createTestResident(adminClient, userClient.user, userClient.property, extraAttrs)
                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(1)
                expect(obj.newId).toEqual(null)
                expect(obj.deletedAt).toEqual(null)
                expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
                expect(obj.createdAt).toMatch(DATETIME_RE)
                expect(obj.updatedAt).toMatch(DATETIME_RE)
                expect(obj.user.id).toEqual(userClient.user.id)
                expect(obj.organization.id).toEqual(userClient.organization.id)
                expect(obj.property.id).toEqual(userClient.property.id)
            })
        })
    })

    describe('Working with Tickets', () => {
        it('can create temporary TicketFile', async () => {
            // TODO(zuch): check id makeClientWithProperty is good for tests with resident
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()
            await createTestResident(adminClient, residentClient.user, userClient.property)
            const [ticketFile] = await createTestTicketFile(residentClient)
            expect(ticketFile.createdBy.id).toEqual(residentClient.user.id)
        })

        it('can create Ticket', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()
            const unitName = faker.random.alphaNumeric(8)
            await createTestResident(adminClient, residentClient.user, userClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(residentClient, userClient.organization, userClient.property, {
                unitName,
            })
            expect(ticket.createdBy.id).toEqual(residentClient.user.id)
        })

        it('cannot update Ticket', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()
            const unitName = faker.random.alphaNumeric(8)
            await createTestResident(adminClient, residentClient.user, userClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(residentClient, userClient.organization, userClient.property, {
                unitName,
            })
            const details = faker.lorem.sentence()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(residentClient, ticket.id, { details })
            })
        })

        it('can connect temporary TicketFile to Ticket', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()
            const unitName = faker.random.alphaNumeric(8)
            await createTestResident(adminClient, residentClient.user, userClient.property, {
                unitName,
            })
            const [ticketFile] = await createTestTicketFile(residentClient)
            const [ticket] = await createTestTicket(residentClient, userClient.organization, userClient.property, {
                unitName,
            })
            const [updatedTicketFile] = await updateTestTicketFile(residentClient, ticketFile.id, { ticket: { connect: { id: ticket.id } } })
            expect(updatedTicketFile.ticket.id).toEqual(ticket.id)
        })
    })

    describe('Virtual fields', () => {
        describe('residentOrganization', () => {
            it('returns id and name of related organization', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })
                expect(obj.residentOrganization).toBeDefined()
                expect(obj.residentOrganization.id).toEqual(userClient.organization.id)
                expect(obj.residentOrganization.name).toEqual(userClient.organization.name)
                expect(obj.residentOrganization.country).toEqual(userClient.organization.country)
                expect(obj.residentOrganization.tin).toEqual(userClient.organization.tin)
                expect(Object.keys(obj.residentOrganization)).toHaveLength(4)
            })
        })

        describe('residentProperty', () => {
            it('returns id, name and address of related property', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })
                expect(obj.residentProperty).toBeDefined()
                expect(obj.residentProperty.id).toEqual(userClient.property.id)
                expect(obj.residentProperty.name).toEqual(userClient.property.name)
                expect(obj.residentProperty.address).toEqual(userClient.property.address)
                expect(Object.keys(obj.residentProperty)).toHaveLength(3)
            })

            it('returns null if no related property', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const address = faker.lorem.words()
                const attrs = {
                    address,
                    addressMeta: buildFakeAddressMeta(address),
                }

                const [{ id }] = await createTestResident(adminClient, userClient.user, null, attrs)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })
                expect(obj.residentProperty).toBeNull()
            })
        })

        describe('organizationFeatures', () => {
            it('correctly sets the hasBillingData if billing data is available', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [integration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration, {
                    lastReport: {
                        period: '2021-09-01',
                        finishTime: dayjs().toISOString(),
                        totalReceipts: 3141592,
                    },
                })

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.organizationFeatures.hasBillingData).toBe(true)
            })

            it('correctly sets the hasBillingData if no context available', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.organizationFeatures.hasBillingData).toBe(false)
            })

            it('correctly sets the hasBillingData if no billing data available', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [integration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.organizationFeatures.hasBillingData).toBe(false)
            })

            it('returns null if no organization', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const address = faker.lorem.words()
                const attrs = {
                    address,
                    addressMeta: buildFakeAddressMeta(address),
                }

                const [{ id }] = await createTestResident(adminClient, userClient.user, null, attrs)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })
                expect(obj.organizationFeatures).toBeNull()
            })

            it('correctly sets the hasMeters: "true" if meters existing in resident property and unit', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const unitName = faker.random.alphaNumeric(8)
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })

                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                await createTestMeter(adminClient, organization, property, resource, {
                    unitName,
                })

                const [obj] = await Resident.getAll(client, { id: resident.id })
                expect(obj.organizationFeatures.hasMeters).toBe(true)
            })

            it('correctly sets the hasMeters: "false" if no meters existing in resident property and unit', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const unitName = faker.random.alphaNumeric(8)
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })

                const [obj] = await Resident.getAll(client, { id: resident.id })
                expect(obj.organizationFeatures.hasMeters).toBe(false)
            })

            it('correctly sets the hasMeters: "false" if resident doesnt have property', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const [organization] = await createTestOrganization(adminClient)
                const { address, addressMeta } = buildFakeAddressAndMeta()
                const [property] = await createTestProperty(adminClient, organization, {
                    address, addressMeta,
                })

                const [resident] = await createTestResident(adminClient, client.user, null, {
                    address,
                    addressMeta,
                })

                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                await createTestMeter(adminClient, organization, property, resource)
                const [obj] = await Resident.getAll(client, { id: resident.id })

                expect(obj.organization).toBe(null)
                expect(obj.organizationFeatures).toBe(null)
            })

            it('correctly sets hasMeters: "true" and hasBillingData: "true" is billingData and meters exists in organization', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const unitName = faker.random.alphaNumeric(8)

                const [integration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, organization, integration, {
                    lastReport: {
                        period: '2021-09-01',
                        finishTime: dayjs().toISOString(),
                        totalReceipts: 3141592,
                    },
                })

                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                await createTestMeter(adminClient, organization, property, resource, {
                    unitName,
                })

                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })

                const [obj] = await Resident.getAll(client, { id: resident.id })
                expect(obj.organizationFeatures.hasBillingData).toBe(true)
                expect(obj.organizationFeatures.hasMeters).toBe(true)
            })
        })

        describe('paymentCategories', () => {
            it('correctly sets the paymentCategories if resident.org has everything', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [billingIntegration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, billingIntegration)

                const [acquiringIntegration] = await createTestAcquiringIntegration(adminClient)
                await createTestAcquiringIntegrationContext(adminClient, userClient.organization, acquiringIntegration)

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.paymentCategories).toBeDefined()
                expect(obj.paymentCategories[0].id).toBeDefined()
                expect(obj.paymentCategories[0].categoryName).toBeDefined()
                expect(obj.paymentCategories[0].billingName).toEqual(billingIntegration.name)
                expect(obj.paymentCategories[0].acquiringName).toEqual(acquiringIntegration.name)
            })

            it('correctly sets the paymentCategories if resident.org has no acquiring', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [billingIntegration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, billingIntegration)

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.paymentCategories).toBeDefined()
                expect(obj.paymentCategories[0].billingName).toEqual(billingIntegration.name)
                expect(obj.paymentCategories[0].acquiringName).toEqual(DEFAULT_ACQUIRING_INTEGRATION_NAME)
            })

            it('correctly sets the paymentCategories if resident.org has no billing', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [acquiringIntegration] = await createTestAcquiringIntegration(adminClient)
                await createTestAcquiringIntegrationContext(adminClient, userClient.organization, acquiringIntegration)

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.paymentCategories).toBeDefined()
                expect(obj.paymentCategories[0].billingName).toEqual(DEFAULT_BILLING_INTEGRATION_NAME)
                expect(obj.paymentCategories[0].acquiringName).toEqual(acquiringIntegration.name)
            })

            it('correctly sets the paymentCategories if resident has no org', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.paymentCategories).toBeDefined()
                expect(obj.paymentCategories[0].billingName).toEqual(DEFAULT_BILLING_INTEGRATION_NAME)
                expect(obj.paymentCategories[0].acquiringName).toEqual(DEFAULT_ACQUIRING_INTEGRATION_NAME)
            })
        })

        describe('Contact-related fields', () => {
            const ResidentWithContactInfo = generateGQLTestUtils(generateGqlQueries(
                'Resident', 
                `{ 
                            id 
                            isVerifiedByManagingCompany 
                            managingCompanyOwnershipPercentage 
                            managingCompanyCommunityFee 
                            managingCompanyContactRole { id name organization } 
                       }`
            ))

            test('Virtual fields isVerifiedByManagingCompany, managingCompanyOwnershipPercentage and managingCompanyCommunityFee must return correct values based on contact data', async () => {
                const staffClient = await makeClientWithProperty()
                const phone = createTestPhone()
                const residentUser = await makeClientWithResidentUser({
                    phone,
                })
                const [resident] = await registerResidentByTestClient(residentUser, {
                    address: staffClient.property.address,
                    addressMeta: staffClient.property.addressMeta,
                    unitType: FLAT_UNIT_TYPE,
                })
                expect(resident).toHaveProperty(['property', 'id'], staffClient.property.id)

                // Case 1: No contact
                const residentWithNoContact = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithNoContact).toHaveProperty('isVerifiedByManagingCompany', false)
                expect(residentWithNoContact).toHaveProperty('managingCompanyOwnershipPercentage', null)
                expect(residentWithNoContact).toHaveProperty('managingCompanyCommunityFee', null)

                // Case 2: Matched but not verified contact
                const [contact] = await createTestContact(staffClient, staffClient.organization, staffClient.property, {
                    unitName: resident.unitName,
                    unitType: resident.unitType,
                    phone,
                })
                const residentWithContact = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithContact).toHaveProperty('isVerifiedByManagingCompany', false)

                // Case 3: Matched and verified contact
                const isVerified = true
                const ownershipPercentage = '0.55000000'
                const communityFee = '57.55000000'
                await updateTestContact(staffClient, contact.id, { isVerified, communityFee,  ownershipPercentage })
                const residentWithVerifiedContact = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithVerifiedContact).toHaveProperty('isVerifiedByManagingCompany', isVerified)
                expect(residentWithVerifiedContact).toHaveProperty('managingCompanyOwnershipPercentage', ownershipPercentage)
                expect(residentWithVerifiedContact).toHaveProperty('managingCompanyCommunityFee', communityFee)

                // Case 4: Same unit, different user
                const anotherPhoneResidentUser = await makeClientWithResidentUser()
                const [anotherPhoneResident] = await registerResidentByTestClient(anotherPhoneResidentUser, {
                    address: staffClient.property.address,
                    addressMeta: staffClient.property.addressMeta,
                    unitName: resident.unitName,
                    unitType: resident.unitType,
                })

                const residentWithDifferentPhone = await ResidentWithContactInfo.getOne(anotherPhoneResidentUser, { id: anotherPhoneResident.id })
                expect(residentWithDifferentPhone).toHaveProperty('isVerifiedByManagingCompany', false)
                expect(residentWithDifferentPhone).toHaveProperty('managingCompanyOwnershipPercentage', null)
                expect(residentWithDifferentPhone).toHaveProperty('managingCompanyCommunityFee', null)

                // Case 5: Deleted contact
                await updateTestContact(staffClient, contact.id, { deletedAt: dayjs().toISOString() })
                const residentWithDeletedContact = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithDeletedContact).toHaveProperty('isVerifiedByManagingCompany', false)
                expect(residentWithDeletedContact).toHaveProperty('managingCompanyOwnershipPercentage', null)
                expect(residentWithDeletedContact).toHaveProperty('managingCompanyCommunityFee', null)

                // Case 6: Same user different unit
                await createTestContact(staffClient, staffClient.organization, staffClient.property, {
                    unitName: resident.unitName,
                    unitType: COMMERCIAL_UNIT_TYPE,
                    phone,
                    isVerified: true,
                })
                const residentWithNoFlatContact = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithNoFlatContact).toHaveProperty('isVerifiedByManagingCompany', false)
                expect(residentWithNoFlatContact).toHaveProperty('managingCompanyOwnershipPercentage', null)
                expect(residentWithNoFlatContact).toHaveProperty('managingCompanyCommunityFee', null)

                // Case 7: Same user, same unit, not managing company
                const anotherStaffClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [serviceProvider] = await registerNewOrganization(anotherStaffClient, { type: SERVICE_PROVIDER_TYPE })
                const [providerProperty] = await createTestProperty(anotherStaffClient, serviceProvider, {
                    address: staffClient.property.address,
                    addressMeta: staffClient.property.addressMeta,
                })
                await createTestContact(anotherStaffClient, serviceProvider, providerProperty, {
                    unitName: resident.unitName,
                    unitType: COMMERCIAL_UNIT_TYPE,
                    phone,
                    isVerified: true,
                })

                const residentWithNonManagingContact = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithNonManagingContact).toHaveProperty('isVerifiedByManagingCompany', false)
                expect(residentWithNonManagingContact).toHaveProperty('managingCompanyOwnershipPercentage', null)
                expect(residentWithNonManagingContact).toHaveProperty('managingCompanyCommunityFee', null)
            })
            test('managingCompanyContactRole must return proper ContactRole is there\'s contact in resident property', async () => {
                // NOTE: managingCompanyContactRole and isVerifiedByManagingCompany share common logic of obtaining contact,
                // so only role logic is tested

                const staffClient = await makeClientWithProperty()
                const phone = createTestPhone()
                const residentUser = await makeClientWithResidentUser({
                    phone,
                })
                const [resident] = await registerResidentByTestClient(residentUser, {
                    address: staffClient.property.address,
                    addressMeta: staffClient.property.addressMeta,
                    unitType: FLAT_UNIT_TYPE,
                })
                expect(resident).toHaveProperty(['property', 'id'], staffClient.property.id)

                const [contact] = await createTestContact(staffClient, staffClient.organization, staffClient.property, {
                    unitName: resident.unitName,
                    unitType: resident.unitType,
                    phone,
                    isVerified: false,
                })

                // Case 1: Contact with no role
                const residentWithNoRole = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithNoRole).toHaveProperty('managingCompanyContactRole', null)

                // Case 2: Contact with default role
                // NOTE: ID was taken from migration, since it does not exist as const
                const residentRoleId = 'f9e88ba8-669e-417c-9511-9e33003c9e65'
                await updateTestContact(staffClient, contact.id, { role: { connect: { id: residentRoleId } } })
                const residentWithDefaultRole = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithDefaultRole.managingCompanyContactRole).toEqual({
                    id: residentRoleId,
                    name: 'contact.role.resident.name',
                    organization: null,
                })

                // Case 3: Organization-specific role
                const [contactRole, contactRoleAttrs] = await createTestContactRole(staffClient, {
                    organization: { connect: { id: staffClient.organization.id } },
                })
                await updateTestContact(staffClient, contact.id, { role: { connect: { id: contactRole.id } } })
                const residentWithOrgRole = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithOrgRole.managingCompanyContactRole).toEqual({
                    id: contactRole.id,
                    name: contactRoleAttrs.name,
                    organization: staffClient.organization.id,
                })

                // Case 4: Role deleted
                await updateTestContactRole(staffClient, contactRole.id, { deletedAt: dayjs().toISOString() })
                const residentWithDeletedRole = await ResidentWithContactInfo.getOne(residentUser, { id: resident.id })
                expect(residentWithDeletedRole).toHaveProperty('managingCompanyContactRole', null)
            })
        })
    })

    describe('Create', () => {
        it('can be created by admin', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const { context } = await makeContextWithOrganizationAndIntegrationAsAdmin()
            const [billingProperty] = await createTestBillingProperty(adminClient, context)
            await createTestBillingAccount(adminClient, context, billingProperty)

            const [obj, attrs] = await createTestResident(adminClient, userClient.user, userClient.property)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
            expect(obj.user.id).toEqual(userClient.user.id)
            expect(obj.organization.id).toEqual(userClient.organization.id)
            expect(obj.property.id).toEqual(userClient.property.id)
            expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
        })

        it('cannot be created by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            await createTestOrganization(adminClient)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestResident(userClient, userClient.user, userClient.property)
            })
        })

        it('cannot be created by anonymous', async () => {
            const userClient = await makeClientWithProperty()
            const anonymous = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestResident(anonymous, userClient.user, userClient.property)
            })
        })
    })

    describe('Read', () => {
        it('can be read by admin', async () => {
            const userClient = await makeClientWithProperty()
            const admin = await makeLoggedInAdminClient()
            const [obj, attrs] = await createTestResident(admin, userClient.user, userClient.property)
            const objs = await Resident.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })
            expect(objs.length).toBeGreaterThanOrEqual(1)
            expect(objs).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    id: obj.id,
                    sender: attrs.sender,
                    createdBy: expect.objectContaining({ id: admin.user.id }),
                    updatedBy: expect.objectContaining({ id: admin.user.id }),
                    createdAt: obj.createdAt,
                    updatedAt: obj.updatedAt,
                    address: attrs.address,
                }),
            ]))
        })

        it('cannot be read by user, who is employed in organization, which manages associated property', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            await createTestResident(adminClient, userClient.user, userClient.property)
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Resident.getAll(userClient, {}, { sortBy: ['updatedAt_DESC'] })
            })
        })

        it('user with type "resident" can read only own residents', async () => {
            const userClient = await makeClientWithProperty()
            await addResidentAccess(userClient.user)
            const anotherUserClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)
            await createTestResident(adminClient, anotherUserClient.user, userClient.property)
            const objs = await Resident.getAll(userClient, {}, { sortBy: ['updatedAt_DESC'] })
            expect(objs).toHaveLength(1)
            expect(objs[0].id).toMatch(obj.id)
        })

        it('user with canReadResidents rights set can read all residents', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anotherUserClient = await makeClientWithProperty()
            
            const [resident1] = await createTestResident(adminClient, userClient.user, userClient.property)
            const [resident2] = await createTestResident(adminClient, anotherUserClient.user, anotherUserClient.property)
            
            const [rightsSet] = await createTestUserRightsSet(adminClient, {
                canReadResidents: true,
            })
            
            const readerClient = await makeClientWithNewRegisteredAndLoggedInUser()
            await updateTestUser(adminClient, readerClient.user.id, {
                rightsSet: { connect: { id: rightsSet.id } },
            })
            
            const residents = await Resident.getAll(readerClient, {
                id_in: [resident1.id, resident2.id],
            })
            
            expect(residents).toHaveLength(2)
            expect(residents.map(r => r.id).sort()).toEqual([resident1.id, resident2.id].sort())
        })

        it('cannot be read by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anonymousClient = await makeClient()
            await createTestResident(adminClient, userClient.user, userClient.property)
            await expectToThrowAuthenticationErrorToObjects(async () => {
                await Resident.getAll(anonymousClient)
            })
        })
    })

    describe('Update', () => {
        it('organization field cannot be updated', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)
            const [newOrganization] = await createTestOrganization(adminClient)
            const payload = {
                organization: { connect: newOrganization.id },
            }
            await catchErrorFrom(async () => {
                await updateTestResident(adminClient, obj.id, payload)
            }, (e) => {
                expect(e.errors[0].message).toContain('Field "organization" is not defined by type "ResidentUpdateInput"')
            })
        })
        it('cannot be updated by changing address, addressMeta, property or unitName', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await catchErrorFrom(async () => {
                const payload = {
                    unitName: faker.random.alphaNumeric(3),
                }
                await updateTestResident(adminClient, obj.id, payload)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Changing of address, addressMeta, unitName or property is not allowed for already existing Resident')
                expect(data).toEqual({ 'obj': null })
            })

            await catchErrorFrom(async () => {
                const payload = {
                    address: faker.address.streetAddress(true),
                }
                await updateTestResident(adminClient, obj.id, payload)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Changing of address, addressMeta, unitName or property is not allowed for already existing Resident')
                expect(data).toEqual({ 'obj': null })
            })

            await catchErrorFrom(async () => {
                const [property] = await createTestProperty(userClient, userClient.organization, { map: buildingMapJson })
                // `property` should correspond to `address` to not overlap with another test case of `property` validation with will cause error "Cannot connect property, because its address differs from address of resident"
                const payload = {
                    address: property.address,
                    property: { connect: { id: property.id } },
                }
                await updateTestResident(adminClient, obj.id, payload)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Changing of address, addressMeta, unitName or property is not allowed for already existing Resident')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('cannot be updated by other user with type resident', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const otherUserClient = await makeClientWithResidentAccessAndProperty()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestResident(otherUserClient, obj.id, {})
            })
        })

        it('can be updated by admin', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const [objUpdated, attrs] = await updateTestResident(adminClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.unitType).toEqual(obj.unitType)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('cannot be updated by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anonymousClient = await makeClient()

            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestResident(anonymousClient, obj.id)
            })
        })
    })

    describe('Delete', () => {
        it('cannot be deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()

            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.delete(adminClient, obj.id)
            })
        })

        it('cannot be deleted by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()

            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.delete(userClient, obj.id)
            })
        })

        it('cannot be deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anonymousClient = await makeClient()

            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.delete(anonymousClient, obj.id)
            })
        })

        it('can be soft-deleted using update operation by admin', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const [objUpdated, attrs] = await Resident.softDelete(adminClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('can be soft-deleted using update operation by current user with type resident', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            // NOTE: USING RAW SINCE WE CANNOT QUERY PROPERTY OF DELETED RESIDENT ANYMORE
            const { data } = await Resident.softDelete(userClient, obj.id, {}, { raw: true })
            expect(data).toBeDefined()
            expect(data).toHaveProperty('obj')
            const { obj: objUpdated } = data
            expect(objUpdated).toHaveProperty('id', obj.id)
            expect(objUpdated).toHaveProperty('dv', 1)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('can be soft-deleted using update operation by current user with type resident with recurrent payment context', async () => {
            const client = await makeClientWithServiceConsumer()
            const adminClient = await makeLoggedInAdminClient()

            // create recurrent payment context
            const [billingCategory] = (await createTestBillingCategory(adminClient, { name: `Category ${new Date()}` }))
            const [recurrentContext] = await createTestRecurrentPaymentContext(adminClient, {
                enabled: false,
                limit: '10000',
                autoPayReceipts: false,
                paymentDay: 10,
                settings: { cardId: faker.datatype.uuid() },
                serviceConsumer: { connect: { id: client.serviceConsumer.id } },
                billingCategory: { connect: { id: billingCategory.id } },
            })

            const contextsBeforeDelete = await RecurrentPaymentContext.getAll(adminClient, { id: recurrentContext.id })
            expect(contextsBeforeDelete).toHaveLength(1)

            // NOTE: USING RAW SINCE WE CANNOT QUERY PROPERTY OF DELETED RESIDENT ANYMORE
            const { data } = await Resident.softDelete(client, client.resident.id, {}, { raw: true })
            expect(data).toBeDefined()
            expect(data).toHaveProperty('obj')
            const { obj: objUpdated } = data
            expect(objUpdated).toHaveProperty('id', client.resident.id)
            expect(objUpdated).toHaveProperty('dv', 1)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)

            await waitFor(async () => {
                const contexts = await RecurrentPaymentContext.getAll(adminClient, { id: recurrentContext.id })
                expect(contexts).toHaveLength(0)
            })
        })

        it('cannot be soft-deleted using update operation by current user with type resident when other fields gets passed as variables', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const notAllowedPayload = {
                address: faker.address.streetAddress(true),
            }

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.softDelete(userClient, obj.id, notAllowedPayload)
            })
        })

        it('cannot be soft-deleted using update operation by other user with type resident', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const otherUserClient = await makeClientWithResidentAccessAndProperty()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.softDelete(otherUserClient, obj.id)
            })
        })
    })
})
