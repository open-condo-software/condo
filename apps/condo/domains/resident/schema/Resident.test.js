/**
 * Generated by `createschema resident.Resident 'user:Relationship:User:CASCADE; organization:Relationship:Organization:PROTECT; property:Relationship:Property:PROTECT; billingAccount?:Relationship:BillingAccount:SET_NULL; unitName:Text;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { cloneDeep } = require('lodash')

const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE } = require('@open-condo/keystone/test.utils')
const {
    catchErrorFrom,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAccessDeniedErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { DEFAULT_ACQUIRING_INTEGRATION_NAME } = require('@condo/domains/acquiring/constants/integration')
const {
    createTestAcquiringIntegration,
    createTestAcquiringIntegrationContext,
    createTestRecurrentPaymentContext,
    RecurrentPaymentContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const { DEFAULT_BILLING_INTEGRATION_NAME } = require('@condo/domains/billing/constants/constants')
const {
    createTestBillingIntegrationOrganizationContext,
    createTestBillingIntegration,
    createTestBillingAccount,
    createTestBillingProperty,
    makeContextWithOrganizationAndIntegrationAsAdmin,
    createTestBillingCategory,
} = require('@condo/domains/billing/utils/testSchema')
const { COLD_WATER_METER_RESOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { MeterResource } = require('@condo/domains/meter/utils/testSchema')
const { createTestMeter } = require('@condo/domains/meter/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { buildingMapJson } = require('@condo/domains/property/constants/property')
const { createTestProperty, makeClientWithResidentAccessAndProperty, makeClientWithProperty } = require('@condo/domains/property/utils/testSchema')
const { buildFakeAddressMeta } = require('@condo/domains/property/utils/testSchema/factories')
const { Resident, createTestResident, updateTestResident, makeClientWithServiceConsumer } = require('@condo/domains/resident/utils/testSchema')
const { createTestTicketFile, updateTestTicketFile, createTestTicket, updateTestTicket } = require('@condo/domains/ticket/utils/testSchema')
const { makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')
const { addResidentAccess } = require('@condo/domains/user/utils/testSchema')

describe('Resident', () => {

    describe('resolveInput', () => {
        it('resolves address to address up to building, if flat is presented in address string', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const addressMetaWithFlat = cloneDeep(userClient.property.addressMeta)
            addressMetaWithFlat.data.flat = '123'
            addressMetaWithFlat.data.flat_type = 'кв.'
            addressMetaWithFlat.value = addressMetaWithFlat.value + ', кв. 123'

            const attrs = {
                address: addressMetaWithFlat.value,
                unitName: faker.random.alphaNumeric(3),
                addressMeta: addressMetaWithFlat,
            }

            const [objCreated] = await createTestResident(adminClient, userClient.user, userClient.property, attrs)
            expect(objCreated.address).toEqual(userClient.property.addressMeta.value)
        })
    })

    describe('validations', () => {
        it('throws error on create record with same set of fields: "address", "unitName" for current user', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const duplicatedFields = {
                address: userClient.property.address,
                unitName: faker.random.alphaNumeric(3),
            }
            await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)

            await catchErrorFrom(async () => {
                await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Cannot create resident, because another resident with the same provided "address" and "unitName" already exists for current user')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('throws error on create record with same set of fields: "address", "unitName" (in different case) for current user', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const fields = {
                address: userClient.property.address,
                unitName: '123a',
            }
            await createTestResident(adminClient, userClient.user, userClient.property, fields)

            const duplicatedFields = {
                address: fields.address.toUpperCase(),
                unitName: fields.unitName.toUpperCase(),
            }

            await catchErrorFrom(async () => {
                await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Cannot create resident, because another resident with the same provided "address" and "unitName" already exists for current user')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('throws error on create record with same set of fields: "address", "unitName" for current user, ignoring flat part in "address"', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const duplicatedFields = {
                address: userClient.property.address,
                unitName: faker.random.alphaNumeric(3),
            }
            await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)

            const addressMetaWithFlat = cloneDeep(userClient.property.addressMeta)
            addressMetaWithFlat.data.flat = '123'
            addressMetaWithFlat.data.flat_type = 'кв.'
            addressMetaWithFlat.value = addressMetaWithFlat.value + ', кв. 123'

            const duplicatedFieldsWithFlatInAddress = {
                address: addressMetaWithFlat.value,
                unitName: duplicatedFields.unitName,
                addressMeta: addressMetaWithFlat,
            }

            await catchErrorFrom(async () => {
                await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFieldsWithFlatInAddress)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Cannot create resident, because another resident with the same provided "address" and "unitName" already exists for current user')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('allows to create record with same set of fields: "property", "unitName" for different user', async () => {
            const userClient = await makeClientWithProperty()
            const userClient2 = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const duplicatedFields = {
                property: { connect: { id: userClient.property.id } },
                unitName: faker.random.alphaNumeric(3),
            }
            await createTestResident(adminClient, userClient.user, userClient.property, duplicatedFields)
            const [obj] = await createTestResident(adminClient, userClient2.user, userClient.property, duplicatedFields)
            expect(obj.id).toMatch(UUID_RE)
        })

        describe('comparsion of resident and property address', () => {
            it('throws error, when trying to connect new resident to property with another address', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [propertyWithAnotherAddress] = await createTestProperty(userClient, userClient.organization, { map: buildingMapJson })

                const attrs = {
                    address: userClient.property.address,
                    addressMeta: userClient.property.addressMeta,
                }

                await catchErrorFrom(async () => {
                    await createTestResident(adminClient, userClient.user, propertyWithAnotherAddress, attrs)
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                    expect(errors[0].data.messages[0]).toMatch('Cannot connect property, because its address differs from address of resident')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            it('allows to connect new resident to property having the same address in different character case', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const { address, addressMeta } = userClient.property

                const extraAttrs = {
                    address: address.toUpperCase(),
                    addressMeta: {
                        ...addressMeta,
                        value: addressMeta.value.toUpperCase(),
                    },
                }

                const [obj, attrs] = await createTestResident(adminClient, userClient.user, userClient.property, extraAttrs)
                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(1)
                expect(obj.newId).toEqual(null)
                expect(obj.deletedAt).toEqual(null)
                expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
                expect(obj.createdAt).toMatch(DATETIME_RE)
                expect(obj.updatedAt).toMatch(DATETIME_RE)
                expect(obj.user.id).toEqual(userClient.user.id)
                expect(obj.organization.id).toEqual(userClient.organization.id)
                expect(obj.property.id).toEqual(userClient.property.id)
            })
        })
    })

    describe('Working with Tickets', () => {
        it('can create temporary TicketFile', async () => {
            // TODO(zuch): check id makeClientWithProperty is good for tests with resident
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()
            await createTestResident(adminClient, residentClient.user, userClient.property)
            const [ticketFile] = await createTestTicketFile(residentClient)
            expect(ticketFile.createdBy.id).toEqual(residentClient.user.id)
        })

        it('can create Ticket', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()
            const unitName = faker.random.alphaNumeric(8)
            await createTestResident(adminClient, residentClient.user, userClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(residentClient, userClient.organization, userClient.property, {
                unitName,
            })
            expect(ticket.createdBy.id).toEqual(residentClient.user.id)
        })

        it('cannot update Ticket', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()
            const unitName = faker.random.alphaNumeric(8)
            await createTestResident(adminClient, residentClient.user, userClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(residentClient, userClient.organization, userClient.property, {
                unitName,
            })
            const details = faker.lorem.sentence()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(residentClient, ticket.id, { details })
            })
        })

        it('can connect temporary TicketFile to Ticket', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()
            const unitName = faker.random.alphaNumeric(8)
            await createTestResident(adminClient, residentClient.user, userClient.property, {
                unitName,
            })
            const [ticketFile] = await createTestTicketFile(residentClient)
            const [ticket] = await createTestTicket(residentClient, userClient.organization, userClient.property, {
                unitName,
            })
            const [updatedTicketFile] = await updateTestTicketFile(residentClient, ticketFile.id, { ticket: { connect: { id: ticket.id } } })
            expect(updatedTicketFile.ticket.id).toEqual(ticket.id)
        })
    })

    describe('Virtual fields', () => {
        describe('residentOrganization', () => {
            it('returns id and name of related organization', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })
                expect(obj.residentOrganization).toBeDefined()
                expect(obj.residentOrganization.id).toEqual(userClient.organization.id)
                expect(obj.residentOrganization.name).toEqual(userClient.organization.name)
                expect(obj.residentOrganization.country).toEqual(userClient.organization.country)
                expect(obj.residentOrganization.tin).toEqual(userClient.organization.tin)
                expect(Object.keys(obj.residentOrganization)).toHaveLength(4)
            })
        })

        describe('residentProperty', () => {
            it('returns id, name and address of related property', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })
                expect(obj.residentProperty).toBeDefined()
                expect(obj.residentProperty.id).toEqual(userClient.property.id)
                expect(obj.residentProperty.name).toEqual(userClient.property.name)
                expect(obj.residentProperty.address).toEqual(userClient.property.address)
                expect(Object.keys(obj.residentProperty)).toHaveLength(3)
            })

            it('returns null if no related property', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const address = faker.lorem.words()
                const attrs = {
                    address,
                    addressMeta: buildFakeAddressMeta(address),
                }
                console.log('user and admin clients created')

                const [{ id }] = await createTestResident(adminClient, userClient.user, null, attrs)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })
                expect(obj.residentProperty).toBeNull()
            })
        })

        describe('organizationFeatures', () => {
            it('correctly sets the hasBillingData if billing data is available', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [integration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration, {
                    lastReport: {
                        period: '2021-09-01',
                        finishTime: dayjs().toISOString(),
                        totalReceipts: 3141592,
                    },
                })

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.organizationFeatures.hasBillingData).toBe(true)
            })

            it('correctly sets the hasBillingData if no context available', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.organizationFeatures.hasBillingData).toBe(false)
            })

            it('correctly sets the hasBillingData if no billing data available', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [integration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.organizationFeatures.hasBillingData).toBe(false)
            })

            it('returns null if no organization', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const address = faker.lorem.words()
                const attrs = {
                    address,
                    addressMeta: buildFakeAddressMeta(address),
                }

                const [{ id }] = await createTestResident(adminClient, userClient.user, null, attrs)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })
                expect(obj.organizationFeatures).toBeNull()
            })

            it('correctly sets the hasMeters: "true" if meters existing in resident property and unit', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const unitName = faker.random.alphaNumeric(8)
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })

                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                await createTestMeter(adminClient, organization, property, resource, {
                    unitName,
                })

                const [obj] = await Resident.getAll(client, { id: resident.id })
                expect(obj.organizationFeatures.hasMeters).toBe(true)
            })

            it('correctly sets the hasMeters: "false" if no meters existing in resident property and unit', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const unitName = faker.random.alphaNumeric(8)
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })

                const [obj] = await Resident.getAll(client, { id: resident.id })
                expect(obj.organizationFeatures.hasMeters).toBe(false)
            })

            it('correctly sets the hasMeters: "false" if resident doesnt have property', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resident] = await createTestResident(adminClient, client.user, null, {
                    address: property.address,
                    addressMeta: property.addressMeta,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                await createTestMeter(adminClient, organization, property, resource)

                const [obj] = await Resident.getAll(client, { id: resident.id })
                expect(obj.organizationFeatures).toBe(null)
            })

            it('correctly sets hasMeters: "true" and hasBillingData: "true" is billingData and meters exists in organization', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const unitName = faker.random.alphaNumeric(8)

                const [integration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, organization, integration, {
                    lastReport: {
                        period: '2021-09-01',
                        finishTime: dayjs().toISOString(),
                        totalReceipts: 3141592,
                    },
                })

                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                await createTestMeter(adminClient, organization, property, resource, {
                    unitName,
                })

                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })

                const [obj] = await Resident.getAll(client, { id: resident.id })
                expect(obj.organizationFeatures.hasBillingData).toBe(true)
                expect(obj.organizationFeatures.hasMeters).toBe(true)
            })
        })

        describe('paymentCategories', () => {
            it('correctly sets the paymentCategories if resident.org has everything', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [billingIntegration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, billingIntegration)

                const [acquiringIntegration] = await createTestAcquiringIntegration(adminClient)
                await createTestAcquiringIntegrationContext(adminClient, userClient.organization, acquiringIntegration)

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.paymentCategories).toBeDefined()
                expect(obj.paymentCategories[0].id).toBeDefined()
                expect(obj.paymentCategories[0].categoryName).toBeDefined()
                expect(obj.paymentCategories[0].billingName).toEqual(billingIntegration.name)
                expect(obj.paymentCategories[0].acquiringName).toEqual(acquiringIntegration.name)
            })

            it('correctly sets the paymentCategories if resident.org has no acquiring', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [billingIntegration] = await createTestBillingIntegration(adminClient)
                await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, billingIntegration)

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.paymentCategories).toBeDefined()
                expect(obj.paymentCategories[0].billingName).toEqual(billingIntegration.name)
                expect(obj.paymentCategories[0].acquiringName).toEqual(DEFAULT_ACQUIRING_INTEGRATION_NAME)
            })

            it('correctly sets the paymentCategories if resident.org has no billing', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [acquiringIntegration] = await createTestAcquiringIntegration(adminClient)
                await createTestAcquiringIntegrationContext(adminClient, userClient.organization, acquiringIntegration)

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.paymentCategories).toBeDefined()
                expect(obj.paymentCategories[0].billingName).toEqual(DEFAULT_BILLING_INTEGRATION_NAME)
                expect(obj.paymentCategories[0].acquiringName).toEqual(acquiringIntegration.name)
            })

            it('correctly sets the paymentCategories if resident has no org', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [{ id }] = await createTestResident(adminClient, userClient.user, userClient.property)
                await addResidentAccess(userClient.user)
                const [obj] = await Resident.getAll(userClient, { id })

                expect(obj.paymentCategories).toBeDefined()
                expect(obj.paymentCategories[0].billingName).toEqual(DEFAULT_BILLING_INTEGRATION_NAME)
                expect(obj.paymentCategories[0].acquiringName).toEqual(DEFAULT_ACQUIRING_INTEGRATION_NAME)
            })
        })
    })

    describe('Create', () => {
        it('can be created by admin', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const { context } = await makeContextWithOrganizationAndIntegrationAsAdmin()
            const [billingProperty] = await createTestBillingProperty(adminClient, context)
            await createTestBillingAccount(adminClient, context, billingProperty)

            const [obj, attrs] = await createTestResident(adminClient, userClient.user, userClient.property)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
            expect(obj.user.id).toEqual(userClient.user.id)
            expect(obj.organization.id).toEqual(userClient.organization.id)
            expect(obj.property.id).toEqual(userClient.property.id)
            expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
        })

        it('cannot be created by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            await createTestOrganization(adminClient)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestResident(userClient, userClient.user, userClient.property)
            })
        })

        it('cannot be created by anonymous', async () => {
            const userClient = await makeClientWithProperty()
            const anonymous = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestResident(anonymous, userClient.user, userClient.property)
            })
        })
    })

    describe('Read', () => {
        it('can be read by admin', async () => {
            const userClient = await makeClientWithProperty()
            const admin = await makeLoggedInAdminClient()
            const [obj, attrs] = await createTestResident(admin, userClient.user, userClient.property)
            const objs = await Resident.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })
            expect(objs.length).toBeGreaterThanOrEqual(1)
            expect(objs).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    id: obj.id,
                    sender: attrs.sender,
                    createdBy: expect.objectContaining({ id: admin.user.id }),
                    updatedBy: expect.objectContaining({ id: admin.user.id }),
                    createdAt: obj.createdAt,
                    updatedAt: obj.updatedAt,
                    address: attrs.address,
                }),
            ]))
        })

        it('cannot be read by user, who is employed in organization, which manages associated property', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            await createTestResident(adminClient, userClient.user, userClient.property)
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Resident.getAll(userClient, {}, { sortBy: ['updatedAt_DESC'] })
            })
        })

        it('user with type "resident" can read only own residents', async () => {
            const userClient = await makeClientWithProperty()
            await addResidentAccess(userClient.user)
            const anotherUserClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)
            await createTestResident(adminClient, anotherUserClient.user, userClient.property)
            const objs = await Resident.getAll(userClient, {}, { sortBy: ['updatedAt_DESC'] })
            expect(objs).toHaveLength(1)
            expect(objs[0].id).toMatch(obj.id)
        })

        it('cannot be read by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anonymousClient = await makeClient()
            await createTestResident(adminClient, userClient.user, userClient.property)
            await expectToThrowAuthenticationErrorToObjects(async () => {
                await Resident.getAll(anonymousClient)
            })
        })
    })

    describe('Update', () => {
        it('organization field cannot be updated', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)
            const [newOrganization] = await createTestOrganization(adminClient)
            const payload = {
                organization: { connect: newOrganization.id },
            }
            await catchErrorFrom(async () => {
                await updateTestResident(adminClient, obj.id, payload)
            }, (e) => {
                expect(e.errors[0].message).toContain('Field "organization" is not defined by type "ResidentUpdateInput"')
            })
        })
        it('cannot be updated by changing address, addressMeta, property or unitName', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await catchErrorFrom(async () => {
                const payload = {
                    unitName: faker.random.alphaNumeric(3),
                }
                await updateTestResident(adminClient, obj.id, payload)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Changing of address, addressMeta, unitName or property is not allowed for already existing Resident')
                expect(data).toEqual({ 'obj': null })
            })

            await catchErrorFrom(async () => {
                const payload = {
                    address: faker.address.streetAddress(true),
                }
                await updateTestResident(adminClient, obj.id, payload)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Changing of address, addressMeta, unitName or property is not allowed for already existing Resident')
                expect(data).toEqual({ 'obj': null })
            })

            await catchErrorFrom(async () => {
                const [property] = await createTestProperty(userClient, userClient.organization, { map: buildingMapJson })
                // `property` should correspond to `address` to not overlap with another test case of `property` validation with will cause error "Cannot connect property, because its address differs from address of resident"
                const payload = {
                    address: property.address,
                    property: { connect: { id: property.id } },
                }
                await updateTestResident(adminClient, obj.id, payload)
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toMatch('Changing of address, addressMeta, unitName or property is not allowed for already existing Resident')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('cannot be updated by other user with type resident', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const otherUserClient = await makeClientWithResidentAccessAndProperty()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestResident(otherUserClient, obj.id, {})
            })
        })

        it('can be updated by admin', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const [objUpdated, attrs] = await updateTestResident(adminClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.unitType).toEqual(obj.unitType)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('cannot be updated by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anonymousClient = await makeClient()

            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestResident(anonymousClient, obj.id)
            })
        })
    })

    describe('Delete', () => {
        it('cannot be deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()

            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.delete(adminClient, obj.id)
            })
        })

        it('cannot be deleted by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()

            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.delete(userClient, obj.id)
            })
        })

        it('cannot be deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anonymousClient = await makeClient()

            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.delete(anonymousClient, obj.id)
            })
        })

        it('can be soft-deleted using update operation by admin', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const [objUpdated, attrs] = await Resident.softDelete(adminClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('can be soft-deleted using update operation by current user with type resident', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            // NOTE: USING RAW SINCE WE CANNOT QUERY PROPERTY OF DELETED RESIDENT ANYMORE
            const { data } = await Resident.softDelete(userClient, obj.id, {}, { raw: true })
            expect(data).toBeDefined()
            expect(data).toHaveProperty('obj')
            const { obj: objUpdated } = data
            expect(objUpdated).toHaveProperty('id', obj.id)
            expect(objUpdated).toHaveProperty('dv', 1)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('can be soft-deleted using update operation by current user with type resident with recurrent payment context', async () => {
            const client = await makeClientWithServiceConsumer()
            const adminClient = await makeLoggedInAdminClient()

            // create recurrent payment context
            const [billingCategory] = (await createTestBillingCategory(adminClient, { name: `Category ${new Date()}` }))
            const [recurrentContext] = await createTestRecurrentPaymentContext(adminClient, {
                enabled: false,
                limit: '10000',
                autoPayReceipts: false,
                paymentDay: 10,
                settings: { cardId: faker.datatype.uuid() },
                serviceConsumer: { connect: { id: client.serviceConsumer.id } },
                billingCategory: { connect: { id: billingCategory.id } },
            })

            const contextsBeforeDelete = await RecurrentPaymentContext.getAll(adminClient, { id: recurrentContext.id })
            expect(contextsBeforeDelete).toHaveLength(1)

            // NOTE: USING RAW SINCE WE CANNOT QUERY PROPERTY OF DELETED RESIDENT ANYMORE
            const { data } = await Resident.softDelete(client, client.resident.id, {}, { raw: true })
            expect(data).toBeDefined()
            expect(data).toHaveProperty('obj')
            const { obj: objUpdated } = data
            expect(objUpdated).toHaveProperty('id', client.resident.id)
            expect(objUpdated).toHaveProperty('dv', 1)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)

            const contexts = await RecurrentPaymentContext.getAll(adminClient, { id: recurrentContext.id })
            expect(contexts).toHaveLength(0)
        })

        it('cannot be soft-deleted using update operation by current user with type resident when other fields gets passed as variables', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const notAllowedPayload = {
                address: faker.address.streetAddress(true),
            }

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.softDelete(userClient, obj.id, notAllowedPayload)
            })
        })

        it('cannot be soft-deleted using update operation by other user with type resident', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestResident(adminClient, userClient.user, userClient.property)

            const otherUserClient = await makeClientWithResidentAccessAndProperty()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Resident.softDelete(otherUserClient, obj.id)
            })
        })
    })
})
