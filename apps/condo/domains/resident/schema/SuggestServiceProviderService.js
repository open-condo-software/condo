/**
 * Generated by `createservice organization.SuggestServiceProviderService --type queries`
 */

const { pick, uniqBy } = require('lodash')

const { GQLCustomSchema, itemsQuery, find } = require('@open-condo/keystone/schema')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const access = require('@condo/domains/resident/access/SuggestServiceProviderService')
const {
    MAX_RESIDENT_SUGGEST_SERVICE_PROVIDER_CALLS_BY_WINDOW_SEC,
    RESIDENT_SUGGEST_SERVICE_PROVIDER_WINDOW_IN_SEC,
    MAX_SUGGEST_SERVICE_PROVIDER_ITEMS_COUNT,
} = require('@condo/domains/resident/constants')
const { RESIDENT } = require('@condo/domains/user/constants/common')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')

const redisGuard = new RedisGuard()

const checkLimits = async (userId, context) => {
    await redisGuard.checkCustomLimitCounters(
        `suggest_service_provider:user:${userId}`,
        RESIDENT_SUGGEST_SERVICE_PROVIDER_WINDOW_IN_SEC,
        MAX_RESIDENT_SUGGEST_SERVICE_PROVIDER_CALLS_BY_WINDOW_SEC,
        context,
    )
}

const filterOrganizationsByAcquiringContextOrMeterResourceOwnership = async (context, organizations) => {
    const organizationIds = [...new Set(organizations.map(organization => organization.id))]

    const acquiringIntegrationContexts = await find('AcquiringIntegrationContext', {
        organization: { id_in: organizationIds },
        deletedAt: null,
        status: CONTEXT_FINISHED_STATUS,
    })

    const meterResourceOwners = await find('MeterResourceOwner', {
        organization: { id_in: organizationIds },
        deletedAt: null,
    })

    const organizationsForSuggest = new Set(
        acquiringIntegrationContexts.map(context => context.organization)
            .concat(meterResourceOwners.map(owner => owner.organization))
    )

    return organizations.filter(organization => organizationsForSuggest.has(organization.id))
}


const SuggestServiceProviderService = new GQLCustomSchema('SuggestServiceProviderService', {
    types: [
        {
            access: true,
            type: 'input SuggestServiceProviderInput { search: String! }',
        },
        {
            access: true,
            type: 'type SuggestServiceProviderOutput { id: String!, tin: String!, name: String!, type: OrganizationTypeType! }',
        },
    ],
    
    queries: [
        {
            access: access.canSuggestServiceProvider,
            schema: 'suggestServiceProvider (data: SuggestServiceProviderInput!): [SuggestServiceProviderOutput!]',
            resolver: async (parent, args, context = {}) => {
                if (context.authedItem.type === RESIDENT) {
                    await checkLimits(context.authedItem.id, context)
                }

                const { data: { search } } = args
                if (!search || search.length < 3) {
                    return []
                }

                const serviceProviders = await itemsQuery('Organization', {
                    where: {
                        OR: [
                            { tin_starts_with: search.trim() },
                            { name_contains_i: search.trim() },
                        ],
                        deletedAt: null,
                        type: SERVICE_PROVIDER_TYPE,
                    },
                    first: MAX_SUGGEST_SERVICE_PROVIDER_ITEMS_COUNT,
                })

                const serviceProvidersForSuggest = await filterOrganizationsByAcquiringContextOrMeterResourceOwnership(context, serviceProviders)
                return uniqBy(serviceProvidersForSuggest, 'tin')
                    .map(serviceProvider => pick(serviceProvider, ['id', 'tin', 'name', 'type']))
            },
        },
    ],
    
})

module.exports = {
    SuggestServiceProviderService,
}
