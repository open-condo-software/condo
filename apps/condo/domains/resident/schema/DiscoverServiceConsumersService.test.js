/**
 * Generated by `createservice resident.DiscoverServiceConsumersService --type mutations`
 */
const { faker } = require('@faker-js/faker')

const {
    makeLoggedInAdminClient, makeClient, expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult, waitFor, getIsFeatureFlagsEnabled, setIsFeatureFlagsEnabled,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    createTestAcquiringIntegrationContext,
    createTestAcquiringIntegration, addAcquiringIntegrationAndContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    createTestBillingProperty,
    createTestBillingAccount,
    ResidentBillingReceipt,
    createTestBillingIntegration,
    createTestBillingIntegrationOrganizationContext,
    createRegisterBillingReceiptsPayload,
    registerBillingReceiptsByTestClient,
    addBillingIntegrationAndContext,
    createTestBillingIntegrationAccessRight,
} = require('@condo/domains/billing/utils/testSchema')
const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const { createTestOrganization, registerNewOrganization } = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const {
    makeClientWithResidentAccessAndProperty,
    makeClientWithProperty, createTestProperty, updateTestProperty,
} = require('@condo/domains/property/utils/testSchema')
const { buildFakeAddressAndMeta } = require('@condo/domains/property/utils/testSchema/factories')
const {
    createTestResident,
    ServiceConsumer,
    discoverServiceConsumersByTestClient,
    registerResidentByTestClient,
} = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

describe('DiscoverServiceConsumersService', () => {
    let admin
    let support
    let anonymous

    const randomPayload = {
        billingAccountsIds: [faker.datatype.uuid()],
    }

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
    })

    describe('access', () => {
        test('admin can discover service consumers', async () => {
            const payload = {
                billingAccountsIds: [],
            }

            const [{ statistics }] = await discoverServiceConsumersByTestClient(admin, payload)

            expect(statistics).toBeDefined()
        })

        test('user cannot discover service consumers', async () => {
            const user = await makeClientWithProperty()
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await discoverServiceConsumersByTestClient(user, randomPayload)
            })
        })

        test('support cannot discover service consumers', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await discoverServiceConsumersByTestClient(support, randomPayload)
            })
        })

        test('anonymous cannot discover service consumers', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await discoverServiceConsumersByTestClient(anonymous, randomPayload)
            })
        })
    })

    describe('logic tests', () => {

        test('must not discover service consumer if there is no acquiring context', async () => {
            const user = await makeClientWithProperty()

            const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(admin, billingIntegrationContext, { address: user.property.address })
            const [resident] = await createTestResident(admin, user.user, user.property, { address: billingProperty.address })

            await createTestBillingAccount(admin, billingIntegrationContext, billingProperty, {
                unitName: resident.unitName,
                unitType: resident.unitType,
            })

            // wait for the task to finish
            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    resident: { id: resident.id },
                    deletedAt: null,
                })

                expect(createdServiceConsumers).toHaveLength(0)
            }, { delay: 500 })
        })

        test('must not discover service consumer if there is no billing account', async () => {
            const user = await makeClientWithProperty()
            const residentClient1 = await makeClientWithResidentAccessAndProperty()

            const unitType1 = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()

            await addAcquiringIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            await createTestBillingProperty(admin, billingIntegrationContext, { address: user.property.address })

            const [resident] = await registerResidentByTestClient(
                residentClient1,
                {
                    address: user.property.address,
                    addressMeta: user.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                resident: { id: resident.id },
                deletedAt: null,
            })

            expect(createdServiceConsumers).toHaveLength(0)
        })

        test('discover multiple service consumers', async () => {
            const user = await makeClientWithProperty()
            const user2 = await makeClientWithProperty()

            await addAcquiringIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(admin, billingIntegrationContext, { address: user.property.address })

            const [resident1] = await createTestResident(admin, user.user, user.property, { address: billingProperty.address })
            const [resident2] = await createTestResident(admin, user2.user, user.property, {
                address: billingProperty.address,
                unitName: resident1.unitName,
                unitType: resident1.unitType,
            })

            const [billingAccount1] = await createTestBillingAccount(admin, billingIntegrationContext, billingProperty,
                { unitName: resident1.unitName, unitType: resident1.unitType },
            )

            const [billingAccount2] = await createTestBillingAccount(admin, billingIntegrationContext, billingProperty,
                { unitName: resident1.unitName, unitType: resident1.unitType },
            )

            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    OR: [
                        { resident: { id: resident1.id } },
                        { resident: { id: resident2.id } },
                    ],
                    deletedAt: null,
                })
                const residentIds = createdServiceConsumers.map(serviceConsumer => serviceConsumer.resident.id)
                const accountNumbers = createdServiceConsumers.map(serviceConsumer => serviceConsumer.accountNumber)

                expect(residentIds).toEqual(expect.arrayContaining([resident1.id, resident2.id]))
                expect(accountNumbers).toEqual(expect.arrayContaining([billingAccount1.number, billingAccount2.number]))
            })
        })

        test('discover multiple service consumers for specific resident', async () => {
            const user = await makeClientWithProperty()

            await addAcquiringIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext: billingIntegrationContext1 } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [organization] = await createTestOrganization(admin)
            await addAcquiringIntegrationAndContext(admin, organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext: billingIntegrationContext2 } = await addBillingIntegrationAndContext(admin, organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty1] = await createTestBillingProperty(admin, billingIntegrationContext1, { address: user.property.address })
            const [billingProperty2] = await createTestBillingProperty(admin, billingIntegrationContext2, { address: user.property.address })

            const unitType1 = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()

            const [billingAccount1] = await createTestBillingAccount(admin, billingIntegrationContext1, billingProperty1,
                { unitType: unitType1, unitName: unitName1 },
            )

            const [billingAccount2] = await createTestBillingAccount(admin, billingIntegrationContext2, billingProperty2,
                { unitType: unitType1, unitName: unitName1 },
            )

            // no consumers should be created after billing accounts appeared in database
            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    // accountNumber: billingAccount.number,
                    OR: [
                        { accountNumber: billingAccount1.number },
                        { accountNumber: billingAccount2.number },

                    ],
                    organization: { id: user.organization.id },
                    deletedAt: null,
                })

                expect(createdServiceConsumers).toHaveLength(0)
            }, { delay: 500 })

            // now, add the resident...
            const residentClient1 = await makeClientWithResidentUser()
            const [resident1] = await registerResidentByTestClient(
                residentClient1,
                {
                    address: user.property.address,
                    addressMeta: user.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            // ...and check for service consumers created immediately
            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    resident: { id: resident1.id },
                    OR: [
                        { accountNumber: billingAccount1.number },
                        { accountNumber: billingAccount2.number },
                    ],
                    deletedAt: null,
                })

                expect(createdServiceConsumers).toHaveLength(2)
                expect(createdServiceConsumers).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        resident: expect.objectContaining({ id: resident1.id }),
                        organization: expect.objectContaining({ id: user.organization.id }),
                        accountNumber: billingAccount1.number,
                        isDiscovered: true,
                    }),
                    expect.objectContaining({
                        resident: expect.objectContaining({ id: resident1.id }),
                        organization: expect.objectContaining({ id: organization.id }),
                        accountNumber: billingAccount2.number,
                        isDiscovered: true,
                    }),
                ]))
            })
        })

        describe('Without DSC feature flag', () => {

            const prevIsFeatureFlagsEnabled = getIsFeatureFlagsEnabled()
            let adminNoFlag

            beforeAll(async () => {
                setIsFeatureFlagsEnabled(false) // Disable feature flags
                adminNoFlag = await makeLoggedInAdminClient()
            })

            afterAll(() => {
                setIsFeatureFlagsEnabled(prevIsFeatureFlagsEnabled) // put the previous value back
            })

            test('discover no service consumers for managing organization if the feature flag was disabled', async () => {
                const user = await makeClientWithProperty()

                await addAcquiringIntegrationAndContext(adminNoFlag, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
                const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminNoFlag, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

                const [billingProperty] = await createTestBillingProperty(adminNoFlag, billingIntegrationContext, { address: user.property.address })
                const [resident] = await createTestResident(adminNoFlag, user.user, user.property,
                    { address: billingProperty.address },
                )
                await createTestBillingAccount(adminNoFlag, billingIntegrationContext, billingProperty,
                    { unitName: resident.unitName, unitType: resident.unitType },
                )

                await waitFor(async () => {
                    const createdServiceConsumers = await ServiceConsumer.getAll(adminNoFlag, {
                        resident: { id: resident.id },
                        deletedAt: null,
                    })
                    expect(createdServiceConsumers).toHaveLength(0)
                })
            })

            test('discover service consumers for service provider org even if the feature DSC-flag was disabled', async () => {
                const user = await makeClientWithProperty()
                const [organization] = await registerNewOrganization(user, { type: SERVICE_PROVIDER_TYPE })
                const [property] = await createTestProperty(user, organization)
                user.organization = organization
                user.property = property

                await addAcquiringIntegrationAndContext(adminNoFlag, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
                const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminNoFlag, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

                const [billingProperty] = await createTestBillingProperty(adminNoFlag, billingIntegrationContext, { address: user.property.address })

                const residentClient1 = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(
                    residentClient1,
                    {
                        address: user.property.address,
                        addressMeta: user.property.addressMeta,
                        unitType: FLAT_UNIT_TYPE,
                        unitName: faker.lorem.word(),
                    })

                const [billingAccount] = await createTestBillingAccount(adminNoFlag, billingIntegrationContext, billingProperty,
                    { unitName: resident.unitName, unitType: resident.unitType },
                )

                await waitFor(async () => {
                    const createdServiceConsumers = await ServiceConsumer.getAll(adminNoFlag, {
                        resident: { id: resident.id },
                        deletedAt: null,
                    })
                    expect(createdServiceConsumers).toHaveLength(1)
                    expect(createdServiceConsumers).toEqual(expect.arrayContaining([
                        expect.objectContaining({
                            resident: expect.objectContaining({ id: resident.id }),
                            organization: expect.objectContaining({ id: user.organization.id }),
                            accountNumber: billingAccount.number,
                            isDiscovered: true,
                        }),
                    ]))
                })
            })
        })
    })

    describe('real life cases', () => {
        test('Upload receipts => register resident => resident can see the receipts list', async () => {
            const residentClient1 = await makeClientWithResidentAccessAndProperty()

            const [billingIntegration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, residentClient1.organization, billingIntegration, { status: CONTEXT_FINISHED_STATUS })
            const [acquiringIntegration] = await createTestAcquiringIntegration(admin)
            await createTestAcquiringIntegrationContext(admin, residentClient1.organization, acquiringIntegration, { status: CONTEXT_FINISHED_STATUS })

            const unitType1 = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()

            // 1/3 upload receipts
            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: residentClient1.property.address,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }
            const [registeredReceipts] = await registerBillingReceiptsByTestClient(admin, payload)

            // 2/3 register resident
            await registerResidentByTestClient(
                residentClient1,
                {
                    address: residentClient1.property.address,
                    addressMeta: residentClient1.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            // 3/3 check that resident can see the receipts list
            const receipts = await ResidentBillingReceipt.getAll(
                residentClient1,
                {},
            )

            expect(receipts).toHaveLength(1)
            expect(registeredReceipts).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: receipts[0].id }),
            ]))
        })

        test('Register 2 residents into the same flat => upload receipts => both residents can see the receipts list', async () => {
            const residentClient1 = await makeClientWithResidentAccessAndProperty()
            const residentClient2 = await makeClientWithResidentAccessAndProperty()

            const [billingIntegration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, residentClient1.organization, billingIntegration, { status: CONTEXT_FINISHED_STATUS })
            const [acquiringIntegration] = await createTestAcquiringIntegration(admin)
            await createTestAcquiringIntegrationContext(admin, residentClient1.organization, acquiringIntegration, { status: CONTEXT_FINISHED_STATUS })

            const unitType1 = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()

            // 1/3 register residents
            await registerResidentByTestClient(
                residentClient1,
                {
                    address: residentClient1.property.address,
                    addressMeta: residentClient1.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            await registerResidentByTestClient(
                residentClient2,
                {
                    address: residentClient1.property.address,
                    addressMeta: residentClient1.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            // 2/3 upload receipts
            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: residentClient1.property.address,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }
            const [registeredReceipts] = await registerBillingReceiptsByTestClient(admin, payload)

            // 3/3 check that residents can see the receipts list
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})

                expect(receipts1).toHaveLength(1)
                expect(registeredReceipts).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                ]))

                expect(receipts2).toHaveLength(1)
                expect(registeredReceipts).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts2[0].id }),
                ]))
            })
        })

        test('game of life', async () => {
            const user1 = await makeClientWithNewRegisteredAndLoggedInUser()
            const serviceUser1 = await makeClientWithServiceUser()
            const user2 = await makeClientWithNewRegisteredAndLoggedInUser()
            const serviceUser2 = await makeClientWithServiceUser()

            const residentClient1 = await makeClientWithResidentUser()
            const residentClient2 = await makeClientWithResidentUser()
            const residentClient3 = await makeClientWithResidentUser()
            const residentClient4 = await makeClientWithResidentUser()
            const residentClient5 = await makeClientWithResidentUser()

            const [managingOrg1] = await registerNewOrganization(user1)
            const [serviceOrg1] = await registerNewOrganization(user2, { type: SERVICE_PROVIDER_TYPE })

            // register resident1 when other actors are not existing yet
            const unitType1 = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()
            const { address: address1, addressMeta: addressMeta1 } = buildFakeAddressAndMeta(true)
            await registerResidentByTestClient(
                residentClient1,
                { address: address1, addressMeta: addressMeta1, unitType: unitType1, unitName: unitName1 },
            )

            // resident1 see no receipts
            const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
            expect(receipts1).toHaveLength(0)

            // user1 adds first receipts to managingOrg1
            const {
                billingIntegrationContext: billingContext1,
                billingIntegration: billingIntegration1,
            } = await addBillingIntegrationAndContext(support, managingOrg1, {}, { status: CONTEXT_FINISHED_STATUS })
            await createTestBillingIntegrationAccessRight(support, billingIntegration1, serviceUser1.user)
            await addAcquiringIntegrationAndContext(support, managingOrg1, {}, { status: CONTEXT_FINISHED_STATUS })
            const payload1 = {
                context: { id: billingContext1.id },
                receipts: [
                    // One of receipts is for resident1
                    createRegisterBillingReceiptsPayload({
                        address: address1,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }
            const [registeredReceipts1] = await registerBillingReceiptsByTestClient(serviceUser1, payload1)
            // resident1: still no receipts, cause the organization haven't added the property
            const receipts1a = await ResidentBillingReceipt.getAll(residentClient1, {})
            expect(receipts1a).toHaveLength(0)

            // Now, managingOrg1 adds property with resident1
            await createTestProperty(user1, managingOrg1, {
                address: address1,
                addressMeta: addressMeta1,
            })
            // and some another property
            await createTestProperty(user1, managingOrg1)

            // resident1 should see receipt
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(1)
                expect(registeredReceipts1).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                ]))
            })

            // Let managingOrg1 load another receipts
            const payload1a = {
                context: { id: billingContext1.id },
                receipts: [
                    // One of receipts is for resident1
                    createRegisterBillingReceiptsPayload({
                        address: address1,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }
            const [registeredReceipts1a] = await registerBillingReceiptsByTestClient(serviceUser1, payload1a)

            // resident1 should see 2 receipts
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(2)
                expect([...registeredReceipts1, ...registeredReceipts1a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                ]))
            })

            // Time for serviceOrg1 add properties
            // the first property is the same as for managingOrg1
            const [property2] = await createTestProperty(user2, serviceOrg1, {
                address: address1, addressMeta: addressMeta1,
            })

            //resident1 still see the same list of receipts
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(2)
                expect([...registeredReceipts1, ...registeredReceipts1a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                ]))
            })

            // Now 2nd resident appears
            const { address: address2, addressMeta: addressMeta2 } = buildFakeAddressAndMeta(true)
            const unitType2 = FLAT_UNIT_TYPE
            const unitName2 = faker.lorem.word()
            await registerResidentByTestClient(
                residentClient2,
                { address: address2, addressMeta: addressMeta2, unitType: unitType2, unitName: unitName2 },
            )

            // 2nd resident see no receipts
            const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})
            expect(receipts2).toHaveLength(0)

            // Ok, let managingOrg1 to add some else receipts
            const payload1b = {
                context: { id: billingContext1.id },
                receipts: [
                    // One of receipts is for resident1
                    createRegisterBillingReceiptsPayload({
                        address: address1,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                    // Another is for resident2
                    createRegisterBillingReceiptsPayload({
                        address: address2,
                        unitType: unitType2,
                        unitName: unitName2,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }
            const [registeredReceipts1b] = await registerBillingReceiptsByTestClient(serviceUser1, payload1b)

            // serviceOrg1 wanna do the same
            const {
                billingIntegrationContext: billingContext2,
                billingIntegration: billingIntegration2,
            } = await addBillingIntegrationAndContext(support, serviceOrg1, {}, { status: CONTEXT_FINISHED_STATUS })
            await createTestBillingIntegrationAccessRight(support, billingIntegration2, serviceUser2.user)
            await addAcquiringIntegrationAndContext(support, serviceOrg1, {}, { status: CONTEXT_FINISHED_STATUS })
            const payload2 = {
                context: { id: billingContext2.id },
                receipts: [
                    // One of receipts is for resident1
                    createRegisterBillingReceiptsPayload({
                        address: address2,
                        unitType: unitType2,
                        unitName: unitName2,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }
            const [registeredReceipts2] = await registerBillingReceiptsByTestClient(serviceUser2, payload2)

            // The 1st resident must see 4 receipts
            // The 2nd one see nothing, cause serviceOrg1 haven't add property
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(3)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                    expect.objectContaining({ id: receipts1[2].id }),
                ]))

                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})
                expect(receipts2).toHaveLength(0)
            })

            // Now serviceOrg1 adds property of resident2
            await createTestProperty(user2, serviceOrg1, {
                address: address2, addressMeta: addressMeta2,
            })

            // And 2nd resident can see the receipts list
            // The 1st one still see the same as last time
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(3)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                    expect.objectContaining({ id: receipts1[2].id }),
                ]))

                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})
                expect(receipts2).toHaveLength(1)
                expect(registeredReceipts2).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts2[0].id }),
                ]))
            })

            // The 3rd resident appears... in the 1st one's flat. OMG!
            await registerResidentByTestClient(
                residentClient3,
                { address: address1, addressMeta: addressMeta1, unitType: unitType1, unitName: unitName1 },
            )

            // After that the 3rd resident must see the same as the 1st one
            // The 2nd see the same
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(3)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                    expect.objectContaining({ id: receipts1[2].id }),
                ]))

                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})
                expect(receipts2).toHaveLength(1)
                expect(registeredReceipts2).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts2[0].id }),
                ]))

                const receipts3 = await ResidentBillingReceipt.getAll(residentClient3, {})
                expect(receipts3).toHaveLength(3)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts3[0].id }),
                    expect.objectContaining({ id: receipts3[1].id }),
                    expect.objectContaining({ id: receipts3[2].id }),
                ]))
            })

            // Now managingOrg1 add receipt for flat where 1st and 3rd lives
            // and one receipt for the 2nd
            const payload1c = {
                context: { id: billingContext1.id },
                receipts: [
                    // One of receipts is for resident1
                    createRegisterBillingReceiptsPayload({
                        address: address1,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                    // Another is for resident2
                    createRegisterBillingReceiptsPayload({
                        address: address2,
                        unitType: unitType2,
                        unitName: unitName2,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }
            const [registeredReceipts1c] = await registerBillingReceiptsByTestClient(serviceUser1, payload1c)

            // After that the 1st and the 3rd residents must see 4 receipts each
            // The 2nd see the same, cause their property is not added to managingOrg1
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(4)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                    expect.objectContaining({ id: receipts1[2].id }),
                    expect.objectContaining({ id: receipts1[3].id }),
                ]))

                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})
                expect(receipts2).toHaveLength(1)
                expect(registeredReceipts2).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts2[0].id }),
                ]))

                const receipts3 = await ResidentBillingReceipt.getAll(residentClient3, {})
                expect(receipts3).toHaveLength(4)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts3[0].id }),
                    expect.objectContaining({ id: receipts3[1].id }),
                    expect.objectContaining({ id: receipts3[2].id }),
                    expect.objectContaining({ id: receipts3[3].id }),
                ]))
            })

            // Add resident4 to resident2's flat
            await registerResidentByTestClient(
                residentClient4,
                { address: address2, addressMeta: addressMeta2, unitType: unitType2, unitName: unitName2 },
            )

            // Let managingOrg1 add the property of the 2nd and 4th residents
            await createTestProperty(user1, managingOrg1, {
                address: address2,
                addressMeta: addressMeta2,
            })

            // The 2nd resident must see +2 receipt from managingOrg1
            // The 1st and 3rd residents must see the same
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(4)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                    expect.objectContaining({ id: receipts1[2].id }),
                    expect.objectContaining({ id: receipts1[3].id }),
                ]))

                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})
                expect(receipts2).toHaveLength(3)
                expect([...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts2[0].id }),
                    expect.objectContaining({ id: receipts2[1].id }),
                    expect.objectContaining({ id: receipts2[2].id }),
                ]))

                const receipts3 = await ResidentBillingReceipt.getAll(residentClient3, {})
                expect(receipts3).toHaveLength(4)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts3[0].id }),
                    expect.objectContaining({ id: receipts3[1].id }),
                    expect.objectContaining({ id: receipts3[2].id }),
                    expect.objectContaining({ id: receipts3[3].id }),
                ]))

                const receipts4 = await ResidentBillingReceipt.getAll(residentClient4, {})
                expect(receipts4).toHaveLength(3)
                expect([...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts4[0].id }),
                    expect.objectContaining({ id: receipts4[1].id }),
                    expect.objectContaining({ id: receipts4[2].id }),
                ]))
            }, { delay: 500 })

            // Now serviceOrg1 add receipts for the flat where 2nd and 4th lives
            // and one receipt for the 2nd
            const payload2a = {
                context: { id: billingContext2.id },
                receipts: [
                    // One of receipts is for resident2 and resident4
                    createRegisterBillingReceiptsPayload({
                        address: address2,
                        unitType: unitType2,
                        unitName: unitName2,
                    }),
                    // Another ones are for resident1
                    createRegisterBillingReceiptsPayload({
                        address: address1,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                    createRegisterBillingReceiptsPayload({
                        address: address1,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                ],
            }
            const [registeredReceipts2a] = await registerBillingReceiptsByTestClient(serviceUser2, payload2a)

            // The 2nd and 4th residents must see +1 receipt from serviceOrg1
            // The 1st and 3rd residents must see +2 receipt from serviceOrg1
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(6)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                    expect.objectContaining({ id: receipts1[2].id }),
                    expect.objectContaining({ id: receipts1[3].id }),
                    expect.objectContaining({ id: receipts1[4].id }),
                    expect.objectContaining({ id: receipts1[5].id }),
                ]))

                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})
                expect(receipts2).toHaveLength(4)
                expect([...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts2[0].id }),
                    expect.objectContaining({ id: receipts2[1].id }),
                    expect.objectContaining({ id: receipts2[2].id }),
                    expect.objectContaining({ id: receipts2[3].id }),
                ]))

                const receipts3 = await ResidentBillingReceipt.getAll(residentClient3, {})
                expect(receipts3).toHaveLength(6)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts3[0].id }),
                    expect.objectContaining({ id: receipts3[1].id }),
                    expect.objectContaining({ id: receipts3[2].id }),
                    expect.objectContaining({ id: receipts3[3].id }),
                    expect.objectContaining({ id: receipts3[4].id }),
                    expect.objectContaining({ id: receipts3[5].id }),
                ]))

                const receipts4 = await ResidentBillingReceipt.getAll(residentClient4, {})
                expect(receipts4).toHaveLength(4)
                expect([...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts4[0].id }),
                    expect.objectContaining({ id: receipts4[1].id }),
                    expect.objectContaining({ id: receipts4[2].id }),
                    expect.objectContaining({ id: receipts4[3].id }),
                ]))
            }, { delay: 500 })

            // Now let's change property2 address
            const { address: address2a, addressMeta: addressMeta2a } = buildFakeAddressAndMeta(true)
            await updateTestProperty(user2, property2.id, {
                address: address2a,
                addressMeta: addressMeta2a,
            })

            // Residents must see the same receipts set
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(6)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                    expect.objectContaining({ id: receipts1[2].id }),
                    expect.objectContaining({ id: receipts1[3].id }),
                    expect.objectContaining({ id: receipts1[4].id }),
                    expect.objectContaining({ id: receipts1[5].id }),
                ]))

                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})
                expect(receipts2).toHaveLength(4)
                expect([...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts2[0].id }),
                    expect.objectContaining({ id: receipts2[1].id }),
                    expect.objectContaining({ id: receipts2[2].id }),
                    expect.objectContaining({ id: receipts2[3].id }),
                ]))

                const receipts3 = await ResidentBillingReceipt.getAll(residentClient3, {})
                expect(receipts3).toHaveLength(6)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts3[0].id }),
                    expect.objectContaining({ id: receipts3[1].id }),
                    expect.objectContaining({ id: receipts3[2].id }),
                    expect.objectContaining({ id: receipts3[3].id }),
                    expect.objectContaining({ id: receipts3[4].id }),
                    expect.objectContaining({ id: receipts3[5].id }),
                ]))

                const receipts4 = await ResidentBillingReceipt.getAll(residentClient4, {})
                expect(receipts4).toHaveLength(4)
                expect([...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts4[0].id }),
                    expect.objectContaining({ id: receipts4[1].id }),
                    expect.objectContaining({ id: receipts4[2].id }),
                    expect.objectContaining({ id: receipts4[3].id }),
                ]))
            }, { delay: 500 })

            // 5th resident registered to updated address
            const unitType5 = FLAT_UNIT_TYPE
            const unitName5 = faker.lorem.word()
            await registerResidentByTestClient(
                residentClient5,
                { address: address2a, addressMeta: addressMeta2a, unitType: unitType5, unitName: unitName5 },
            )

            // No receipts for mr. 5th at the new address
            const receipts5 = await ResidentBillingReceipt.getAll(residentClient5, {})
            expect(receipts5).toHaveLength(0)

            // add one receipt for the new 5th resident
            const payload5 = {
                context: { id: billingContext2.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: address2a,
                        unitType: unitType5,
                        unitName: unitName5,
                    }),
                ],
            }
            const [registeredReceipts5] = await registerBillingReceiptsByTestClient(serviceUser2, payload5)

            // One receipt must appear for 5th
            // The others must see the same as last time
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                expect(receipts1).toHaveLength(6)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                    expect.objectContaining({ id: receipts1[1].id }),
                    expect.objectContaining({ id: receipts1[2].id }),
                    expect.objectContaining({ id: receipts1[3].id }),
                    expect.objectContaining({ id: receipts1[4].id }),
                    expect.objectContaining({ id: receipts1[5].id }),
                ]))

                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})
                expect(receipts2).toHaveLength(4)
                expect([...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts2[0].id }),
                    expect.objectContaining({ id: receipts2[1].id }),
                    expect.objectContaining({ id: receipts2[2].id }),
                    expect.objectContaining({ id: receipts2[3].id }),
                ]))

                const receipts3 = await ResidentBillingReceipt.getAll(residentClient3, {})
                expect(receipts3).toHaveLength(6)
                expect([...registeredReceipts1, ...registeredReceipts1a, ...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts3[0].id }),
                    expect.objectContaining({ id: receipts3[1].id }),
                    expect.objectContaining({ id: receipts3[2].id }),
                    expect.objectContaining({ id: receipts3[3].id }),
                    expect.objectContaining({ id: receipts3[4].id }),
                    expect.objectContaining({ id: receipts3[5].id }),
                ]))

                const receipts4 = await ResidentBillingReceipt.getAll(residentClient4, {})
                expect(receipts4).toHaveLength(4)
                expect([...registeredReceipts1b, ...registeredReceipts1c, ...registeredReceipts2, ...registeredReceipts2a]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts4[0].id }),
                    expect.objectContaining({ id: receipts4[1].id }),
                    expect.objectContaining({ id: receipts4[2].id }),
                    expect.objectContaining({ id: receipts4[3].id }),
                ]))

                const receipts5 = await ResidentBillingReceipt.getAll(residentClient5, {})
                expect(receipts5).toHaveLength(1)
                expect([...registeredReceipts5]).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts5[0].id }),
                ]))
            }, { delay: 500 })
        })
    })
})
