/**
 * Generated by `createservice resident.DiscoverServiceConsumersService --type mutations`
 */
const { faker } = require('@faker-js/faker')

const {
    makeLoggedInAdminClient, makeClient, expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult, waitFor, getIsFeatureFlagsEnabled, setIsFeatureFlagsEnabled,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    createTestAcquiringIntegrationContext,
    createTestAcquiringIntegration, addAcquiringIntegrationAndContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const {
    makeContextWithOrganizationAndIntegrationAsAdmin,
    createTestBillingProperty,
    createTestBillingAccount,
    ResidentBillingReceipt,
    createTestBillingIntegration,
    createTestBillingIntegrationOrganizationContext,
    createRegisterBillingReceiptsPayload,
    registerBillingReceiptsByTestClient, addBillingIntegrationAndContext,
} = require('@condo/domains/billing/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const {
    makeClientWithResidentAccessAndProperty,
    makeClientWithProperty,
} = require('@condo/domains/property/utils/testSchema')
const {
    createTestResident,
    ServiceConsumer,
    discoverServiceConsumersByTestClient,
    registerResidentByTestClient,
} = require('@condo/domains/resident/utils/testSchema')
const { makeClientWithSupportUser, makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')

describe('DiscoverServiceConsumersService', () => {
    let admin
    let support
    let anonymous

    const randomPayload = {
        billingAccountsIds: [faker.datatype.uuid()],
    }

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
    })

    describe('access', () => {
        test('admin can discover service consumers', async () => {
            const payload = {
                billingAccountsIds: [],
            }

            const [{ statistics }] = await discoverServiceConsumersByTestClient(admin, payload)

            expect(statistics).toBeDefined()
        })

        test('user cannot discover service consumers', async () => {
            const user = await makeClientWithProperty()
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await discoverServiceConsumersByTestClient(user, randomPayload)
            })
        })

        test('support cannot discover service consumers', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await discoverServiceConsumersByTestClient(support, randomPayload)
            })
        })

        test('anonymous cannot discover service consumers', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await discoverServiceConsumersByTestClient(anonymous, randomPayload)
            })
        })
    })

    describe('logic tests', () => {
        test('discover one service consumer', async () => {
            const user = await makeClientWithProperty()

            await addAcquiringIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(admin, billingIntegrationContext, { address: user.property.address })
            const [resident] = await createTestResident(admin, user.user, user.property, { address: billingProperty.address })

            const [billingAccount] = await createTestBillingAccount(admin, billingIntegrationContext, billingProperty, {
                unitName: resident.unitName,
                unitType: resident.unitType,
            })

            // wait for the task to finish
            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    resident: { id: resident.id },
                    deletedAt: null,
                })

                expect(createdServiceConsumers).toHaveLength(1)
                expect(createdServiceConsumers[0].organization.id).toEqual(user.organization.id)
                expect(createdServiceConsumers[0].accountNumber).toEqual(billingAccount.number)
            })
        })

        test('must not discover service consumer if there is no acquiring context', async () => {
            const user = await makeClientWithProperty()

            const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(admin, billingIntegrationContext, { address: user.property.address })
            const [resident] = await createTestResident(admin, user.user, user.property, { address: billingProperty.address })

            await createTestBillingAccount(admin, billingIntegrationContext, billingProperty, {
                unitName: resident.unitName,
                unitType: resident.unitType,
            })

            // wait for the task to finish
            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    resident: { id: resident.id },
                    deletedAt: null,
                })

                expect(createdServiceConsumers).toHaveLength(0)
            }, { delay: 500 })
        })

        test('must not discover service consumer if there is no billing account', async () => {
            const user = await makeClientWithProperty()
            const residentClient1 = await makeClientWithResidentAccessAndProperty()

            const unitType1 = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()

            await addAcquiringIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            await createTestBillingProperty(admin, billingIntegrationContext, { address: user.property.address })

            const [resident] = await registerResidentByTestClient(
                residentClient1,
                {
                    address: user.property.address,
                    addressMeta: user.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                resident: { id: resident.id },
                deletedAt: null,
            })

            expect(createdServiceConsumers).toHaveLength(0)
        })

        test('discover multiple service consumers', async () => {
            const user = await makeClientWithProperty()
            const user2 = await makeClientWithProperty()

            await addAcquiringIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(admin, billingIntegrationContext, { address: user.property.address })

            const [resident1] = await createTestResident(admin, user.user, user.property, { address: billingProperty.address })
            const [resident2] = await createTestResident(admin, user2.user, user.property, {
                address: billingProperty.address,
                unitName: resident1.unitName,
                unitType: resident1.unitType,
            })

            const [billingAccount1] = await createTestBillingAccount(admin, billingIntegrationContext, billingProperty,
                { unitName: resident1.unitName, unitType: resident1.unitType },
            )

            const [billingAccount2] = await createTestBillingAccount(admin, billingIntegrationContext, billingProperty,
                { unitName: resident1.unitName, unitType: resident1.unitType },
            )

            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    OR: [
                        { resident: { id: resident1.id } },
                        { resident: { id: resident2.id } },
                    ],
                    deletedAt: null,
                })
                const residentIds = createdServiceConsumers.map(serviceConsumer => serviceConsumer.resident.id)
                const accountNumbers = createdServiceConsumers.map(serviceConsumer => serviceConsumer.accountNumber)

                expect(residentIds).toEqual(expect.arrayContaining([resident1.id, resident2.id]))
                expect(accountNumbers).toEqual(expect.arrayContaining([billingAccount1.number, billingAccount2.number]))
            })
        })

        test('discover one service consumer for specific resident', async () => {
            const user = await makeClientWithProperty()

            await addAcquiringIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty] = await createTestBillingProperty(admin, billingIntegrationContext, { address: user.property.address })

            const unitType = FLAT_UNIT_TYPE
            const unitName = faker.lorem.word()

            const [billingAccount] = await createTestBillingAccount(admin, billingIntegrationContext, billingProperty,
                { unitType, unitName },
            )

            // no consumers should be created
            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    accountNumber: billingAccount.number,
                    organization: { id: user.organization.id },
                    deletedAt: null,
                })

                expect(createdServiceConsumers).toHaveLength(0)
            }, { delay: 500 })

            // now, add the resident...
            const residentClient = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(
                residentClient,
                {
                    address: user.property.address,
                    addressMeta: user.property.addressMeta,
                    unitType,
                    unitName,
                })

            // ...and check for service consumer created immediately
            const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                resident: { id: resident.id },
                deletedAt: null,
            })

            expect(createdServiceConsumers).toHaveLength(1)
            expect(createdServiceConsumers[0].organization.id).toEqual(user.organization.id)
            expect(createdServiceConsumers[0].accountNumber).toEqual(billingAccount.number)
        })

        test('discover multiple service consumers for specific resident', async () => {
            const user = await makeClientWithProperty()

            await addAcquiringIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext: billingIntegrationContext1 } = await addBillingIntegrationAndContext(admin, user.organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [organization] = await createTestOrganization(admin)
            await addAcquiringIntegrationAndContext(admin, organization, {}, { status: CONTEXT_FINISHED_STATUS })
            const { billingIntegrationContext: billingIntegrationContext2 } = await addBillingIntegrationAndContext(admin, organization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [billingProperty1] = await createTestBillingProperty(admin, billingIntegrationContext1, { address: user.property.address })
            const [billingProperty2] = await createTestBillingProperty(admin, billingIntegrationContext2, { address: user.property.address })

            const unitType1 = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()

            const [billingAccount1] = await createTestBillingAccount(admin, billingIntegrationContext1, billingProperty1,
                { unitType: unitType1, unitName: unitName1 },
            )

            const [billingAccount2] = await createTestBillingAccount(admin, billingIntegrationContext2, billingProperty2,
                { unitType: unitType1, unitName: unitName1 },
            )

            // no consumers should be created after billing accounts appeared in database
            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    // accountNumber: billingAccount.number,
                    OR: [
                        { accountNumber: billingAccount1.number },
                        { accountNumber: billingAccount2.number },

                    ],
                    organization: { id: user.organization.id },
                    deletedAt: null,
                })

                expect(createdServiceConsumers).toHaveLength(0)
            }, { delay: 500 })

            // now, add the resident...
            const residentClient1 = await makeClientWithResidentUser()
            const [resident1] = await registerResidentByTestClient(
                residentClient1,
                {
                    address: user.property.address,
                    addressMeta: user.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            // ...and check for service consumers created immediately
            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    resident: { id: resident1.id },
                    OR: [
                        { accountNumber: billingAccount1.number },
                        { accountNumber: billingAccount2.number },
                    ],
                    deletedAt: null,
                })

                expect(createdServiceConsumers).toHaveLength(2)
                expect(createdServiceConsumers).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        resident: expect.objectContaining({ id: resident1.id }),
                        organization: expect.objectContaining({ id: user.organization.id }),
                        accountNumber: billingAccount1.number,
                        isDiscovered: true,
                    }),
                    expect.objectContaining({
                        resident: expect.objectContaining({ id: resident1.id }),
                        organization: expect.objectContaining({ id: user.organization.id }),
                        accountNumber: billingAccount2.number,
                        isDiscovered: true,
                    }),
                ]))
            })
        })

        test('discover no service consumers if the feature flag was disabled', async () => {
            const prevIsFeatureFlagsEnabled = getIsFeatureFlagsEnabled()
            setIsFeatureFlagsEnabled(false) // Disable feature flags

            const user = await makeClientWithProperty()
            const { context } = await makeContextWithOrganizationAndIntegrationAsAdmin(
                {}, {}, { status: 'Finished' },
            )

            const [billingProperty] = await createTestBillingProperty(admin, context, { address: user.property.address })
            const [resident] = await createTestResident(admin, user.user, user.property,
                { address: billingProperty.address },
            )
            await createTestBillingAccount(admin, context, billingProperty,
                { unitName: resident.unitName, unitType: resident.unitType },
            )

            await waitFor(async () => {
                const createdServiceConsumers = await ServiceConsumer.getAll(admin, {
                    resident: { id: resident.id },
                    deletedAt: null,
                })
                expect(createdServiceConsumers).toHaveLength(0)
            })

            setIsFeatureFlagsEnabled(prevIsFeatureFlagsEnabled) // put the previous value back
        })
    })

    describe('real life cases', () => {
        test('Upload receipts => register resident => resident can see the receipts list', async () => {
            const residentClient1 = await makeClientWithResidentAccessAndProperty()

            const [billingIntegration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, residentClient1.organization, billingIntegration, { status: CONTEXT_FINISHED_STATUS })
            const [acquiringIntegration] = await createTestAcquiringIntegration(admin)
            await createTestAcquiringIntegrationContext(admin, residentClient1.organization, acquiringIntegration, { status: CONTEXT_FINISHED_STATUS })

            const unitType1 = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()

            // 1/3 upload receipts
            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: residentClient1.property.address,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }
            const [registeredReceipts] = await registerBillingReceiptsByTestClient(admin, payload)

            // 2/3 register resident
            await registerResidentByTestClient(
                residentClient1,
                {
                    address: residentClient1.property.address,
                    addressMeta: residentClient1.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            // 3/3 check that resident can see the receipts list
            const receipts = await ResidentBillingReceipt.getAll(
                residentClient1,
                {},
            )

            expect(receipts).toHaveLength(1)
            expect(registeredReceipts).toEqual(expect.arrayContaining([
                expect.objectContaining({ id: receipts[0].id }),
            ]))
        })

        test('Register 2 residents into the same flat => upload receipts => both residents can see the receipts list', async () => {
            const residentClient1 = await makeClientWithResidentAccessAndProperty()
            const residentClient2 = await makeClientWithResidentAccessAndProperty()

            const [billingIntegration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, residentClient1.organization, billingIntegration, { status: CONTEXT_FINISHED_STATUS })
            const [acquiringIntegration] = await createTestAcquiringIntegration(admin)
            await createTestAcquiringIntegrationContext(admin, residentClient1.organization, acquiringIntegration, { status: CONTEXT_FINISHED_STATUS })

            const unitType1 = FLAT_UNIT_TYPE
            const unitName1 = faker.lorem.word()

            // 1/3 register residents
            await registerResidentByTestClient(
                residentClient1,
                {
                    address: residentClient1.property.address,
                    addressMeta: residentClient1.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            await registerResidentByTestClient(
                residentClient2,
                {
                    address: residentClient1.property.address,
                    addressMeta: residentClient1.property.addressMeta,
                    unitType: unitType1,
                    unitName: unitName1,
                })

            // 2/3 upload receipts
            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: residentClient1.property.address,
                        unitType: unitType1,
                        unitName: unitName1,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }
            const [registeredReceipts] = await registerBillingReceiptsByTestClient(admin, payload)

            // 3/3 check that residents can see the receipts list
            await waitFor(async () => {
                const receipts1 = await ResidentBillingReceipt.getAll(residentClient1, {})
                const receipts2 = await ResidentBillingReceipt.getAll(residentClient2, {})

                expect(receipts1).toHaveLength(1)
                expect(registeredReceipts).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts1[0].id }),
                ]))

                expect(receipts2).toHaveLength(1)
                expect(registeredReceipts).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipts2[0].id }),
                ]))
            })
        })
    })
})
