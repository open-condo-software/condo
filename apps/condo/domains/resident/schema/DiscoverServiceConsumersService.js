/**
 * Generated by `createservice resident.DiscoverServiceConsumersService --type mutations`
 */
const dayjs = require('dayjs')
const { filter, flatMap, map, omit, pick, uniq } = require('lodash')

const { featureToggleManager } = require('@open-condo/featureflags/featureToggleManager')
const { getLogger } = require('@open-condo/keystone/logging')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const { BILLING_ACCOUNT_OWNER_TYPE_COMPANY } = require('@condo/domains/billing/constants/constants')
const { BillingAccount, BillingReceipt } = require('@condo/domains/billing/utils/serverSchema')
const { DISABLE_DISCOVER_SERVICE_CONSUMERS } = require('@condo/domains/common/constants/featureflags')
const { loadListByChunks } = require('@condo/domains/common/utils/serverSchema')
const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const { Property } = require('@condo/domains/property/utils/serverSchema')
const access = require('@condo/domains/resident/access/DiscoverServiceConsumersService')
const { Resident, ServiceConsumer } = require('@condo/domains/resident/utils/serverSchema')


const MAX_RESIDENTS_COUNT_FOR_USER_PROPERTY = 6
const BILLING_ACCOUNT_FIELDS = 'id unitName unitType number '
    + 'context { id organization { id type } } property { id address addressKey }'
const logger = getLogger()

/**
 * @typedef {Object} BillingAccountData
 * @property {string} id
 * @property {string} organizationId
 * @property {string} organizationType
 * @property {string} address
 * @property {string} addressKey
 * @property {string} unitType
 * @property {string} unitName
 * @property {string} number
 * @property {string} billingContextId
 */

/**
 * @param {BillingAccount} billingAccount
 * @returns {BillingAccountData}
 */
function extractDataFromBillingAccount (billingAccount) {
    const id = billingAccount?.id
    const organizationId = billingAccount?.context?.organization?.id ?? null
    const organizationType = billingAccount?.context?.organization?.type ?? null
    const address = billingAccount?.property?.address ?? null
    const addressKey = billingAccount?.property?.addressKey ?? null
    const unitType = billingAccount?.unitType ?? null
    const unitName = billingAccount?.unitName ?? null
    const number = billingAccount?.number
    const billingContextId = billingAccount?.context?.id ?? null

    return {
        id,
        organizationId,
        organizationType,
        address,
        addressKey,
        unitType,
        unitName,
        number,
        billingContextId,
    }
}

const DiscoverServiceConsumersService = new GQLCustomSchema('DiscoverServiceConsumersService', {
    schemaDoc: 'Mutation to create Service Consumers for all residents for address, unitType, unitName, and BillingAccounts for said address' +
        'If a new Resident is created this mutation is called for specific Resident (optional field Resident is provided)' +
        'If a new BillingAccount is created this mutation is called for specific BillingAccount (optional field BillingAccount is provided)',

    types: [
        {
            access: true,
            type: 'input DiscoverServiceConsumersInputFilters { residentsIds: [ID!] }',
        },
        {
            access: true,
            type: 'input DiscoverServiceConsumersInput { dv: Int!, sender: SenderFieldInput!, billingAccountsIds: [ID!]!, filters: DiscoverServiceConsumersInputFilters }',
        },
        {
            access: true,
            type: 'type DiscoverServiceConsumersOutputStatistics { created: Int!, residentsFound: Int!, billingAccountsFound: Int! }',
        },
        {
            access: true,
            type: 'type DiscoverServiceConsumersOutput { status: String!, statistics: DiscoverServiceConsumersOutputStatistics! }',
        },
    ],

    mutations: [
        {
            access: access.canDiscoverServiceConsumers,
            schema: 'discoverServiceConsumers(data: DiscoverServiceConsumersInput!): DiscoverServiceConsumersOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { dv, sender, billingAccountsIds, filters } = data

                const discoveringSteps = [{ name: 'input', billingAccountsIds }]

                if (billingAccountsIds.length === 0) {
                    return {
                        status: 'skip',
                        statistics: {
                            created: 0,
                            residentsFound: 0,
                            billingAccountsFound: 0,
                        },
                    }
                }

                /**
                 * @type {BillingAccountData[]}
                 */
                let billingAccountItemsData = []
                await loadListByChunks({
                    context,
                    list: BillingAccount,
                    chunkSize: 50,
                    where: {
                        deletedAt: null,
                        context: { status: CONTEXT_FINISHED_STATUS, deletedAt: null },
                        id_in: billingAccountsIds,
                        isClosed: false,
                        ownerType_not: BILLING_ACCOUNT_OWNER_TYPE_COMPANY,
                    },
                    fields: BILLING_ACCOUNT_FIELDS,
                    chunkProcessor: async (/** @type {BillingAccount[]} */ chunk) => {
                        for (const billingAccount of chunk) {
                            const organizationId = billingAccount?.context?.organization?.id ?? null
                            const organizationType = billingAccount?.context?.organization?.type ?? null

                            const shouldDiscover = organizationType === SERVICE_PROVIDER_TYPE ? true : !await featureToggleManager.isFeatureEnabled(
                                context,
                                DISABLE_DISCOVER_SERVICE_CONSUMERS,
                                { organization: organizationId },
                            )

                            if (shouldDiscover) {
                                billingAccountItemsData.push(extractDataFromBillingAccount(billingAccount))
                            }
                        }

                        return []
                    },
                })

                // Filter by acquiring context
                // The organization must have the finished acquiring context
                /** @type {Object<string, string[]>} */
                let organizationsToAcquiringContextsMap = {}
                await loadListByChunks({
                    context,
                    list: AcquiringIntegrationContext,
                    chunkSize: 50,
                    where: {
                        deletedAt: null,
                        organization: { id_in: map(billingAccountItemsData, 'organizationId') },
                        status: CONTEXT_FINISHED_STATUS,
                    },
                    fields: 'id organization { id }',
                    chunkProcessor: (chunk) => {
                        chunk.forEach((row) => {
                            const organizationId = row?.organization?.id
                            const acquiringContextId = row?.id
                            organizationsToAcquiringContextsMap = {
                                ...organizationsToAcquiringContextsMap,
                                [organizationId]: [
                                    ...(organizationsToAcquiringContextsMap[organizationId] || []),
                                    acquiringContextId,
                                ],
                            }
                        })
                        return []
                    },
                })

                billingAccountItemsData = billingAccountItemsData.filter((item) => !!organizationsToAcquiringContextsMap[item.organizationId])

                // Filter by property
                // Make sure that organization has the property
                const organizationsIdsWithProperties = new Set()
                await loadListByChunks({
                    context,
                    list: Property,
                    chunkSize: 50,
                    where: {
                        deletedAt: null,
                        OR: billingAccountItemsData.map((item) => ({
                            AND: [
                                { deletedAt: null },
                                { organization: { id: item.organizationId } },
                                { OR: [{ address_i: item.address }, { addressKey: item.addressKey }] },
                            ],
                        })),
                    },
                    fields: 'organization { id } address',
                    chunkProcessor: (chunk) => {
                        chunk.forEach((row) => {
                            organizationsIdsWithProperties.add(`${row?.organization?.id}_${row?.address}`)
                        })
                        return []
                    },
                })

                billingAccountItemsData = billingAccountItemsData.filter((item) => organizationsIdsWithProperties.has(`${item.organizationId}_${item.address}`))

                discoveringSteps.push({
                    name: 'start filtration',
                    billingAccountItemsData: [...billingAccountItemsData],
                })

                // Before filtering duplicates we must load additional billing accounts that may not be included into arguments of this mutation
                // Filter duplicates (same address, unitType, and unitName) of each billing account

                /**
                     * @type {BillingAccountData[]}
                     * */
                const additionalBillingAccountsData = await loadListByChunks({
                    context,
                    list: BillingAccount,
                    where: {
                        id_not_in: map(billingAccountItemsData, 'id'),
                        OR: billingAccountItemsData.map((item) => ({
                            AND: [
                                { deletedAt: null },
                                { isClosed: false },
                                { ownerType_not: BILLING_ACCOUNT_OWNER_TYPE_COMPANY },
                                {
                                    OR: [
                                        {
                                            AND: [
                                                { property: { address: item.address } },
                                                { unitType: item.unitType },
                                                { unitName: item.unitName },
                                            ],
                                        },
                                        {
                                            AND: [
                                                { context: { organization: { id: item.organizationId } } },
                                                { number: item.number },
                                            ],
                                        },
                                    ],
                                },
                            ],
                        })),
                    },
                    chunkSize: 50,
                    fields: BILLING_ACCOUNT_FIELDS,
                    chunkProcessor: (chunk) => {
                        return chunk.map(extractDataFromBillingAccount)
                    },
                })

                discoveringSteps.push({ name: 'find additional accounts', additionalBillingAccountsData })

                billingAccountItemsData.push(...additionalBillingAccountsData)

                discoveringSteps.push({
                    name: 'mix input data with additional data',
                    billingAccountItemsData: [...billingAccountItemsData],
                })

                // Filter duplicates (same organization and number) of each billing account
                /** @type {Object<string, string[]>} */
                const billingAccountsCandidatesForDuplicatesByNumber = {}
                billingAccountItemsData.forEach((billingAccount) => {
                    const theKey = `${billingAccount.organizationId}_${billingAccount.number}`
                    const currentIds = billingAccountsCandidatesForDuplicatesByNumber[theKey] || []
                    billingAccountsCandidatesForDuplicatesByNumber[theKey] = uniq([...currentIds, billingAccount.id])
                })

                discoveringSteps.push({
                    name: 'find candidates for duplicates by number',
                    billingAccountsCandidatesForDuplicatesByNumber,
                })

                // There should be only one
                // Keep billing account which has the latest receipt
                const billingReceiptsIdsWithoutDuplicates = []
                for (const theKey in billingAccountsCandidatesForDuplicatesByNumber)
                {
                    const billingAccountsIds = billingAccountsCandidatesForDuplicatesByNumber[theKey]
                    if (billingAccountsIds.length === 1) {
                        billingReceiptsIdsWithoutDuplicates.push(billingAccountsIds[0])
                    } else {
                        const [lastReceipt] = await BillingReceipt.getAll(
                            context,
                            { account: { id_in: billingAccountsIds } },
                            'id account { id }',
                            {
                                sortBy: 'period_DESC',
                                first: 1,
                            }
                        )
                        if (lastReceipt) {
                            billingReceiptsIdsWithoutDuplicates.push(lastReceipt.account.id)
                        } else {
                            // It's impossible but must be logged :)
                            logger.warn({ msg: 'duplicated billing accounts without receipts', data: { billingAccountsIds } })
                        }
                    }
                }
                discoveringSteps.push({
                    name: 'detect billing accounts with latest receipt',
                    billingReceiptsIdsWithoutDuplicates,
                })
                billingAccountItemsData = billingAccountItemsData.filter(({ id }) => billingReceiptsIdsWithoutDuplicates.includes(id))

                discoveringSteps.push({
                    name: 'filter out duplicates by number',
                    billingAccountItemsData: [...billingAccountItemsData],
                })

                // Filter out billing accounts that have the same address, unitType, and unitName,
                // and one of two last receipts have the same category as the receipt for the 2nd account
                // with the same period

                // Check 2 last periods
                const period_in = []
                let now = dayjs()
                for (let i = 0; i < 2; i++) {
                    period_in.push(now.format('YYYY-MM-01'))
                    now = now.subtract(1, 'month')
                }
                /** @type {Object<string, Set<string>>} */
                const billingAccountsByAddressAndCategoryAndPeriod = {}
                const billingAccountsWithoutReceipts = new Set()
                for (const item of billingAccountItemsData) {
                    /** @type {BillingReceipt[]} */
                    const receipts = await BillingReceipt.getAll(context, {
                        period_in,
                        deletedAt: null,
                        context: {
                            deletedAt: null,
                            organization: { id: item.organizationId },
                        },
                        account: {
                            deletedAt: null,
                            OR: [
                                { property: { address: item.address } },
                                { property: { addressKey: item.addressKey } },
                            ],
                            unitType: item.unitType,
                            unitName: item.unitName,
                            number: item.number,
                        },
                    },
                    'id category { id }',
                    { sortBy: ['period_DESC'], first: 1 })

                    if (receipts.length === 0) {
                        // if no receipts found - not create service consumer
                        billingAccountsWithoutReceipts.add(item.id)
                    } else {
                        for (const receipt of receipts) {
                            const theKey = `${item.address}_${item.unitType}_${item.unitName}_${receipt.category.id}`
                            /** @type {Set<string>} */
                            const current = billingAccountsByAddressAndCategoryAndPeriod[theKey] || new Set()
                            current.add(item.id)
                            billingAccountsByAddressAndCategoryAndPeriod[theKey] = current
                        }
                    }
                }

                discoveringSteps.push({
                    name: 'group billing accounts by flat+category',
                    billingAccountsByAddressAndCategoryAndPeriod,
                })

                const billingAccountsIdsExcludedBySameCategory = Object.keys(billingAccountsByAddressAndCategoryAndPeriod).reduce((result, k) => {
                    const billingAccountsIds = billingAccountsByAddressAndCategoryAndPeriod[k]
                    if (billingAccountsIds.size >= 2) {
                        return [...result, ...Array.from(billingAccountsIds)]
                    }

                    return result
                }, [])

                billingAccountItemsData = billingAccountItemsData.filter(({ id }) => !billingAccountsIdsExcludedBySameCategory.includes(id))
                billingAccountItemsData = billingAccountItemsData.filter(({ id }) => !billingAccountsWithoutReceipts.has(id))

                discoveringSteps.push({
                    name: 'filter out duplicates by same address and category',
                    billingAccountsIdsExcludedBySameCategory,
                    billingAccountsWithoutReceipts,
                    billingAccountItemsData: [...billingAccountItemsData],
                })

                // filter out additionally added billing accounts
                const additionalBillingAccountIds = additionalBillingAccountsData.map(({ id }) => id)
                billingAccountItemsData = billingAccountItemsData.filter(({ id }) => !additionalBillingAccountIds.includes(id))

                discoveringSteps.push({
                    name: 'filter out additional accounts',
                    billingAccountItemsData: [...billingAccountItemsData],
                    additionalBillingAccountIds,
                })

                const residentsWhere = {
                    deletedAt: null,
                    OR: billingAccountItemsData.map(({ address, addressKey, unitType, unitName }) => ({
                        AND: [{ OR: [{ address_i: address }, { addressKey }] }, { unitType }, { unitName }],
                    })),
                }
                const residentsFilter = filters?.residentsIds
                if (residentsFilter) {
                    residentsWhere.id_in = residentsFilter
                }

                discoveringSteps.push({ name: 'searching residents', residentsWhere })

                let residentsCount = 0
                const combinations = []
                await loadListByChunks({
                    context,
                    list: Resident,
                    chunkSize: 50,
                    where: residentsWhere,
                    fields: 'id address addressKey unitType unitName property { id } user { id }',
                    chunkProcessor: (/** @type {Resident[]} */ chunk) => {
                        const chunkCombinations = flatMap(chunk, (resident) => billingAccountItemsData.map((billingAccountItemData) => {
                            if (
                                (
                                    resident.address === billingAccountItemData.address
                                    || (
                                        !!resident.addressKey
                                        && !!billingAccountItemData.addressKey
                                        && resident.addressKey === billingAccountItemData.addressKey
                                    )
                                )
                                && resident.unitType === billingAccountItemData.unitType
                                && resident.unitName === billingAccountItemData.unitName
                            ) {
                                return [resident, billingAccountItemData]
                            }
                        }))

                        combinations.push(...chunkCombinations)

                        residentsCount += chunk.length

                        return []
                    },
                })

                const definedCombinations = combinations.filter(Boolean)

                let serviceConsumersData = definedCombinations.map(([resident, account]) => {
                    const organizationId = account?.organizationId ?? null
                    const billingContextId = account?.billingContextId ?? null
                    const [acquiringContextId] = organizationsToAcquiringContextsMap[organizationId] ?? [null]

                    return {
                        dv,
                        sender,
                        resident: resident.id,
                        accountNumber: account.number,
                        organization: organizationId,
                        billingIntegrationContext: billingContextId || null,
                        acquiringIntegrationContext: acquiringContextId || null,
                        property: resident?.property?.id,
                        user: resident?.user?.id,
                    }
                })

                discoveringSteps.push({ name: 'build data for creating consumers', serviceConsumersData })

                // Find already created service consumers to prevent creating of duplicates
                const existingServiceConsumers = await ServiceConsumer.getAll(context, {
                    OR: serviceConsumersData.map((data) => ({
                        AND: [
                            { resident: { id: data.resident } },
                            { accountNumber: data.accountNumber },
                            { organization: { id: data.organization } },
                        ],
                    })),
                }, 'id resident { id } organization { id } accountNumber billingAccount')

                discoveringSteps.push({
                    name: 'search existing consumers',
                    existingServiceConsumers: map(existingServiceConsumers, (x) => pick(x, ['id', 'resident', 'organization', 'accountNumber', 'billingAccount'])),
                })

                // count residents per property for each user to prevent discover service consumers if there are more than MAX_CONSUMERS_COUNT_FOR_USER_PROPERTY residents at the property
                const residentsCountByUserAndProperty = {}
                await loadListByChunks({
                    context,
                    list: Resident,
                    chunkSize: 20,
                    where: { user: { id_in: map(serviceConsumersData, 'user') }, deletedAt: null },
                    fields: 'id user { id } property { id }',
                    chunkProcessor: (/** @type {Resident[]} */ chunk) => {
                        for (const resident of chunk) {
                            const userId = resident?.user?.id
                            const propertyId = resident?.property?.id
                            if (!!userId && !!propertyId) {
                                if (!residentsCountByUserAndProperty[userId]) {
                                    residentsCountByUserAndProperty[userId] = {}
                                }
                                const currentCount = residentsCountByUserAndProperty[userId][propertyId] || 0
                                residentsCountByUserAndProperty[userId][propertyId] = currentCount + 1
                            }
                        }
                        return []
                    },
                })

                serviceConsumersData = serviceConsumersData.filter(({
                    user,
                    property,
                }) => (residentsCountByUserAndProperty[user]?.[property] || 0) <= MAX_RESIDENTS_COUNT_FOR_USER_PROPERTY)

                discoveringSteps.push({
                    name: `filter out users with ${MAX_RESIDENTS_COUNT_FOR_USER_PROPERTY + 1}+ existing residents for property`,
                    residentsCountByUserAndProperty,
                })

                const createdServiceConsumers = await Promise.all(
                    serviceConsumersData.map((serviceConsumerData) => {
                        const [existingServiceConsumer] = filter(existingServiceConsumers, {
                            resident: { id: serviceConsumerData.resident },
                            accountNumber: serviceConsumerData.accountNumber,
                            organization: { id: serviceConsumerData.organization },
                        })

                        const data = {
                            ...pick(serviceConsumerData, [
                                'dv',
                                'sender',
                                'resident',
                                'accountNumber',
                                'organization',
                                'billingAccount',
                                'billingIntegrationContext',
                                'acquiringIntegrationContext',
                            ]),
                            resident: { connect: { id: serviceConsumerData.resident } },
                            organization: { connect: { id: serviceConsumerData.organization } },
                            billingIntegrationContext: serviceConsumerData.billingIntegrationContext ? { connect: { id: serviceConsumerData.billingIntegrationContext } } : null,
                            acquiringIntegrationContext: serviceConsumerData.acquiringIntegrationContext ? { connect: { id: serviceConsumerData.acquiringIntegrationContext } } : null,
                        }

                        if (existingServiceConsumer) {
                            return ServiceConsumer.update(context, existingServiceConsumer.id, {
                                // We don't update organization!
                                ...omit(data, 'organization'),
                                deletedAt: null,
                            })
                        }

                        return ServiceConsumer.create(context, { ...data, isDiscovered: true })
                    }),
                )

                discoveringSteps.push({
                    name: 'created service consumers',
                    createdServiceConsumers: map(createdServiceConsumers, (x) => pick(x, ['id', 'resident', 'organization', 'accountNumber', 'billingAccount'])),
                })

                const statistics = {
                    created: createdServiceConsumers.filter(Boolean).length,
                    residentsFound: residentsCount,
                    billingAccountsFound: billingAccountItemsData.length,
                }

                logger.info({
                    msg: 'DiscoverServiceConsumersService created ServiceConsumers',
                    data: {
                        billingAccountsIds,
                        statistics,
                        data: discoveringSteps,
                    },
                })

                return { status: 'success', statistics }
            },
        },
    ],
})

module.exports = {
    DiscoverServiceConsumersService,
}
