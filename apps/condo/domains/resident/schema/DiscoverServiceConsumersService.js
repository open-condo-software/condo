/**
 * Generated by `createservice resident.DiscoverServiceConsumersService --type mutations`
 */
const { get, flatMap } = require('lodash')

const { featureToggleManager } = require('@open-condo/featureflags/featureToggleManager')
const { getLogger } = require('@open-condo/keystone/logging')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const { BillingAccount } = require('@condo/domains/billing/utils/serverSchema')
const { ENABLE_DISCOVER_SERVICE_CONSUMERS } = require('@condo/domains/common/constants/featureflags')
const { Property } = require('@condo/domains/property/utils/serverSchema')
const access = require('@condo/domains/resident/access/DiscoverServiceConsumersService')
const { Resident, ServiceConsumer } = require('@condo/domains/resident/utils/serverSchema')

const logger = getLogger('DiscoverServiceConsumersMutation')

const asyncFilter = async (arr, predicate) => Promise.all(arr.map(predicate)).then((results) => arr.filter((_v, index) => results[index]))

const DiscoverServiceConsumersService = new GQLCustomSchema('DiscoverServiceConsumersService', {
    schemaDoc: 'Mutation to create Service Consumers for all residents for address, unitType, unitName, and BillingAccounts for said address' +
        'If a new Resident is created this mutation is called for specific Resident (optional field Resident is provided)' +
        'If a new BillingAccount is created this mutation is called for specific BillingAccount (optional field BillingAccount is provided)',

    types: [
        {
            access: true,
            type: 'input DiscoverServiceConsumersInput { dv: Int!, sender: SenderFieldInput!, address: String!, unitName: String!, unitType: String!, billingAccount: BillingAccountWhereUniqueInput, resident: ResidentWhereUniqueInput }',
        },
        {
            access: true,
            type: 'type DiscoverServiceConsumersOutputStatistics { created: Int!, residentsFound: Int!, billingAccountsFound: Int! }',
        },
        {
            access: true,
            type: 'type DiscoverServiceConsumersOutput { status: String!, statistics: DiscoverServiceConsumersOutputStatistics! }',
        },
    ],

    mutations: [
        {
            access: access.canDiscoverServiceConsumers,
            schema: 'discoverServiceConsumers(data: DiscoverServiceConsumersInput!): DiscoverServiceConsumersOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { address, unitName, unitType, billingAccount, resident, dv, sender } = data

                const reqId = get(context, ['req', 'id'])

                const billingAccounts = await BillingAccount.getAll(
                    context,
                    {
                        deletedAt: null,
                        context: { status: CONTEXT_FINISHED_STATUS, deletedAt: null },
                        ...billingAccount ? {
                            id: billingAccount.id,
                        } : {
                            property: { address, deletedAt: null }, unitName, unitType,
                        },
                    },
                )

                const residents = await Resident.getAll(
                    context,
                    { deletedAt: null, ...resident ? { id: resident.id } : { address, unitName, unitType } },
                )

                // Keep only residents of organizations the feature flag enabled for
                const residentsFilteredByFeatureFlag = await asyncFilter(
                    residents,
                    async (resident) => await featureToggleManager.isFeatureEnabled(
                        context,
                        ENABLE_DISCOVER_SERVICE_CONSUMERS,
                        { organization: resident.organization.id },
                    ),
                )

                // Keep only residents of organizations the acquiring context is existing for
                const residentsFilteredByOrganizationAcquiringContext = await asyncFilter(
                    residentsFilteredByFeatureFlag,
                    async (resident) => await AcquiringIntegrationContext.count(
                        context,
                        {
                            deletedAt: null,
                            organization: { id: get(resident, ['organization', 'id']) },
                            status: CONTEXT_FINISHED_STATUS,
                        }
                    ),
                )

                // Keep only residents the properties of which are exist in the organization
                const residentsFilteredByProperty = await asyncFilter(
                    residentsFilteredByOrganizationAcquiringContext,
                    async (resident) => {
                        return await Property.count(
                            context,
                            {
                                deletedAt: null,
                                organization: { id: get(resident, ['organization', 'id']) },
                                OR: [
                                    { addressKey: get(resident, ['property', 'addressKey']) },
                                    { address_i: get(resident, ['property', 'address']) },
                                ],
                            },
                        ) > 0
                    },
                )

                const combinations = flatMap(residentsFilteredByProperty, (resident) => billingAccounts.map((account) => [resident, account]))
                const createdServiceConsumers = await Promise.all(
                    combinations.map(([resident, account]) => ServiceConsumer.create(context, {
                        dv,
                        sender,
                        resident: { connect: { id: resident.id } },
                        organization: { connect: { id: get(resident, ['organization', 'id']) } },
                        accountNumber: account.number,
                        isDiscovered: true,
                    })),
                )

                const statistics = {
                    created: createdServiceConsumers.length,
                    residentsFound: residentsFilteredByProperty.length,
                    billingAccountsFound: billingAccounts.length,
                }

                logger.info({
                    msg: 'Created ServiceConsumers',
                    payload: { address, unitName, unitType, billingAccount, resident },
                    statistics,
                    reqId,
                })

                return { status: 'success', statistics }
            },
        },
    ],
})

module.exports = {
    DiscoverServiceConsumersService,
}
