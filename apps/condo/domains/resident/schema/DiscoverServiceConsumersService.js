/**
 * Generated by `createservice resident.DiscoverServiceConsumersService --type mutations`
 */
const { get, flatMap } = require('lodash')

const { featureToggleManager } = require('@open-condo/featureflags/featureToggleManager')
const { getLogger } = require('@open-condo/keystone/logging')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const { BillingAccount } = require('@condo/domains/billing/utils/serverSchema')
const { ENABLE_DISCOVER_SERVICE_CONSUMERS } = require('@condo/domains/common/constants/featureflags')
const { loadListByChunks } = require('@condo/domains/common/utils/serverSchema')
const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const { Property } = require('@condo/domains/property/utils/serverSchema')
const access = require('@condo/domains/resident/access/DiscoverServiceConsumersService')
const { Resident, ServiceConsumer } = require('@condo/domains/resident/utils/serverSchema')

const logger = getLogger('DiscoverServiceConsumersMutation')

const DiscoverServiceConsumersService = new GQLCustomSchema('DiscoverServiceConsumersService', {
    schemaDoc: 'Mutation to create Service Consumers for all residents for address, unitType, unitName, and BillingAccounts for said address' +
        'If a new Resident is created this mutation is called for specific Resident (optional field Resident is provided)' +
        'If a new BillingAccount is created this mutation is called for specific BillingAccount (optional field BillingAccount is provided)',

    types: [
        {
            access: true,
            type: 'input DiscoverServiceConsumersInputFilters { residentsIds: [ID!] }',
        },
        {
            access: true,
            type: 'input DiscoverServiceConsumersInput { dv: Int!, sender: SenderFieldInput!, billingAccountsIds: [ID!]!, filters: DiscoverServiceConsumersInputFilters }',
        },
        {
            access: true,
            type: 'type DiscoverServiceConsumersOutputStatistics { created: Int!, residentsFound: Int!, billingAccountsFound: Int! }',
        },
        {
            access: true,
            type: 'type DiscoverServiceConsumersOutput { status: String!, statistics: DiscoverServiceConsumersOutputStatistics! }',
        },
    ],

    mutations: [
        {
            access: access.canDiscoverServiceConsumers,
            schema: 'discoverServiceConsumers(data: DiscoverServiceConsumersInput!): DiscoverServiceConsumersOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { dv, sender, billingAccountsIds, filters } = data

                const reqId = get(context, ['req', 'id'])

                const billingAccounts = await BillingAccount.getAll(
                    context,
                    {
                        deletedAt: null,
                        context: { status: CONTEXT_FINISHED_STATUS, deletedAt: null },
                        id_in: billingAccountsIds,
                    },
                )

                let items = []
                for (const billingAccount of billingAccounts) {
                    const organizationId = get(billingAccount, ['context', 'organization', 'id'], null)
                    const organizationType = get(billingAccount, ['context', 'organization', 'type'], null)
                    const address = get(billingAccount, ['property', 'address'], null)
                    const addressKey = get(billingAccount, ['property', 'addressKey'], null)
                    const unitType = get(billingAccount, 'unitType', null)
                    const unitName = get(billingAccount, 'unitName', null)

                    const shouldDiscover = organizationType === SERVICE_PROVIDER_TYPE ? true : await featureToggleManager.isFeatureEnabled(
                        context,
                        ENABLE_DISCOVER_SERVICE_CONSUMERS,
                        { organization: organizationId },
                    )

                    if (shouldDiscover) {
                        items.push({ organizationId, address, addressKey, unitType, unitName })
                    }
                }

                // Filter by acquiring context
                const organizationsIdsWithAcquiringContext = new Set()
                await loadListByChunks({
                    context,
                    list: AcquiringIntegrationContext,
                    chunkSize: 50,
                    where: {
                        deletedAt: null,
                        organization: { id_in: items.map(({ organizationId }) => organizationId) },
                        status: CONTEXT_FINISHED_STATUS,
                    },
                    chunkProcessor: (chunk) => {
                        chunk.forEach((row) => {
                            organizationsIdsWithAcquiringContext.add(get(row, ['organization', 'id']))
                        })
                        return []
                    },
                })

                items = items.filter((item) => organizationsIdsWithAcquiringContext.has(item.organizationId))

                // Filter by property
                const organizationsIdsWithProperties = new Set()
                await loadListByChunks({
                    context,
                    list: Property,
                    chunkSize: 50,
                    where: {
                        deletedAt: null,
                        OR: items.map((item) => ({
                            AND: [
                                { organization: { id: item.organizationId } },
                                { OR: [{ address_i: item.address }, { addressKey: item.addressKey }] },
                            ],
                        })),
                    },
                    chunkProcessor: (chunk) => {
                        chunk.forEach((row) => {
                            organizationsIdsWithProperties.add(`${get(row, ['organization', 'id'])}_${get(row, 'address')}`)
                        })
                        return []
                    },
                })

                items = items.filter((item) => organizationsIdsWithProperties.has(`${item.organizationId}_${item.address}`))

                const residentsWhere = {
                    deletedAt: null,
                    OR: items.map(({ address, addressKey, unitType, unitName }) => ({
                        AND: [{ OR: [{ address_i: address }, { addressKey }] }, { unitType }, { unitName }],
                    })),
                }
                const residentsFilter = get(filters, 'residentsIds')
                if (residentsFilter) {
                    residentsWhere.id_in = residentsFilter
                }
                const residents = await Resident.getAll(context, residentsWhere)

                const combinations = flatMap(residents, (resident) => billingAccounts.map((account) => {
                    if (
                        (
                            resident.address === account.property.address
                            || resident.addressKey === account.property.addressKey
                        )
                        && resident.unitType === account.unitType
                        && resident.unitName === account.unitName
                    ) {
                        return [resident, account]
                    }
                }))
                const definedCombinations = combinations.filter(Boolean)
                const createdServiceConsumers = await Promise.all(
                    definedCombinations.map(([resident, account]) => ServiceConsumer.create(context, {
                        dv,
                        sender,
                        resident: { connect: { id: resident.id } },
                        organization: { connect: { id: get(account, ['context', 'organization', 'id'], null) } },
                        billingIntegrationContext: { connect: { id: get(account, ['context', 'id'], null) } },
                        accountNumber: account.number,
                        isDiscovered: true,

                        // fill the deprecated field for backward compatibility
                        // See apps/condo/domains/billing/schema/AllResidentBillingReceiptsService.js:74)
                        billingAccount: { connect: { id: account.id } },
                    })),
                )

                const statistics = {
                    created: createdServiceConsumers.length,
                    residentsFound: residents.length,
                    billingAccountsFound: billingAccounts.length,
                }

                logger.info({
                    msg: 'Created ServiceConsumers',
                    payload: { billingAccountsIds },
                    statistics,
                    reqId,
                })

                return { status: 'success', statistics }
            },
        },
    ],
})

module.exports = {
    DiscoverServiceConsumersService,
}
