/**
 * Generated by `createservice resident.RegisterServiceConsumerService --type mutations`
 */

const { get, omit } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { getById, GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const {
    BillingIntegrationOrganizationContext,
    BillingAccount,
} = require('@condo/domains/billing/utils/serverSchema')
const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const { Meter } = require('@condo/domains/meter/utils/serverSchema')
const { HOLDING_TYPE } = require('@condo/domains/organization/constants/common')
const { Organization } = require('@condo/domains/organization/utils/serverSchema')
const { Property } = require('@condo/domains/property/utils/serverSchema')
const access = require('@condo/domains/resident/access/RegisterServiceConsumerService')
const { ServiceConsumer, Resident } = require('@condo/domains/resident/utils/serverSchema')

const ERRORS = {
    RESIDENT_NOT_FOUND: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'residentId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find Resident for current user',
    },
    ORGANIZATION_NOT_FOUND: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'organizationId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find Organization for current user',
    },
    BILLING_ACCOUNT_NOT_FOUND: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'accountNumber'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Can\'t find billingAccount and any meters with this accountNumber, unitName and organization combination',
    },
    ACCOUNT_NUMBER_IS_NOT_SPECIFIED: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'accountNumber'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Argument "accountNumber" is null or empty',
    },
}

const RegisterServiceConsumerService = new GQLCustomSchema('RegisterServiceConsumerService', {
    types: [
        {
            access: true,
            // TODO(pahaz): DOMA-4138 remove this legacy!
            type: 'input RegisterServiceConsumerInputExtra { paymentCategory: String }',
        },
        {
            access: true,
            // TODO(pahaz): DOMA-4150 remove residentId and organizationId and migrate to ResidentWhereUniqueInput and OrganizationWhereUniqueInput
            type: 'input RegisterServiceConsumerInput { dv: Int!, sender: SenderFieldInput!, residentId: ID!, accountNumber: String!, organizationId: ID!, extra: RegisterServiceConsumerInputExtra }',
        },
        {
            access: true,
            type: 'input RegisterResidentServiceConsumersInput { dv: Int!, sender: SenderFieldInput!, resident: ResidentWhereUniqueInput!, accountNumber: String!, paymentCategory: String }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterServiceConsumer,
            schema: 'registerResidentServiceConsumers(data: RegisterResidentServiceConsumersInput!): [ServiceConsumer!]',
            resolver: async (_, args, context) => {
                const { data: { dv, sender, resident: { id }, accountNumber, paymentCategory } } = args

                if (!accountNumber || accountNumber.length === 0) throw new GQLError(ERRORS.ACCOUNT_NUMBER_IS_NOT_SPECIFIED, context)

                const resident = await Resident.getOne(context, { id })
                if (!resident) throw new GQLError(ERRORS.RESIDENT_NOT_FOUND, context)

                const residentProperties = await Property.getAll(context, {
                    addressKey: resident.addressKey, deletedAt: null,
                })

                let organizations = await Organization.getAll(context, {
                    id_in: residentProperties.map(property => property.organization.id), deletedAt: null,
                    type_not: HOLDING_TYPE,
                })
                if (!organizations.length) throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)

                const residentOrganizationIds = organizations.map(organization => organization.id)

                const billingIntegrationContexts = await BillingIntegrationOrganizationContext.getAll(context, {
                    organization: { id_in: residentOrganizationIds },
                    deletedAt: null,
                })

                const serviceConsumers = []

                if (billingIntegrationContexts.length > 0) {
                    const acquiringIntegrationContexts = await AcquiringIntegrationContext.getAll(context, {
                        organization: { id_in: residentOrganizationIds },
                        deletedAt: null,
                        status: CONTEXT_FINISHED_STATUS,
                    })
                    const billingAccounts = await BillingAccount.getAll(context, {
                        context: { id_in: billingIntegrationContexts.map(context => context.id) },
                        deletedAt: null,
                        number_i: accountNumber,
                    })

                    for (const billingAccount of billingAccounts) {
                        const [existingServiceConsumer] = await ServiceConsumer.getAll(context, {
                            resident: { id },
                            accountNumber,
                            organization: { id: billingAccount.context.organization.id },
                        })

                        if (existingServiceConsumer) {
                            await ServiceConsumer.update(context, existingServiceConsumer.id, {
                                deletedAt: null, dv, sender,
                            })
                            serviceConsumers.push(existingServiceConsumer.id)
                        } else {
                            const acquiringIntegrationContext = acquiringIntegrationContexts
                                .find(context => context.organization.id === billingAccount.context.organization.id)
                            const serviceConsumer = await ServiceConsumer.create(context, {
                                dv, sender, accountNumber,
                                resident: { connect: { id } },
                                organization: { connect: { id: billingAccount.context.organization.id } },
                                paymentCategory: paymentCategory ? paymentCategory : null,
                                billingAccount: { connect: { id: billingAccount.id } },
                                billingIntegrationContext: { connect: { id: billingAccount.context.id } },
                                acquiringIntegrationContext: acquiringIntegrationContext ? { connect: { id: acquiringIntegrationContext.id } } : null,
                            })

                            serviceConsumers.push(serviceConsumer.id)
                        }
                        organizations = organizations
                            .filter(organization => organization.id !== billingAccount.context.organization.id)
                    }
                }

                for (const organization of organizations) {
                    const meters = await Meter.getAll(context, {
                        accountNumber, organization: { id: organization.id }, deletedAt: null,
                    })

                    if (meters.length > 0) {
                        const [existingServiceConsumer] = await ServiceConsumer.getAll(context, {
                            resident: { id },
                            accountNumber,
                            organization: { id: organization.id },
                        })

                        if (existingServiceConsumer) {
                            await ServiceConsumer.update(context, existingServiceConsumer.id, {
                                deletedAt: null, dv, sender,
                            })
                            serviceConsumers.push(existingServiceConsumer.id)
                        } else {
                            const serviceConsumer = await ServiceConsumer.create(context, {
                                dv, sender, accountNumber,
                                organization: { connect: { id: organization.id } },
                                resident: { connect: { id } },
                                paymentCategory: paymentCategory ? paymentCategory : null,
                            })
                            serviceConsumers.push(serviceConsumer.id)
                        }
                    }
                }

                if (serviceConsumers.length === 0) throw new GQLError(ERRORS.BILLING_ACCOUNT_NOT_FOUND, context)

                return await find('ServiceConsumer', { id_in: serviceConsumers })
            },
        },
        {
            doc: {
                summary: 'Creates service consumer with default data, and automatically populates the optional data fields, such as `billingAccount',
                description: 'To be successfully created accountNumber and unitName should at least have billingAccount with same data or Meter with same data',
                errors: ERRORS,
            },
            access: access.canRegisterServiceConsumer,
            schema: 'registerServiceConsumer(data: RegisterServiceConsumerInput!): ServiceConsumer',
            resolver: async (parent, args, context = {}) => {
                const { data: { dv, sender, residentId, accountNumber, organizationId, extra } } = args

                if (!accountNumber || accountNumber.length === 0) { throw new GQLError(ERRORS.ACCOUNT_NUMBER_IS_NOT_SPECIFIED, context) }

                const [ resident ] = await Resident.getAll(context, { id: residentId })
                if (!resident) {
                    throw new GQLError(ERRORS.RESIDENT_NOT_FOUND, context)
                }

                const [ organization ] = await Organization.getAll(context, { id: organizationId })
                if (!organization) {
                    throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)
                }

                const paymentCategory = get(extra, 'paymentCategory', null)

                const attrs = {
                    dv,
                    sender,
                    resident: { connect: { id: residentId } },
                    accountNumber: accountNumber,
                    organization: { connect: { id: organization.id } },
                    paymentCategory: paymentCategory,
                }

                const [ billingIntegrationContext ] = await BillingIntegrationOrganizationContext.getAll(context, { organization: { id: organization.id, deletedAt: null }, deletedAt: null })
                if (billingIntegrationContext) {
                    const [acquiringIntegrationContext] = await AcquiringIntegrationContext.getAll(context, { organization: { id: organization.id, deletedAt: null }, deletedAt: null })
                    const [billingAccount] = await BillingAccount.getAll(context,
                        {
                            context: { id: billingIntegrationContext.id },
                            number_i: accountNumber,
                        }
                    )
                    // This is deprecated. These fields are not going to be set in future releases!
                    attrs.billingAccount = billingAccount ? { connect: { id: billingAccount.id } } : null
                    attrs.billingIntegrationContext = billingAccount ? { connect: { id: billingIntegrationContext.id } } : null
                    attrs.acquiringIntegrationContext = billingAccount && acquiringIntegrationContext ? { connect: { id: acquiringIntegrationContext.id } } : null
                }
                if (!attrs.billingAccount) {
                    const meters = await Meter.getAll(context, { accountNumber: accountNumber, organization: { id: organizationId, deletedAt: null }, deletedAt: null })
                    if (meters.length < 1) {
                        throw new GQLError(ERRORS.BILLING_ACCOUNT_NOT_FOUND, context)
                    }
                }

                const [existingServiceConsumer] = await ServiceConsumer.getAll(context, {
                    resident: { id: residentId },
                    accountNumber: accountNumber,
                    organization: { id: organizationId },
                })

                let id
                if (existingServiceConsumer) {
                    await ServiceConsumer.update(context, existingServiceConsumer.id, {
                        // We don't update organization!
                        ...omit(attrs, 'organization'),
                        deletedAt: null,
                    })
                    id = existingServiceConsumer.id
                } else {
                    const serviceConsumer = await ServiceConsumer.create(context, attrs)
                    id = serviceConsumer.id
                }

                // Hack that helps to resolve all subfields in result of this mutation
                return await getById('ServiceConsumer', id)
            },
        },
    ],
})

module.exports = {
    RegisterServiceConsumerService,
}
