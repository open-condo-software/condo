/**
 * Generated by `createservice resident.RegisterServiceConsumerService --type mutations`
 */

const { get, omit, uniq } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { getById, GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const {
    BillingIntegrationOrganizationContext,
    BillingAccount,
} = require('@condo/domains/billing/utils/serverSchema')
const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const { Meter } = require('@condo/domains/meter/utils/serverSchema')
const { HOLDING_TYPE } = require('@condo/domains/organization/constants/common')
const { Organization } = require('@condo/domains/organization/utils/serverSchema')
const { Property } = require('@condo/domains/property/utils/serverSchema')
const access = require('@condo/domains/resident/access/RegisterServiceConsumerService')
const { ServiceConsumer, Resident } = require('@condo/domains/resident/utils/serverSchema')

const ERRORS = {
    RESIDENT_NOT_FOUND: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'residentId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find Resident for current user',
    },
    ORGANIZATION_NOT_FOUND: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'organizationId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find Organization for current user',
    },
    RESIDENT_ORGANIZATION_NOT_FOUND: {
        mutation: 'registerResidentServiceConsumers',
        variable: ['data', 'resident', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find Organization for current resident',
    },
    BILLING_ACCOUNT_OR_METER_NOT_FOUND: {
        mutation: 'registerResidentServiceConsumers',
        variable: ['data', 'accountNumber'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Can\'t find billingAccount and any meters with this accountNumber, unitName and address',
    },
    BILLING_ACCOUNT_NOT_FOUND: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'accountNumber'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Can\'t find billingAccount and any meters with this accountNumber, unitName and organization combination',
    },
    ACCOUNT_NUMBER_IS_NOT_SPECIFIED: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'accountNumber'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Argument "accountNumber" is null or empty',
    },
}

const RegisterServiceConsumerService = new GQLCustomSchema('RegisterServiceConsumerService', {
    types: [
        {
            access: true,
            // TODO(pahaz): DOMA-4138 remove this legacy!
            type: 'input RegisterServiceConsumerInputExtra { paymentCategory: String }',
        },
        {
            access: true,
            // TODO(pahaz): DOMA-4150 remove residentId and organizationId and migrate to ResidentWhereUniqueInput and OrganizationWhereUniqueInput
            type: 'input RegisterServiceConsumerInput { dv: Int!, sender: SenderFieldInput!, residentId: ID!, accountNumber: String!, organizationId: ID!, extra: RegisterServiceConsumerInputExtra }',
        },
        {
            access: true,
            type: 'input RegisterResidentServiceConsumersInput { dv: Int!, sender: SenderFieldInput!, resident: ResidentWhereUniqueInput!, accountNumber: String!, paymentCategory: String }',
        },
    ],

    mutations: [
        {
            doc: {
                summary: 'Creates service consumers with default data, and automatically populates the optional data fields, such as `billingAccount',
                description: 'Search for accountNumbers across all organizations matching resident address and provided accountNumber. May return more than one ServiceConsumer in case of some organizations at resident address had same accountNumber. To be successfully created accountNumber and unitName should at least have billingAccount with same data or Meter with same data',
                errors: ERRORS,
            },
            access: access.canRegisterServiceConsumer,
            schema: 'registerResidentServiceConsumers(data: RegisterResidentServiceConsumersInput!): [ServiceConsumer!]',
            resolver: async (_, args, context) => {
                // TODO(DOMA-4138): remove paymentCategory usages
                const { data: { dv, sender, resident: { id }, accountNumber, paymentCategory } } = args

                if (!accountNumber || accountNumber.length === 0) throw new GQLError(ERRORS.ACCOUNT_NUMBER_IS_NOT_SPECIFIED, context)

                const resident = await Resident.getOne(context, { id, deletedAt: null })
                if (!resident) throw new GQLError(ERRORS.RESIDENT_NOT_FOUND, context)

                const propertyWhere = resident.addressKey
                    ? { addressKey: resident.addressKey }
                    : { address_i: resident.address }

                const residentProperties = await Property.getAll(context, propertyWhere)

                let organizations = await Organization.getAll(context, {
                    id_in: uniq(residentProperties.map(property => property.organization.id)), deletedAt: null,
                    type_not: HOLDING_TYPE,
                })
                if (!organizations.length) throw new GQLError(ERRORS.RESIDENT_ORGANIZATION_NOT_FOUND, context)

                const residentOrganizationIds = uniq(organizations.map(organization => organization.id))

                const billingIntegrationContexts = await BillingIntegrationOrganizationContext.getAll(context, {
                    organization: { id_in: residentOrganizationIds },
                    deletedAt: null,
                    status: CONTEXT_FINISHED_STATUS,
                })

                const serviceConsumers = []

                if (billingIntegrationContexts.length > 0) {
                    const acquiringIntegrationContexts = await AcquiringIntegrationContext.getAll(context, {
                        organization: { id_in: residentOrganizationIds },
                        deletedAt: null,
                        status: CONTEXT_FINISHED_STATUS,
                    })
                    const billingAccounts = await BillingAccount.getAll(context, {
                        context: { id_in: billingIntegrationContexts.map(context => context.id) },
                        deletedAt: null,
                        number_i: accountNumber,
                    })

                    for (const billingAccount of billingAccounts) {
                        const [existingServiceConsumer] = await ServiceConsumer.getAll(context, {
                            resident: { id },
                            accountNumber,
                            organization: { id: billingAccount.context.organization.id },
                        })

                        if (existingServiceConsumer) {
                            await ServiceConsumer.update(context, existingServiceConsumer.id, {
                                deletedAt: null, dv, sender,
                            })
                            serviceConsumers.push(existingServiceConsumer.id)
                        } else {
                            const acquiringIntegrationContext = acquiringIntegrationContexts
                                .find(context => context.organization.id === billingAccount.context.organization.id)
                            const serviceConsumer = await ServiceConsumer.create(context, {
                                dv, sender, accountNumber,
                                resident: { connect: { id } },
                                organization: { connect: { id: billingAccount.context.organization.id } },
                                paymentCategory: paymentCategory ? paymentCategory : null,
                                billingIntegrationContext: { connect: { id: billingAccount.context.id } },
                                acquiringIntegrationContext: acquiringIntegrationContext ? { connect: { id: acquiringIntegrationContext.id } } : null,
                            })

                            serviceConsumers.push(serviceConsumer.id)
                        }
                        organizations = organizations
                            .filter(organization => organization.id !== billingAccount.context.organization.id)
                    }
                }

                for (const organization of organizations) {
                    const meters = await Meter.getAll(context, {
                        accountNumber, organization: { id: organization.id }, deletedAt: null,
                    })

                    if (meters.length > 0) {
                        const [existingServiceConsumer] = await ServiceConsumer.getAll(context, {
                            resident: { id },
                            accountNumber,
                            organization: { id: organization.id },
                        })

                        if (existingServiceConsumer) {
                            await ServiceConsumer.update(context, existingServiceConsumer.id, {
                                deletedAt: null, dv, sender,
                            })
                            serviceConsumers.push(existingServiceConsumer.id)
                        } else {
                            const serviceConsumer = await ServiceConsumer.create(context, {
                                dv, sender, accountNumber,
                                organization: { connect: { id: organization.id } },
                                resident: { connect: { id } },
                                paymentCategory: paymentCategory ? paymentCategory : null,
                            })
                            serviceConsumers.push(serviceConsumer.id)
                        }
                    }
                }

                if (serviceConsumers.length === 0) throw new GQLError(ERRORS.BILLING_ACCOUNT_OR_METER_NOT_FOUND, context)

                return await find('ServiceConsumer', { id_in: serviceConsumers })
            },
        },
        {
            doc: {
                summary: '[DEPRECATED] Creates service consumer with default data, and automatically populates the optional data fields, such as `billingAccount',
                description: 'To be successfully created accountNumber and unitName should at least have billingAccount with same data or Meter with same data',
                errors: ERRORS,
            },
            access: access.canRegisterServiceConsumer,
            schema: 'registerServiceConsumer(data: RegisterServiceConsumerInput!): ServiceConsumer',
            resolver: async (parent, args, context = {}) => {
                const { data: { dv, sender, residentId, accountNumber, organizationId, extra } } = args

                if (!accountNumber || accountNumber.length === 0) { throw new GQLError(ERRORS.ACCOUNT_NUMBER_IS_NOT_SPECIFIED, context) }

                const [ resident ] = await Resident.getAll(context, { id: residentId })
                if (!resident) {
                    throw new GQLError(ERRORS.RESIDENT_NOT_FOUND, context)
                }

                const [ organization ] = await Organization.getAll(context, { id: organizationId })
                if (!organization) {
                    throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)
                }

                const paymentCategory = get(extra, 'paymentCategory', null)

                let isBillingAccountFound = false

                const attrs = {
                    dv,
                    sender,
                    resident: { connect: { id: residentId } },
                    accountNumber: accountNumber,
                    organization: { connect: { id: organization.id } },
                    paymentCategory: paymentCategory,
                }

                const [ billingIntegrationContext ] = await BillingIntegrationOrganizationContext.getAll(context, { status: CONTEXT_FINISHED_STATUS, organization: { id: organization.id, deletedAt: null }, deletedAt: null })
                if (billingIntegrationContext) {
                    const [acquiringIntegrationContext] = await AcquiringIntegrationContext.getAll(context, { status: CONTEXT_FINISHED_STATUS, organization: { id: organization.id, deletedAt: null }, deletedAt: null })
                    const [billingAccount] = await BillingAccount.getAll(context,
                        {
                            context: { id: billingIntegrationContext.id },
                            number_i: accountNumber,
                        }
                    )
                    if (billingAccount) {
                        isBillingAccountFound = true
                    }
                    // This is deprecated. These fields are not going to be set in future releases!
                    attrs.billingIntegrationContext = billingAccount ? { connect: { id: billingIntegrationContext.id } } : null
                    attrs.acquiringIntegrationContext = billingAccount && acquiringIntegrationContext ? { connect: { id: acquiringIntegrationContext.id } } : null
                }
                if (!isBillingAccountFound) {
                    const meters = await Meter.getAll(context, { accountNumber: accountNumber, organization: { id: organizationId, deletedAt: null }, deletedAt: null })
                    if (meters.length < 1) {
                        throw new GQLError(ERRORS.BILLING_ACCOUNT_NOT_FOUND, context)
                    }
                }

                const [existingServiceConsumer] = await ServiceConsumer.getAll(context, {
                    resident: { id: residentId },
                    accountNumber: accountNumber,
                    organization: { id: organizationId },
                })

                let id
                if (existingServiceConsumer) {
                    await ServiceConsumer.update(context, existingServiceConsumer.id, {
                        // We don't update organization!
                        ...omit(attrs, 'organization'),
                        deletedAt: null,
                    })
                    id = existingServiceConsumer.id
                } else {
                    const serviceConsumer = await ServiceConsumer.create(context, attrs)
                    id = serviceConsumer.id
                }

                // Hack that helps to resolve all subfields in result of this mutation
                return await getById('ServiceConsumer', id)
            },
        },
    ],
})

module.exports = {
    RegisterServiceConsumerService,
}
