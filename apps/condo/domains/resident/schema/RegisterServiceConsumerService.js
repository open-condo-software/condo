/**
 * Generated by `createservice resident.RegisterServiceConsumerService --type mutations`
 */

const { uniq, isEmpty } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { getById, GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const { CONTEXT_FINISHED_STATUS: ACQUIRING_CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const { CONTEXT_FINISHED_STATUS: BILLING_CONTEXT_FINISHED_STATUS } = require('@condo/domains/billing/constants/constants')
const {
    BillingIntegrationOrganizationContext,
    BillingAccount,
} = require('@condo/domains/billing/utils/serverSchema')
const { checkAccountNumberWithOnlineInteractionUrl } = require('@condo/domains/billing/utils/serverSchema/checkAccountNumberWithOnlineInteractionUrl')
const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const { Meter } = require('@condo/domains/meter/utils/serverSchema')
const { HOLDING_TYPE } = require('@condo/domains/organization/constants/common')
const { Organization } = require('@condo/domains/organization/utils/serverSchema')
const { Property } = require('@condo/domains/property/utils/serverSchema')
const access = require('@condo/domains/resident/access/RegisterServiceConsumerService')
const { resetUserResidentCache } = require('@condo/domains/resident/utils/accessSchema')
const { ServiceConsumer, Resident } = require('@condo/domains/resident/utils/serverSchema')


const ERRORS = {
    RESIDENT_NOT_FOUND: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'residentId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find Resident for current user',
    },
    ORGANIZATION_NOT_FOUND: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'organizationId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find Organization for current user',
    },
    RESIDENT_ORGANIZATION_NOT_FOUND: {
        mutation: 'registerResidentServiceConsumers',
        variable: ['data', 'resident', 'id'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Cannot find Organization for current resident',
    },
    BILLING_ACCOUNT_OR_METER_NOT_FOUND: {
        mutation: 'registerResidentServiceConsumers',
        variable: ['data', 'accountNumber'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Can\'t find billingAccount and any meters with this accountNumber, unitName and address',
        messageForUser: 'api.resident.registerServiceConsumers.BILLING_ACCOUNT_OR_METER_NOT_FOUND',
    },
    BILLING_ACCOUNT_NOT_FOUND: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'accountNumber'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Can\'t find billingAccount and any meters with this accountNumber, unitName and organization combination',
        messageForUser: 'api.resident.registerServiceConsumers.BILLING_ACCOUNT_NOT_FOUND',
    },
    ACCOUNT_NUMBER_IS_NOT_SPECIFIED: {
        mutation: 'registerServiceConsumer',
        variable: ['data', 'accountNumber'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Argument "accountNumber" is null or empty',
    },
}

const RegisterServiceConsumerService = new GQLCustomSchema('RegisterServiceConsumerService', {
    types: [
        {
            access: true,
            // TODO(pahaz): DOMA-4138 remove this legacy!
            type: 'input RegisterServiceConsumerInputExtra { paymentCategory: String }',
        },
        {
            access: true,
            // TODO(pahaz): DOMA-4150 remove residentId and organizationId and migrate to ResidentWhereUniqueInput and OrganizationWhereUniqueInput
            type: 'input RegisterServiceConsumerInput { dv: Int!, sender: SenderFieldInput!, residentId: ID!, accountNumber: String!, organizationId: ID!, extra: RegisterServiceConsumerInputExtra }',
        },
        {
            access: true,
            type: 'input RegisterResidentServiceConsumersInput { dv: Int!, sender: SenderFieldInput!, resident: ResidentWhereUniqueInput!, accountNumber: String!, paymentCategory: String }',
        },
    ],

    mutations: [
        {
            doc: {
                summary: 'Creates service consumers with default data, and automatically populates the optional data fields, such as `billingAccount',
                description: 'Search for accountNumbers across all organizations matching resident address and provided accountNumber. May return more than one ServiceConsumer in case of some organizations at resident address had same accountNumber. To be successfully created accountNumber and unitName should at least have billingAccount with same data or Meter with same data',
                errors: ERRORS,
            },
            access: access.canRegisterServiceConsumer,
            schema: 'registerResidentServiceConsumers(data: RegisterResidentServiceConsumersInput!): [ServiceConsumer!]',
            resolver: async (_, args, context) => {
                // TODO(DOMA-4138): remove paymentCategory usages
                const { data: { dv, sender, resident: { id }, accountNumber, paymentCategory } } = args

                if (!accountNumber || accountNumber.length === 0) throw new GQLError(ERRORS.ACCOUNT_NUMBER_IS_NOT_SPECIFIED, context)

                const resident = await Resident.getOne(context, { id, deletedAt: null }, 'id user { id } address addressKey')
                if (!resident) throw new GQLError(ERRORS.RESIDENT_NOT_FOUND, context)
                await resetUserResidentCache(resident.user.id)

                const propertyWhere = resident.addressKey
                    ? { addressKey: resident.addressKey }
                    : { address_i: resident.address }

                const residentProperties = await Property.getAll(context, propertyWhere, 'id organization { id }')

                let organizations = await Organization.getAll(context, {
                    id_in: uniq(residentProperties.map(property => property.organization.id)), deletedAt: null,
                    type_not: HOLDING_TYPE,
                })
                if (!organizations.length) throw new GQLError(ERRORS.RESIDENT_ORGANIZATION_NOT_FOUND, context)

                const residentOrganizationIds = uniq(organizations.map(organization => organization.id))

                const billingIntegrationContexts = await BillingIntegrationOrganizationContext.getAll(context, {
                    organization: { id_in: residentOrganizationIds },
                    deletedAt: null,
                    status: BILLING_CONTEXT_FINISHED_STATUS,
                })

                const serviceConsumers = []

                if (billingIntegrationContexts.length > 0) {
                    const acquiringIntegrationContexts = await AcquiringIntegrationContext.getAll(context, {
                        organization: { id_in: residentOrganizationIds },
                        deletedAt: null,
                        status: ACQUIRING_CONTEXT_FINISHED_STATUS,
                    }, 'id organization { id }')
                    const billingAccounts = await BillingAccount.getAll(context, {
                        context: { id_in: billingIntegrationContexts.map(context => context.id) },
                        deletedAt: null,
                        number_i: accountNumber,
                    }, 'id context { id organization { id } }')

                    for (const billingAccount of billingAccounts) {
                        const [existingServiceConsumer] = await ServiceConsumer.getAll(context, {
                            resident: { id },
                            accountNumber,
                            organization: { id: billingAccount.context.organization.id },
                        })

                        if (existingServiceConsumer) {
                            await ServiceConsumer.update(context, existingServiceConsumer.id, {
                                deletedAt: null, dv, sender,
                            })
                            serviceConsumers.push(existingServiceConsumer.id)
                        } else {
                            const acquiringIntegrationContext = acquiringIntegrationContexts
                                .find(context => context.organization.id === billingAccount.context.organization.id)
                            const serviceConsumer = await ServiceConsumer.create(context, {
                                dv, sender, accountNumber,
                                resident: { connect: { id } },
                                organization: { connect: { id: billingAccount.context.organization.id } },
                                paymentCategory: paymentCategory ? paymentCategory : null,
                                billingIntegrationContext: { connect: { id: billingAccount.context.id } },
                                acquiringIntegrationContext: acquiringIntegrationContext ? { connect: { id: acquiringIntegrationContext.id } } : null,
                            })

                            serviceConsumers.push(serviceConsumer.id)
                        }
                        organizations = organizations
                            .filter(organization => organization.id !== billingAccount.context.organization.id)
                    }
                }

                for (const organization of organizations) {
                    const meters = await Meter.getAll(context, {
                        accountNumber, organization: { id: organization.id }, deletedAt: null,
                    })

                    if (meters.length > 0) {
                        const [existingServiceConsumer] = await ServiceConsumer.getAll(context, {
                            resident: { id },
                            accountNumber,
                            organization: { id: organization.id },
                        })

                        if (existingServiceConsumer) {
                            await ServiceConsumer.update(context, existingServiceConsumer.id, {
                                deletedAt: null, dv, sender,
                            })
                            serviceConsumers.push(existingServiceConsumer.id)
                        } else {
                            const serviceConsumer = await ServiceConsumer.create(context, {
                                dv, sender, accountNumber,
                                organization: { connect: { id: organization.id } },
                                resident: { connect: { id } },
                                paymentCategory: paymentCategory ? paymentCategory : null,
                            })
                            serviceConsumers.push(serviceConsumer.id)
                        }
                    }
                }

                if (serviceConsumers.length === 0) throw new GQLError(ERRORS.BILLING_ACCOUNT_OR_METER_NOT_FOUND, context)

                return await find('ServiceConsumer', { id_in: serviceConsumers })
            },
        },
        {
            doc: {
                summary: 'Creates service consumer with default data, and automatically populates the optional data fields, such as `billingAccount',
                description: 'To be successfully created accountNumber and unitName should at least have billingAccount with same data or Meter with same data',
                errors: ERRORS,
            },
            access: access.canRegisterServiceConsumer,
            schema: 'registerServiceConsumer(data: RegisterServiceConsumerInput!): ServiceConsumer',
            resolver: async (parent, args, context = {}) => {
                const { data: { dv, sender, residentId, accountNumber: accountNumberUserInput, organizationId } } = args
                const accountNumber = (accountNumberUserInput || '').trim()
                if (!accountNumber || accountNumber.length === 0) {
                    throw new GQLError(ERRORS.ACCOUNT_NUMBER_IS_NOT_SPECIFIED, context)
                }
                const [resident] = await find('Resident', { id: residentId, deletedAt: null })
                if (!resident) {
                    throw new GQLError(ERRORS.RESIDENT_NOT_FOUND, context)
                }
                await resetUserResidentCache(resident.user)
                const organization = await getById('Organization', organizationId)
                if (!organization || organization.deletedAt) {
                    throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)
                }
                const billingContexts = await find('BillingIntegrationOrganizationContext', {
                    status: BILLING_CONTEXT_FINISHED_STATUS,
                    organization: { id: organization.id },
                    integration: { deletedAt: null },
                    deletedAt: null,
                })
                let isBillingAccountFound = false
                let isMetersFound = false
                if (billingContexts.length) {
                    const billingContextIds = billingContexts.map(({ id }) => id)
                    const [billingAccount] = await find('BillingAccount', {
                        context: { id_in: billingContextIds },
                        number_i: accountNumber,
                        deletedAt: null,
                    })
                    if (billingAccount) {
                        isBillingAccountFound = true
                    } else {
                        const billingIntegrationIds = new Set(billingContexts.map(({ integration }) => integration))
                        const billingIntegrations = await find('BillingIntegration', {
                            id_in: [...billingIntegrationIds],
                            checkAccountNumberUrl_not: null,
                        })
                        if (billingIntegrations.length) {
                            try {
                                await Promise.any(
                                    billingIntegrations.map(async ({ checkAccountNumberUrl }) => {
                                        const result = await checkAccountNumberWithOnlineInteractionUrl(
                                            checkAccountNumberUrl,
                                            organization.tin,
                                            accountNumber
                                        )
                                        return result ? true : Promise.reject()
                                    })
                                )
                                isBillingAccountFound = true
                            } catch {
                                isBillingAccountFound = false
                            }
                        }
                    }
                }
                const [acquiringContext] = await find('AcquiringIntegrationContext', {
                    status: ACQUIRING_CONTEXT_FINISHED_STATUS,
                    organization: {
                        id: organization.id,
                    },
                    integration: {
                        deletedAt: null,
                    },
                    deletedAt: null,
                })
                if (!isBillingAccountFound) {
                    const meters = await find('Meter', {
                        accountNumber_i: accountNumber,
                        organization: {
                            id: organizationId,
                            deletedAt: null,
                        },
                        deletedAt: null,
                    })
                    if (meters.length) {
                        isMetersFound = true
                    }
                }
                if (!isBillingAccountFound && !isMetersFound) {
                    throw new GQLError(ERRORS.BILLING_ACCOUNT_NOT_FOUND, context)
                }
                const [existingServiceConsumer] = await find('ServiceConsumer', {
                    resident: { id: residentId },
                    accountNumber_i: accountNumber,
                    organization: { id: organizationId },
                    deletedAt: null,
                })
                let serviceConsumerId = existingServiceConsumer ? existingServiceConsumer.id : null
                if (existingServiceConsumer) {
                    serviceConsumerId = existingServiceConsumer.id
                    const updateInput = {}
                    if (acquiringContext && existingServiceConsumer.acquiringIntegrationContext !== acquiringContext.id) {
                        updateInput.acquiringIntegrationContext = { connect: { id: acquiringContext.id } }
                    }
                    if (!isEmpty(updateInput)) {
                        await ServiceConsumer.update(context, existingServiceConsumer.id, { dv, sender, ...updateInput })
                    }
                } else {
                    const deprecatedFields = {
                        ...acquiringContext ? { acquiringIntegrationContext: { connect: { id: acquiringContext.id } } } : {},
                    }
                    const consumer = await ServiceConsumer.create(context, {
                        dv,
                        sender,
                        resident: { connect: { id: residentId } },
                        accountNumber: accountNumber,
                        organization: { connect: { id: organization.id } },
                        ...deprecatedFields,
                    })
                    serviceConsumerId = consumer.id
                }
                // Hack that helps to resolve all subfields in result of this mutation
                return await getById('ServiceConsumer', serviceConsumerId)
            },
        },
    ],
})

module.exports = {
    RegisterServiceConsumerService,
    ERRORS,
}
