/**
 * Generated by `createservice resident.FindOrganizationsByAddressService --type queries`
 */
const { GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const access = require('@condo/domains/resident/access/FindOrganizationsByAddressService')
const {
    MAX_RESIDENT_FIND_ORGANIZATIONS_BY_WINDOW_SEC,
    RESIDENT_FIND_ORGANIZATIONS_WINDOW_SEC,
} = require('@condo/domains/resident/constants/constants')
const {
    getOrganizationIdsWithAcquiring,
    getOrganizationIdsWithMeters,
    findOrganizationByAddressKeyTinAccountNumber,
    findOrganizationByAddressKeyUnitNameUnitType,
    findOrganizationByAddressKey,
} = require('@condo/domains/resident/utils/serverSchema/findOrganizationsByAddress')
const { RESIDENT } = require('@condo/domains/user/constants/common')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')

const redisGuard = new RedisGuard()

const checkLimits = async (uniqueField, context) => {
    await redisGuard.checkCustomLimitCounters(
        `find-organizations-by-address-${uniqueField}`,
        RESIDENT_FIND_ORGANIZATIONS_WINDOW_SEC,
        MAX_RESIDENT_FIND_ORGANIZATIONS_BY_WINDOW_SEC,
        context,
    )
}

const FindOrganizationsByAddressService = new GQLCustomSchema('FindOrganizationsByAddressService', {
    types: [
        {
            access: true,
            type: 'input FindOrganizationsByAddressInput { addressKey: String!, unitName: String, unitType: String, tin: String, accountNumber: String }',
        },
        {
            access: true,
            type: 'type FindOrganizationByAddressReceiptType { accountNumber: String, category: ID!, balance: String, routingNumber: String, bankAccount: String, address: String }',
        },
        {
            access: true,
            type: 'type FindOrganizationByAddressMeterType { resource: ID!, number: String, accountNumber: String, address: String }',
        },
        {
            access: true,
            type: 'type FindOrganizationByAddressOutput { id: ID!, name: String!, tin: String!, type:OrganizationTypeType!, receipts: [FindOrganizationByAddressReceiptType]!, meters: [FindOrganizationByAddressMeterType]! }',
        },
    ],
    queries: [
        {
            access: access.canFindOrganizationsByAddress,
            schema: 'findOrganizationsByAddress (data: FindOrganizationsByAddressInput!): [FindOrganizationByAddressOutput]',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { addressKey, unitName, unitType, tin, accountNumber } = data

                if (context.authedItem.type === RESIDENT) {
                    await checkLimits(context.authedItem.id, context)
                }

                const properties = await find('Property', {
                    organization: {
                        ...(tin ? { tin } : { tin_not: null }),
                        deletedAt: null, 
                    },
                    addressKey,
                    deletedAt: null,
                })

                if (!properties.length && !tin && !accountNumber) return []

                let organizations = await find('Organization', {
                    id_in: [...new Set(properties.map(({ organization }) => organization))],
                    deletedAt: null,
                })

                if (tin && accountNumber) {
                    // NOTE(YEgorLu): Service providers might not have properties in system. But we should be able to
                    //                see them by tin and account number
                    let serviceProviders = await find('Organization', {
                        tin,
                        type: SERVICE_PROVIDER_TYPE,
                        deletedAt: null,
                    })
                    const uniqueIds = new Set(organizations.map(({ id }) => id))
                    serviceProviders = serviceProviders.filter(provider => !uniqueIds.has(provider.id))
                    organizations = organizations.concat(serviceProviders)
                }

                if (!organizations.length) return []

                const [withAcquiring, withMeters] = await Promise.all([
                    getOrganizationIdsWithAcquiring(organizations),
                    getOrganizationIdsWithMeters(organizations, addressKey),
                ])

                organizations = organizations.filter(({ id }) => withAcquiring.has(id) || withMeters.has(id))

                if (!organizations.length) return []

                /*
                    TODO: (DOMA-11059) Optimize by eliminating subqueries. All data will be retrieved as a flat array and then processed.
                    Here, we should have all the necessary data.
                 */

                const fetchOrganizationData = async (organization) => {
                    if (tin && accountNumber) {
                        const org = await findOrganizationByAddressKeyTinAccountNumber(organization, data, properties)

                        return org.meters.length || org.receipts.length ? org : null
                    } else if (unitName && unitType) {
                        return findOrganizationByAddressKeyUnitNameUnitType(organization, data, context, properties)
                    } else {
                        return findOrganizationByAddressKey(organization, data)
                    }
                }

                const result = await Promise.all(organizations.map(fetchOrganizationData))

                return result.filter(Boolean)
            },
        },
    ],
})

module.exports = {
    FindOrganizationsByAddressService,
}
