/**
 * Generated by `createschema ticket.Ticket organization:Text; statusReopenedCounter:Integer; statusReason?:Text; status:Relationship:TicketStatus:PROTECT; number?:Integer; client?:Relationship:User:SET_NULL; clientName:Text; clientEmail:Text; clientPhone:Text; operator:Relationship:User:SET_NULL; assignee?:Relationship:User:SET_NULL; details:Text; meta?:Json;`
 */
const { Text, Relationship, Integer, DateTimeUtc, Checkbox, Select } = require('@keystonejs/fields')
const dayjs = require('dayjs')
const { isEmpty, get, isNull, compact, isArray, isString, uniq } = require('lodash')

const conf = require('@open-condo/config')
const { canOnlyServerSideWithoutUserRequest } = require('@open-condo/keystone/access')
const { readOnlyFieldAccess, writeOnlyServerSideFieldAccess } = require('@open-condo/keystone/access')
const { GQLErrorCode: { BAD_USER_INPUT }, GQLError } = require('@open-condo/keystone/errors')
const { Json, AutoIncrementInteger } = require('@open-condo/keystone/fields')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getByCondition, getById, find } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')
const { i18n } = require('@open-condo/locales/loader')
const { webHooked } = require('@open-condo/webhooks/plugins')

const {
    PROPERTY_REQUIRED_ERROR,
    JSON_EXPECT_OBJECT_ERROR,
    JSON_UNKNOWN_VERSION_ERROR,
    WRONG_VALUE,
} = require('@condo/domains/common/constants/errors')
const {
    CLIENT_PHONE_LANDLINE_FIELD,
    CLIENT_EMAIL_FIELD,
    CLIENT_NAME_FIELD,
    CONTACT_FIELD,
    CLIENT_FIELD,
    ADDRESS_META_FIELD,
    UNIT_TYPE_FIELD,
} = require('@condo/domains/common/schema/fields')
const { md5 } = require('@condo/domains/common/utils/crypto')
const { buildSetOfFieldsToTrackFrom, storeChangesIfUpdated } = require('@condo/domains/common/utils/serverSchema/changeTrackable')
const { getUnitTypeFieldResolveInput, getSectionTypeFieldResolveInput } = require('@condo/domains/common/utils/serverSchema/resolveHelpers')
const { normalizeText } = require('@condo/domains/common/utils/text')
const { hasDbFields } = require('@condo/domains/common/utils/validation.utils')
const { Contact } = require('@condo/domains/contact/utils/serverSchema')
const { INVOICE_STATUS_CANCELED, INVOICE_STATUS_PAID, INVOICE_STATUS_PUBLISHED, INVOICE_STATUS_DRAFT } = require('@condo/domains/marketplace/constants')
const { Invoice } = require('@condo/domains/marketplace/utils/serverSchema')
const { ORGANIZATION_OWNED_FIELD } = require('@condo/domains/organization/schema/fields')
const { SECTION_TYPES } = require('@condo/domains/property/constants/common')
const access = require('@condo/domains/ticket/access/Ticket')
const {
    OMIT_TICKET_CHANGE_TRACKABLE_FIELDS, REVIEW_VALUES, DEFERRED_STATUS_TYPE,
} = require('@condo/domains/ticket/constants')
const { FEEDBACK_VALUES, FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY } = require('@condo/domains/ticket/constants/feedback')
const { QUALITY_CONTROL_VALUES } = require('@condo/domains/ticket/constants/qualityControl')
const { STATUS_IDS } = require('@condo/domains/ticket/constants/statusTransitions')
const { QUALITY_CONTROL_ADDITIONAL_OPTIONS_FIELD } = require('@condo/domains/ticket/schema/fields/QualityControlAdditionalOptions')
const { FEEDBACK_ADDITIONAL_OPTIONS_FIELD } = require('@condo/domains/ticket/schema/fields/TicketFeedbackAdditionalOptions')
const { sendTicketChangedNotifications } = require('@condo/domains/ticket/tasks')
const {
    calculateTicketOrder, calculateReopenedCounter,
    setSectionAndFloorFieldsByDataFromPropertyMap, setClientNamePhoneEmailFieldsByDataFromUser,
    overrideTicketFieldsForResidentUserType, setClientIfContactPhoneAndTicketAddressMatchesResidentFields, connectContactToTicket,
    calculateCompletedAt,
    calculateStatusUpdatedAt,
    calculateDeferredUntil,
    setDeadline, updateStatusAfterResidentFeedback,
    classifyTicket,
    calculateIsCompletedAfterDeadline,
} = require('@condo/domains/ticket/utils/serverSchema/resolveHelpers')
const {
    createTicketChange,
    ticketChangeDisplayNameResolversForSingleRelations,
    relatedManyToManyResolvers,
} = require('@condo/domains/ticket/utils/serverSchema/TicketChange')
const { RESIDENT } = require('@condo/domains/user/constants/common')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')


const usersWithoutTicketLimits = Object.keys(conf.USERS_WITHOUT_TICKET_LIMITS ? JSON.parse(conf.USERS_WITHOUT_TICKET_LIMITS) : {})

const redisGuard = new RedisGuard()

const DAILY_TICKET_LIMIT = parseInt(conf.DAILY_TICKET_LIMIT) || 10
const DAILY_SAME_TICKET_LIMIT = parseInt(conf.DAILY_SAME_TICKET_LIMIT) || 2

// NOTE: The mobile app may send a deleted classifier due to out of sync with the server.
// If this happens, then the mobile application will attack the server with endless requests to create/update ticket with the old classifier.
// And the server will return an error due to the fact that the specified classifier does not exist.
// In order to prevent this from happening, we override the old classifiers on the server with new ones and send correct ticket in response
// This only works if you pass "delete=true" in url! (ex. "https://path/to/api?delete=true")
const OVERRIDED_CLASSIFIERS = {
    '46294639-9247-49cc-9431-e86376c3bd34': '26c16d55-ea34-4e30-aa14-322a49cb40a5',
    '9ff5652a-ba9d-42fe-856b-f8764cff299d': '0343901e-bb55-411d-8bf2-62f5849d900d',
    'eb76f50b-3f7d-462c-86c2-fd3cece53f9b': '042fb4a6-22eb-4694-8d96-4bfb84f7316c',
    'e74a843e-2049-4f28-9733-aaf0febf46ae': 'fc23f952-6a56-4919-a996-4051e560a71d',
    '4d765237-f5a5-426d-8aed-af137739e710': '21b71c2a-bcab-4046-af75-1992d76089fc',
    'a648960f-d48b-451d-81d3-a52046e2a960': '21b71c2a-bcab-4046-af75-1992d76089fc',
    'aa5d4a39-1cdd-477a-b718-04bd5c39fc14': 'a4adef0a-c4c6-406b-b558-d29c72f49511',
    '8bb4453a-4a12-49d3-94cc-f40d1569a2c8': '49df645c-6168-4f8b-98b0-29de8d9b5473',
    '3d2d9e2f-56d1-4520-8186-22faaecc728b': '3f4959b1-95be-46c1-8bde-80935c852ac7',
    '61739781-2202-4c42-b2af-80cf2539bc43': '2ef8d34c-69cb-4da7-b836-92b8cae2afef',
    'd119c4f6-511f-46b6-bd79-d0233f1179ce': 'a6dd42f0-3107-4109-88c8-cab07c6eadb4',
    '39d1a542-66e1-491d-a7e4-129bb0f478f7': '547caf5e-fa95-459f-a1ba-2213693017d0',
    'b3141d81-f5f3-43c2-ba89-8e38d6a2d510': '535cf2ea-2527-4b07-8a3c-0b5c7eb30853',
    'f69b2093-adc0-452d-a8d1-74505107b644': '1ac446d9-ea6e-4dbc-b82c-f36f118430fa',
    'Ccaba951-790f-48a2-af90-9f74a6403dec': '38310aae-d736-41a5-808c-413c6b7a117b',
    '43ba62b3-9173-49d5-9f50-cd45d81d154c': '38310aae-d736-41a5-808c-413c6b7a117b',
    '8ffcac7a-93bc-433d-9076-cacf481ea4f9': '41df7175-c3cc-4715-962b-49d07fb0e03c',
    '3922d1a5-b9db-429e-ad9a-c7594cb4f03c': '24f5e6d9-1b6d-4d4d-b782-0442edf3deb4',
    '345e14c9-d23d-4421-bba7-5fd8f7685e06': '4c9c9e4a-b349-4a39-94b7-1b26aa7b2153',
    'cd33d788-205a-4909-b107-b56dfa8a9e75': 'f75b8051-ecd6-47bc-8067-9cc4000b04d9',
    'dbecbe32-5f72-4f5f-a9aa-f40bc689dfda': '62be8ac8-6f85-4096-b5d2-997ba8792828',
    'a0f0ccac-d8f1-492e-9a40-3e0fb875aeb8': '0d322303-9eb9-4d43-ab20-a566c1e502e5',
    'E52937b0-c380-4b1a-abeb-d7adc18d788c': '410d2443-e088-4912-9a29-059732bd7e2d',
    'bf4693ca-cd50-4f6d-8aaf-0f36f86f137b': 'be85fbbb-465f-4f42-9dc0-750d58d7cd58',
    '3ae41e91-702b-4e09-8fdd-eb3ef29acfb7': '1ccbf170-521b-4ab0-9d24-9e7f996556fd',
    'Eb6fc32e-15b2-4719-8f53-001cc8a23d4c': 'f567e509-bf2a-4c92-9256-2f6797b6cf23',
    '63cada2b-c370-4c48-ac0a-30ac2ba7b39f': '9a34f595-057a-456e-b4bb-811b3dbbd669',
    'e955fbf9-20ab-4884-9af6-4ecec9819ef0': 'ca9343c4-f52c-43e2-9751-0d65323a69da',
    '54093d20-e9b0-4a5b-b9c8-2c47dfd7c3dd': '95700163-7859-408e-a106-75e50e738d39',
    '01901147-8fe0-4a7e-8237-9a3d18fc94fc': 'a2c7014b-a3b1-4571-8e0a-3a2d0900798f',
    'dac5c4a0-452f-409a-8260-a845ce1aaad4': '99a42209-7679-4272-9d7c-4f31c815e31f',
    '0ac04c15-9ec0-4403-b62c-03760726bf67': 'b13078e9-fdbc-45b6-8703-5d1596db0491',
    '47f85878-2550-4b5e-8a6b-c792cd1eec0f': '40194647-2394-4352-89b7-d2286a9b601a',
    '6fc897d4-e912-4ffa-ade8-651483cc5ec1': '32c4e147-7a35-458a-85a2-b28689b5addc',
    '45f8f996-ddd5-463e-bd0f-df0265568120': 'bc9bbe71-54e9-4767-b8f4-e8a379b770f6',
    'a944bd82-890d-4d75-856e-f9f4848b2d3f': '94cbacec-e214-4b94-88ce-5f8948cc1b82',
    '66568026-3169-4ba0-bd2c-baa5adcf10ce': 'c39a294b-583e-42d8-bab1-902533bced73',
    'b8ee3c90-1d33-4abf-8f59-f7b2959684d6': 'b937de0d-4495-401c-90a4-03f4416b5a1d',
    'bbe28de9-7251-4026-863b-d844aaaba9a0': '0ebcbe4c-e324-4e67-940b-7860e0a8744b',
    'dd1aa20b-15c1-44d2-973e-e6c88d5f94c8': '5e17c1fa-7306-4b64-a6e6-704f95cc8c65',
    'e599ee70-c299-4a5f-a236-1bc923f6af56': 'ce3d0899-686e-4191-90b2-ee2cdee4632f',
    '237e855d-bf0d-4284-b125-a186e0734016': '378fa2fa-7184-41e3-a317-e3a700dfc2de',
    'df14c9e9-3b2f-4379-839c-4289009e6dbf': '638ee590-9981-4f9a-abaf-9d79049ea19e',
    '6e675c2a-6e27-4163-b175-f8ab4ed84cfb': '002a382d-1a14-48d7-bf48-3cc3c78c1ddc',
    'f239ac75-00f7-4301-9e5d-fc040844d0bf': '9133e2e3-b236-4b10-994c-f29700a25045',
    'f9347fb5-14ae-4a89-97ca-0380af06bc11': 'e457a983-a024-4bdc-9256-f756131555b0',
    '186c243a-05e4-429c-b60d-d4f4fdc2ba2e': 'a03f41ae-fdd0-4df9-949b-3996d5ab05da',
    '6e250076-dafa-4575-96bc-464b8301978f': 'fe0f543d-8e93-4f7d-8076-e077ee6150bc',
    '5aa6ae1a-ac38-40d6-8e60-bafeba3ce880': '924bff38-123e-48f7-a8dc-ba874be02df0',
    'fc9b4288-a71d-4fa4-accf-a289e388d124': 'd83ccb81-72f0-4d8a-beef-7a751eccd518',
    '8fb33454-c271-46d5-8332-57977ea45e5e': '47469c77-4e26-4d71-bb5e-c0447f7d0406',
    'cfd61c63-244b-400b-ae5b-e1bc64173cdb': 'e24d136e-2fcc-4852-b6f5-e21e60a5ad44',
    '81d8cfda-aeda-4654-a700-b96705c7ff25': '0343901e-bb55-411d-8bf2-62f5849d900d',
    'd4b76717-70c1-41e4-9ec5-2da5821d6850': 'fc23f952-6a56-4919-a996-4051e560a71d',
    '78307064-c6d1-47ff-ab87-fa97442fb4c5': '21b71c2a-bcab-4046-af75-1992d76089fc',
    '62aceb01-4bdd-4743-bec0-91bc25319718': 'a4adef0a-c4c6-406b-b558-d29c72f49511',
    '93377e53-c4ec-4ba1-bb80-59d9725c782a': '49df645c-6168-4f8b-98b0-29de8d9b5473',
    '2bfb784a-48c1-4f2f-bb91-17eba775656e': '3f4959b1-95be-46c1-8bde-80935c852ac7',
    'd1352467-cd59-4488-a711-b9c920ee5324': '2ef8d34c-69cb-4da7-b836-92b8cae2afef',
    '0cebea6d-deab-4fcd-b0c2-09294fdb9f43': 'a6dd42f0-3107-4109-88c8-cab07c6eadb4',
    '9d46dc5a-ffb6-4864-bb93-c204d88af53b': '547caf5e-fa95-459f-a1ba-2213693017d0',
    '9e43a3a8-ce83-4ec9-bb0f-51f53bb6adb6': 'f75b8051-ecd6-47bc-8067-9cc4000b04d9',
    '942fe980-5153-4fa0-9e52-6731467428bf': '1ac446d9-ea6e-4dbc-b82c-f36f118430fa',
    '5afe6c4b-6c45-4452-b0f2-1883f696c2c7': '5e5c3858-c7a8-49d4-9a53-8bde7f37e315',
    '2db263bc-b5a2-4517-959a-3d51ee512a71': '5e5c3858-c7a8-49d4-9a53-8bde7f37e315',
}
const overrideOldClassifier = (resolvedData) => {
    const classifierId = get(resolvedData, 'classifier')
    if (classifierId && classifierId in OVERRIDED_CLASSIFIERS) {
        resolvedData.classifier = OVERRIDED_CLASSIFIERS[classifierId]
    }
}

const ERRORS = {
    FEEDBACK_VALUE_MUST_BE_SPECIFIED: {
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: '"feedbackValue" must be specified if there is "feedbackAdditionalOptions" or "feedbackComment"',
        messageForUser: 'api.ticket.FEEDBACK_VALUE_MUST_BE_SPECIFIED',
    },
    QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED: {
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: '"qualityControlValue" must be specified if there is "qualityControlAdditionalOptions" or "qualityControlComment"',
        messageForUser: 'api.ticket.QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED',
    },
    TICKET_FOR_PHONE_DAY_LIMIT_REACHED: {
        code: 'BAD_USER_INPUT',
        type: 'TICKET_FOR_PHONE_DAY_LIMIT_REACHED',
        message: 'Please try again tomorrow. You can not create more tickets!',
        messageForUser: 'api.ticket.TICKET_FOR_PHONE_DAY_LIMIT_REACHED',
        messageInterpolation: { ticketLimit: DAILY_TICKET_LIMIT },
    },
    SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED: {
        code: 'BAD_USER_INPUT',
        type: 'SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED',
        message: 'You already sent this ticket! You can not create more tickets!',
        messageForUser: 'api.ticket.SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED',
    },
}

/**
 * Checks limits on ticket creation.
 * User should not be able to create more than $DAILY_TICKET_LIMIT tickets to 1 organization.
 * User should not be able to create more than $DAILY_SAME_TICKET_LIMIT tickets to 1 organization.
 *
 * $USERS_WITHOUT_TICKET_LIMITS phones are excluded from this rule.
 *
 * @param {string} phone
 * @param {string} organizationId
 * @param {string} details
 * @param context
 * @param {boolean} isInvoiceTicket
 * @returns {Promise<void>}
 */
const checkDailyTicketLimit = async ({ userId, organizationId, details, context, isInvoiceTicket, isPayable }) => {
    if (usersWithoutTicketLimits.includes(userId)) {
        return
    }

    if (!userId) {
        throw new Error('No user id in Ticket.checkDailyTicketLimit')
    }

    if (!organizationId) {
        throw new Error('No organization id in Ticket.checkDailyTicketLimit')
    }

    if (!details) {
        throw new Error('No details in Ticket.checkDailyTicketLimit')
    }

    const byIdAndOrgKey = `dailyTicketLimit:id:${userId}:organization:${organizationId}`
    const byIdOrgAndDetailsKey = `${byIdAndOrgKey}:details:${md5(details)}`

    const byIdOrgAndDetailsCounter = isInvoiceTicket && isPayable ? 0 : await redisGuard.incrementDayCounter(byIdOrgAndDetailsKey)
    if (byIdOrgAndDetailsCounter > DAILY_SAME_TICKET_LIMIT) {
        throw new GQLError(ERRORS.SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED, context)
    }

    const byIdAndOrgCounter = await redisGuard.incrementDayCounter(byIdAndOrgKey)
    if (byIdAndOrgCounter > DAILY_TICKET_LIMIT) {
        throw new GQLError(ERRORS.TICKET_FOR_PHONE_DAY_LIMIT_REACHED, context)
    }
}
/*
* TODO(DOMA-5833): This is a temporary hardcode.
*  Should delete "convertReviewCommentOptionToFeedbackAdditionalOptionKey"
*  and "convertFeedbackAdditionalOptionKeyToReviewCommentOption"
*  functions when the mobile app will use 'feedback*' fields
*/
const convertReviewCommentOptionToFeedbackAdditionalOptionKey = (option) => {
    if (option === 'Сделали на совесть' || option === 'Made in good faith') return FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.HIGH_QUALITY
    if (option === 'Быстро сделали' || option === 'Quickly done') return FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.QUICKLY
    if (option === 'It was done poorly' || option === 'Сделали некачественно') return FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.LOW_QUALITY
    if (option === 'It took a long time' || option === 'Долго делали') return FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.SLOWLY
    return null
}
const convertFeedbackAdditionalOptionKeyToReviewCommentOption = (option) => {
    if (option === FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.HIGH_QUALITY) return 'Сделали на совесть'
    if (option === FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.QUICKLY) return 'Быстро сделали'
    if (option === FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.LOW_QUALITY) return 'Сделали некачественно'
    if (option === FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.SLOWLY) return 'Долго делали'
    return null
}


const Ticket = new GQLListSchema('Ticket', {
    schemaDoc: 'Users request or contact with the user. ' +
        'It has fields `clientName`, `clientPhone`, `clientEmail`, which stores contact information at the moment of creating or updating. ' +
        'Values of these fields are independent from related entities, like Contact, Resident etc. ' +
        'If by some reason related entities will be deleted, unavailable or will change its contact information, these fields will stay unchanged.' +
        'So, by creating a new ticket with connection to some contact entity (Contact, Resident), these fields will be populated by its contact information if other values are not explicitly provided.',
    fields: {
        // TODO(pahaz): no needed to check organization access!
        organization: ORGANIZATION_OWNED_FIELD,

        // statusDeadline
        // statusDeferredDate
        // statusDeferredBy
        // TODO(pahaz): server side autogen
        statusReopenedCounter: {
            schemaDoc: 'Counter showing the number of changes `status` to `new_or_reopened`',
            type: Integer,
            isRequired: true,
            defaultValue: 0,
            access: readOnlyFieldAccess,
        },

        // TODO(DOMA-5833): delete 'reviewValue' and 'reviewComment' when the mobile app will use 'feedback*' fields
        reviewValue: {
            schemaDoc: '@deprecated - use "feedbackValue". This field will be removed soon. ' +
                'Review of the ticket by a resident on a 2-point scale. 0 – ticket returned, 1 – bad review, 2 – good review',
            type: Select,
            options: Object.values(REVIEW_VALUES).join(','),
        },
        reviewComment: {
            schemaDoc: '@deprecated - use "feedbackAdditionalOptions" and "feedbackComment". This field will be removed soon. ' +
                'Resident\'s comment on ticket review',
            type: Text,
        },

        feedbackValue: {
            schemaDoc: 'Feedback of the ticket by a resident on a 2-point scale (0 – ticket returned, 1 – bad review, 2 – good review)',
            type: Select,
            options: FEEDBACK_VALUES.join(','),
        },
        feedbackComment: {
            schemaDoc: 'Staff\'s comment on ticket feedback',
            type: Text,
            hooks: {
                resolveInput: async ({ resolvedData, fieldPath }) => {
                    if (fieldPath in resolvedData) {
                        return normalizeText(resolvedData[fieldPath]) || null
                    }
                },
            },
        },
        feedbackAdditionalOptions: FEEDBACK_ADDITIONAL_OPTIONS_FIELD,
        feedbackUpdatedAt: {
            schemaDoc: 'Feedback update time',
            type: DateTimeUtc,
            access: {
                read: true,
                update: false,
                create: false,
            },
        },

        qualityControlValue: {
            schemaDoc: 'Review of the ticket by a staff on a 2-point scale (bad or good)',
            type: Select,
            options: QUALITY_CONTROL_VALUES.join(','),
        },
        qualityControlComment: {
            schemaDoc: 'Staff\'s comment on ticket review',
            type: Text,
            hooks: {
                resolveInput: async ({ resolvedData, fieldPath }) => {
                    if (fieldPath in resolvedData) {
                        return normalizeText(resolvedData[fieldPath]) || null
                    }
                },
            },
        },
        qualityControlAdditionalOptions: QUALITY_CONTROL_ADDITIONAL_OPTIONS_FIELD,
        qualityControlUpdatedAt: {
            schemaDoc: 'Quality control updated at time',
            type: DateTimeUtc,
            access: readOnlyFieldAccess,
        },
        qualityControlUpdatedBy: {
            schemaDoc: 'User who last updated quality control value/control/additional options',
            type: Relationship,
            ref: 'User',
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
            access: readOnlyFieldAccess,
        },

        // Can be created/updated from client, because of offline mode in master app.
        // It uses TicketMultipleUpdateService and pass there updated status and actual statusUpdatedAt date for offline status changing
        statusUpdatedAt: {
            schemaDoc: 'Status updated at time',
            type: DateTimeUtc,
        },
        completedAt: {
            schemaDoc: 'When status of the ticket was changed to completed',
            type: DateTimeUtc,
            access: readOnlyFieldAccess,
        },
        lastCommentAt: {
            schemaDoc: 'Last comment time in ticket',
            type: DateTimeUtc,
            access: writeOnlyServerSideFieldAccess,
        },
        lastResidentCommentAt: {
            schemaDoc: 'Time of the last comment with resident author in ticket',
            type: DateTimeUtc,
            access: writeOnlyServerSideFieldAccess,
        },
        lastCommentWithResidentTypeAt: {
            schemaDoc: 'Time of the last comment with resident type (from staff or resident user) in ticket',
            type: DateTimeUtc,
            access: writeOnlyServerSideFieldAccess,
        },
        statusReason: {
            schemaDoc: 'Text reason for status changes. Sometimes you should describe the reason why you change the `status`',
            type: Text,
        },
        status: {
            schemaDoc: 'Status is the step of the ticket processing workflow. Companies may have different ticket processing workflows',
            type: Relationship,
            ref: 'TicketStatus',
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },
        deadline: {
            schemaDoc: 'Time after which the ticket must be completed',
            type: DateTimeUtc,
        },
        order: {
            schemaDoc: 'Field required for specific sorting of model objects',
            type: Integer,
            kmigratorOptions: { db_index: true },
            access: readOnlyFieldAccess,
        },
        number: {
            schemaDoc: 'Autogenerated ticket human readable ID',
            type: AutoIncrementInteger,
            isRequired: false,
            kmigratorOptions: { unique: true, null: false },
            access: readOnlyFieldAccess,
        },

        client: {
            ...CLIENT_FIELD,
            schemaDoc: CLIENT_FIELD.schemaDoc +
                ' This field indicates, that the Ticket is visible to a Resident and it has access to it. ' +
                'This field will be set to User of corresponding Resident in following cases: ' +
                '1) the Ticket was created by Resident from mobile app;' +
                '2) the Ticket was created by OrganizationEmployee with phone number, that matches some Resident;' +
                '3) a Resident was registered after this Ticket was created and the Resident have the same phone number as in this Ticket, so this Ticket will be automatically connected to it.',
        },
        contact: CONTACT_FIELD,
        clientName: CLIENT_NAME_FIELD,
        clientEmail:  CLIENT_EMAIL_FIELD,
        clientPhone: CLIENT_PHONE_LANDLINE_FIELD,

        // Integrations!?
        // hookStatus
        // hookResult

        // department?
        // who close
        // who accept

        assignee: {
            schemaDoc: 'Assignee/responsible employee/user who must ensure that the issue is fulfilled',
            type: Relationship,
            ref: 'User',
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },
        executor: {
            schemaDoc: 'Executor employee/user who perform the issue',
            type: Relationship,
            ref: 'User',
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },
        // TODO(zuch): make it required
        categoryClassifier: {
            schemaDoc: '@deprecated',
            type: Relationship,
            ref: 'TicketCategoryClassifier',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            access: readOnlyFieldAccess,
        },
        placeClassifier: {
            schemaDoc: '@deprecated',
            type: Relationship,
            ref: 'TicketPlaceClassifier',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            access: readOnlyFieldAccess,
        },
        problemClassifier: {
            schemaDoc: '@deprecated',
            type: Relationship,
            ref: 'TicketProblemClassifier',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            access: readOnlyFieldAccess,
        },
        classifier: {
            schemaDoc: 'Valid combination of 3 classifiers',
            type: Relationship,
            ref: 'TicketClassifier',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
        },
        isAutoClassified: {
            schemaDoc: 'Indicates that ticket has been classified automatically without human confirmation',
            type: Checkbox,
            defaultValue: false,
            isRequired: true,
            access: readOnlyFieldAccess,
        },
        // description / title
        details: {
            schemaDoc: 'Text description of the issue. Maybe written by a user or an operator',
            type: Text,
            isRequired: true,
            hooks: {
                resolveInput: async ({ resolvedData }) => {
                    return normalizeText(resolvedData['details'])
                },
            },
        },
        related: {
            schemaDoc: 'Sometimes, it is important for us to show related issues. For example, to show related issues',
            type: Relationship,
            ref: 'Ticket',
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },

        /**
         * @deprecated Please use "isPayable"
         */
        isPaid: {
            schemaDoc: '@deprecated Please use "isPayable"' +
                '\nIndicates the ticket is payable',
            type: Checkbox,
            defaultValue: false,
            isRequired: true,
        },

        isPayable: {
            schemaDoc: 'Indicates the ticket is payable',
            type: Checkbox,
            defaultValue: false,
            isRequired: true,
        },
        isEmergency: {
            schemaDoc: 'Indicates the ticket is emergency',
            type: Checkbox,
            defaultValue: false,
            isRequired: true,
        },
        isWarranty: {
            schemaDoc: 'Indicates the ticket is warranty',
            type: Checkbox,
            defaultValue: false,
            isRequired: true,
        },
        isResidentTicket: {
            schemaDoc: 'Determines who the ticket was created for: for a resident or not for a resident',
            type: Checkbox,
            defaultValue: false,
        },
        canReadByResident: {
            schemaDoc: 'Determines if a resident in the mobile app can see the ticket created in crm',
            type: Checkbox,
            defaultValue: false,
            isRequired: true,
        },
        meta: {
            schemaDoc: 'Extra analytics not related to remote system',
            type: Json,
            isRequired: false,
            hooks: {
                validateInput: ({ resolvedData, fieldPath, addFieldValidationError }) => {
                    if (!resolvedData.hasOwnProperty(fieldPath)) return // skip if on value
                    const value = resolvedData[fieldPath]
                    if (value === null) return // null is OK
                    if (typeof value !== 'object') {return addFieldValidationError(`${JSON_EXPECT_OBJECT_ERROR}${fieldPath}] ${fieldPath} field type error. We expect JSON Object`)}
                    const { dv } = value
                    if (dv === 1) {
                        // TODO(pahaz): need to checkIt!
                    } else {
                        return addFieldValidationError(`${JSON_UNKNOWN_VERSION_ERROR}${fieldPath}] Unknown \`dv\` attr inside JSON Object`)
                    }
                },
            },
        },
        // Where?
        // building/community
        // entrance/section
        // floor
        // premise/unit
        // placeDetail (behind the radiator, on the fifth step of the stairs)
        // Intercom code

        property: {
            schemaDoc: 'Property related to the Ticket',
            type: Relationship,
            ref: 'Property',
            isRequired: true,
            knexOptions: { isNotNullable: true },
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },
        propertyAddress: {
            schemaDoc: 'Address of property, which synced with property and displayed, if property is deleted',
            type: Text,
            isRequired: true,
            // USED TO REMOVE FIELDS FROM SCHEMA DOC FOR CREATE / UPDATE OPERATIONS
            access: readOnlyFieldAccess,
        },
        propertyAddressMeta: {
            ...ADDRESS_META_FIELD,
            schemaDoc: 'Address meta of property, which synced with property and used to form view of address, if property is deleted',
            isRequired: true,
            // USED TO REMOVE FIELDS FROM SCHEMA DOC FOR CREATE / UPDATE OPERATIONS
            access: readOnlyFieldAccess,
        },
        sectionName: {
            schemaDoc: 'Section name/number of an apartment building (property). You need to take from Property.map',
            type: Text,
        },
        sectionType: {
            schemaDoc: 'Type of section, such as parking or section. Default value: "section"',
            type: Select,
            options: SECTION_TYPES,
            dataType: 'string',
            isRequired: false,
            defaultValue: null,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true },
            hooks: {
                resolveInput: getSectionTypeFieldResolveInput(),
            },
        },
        floorName: {
            schemaDoc: 'Floor of an apartment building (property). You need to take from Property.map',
            type: Text,
        },
        // TODO(pahaz): make a link to property domain fields
        unitName: {
            schemaDoc: 'Flat number / door number of an apartment building (property). You need to take from Property.map',
            type: Text,
        },
        unitType: {
            ...UNIT_TYPE_FIELD,
            // Allow to set unitType to null
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true },
            defaultValue: null,
            hooks: {
                resolveInput: getUnitTypeFieldResolveInput(),
            },
        },
        source: {
            schemaDoc: 'Ticket source channel/system. Examples: call, email, visit, ...',
            type: Relationship,
            ref: 'TicketSource',
            isRequired: true,
            knexOptions: { isNotNullable: true },
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },
        sourceMeta: {
            schemaDoc: 'In the case of remote system sync, you can store some extra analytics. Examples: email, name, phone, ...',
            type: Json,
        },
        deferredUntil: {
            schemaDoc: 'Date until which the ticket is deferred',
            type: DateTimeUtc,
            hooks: {
                validateInput: async ({ resolvedData, addFieldValidationError }) => {
                    if (!resolvedData.deferredUntil) return

                    const deferredUntil = dayjs(resolvedData.deferredUntil)
                    const currentDate = dayjs()
                    const differenceInDays = deferredUntil.diff(currentDate, 'days')

                    if (differenceInDays < 0) {
                        return addFieldValidationError(`${WRONG_VALUE} the value of the "deferredUntil" field must be greater than the current date`)
                    }
                    if (differenceInDays > 365) {
                        return addFieldValidationError(`${WRONG_VALUE} the value of the "deferredUntil" field must be no more than 1 year old than the current date`)
                    }
                },
            },
        },
        isCompletedAfterDeadline: {
            schemaDoc: '(Auto-set) Used to filter tickets that were completed (,closed or cancelled) after the deadline. ',
            type: 'Checkbox',
            defaultValue: false,
            kmigratorOptions: { default: false },
            access: readOnlyFieldAccess,
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), webHooked()],
    hooks: {
        resolveInput: async ({ operation, context, resolvedData, existingItem, originalInput }) => {
            // NOTE(pahaz): can be undefined if you use it on worker or inside the scripts
            const user = get(context, ['req', 'user'])
            const userType = get(user, 'type')
            const userId = get(user, 'id')
            const isCreateOperation = operation === 'create'
            const isUpdateOperation = operation === 'update'

            if (isCreateOperation && !resolvedData.status) {
                resolvedData.status = STATUS_IDS.OPEN
            }

            // TODO(DOMA-5833):  delete this block when the mobile app will use 'feedback*' fields
            {
                /*
                NOTE: if you pass 'feedbackValue', 'feedbackAdditionalOptions' or 'feedbackComment'
                then reset 'reviewValue', 'reviewComment' and set value from feedback fields.

                If you pass only 'reviewValue' or 'reviewComment'
                then auto-set 'feedbackValue' and 'feedbackAdditionalOptions'
                 */
                if ('feedbackValue' in resolvedData || 'feedbackAdditionalOptions' in resolvedData || 'feedbackComment' in resolvedData) {
                    delete resolvedData.reviewValue
                    delete resolvedData.reviewComment

                    if ('feedbackValue' in resolvedData) {
                        resolvedData.reviewValue = resolvedData.feedbackValue
                    }
                    if ('feedbackAdditionalOptions' in resolvedData) {
                        resolvedData.reviewComment = isArray(resolvedData.feedbackAdditionalOptions)
                            ? resolvedData.feedbackAdditionalOptions
                                .map(key => convertFeedbackAdditionalOptionKeyToReviewCommentOption(key))
                                .filter(Boolean)
                                .join(';')
                            : null
                    }
                } else {
                    if ('reviewValue' in resolvedData) {
                        resolvedData.feedbackValue = resolvedData.reviewValue
                    }
                    if ('reviewComment' in resolvedData) {
                        const reviewComment = resolvedData.reviewComment
                        if (isString(reviewComment)) {
                            const option = reviewComment
                                .split(';')
                                .map(option => convertReviewCommentOptionToFeedbackAdditionalOptionKey(option))
                            if (isArray(option)) {
                                // NOTE: We clear the array of values from duplicates.
                                // Also sort values and convert empty arrays to null to get rid of changes history problems
                                const preparedValue = compact(uniq(option.sort()))
                                resolvedData.feedbackAdditionalOptions = isEmpty(preparedValue) ? null : preparedValue
                            }
                        }
                    }
                }
            }

            // TODO(DOMA-7224): delete this block when the mobile app will use 'isPayable' field
            {
                if ('isPayable' in originalInput) {
                    resolvedData.isPaid = resolvedData.isPayable
                } else if ('isPaid' in originalInput) {
                    resolvedData.isPayable = resolvedData.isPaid
                }
            }

            if (
                userType === RESIDENT
                && isUpdateOperation
                && resolvedData.feedbackValue
                && existingItem.status === STATUS_IDS.COMPLETED
            ) {
                updateStatusAfterResidentFeedback(resolvedData)
            }

            const newItem = { ...existingItem, ...resolvedData }
            const resolvedStatusId = get(newItem, 'status', null)
            const existedStatusId = get(existingItem, 'status', null)
            const resolvedClient = get(newItem, 'client', null)

            // Set isAutoClassified to false if classifier was passed
            if ((isCreateOperation || newItem.isAutoClassified) && resolvedData.classifier) {
                resolvedData.isAutoClassified = false
            }
            // Predict ticket classification if create ticket without classifier (ex: from mobile app)
            if (isCreateOperation && resolvedData.details && !resolvedData.classifier) {
                const classifierResult = await classifyTicket(context, resolvedData.details)

                resolvedData.classifier = get(classifierResult, 'id')
                resolvedData.isAutoClassified = true
            }
            overrideOldClassifier(resolvedData)

            if (resolvedStatusId) {
                calculateTicketOrder(resolvedData, resolvedStatusId)

                const resolvedStatus = await getById('TicketStatus', resolvedStatusId)
                let existedStatus = null
                if (existedStatusId) {
                    existedStatus = await getById('TicketStatus', existedStatusId)

                    await calculateReopenedCounter(context, existingItem, resolvedData, existedStatus, resolvedStatus)
                    calculateStatusUpdatedAt(resolvedData, existedStatusId, resolvedStatusId)
                    calculateDeferredUntil(resolvedData, existedStatus, resolvedStatus)
                }
                calculateCompletedAt(resolvedData, existedStatus, resolvedStatus)
            }

            if (userType === RESIDENT && isCreateOperation) {
                overrideTicketFieldsForResidentUserType(context, resolvedData)
                await setSectionAndFloorFieldsByDataFromPropertyMap(context, resolvedData)
                setClientNamePhoneEmailFieldsByDataFromUser(get(context, ['req', 'user']), resolvedData)
                await setDeadline(resolvedData)
            }

            calculateIsCompletedAfterDeadline(resolvedData, existingItem)
            await connectContactToTicket(context, resolvedData, existingItem)

            // When creating ticket or updating ticket address,
            // if client is not passed in resolvedData,
            // we find a registered user with a phone number that matches the contact's phone number
            // and an address that matches the ticket address.
            if (userType !== RESIDENT && isNull(resolvedClient)) {
                const contactId = get(resolvedData, 'contact', null)
                const propertyId = get(resolvedData, 'property', null)
                const unitName = get(resolvedData, 'unitName', null)

                if (!isNull(contactId) || !isNull(propertyId) || !isNull(unitName)) {
                    await setClientIfContactPhoneAndTicketAddressMatchesResidentFields(operation, resolvedData, existingItem)
                }
            }

            const propertyId = get(newItem, 'property', null)
            if (!propertyId) {
                throw new Error(`${PROPERTY_REQUIRED_ERROR}] empty property for ticket`)
            }
            const property = await getByCondition('Property', {
                id: propertyId,
                deletedAt: null,
            })
            // If property was soft- or hard-deleted = keep existing data = don't modify propertyAddress and propertyAddressMeta
            if (property) {
                resolvedData.propertyAddress = property.address
                resolvedData.propertyAddressMeta = property.addressMeta
            }

            if (resolvedData.contact) {
                const contact = await Contact.getOne(context, { id: resolvedData.contact })

                if (!resolvedData.clientName) resolvedData.clientName = contact.name
                if (!resolvedData.clientEmail) resolvedData.clientEmail = contact.email
                if (!resolvedData.clientPhone) resolvedData.clientPhone = contact.phone
            }
            if (resolvedData.classifier) {
                const classifier = await getById('TicketClassifier', resolvedData.classifier)

                resolvedData.placeClassifier = get(classifier, 'place', null)
                resolvedData.problemClassifier = get(classifier, 'problem', null)
                resolvedData.categoryClassifier = get(classifier, 'category', null)
            }

            if ('qualityControlValue' in resolvedData || 'qualityControlComment' in resolvedData || 'qualityControlAdditionalOptions' in resolvedData) {
                resolvedData.qualityControlUpdatedAt = dayjs().toISOString()
                if (userId) {
                    resolvedData.qualityControlUpdatedBy = userId
                }
            }

            const hasUpdatedFeedbackFields = 'feedbackValue' in resolvedData || 'feedbackComment' in resolvedData || 'feedbackAdditionalOptions' in resolvedData
            if (hasUpdatedFeedbackFields) {
                resolvedData.feedbackUpdatedAt = dayjs().toISOString()
            }

            return resolvedData
        },
        validateInput: async ({ resolvedData, existingItem, addValidationError, context, operation, originalInput }) => {
            // Todo(zuch): add placeClassifier, categoryClassifier and classifierRule
            if (!hasDbFields(['organization', 'source', 'status', 'details'], resolvedData, existingItem, context, addValidationError)) return

            const user = get(context, ['req', 'user'])
            const userType = get(user, 'type')

            if (userType === RESIDENT && operation === 'create') {
                const locale = extractReqLocale(context.req) || conf.DEFAULT_LOCALE
                await checkDailyTicketLimit({
                    userId: get(user, 'id'),
                    organizationId: get(resolvedData, 'organization'),
                    details: get(resolvedData, 'details'),
                    isInvoiceTicket: get(resolvedData, 'details') === i18n('marketplace.invoice.newTicket.details', { locale }),
                    isPayable: get(resolvedData, 'isPayable'),
                    context,
                })
            }

            const newItem = { ...existingItem, ...resolvedData }
            const resolvedStatus = await getById('TicketStatus', newItem.status)

            if (newItem.deferredUntil) {
                if (operation === 'create') {
                    if (resolvedStatus.type !== DEFERRED_STATUS_TYPE) {
                        return addValidationError(`${WRONG_VALUE} should not create ticket with "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE}`)
                    }
                }

                if (operation === 'update') {
                    const existingStatus = await getById('TicketStatus', existingItem.status)
                    // we shouldn't change the deferredUntil field unless it's for deferred tickets (before or after update)
                    if (originalInput.deferredUntil && existingStatus.type !== DEFERRED_STATUS_TYPE && resolvedStatus.type !== DEFERRED_STATUS_TYPE) {
                        return addValidationError(`${WRONG_VALUE} should not change "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE} before or after changes`)
                    }
                }
            }

            const qualityControlAdditionalOptions = get(newItem, 'qualityControlAdditionalOptions')

            if ((!isEmpty(qualityControlAdditionalOptions) || !!newItem.qualityControlComment) && !newItem.qualityControlValue) {
                throw new GQLError(ERRORS.QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED, context)
            }

            const feedbackAdditionalOptions = get(newItem, 'feedbackAdditionalOptions')

            if ((!isEmpty(feedbackAdditionalOptions) || !!newItem.feedbackComment) && !newItem.feedbackValue) {
                throw new GQLError(ERRORS.FEEDBACK_VALUE_MUST_BE_SPECIFIED, context)
            }

            if (!newItem.deferredUntil && resolvedStatus.type === DEFERRED_STATUS_TYPE) {
                return addValidationError(`${WRONG_VALUE} deferredUntil is null, but status type is ${DEFERRED_STATUS_TYPE}`)
            }
        },
        // `beforeChange` cannot be used, because data can be manipulated during updating process somewhere inside a ticket
        // We need a final result after update
        afterChange: async (...args) => {
            /**
             * Creates a new TicketChange item.
             * 👉 When a new "single" or "many" relation field will be added to Ticket,
             * new resolver should be implemented in `ticketChangeDisplayNameResolversForSingleRelations` and `relatedManyToManyResolvers`
             */
            const { property, unitName, sectionName, sectionType, unitType, floorName, classifier } = Ticket.schema.fields

            const [requestData] = args

            const { existingItem, updatedItem, operation, context } = requestData

            if (operation === 'update') {
                const ticketId = updatedItem.id
                const isPropertyChanged = existingItem.property !== updatedItem.property
                const isUnitChanged = existingItem.unitName !== updatedItem.unitName || existingItem.unitType !== updatedItem.unitType
                const isClientInfoChanged = existingItem.clientName !== updatedItem.clientName || existingItem.clientPhone !== updatedItem.clientPhone
                const isTicketCanceled = existingItem.status !== STATUS_IDS.DECLINED && updatedItem.status === STATUS_IDS.DECLINED

                if (isPropertyChanged || isUnitChanged || isClientInfoChanged || isTicketCanceled) {
                    const invoicesWithTicket = await find('Invoice', {
                        ticket: { id: ticketId },
                        status_in: [INVOICE_STATUS_PUBLISHED, INVOICE_STATUS_DRAFT],
                        deletedAt: null,
                    })

                    const updateInvoicePayload = { dv: updatedItem.dv, sender: updatedItem.sender }
                    if (isPropertyChanged) {
                        updateInvoicePayload['property'] = { connect: { id: updatedItem.property } }
                    }
                    if (isUnitChanged) {
                        updateInvoicePayload['unitName'] = updatedItem.unitName
                        updateInvoicePayload['unitType'] = updatedItem.unitType
                    }
                    if (isClientInfoChanged) {
                        updateInvoicePayload['clientName'] = updatedItem.clientName
                        updateInvoicePayload['clientPhone'] = updatedItem.clientPhone
                    }

                    for (const invoice of invoicesWithTicket) {
                        await Invoice.update(context, invoice.id, updateInvoicePayload)
                    }
                }

                if (isTicketCanceled) {
                    const invoicesWithTicket = await find('Invoice', {
                        ticket: { id: ticketId },
                        status_not_in: [INVOICE_STATUS_PAID, INVOICE_STATUS_CANCELED],
                        deletedAt: null,
                    })

                    for (const invoice of invoicesWithTicket) {
                        await Invoice.update(context, invoice.id, {
                            status: INVOICE_STATUS_CANCELED,
                            dv: updatedItem.dv,
                            sender: updatedItem.sender,
                        })
                    }
                }
            }

            await storeChangesIfUpdated(
                buildSetOfFieldsToTrackFrom(Ticket.schema, { except: OMIT_TICKET_CHANGE_TRACKABLE_FIELDS }),
                createTicketChange,
                ticketChangeDisplayNameResolversForSingleRelations,
                relatedManyToManyResolvers,
                [
                    { property, unitName, sectionName, sectionType, unitType, floorName },
                    { classifier },
                ]
            )(...args)

            /* NOTE: this sends different kinds of notifications on ticket create/update */
            await sendTicketChangedNotifications.delay({ ticketId: updatedItem.id, existingItem, operation })
        },
    },
    access: {
        read: access.canReadTickets,
        create: access.canManageTickets,
        update: access.canManageTickets,
        delete: false,
        auth: true,
    },
})

module.exports = {
    Ticket,
    ERRORS,
    DAILY_TICKET_LIMIT,
    DAILY_SAME_TICKET_LIMIT,
}
