/**
 * Generated by `createschema ticket.Ticket organization:Text; statusReopenedCounter:Integer; statusReason?:Text; status:Relationship:TicketStatus:PROTECT; number?:Integer; client?:Relationship:User:SET_NULL; clientName:Text; clientEmail:Text; clientPhone:Text; operator:Relationship:User:SET_NULL; assignee?:Relationship:User:SET_NULL; details:Text; meta?:Json;`
 */

const dayjs = require('dayjs')
const { isEmpty, get, isNull, compact, isArray, isString, uniq } = require('lodash')

const conf = require('@open-condo/config')
const { featureToggleManager } = require('@open-condo/featureflags/featureToggleManager')
const { readOnlyFieldAccess, writeOnlyServerSideFieldAccess } = require('@open-condo/keystone/access')
const { GQLErrorCode: { BAD_USER_INPUT }, GQLError } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getByCondition, getById, find } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')
const { i18n } = require('@open-condo/locales/loader')
const { webHooked } = require('@open-condo/webhooks/plugins')

const {
    PROPERTY_REQUIRED_ERROR,
    JSON_EXPECT_OBJECT_ERROR,
    JSON_UNKNOWN_VERSION_ERROR,
    WRONG_VALUE,
} = require('@condo/domains/common/constants/errors')
const { SKIP_DAILY_SAME_TICKET_LIMIT, SKIP_DAILY_TICKET_LIMIT } = require('@condo/domains/common/constants/featureflags')
const {
    CLIENT_PHONE_LANDLINE_FIELD,
    CLIENT_EMAIL_FIELD,
    CLIENT_NAME_FIELD,
    CONTACT_FIELD,
    CLIENT_FIELD,
    ADDRESS_META_FIELD,
    UNIT_TYPE_FIELD,
} = require('@condo/domains/common/schema/fields')
const { md5 } = require('@condo/domains/common/utils/crypto')
const { buildSetOfFieldsToTrackFrom, storeChangesIfUpdated } = require('@condo/domains/common/utils/serverSchema/changeTrackable')
const { getUnitTypeFieldResolveInput, getSectionTypeFieldResolveInput } = require('@condo/domains/common/utils/serverSchema/resolveHelpers')
const { normalizeText } = require('@condo/domains/common/utils/text')
const { hasDbFields } = require('@condo/domains/common/utils/validation.utils')
const { Contact } = require('@condo/domains/contact/utils/serverSchema')
const { INVOICE_STATUS_CANCELED, INVOICE_STATUS_PAID, INVOICE_STATUS_PUBLISHED, INVOICE_STATUS_DRAFT } = require('@condo/domains/marketplace/constants')
const { Invoice } = require('@condo/domains/marketplace/utils/serverSchema')
const { ORGANIZATION_OWNED_FIELD } = require('@condo/domains/organization/schema/fields')
const { SECTION_TYPES } = require('@condo/domains/property/constants/common')
const access = require('@condo/domains/ticket/access/Ticket')
const {
    OMIT_TICKET_CHANGE_TRACKABLE_FIELDS,
    REVIEW_VALUES,
    DEFERRED_STATUS_TYPE,
} = require('@condo/domains/ticket/constants')
const { FEEDBACK_VALUES, FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY } = require('@condo/domains/ticket/constants/feedback')
const { QUALITY_CONTROL_VALUES } = require('@condo/domains/ticket/constants/qualityControl')
const { STATUS_IDS } = require('@condo/domains/ticket/constants/statusTransitions')
const { QUALITY_CONTROL_ADDITIONAL_OPTIONS_FIELD } = require('@condo/domains/ticket/schema/fields/QualityControlAdditionalOptions')
const { FEEDBACK_ADDITIONAL_OPTIONS_FIELD } = require('@condo/domains/ticket/schema/fields/TicketFeedbackAdditionalOptions')
const { sendTicketChangedNotifications } = require('@condo/domains/ticket/tasks')
const {
    calculateTicketOrder, calculateReopenedCounter,
    setSectionAndFloorFieldsByDataFromPropertyMap, setClientNamePhoneEmailFieldsByDataFromUser,
    overrideTicketFieldsForResidentUserType, setClientIfContactPhoneAndTicketAddressMatchesResidentFields, connectContactToTicket,
    calculateCompletedAt,
    calculateStatusUpdatedAt,
    calculateDeferredUntil,
    setDeadline, updateStatusAfterResidentFeedback,
    classifyTicket,
    calculateIsCompletedAfterDeadline,
} = require('@condo/domains/ticket/utils/serverSchema/resolveHelpers')
const {
    createTicketChange,
    ticketChangeDisplayNameResolversForSingleRelations,
    relatedManyToManyResolvers,
} = require('@condo/domains/ticket/utils/serverSchema/TicketChange')
const { RESIDENT } = require('@condo/domains/user/constants/common')
const { USER_TYPES } = require('@condo/domains/user/constants/common')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')



const usersWithoutTicketLimits = Object.keys(conf.USERS_WITHOUT_TICKET_LIMITS ? JSON.parse(conf.USERS_WITHOUT_TICKET_LIMITS) : {})

const redisGuard = new RedisGuard()

const DAILY_TICKET_LIMIT = parseInt(conf.DAILY_TICKET_LIMIT) || 10
const DAILY_SAME_TICKET_LIMIT = parseInt(conf.DAILY_SAME_TICKET_LIMIT) || 2

const ERRORS = {
    FEEDBACK_VALUE_MUST_BE_SPECIFIED: {
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: '"feedbackValue" must be specified if there is "feedbackAdditionalOptions" or "feedbackComment"',
        messageForUser: 'api.ticket.ticket.FEEDBACK_VALUE_MUST_BE_SPECIFIED',
    },
    QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED: {
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: '"qualityControlValue" must be specified if there is "qualityControlAdditionalOptions" or "qualityControlComment"',
        messageForUser: 'api.ticket.ticket.QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED',
    },
    TICKET_FOR_PHONE_DAY_LIMIT_REACHED: {
        code: 'BAD_USER_INPUT',
        type: 'TICKET_FOR_PHONE_DAY_LIMIT_REACHED',
        message: 'Please try again tomorrow. You can not create more tickets!',
        messageForUser: 'api.ticket.ticket.TICKET_FOR_PHONE_DAY_LIMIT_REACHED',
        messageInterpolation: { ticketLimit: DAILY_TICKET_LIMIT },
    },
    SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED: {
        code: 'BAD_USER_INPUT',
        type: 'SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED',
        message: 'You already sent this ticket! You can not create more tickets!',
        messageForUser: 'api.ticket.ticket.SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED',
    },
}

/**
 * Checks limits on ticket creation.
 * User should not be able to create more than $DAILY_TICKET_LIMIT tickets to 1 organization.
 * User should not be able to create more than $DAILY_SAME_TICKET_LIMIT tickets to 1 organization.
 * Pushes for bulk operations are disabled in this scheme.
 * 
 * $USERS_WITHOUT_TICKET_LIMITS phones are excluded from this rule.
 *
 * @param {string} phone
 * @param {string} organizationId
 * @param {string} details
 * @param context
 * @param {boolean} isInvoiceTicket
 * @returns {Promise<void>}
 */
const checkDailyTicketLimit = async ({ userId, organizationId, details, context, isInvoiceTicket, isPayable }) => {
    if (usersWithoutTicketLimits.includes(userId)) {
        return
    }

    if (!userId) {
        throw new Error('No user id in Ticket.checkDailyTicketLimit')
    }

    if (!organizationId) {
        throw new Error('No organization id in Ticket.checkDailyTicketLimit')
    }

    if (!details) {
        throw new Error('No details in Ticket.checkDailyTicketLimit')
    }

    const byIdAndOrgKey = `dailyTicketLimit:id:${userId}:organization:${organizationId}`
    const byIdOrgAndDetailsKey = `${byIdAndOrgKey}:details:${md5(details)}`

    const isSkipSameTicketLimitFeatureEnabled = await featureToggleManager.isFeatureEnabled(context, SKIP_DAILY_SAME_TICKET_LIMIT, { organization: organizationId })
    const byIdOrgAndDetailsCounter = isInvoiceTicket && isPayable ? 0 : await redisGuard.incrementDayCounter(byIdOrgAndDetailsKey)
    if (!isSkipSameTicketLimitFeatureEnabled && byIdOrgAndDetailsCounter > DAILY_SAME_TICKET_LIMIT) {
        throw new GQLError(ERRORS.SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED, context)
    }

    const isSkipTicketLimitFeatureEnabled = await featureToggleManager.isFeatureEnabled(context, SKIP_DAILY_TICKET_LIMIT, { organization: organizationId })
    const byIdAndOrgCounter = await redisGuard.incrementDayCounter(byIdAndOrgKey)
    if (!isSkipTicketLimitFeatureEnabled && byIdAndOrgCounter > DAILY_TICKET_LIMIT) {
        throw new GQLError(ERRORS.TICKET_FOR_PHONE_DAY_LIMIT_REACHED, context)
    }
}
/*
* TODO(DOMA-5833): This is a temporary hardcode.
*  Should delete "convertReviewCommentOptionToFeedbackAdditionalOptionKey"
*  and "convertFeedbackAdditionalOptionKeyToReviewCommentOption"
*  functions when the mobile app will use 'feedback*' fields
*/
const convertReviewCommentOptionToFeedbackAdditionalOptionKey = (option) => {
    if (option === 'Сделали на совесть' || option === 'Made in good faith') return FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.HIGH_QUALITY
    if (option === 'Быстро сделали' || option === 'Quickly done') return FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.QUICKLY
    if (option === 'It was done poorly' || option === 'Сделали некачественно') return FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.LOW_QUALITY
    if (option === 'It took a long time' || option === 'Долго делали') return FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.SLOWLY
    return null
}
const convertFeedbackAdditionalOptionKeyToReviewCommentOption = (option) => {
    if (option === FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.HIGH_QUALITY) return 'Сделали на совесть'
    if (option === FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.QUICKLY) return 'Быстро сделали'
    if (option === FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.LOW_QUALITY) return 'Сделали некачественно'
    if (option === FEEDBACK_ADDITIONAL_OPTIONS_BY_KEY.SLOWLY) return 'Долго делали'
    return null
}


const Ticket = new GQLListSchema('Ticket', {
    schemaDoc: 'Users request or contact with the user. ' +
        'It has fields `clientName`, `clientPhone`, `clientEmail`, which stores contact information at the moment of creating or updating. ' +
        'Values of these fields are independent from related entities, like Contact, Resident etc. ' +
        'If by some reason related entities will be deleted, unavailable or will change its contact information, these fields will stay unchanged.' +
        'So, by creating a new ticket with connection to some contact entity (Contact, Resident), these fields will be populated by its contact information if other values are not explicitly provided.',
    fields: {
        // TODO(pahaz): no needed to check organization access!
        organization: ORGANIZATION_OWNED_FIELD,

        // statusDeadline
        // statusDeferredDate
        // statusDeferredBy
        // TODO(pahaz): server side autogen
        statusReopenedCounter: {
            schemaDoc: 'Counter showing the number of changes `status` to `new_or_reopened`',
            type: 'Integer',
            isRequired: true,
            defaultValue: 0,
            access: readOnlyFieldAccess,
        },

        // TODO(DOMA-5833): delete 'reviewValue' and 'reviewComment' when the mobile app will use 'feedback*' fields
        reviewValue: {
            schemaDoc: '@deprecated - use "feedbackValue". This field will be removed soon. ' +
                'Review of the ticket by a resident on a 2-point scale. 0 – ticket returned, 1 – bad review, 2 – good review',
            type: 'Select',
            options: Object.values(REVIEW_VALUES).join(','),
        },
        reviewComment: {
            schemaDoc: '@deprecated - use "feedbackAdditionalOptions" and "feedbackComment". This field will be removed soon. ' +
                'Resident\'s comment on ticket review',
            type: 'Text',
        },

        feedbackValue: {
            schemaDoc: 'Feedback of the ticket by a resident on a 2-point scale (0 – ticket returned, 1 – bad review, 2 – good review)',
            type: 'Select',
            options: FEEDBACK_VALUES.join(','),
        },
        feedbackComment: {
            schemaDoc: 'Staff\'s comment on ticket feedback',
            type: 'Text',
            hooks: {
                resolveInput: async ({ resolvedData, fieldPath }) => {
                    if (fieldPath in resolvedData) {
                        return normalizeText(resolvedData[fieldPath]) || null
                    }
                },
            },
        },
        feedbackAdditionalOptions: FEEDBACK_ADDITIONAL_OPTIONS_FIELD,
        feedbackUpdatedAt: {
            schemaDoc: 'Feedback update time',
            type: 'DateTimeUtc',
            access: {
                read: true,
                update: false,
                create: false,
            },
        },

        qualityControlValue: {
            schemaDoc: 'Review of the ticket by a staff on a 2-point scale (bad or good)',
            type: 'Select',
            options: QUALITY_CONTROL_VALUES.join(','),
        },
        qualityControlComment: {
            schemaDoc: 'Staff\'s comment on ticket review',
            type: 'Text',
            hooks: {
                resolveInput: async ({ resolvedData, fieldPath }) => {
                    if (fieldPath in resolvedData) {
                        return normalizeText(resolvedData[fieldPath]) || null
                    }
                },
            },
        },
        qualityControlAdditionalOptions: QUALITY_CONTROL_ADDITIONAL_OPTIONS_FIELD,
        qualityControlUpdatedAt: {
            schemaDoc: 'Quality control updated at time',
            type: 'DateTimeUtc',
            access: readOnlyFieldAccess,
        },
        qualityControlUpdatedBy: {
            schemaDoc: 'User who last updated quality control value/control/additional options',
            type: 'Relationship',
            ref: 'User',
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
            access: readOnlyFieldAccess,
        },

        // Can be created/updated from client, because of offline mode in master app.
        // It uses TicketMultipleUpdateService and pass there updated status and actual statusUpdatedAt date for offline status changing
        statusUpdatedAt: {
            schemaDoc: 'Status updated at time',
            type: 'DateTimeUtc',
        },
        completedAt: {
            schemaDoc: 'When status of the ticket was changed to completed',
            type: 'DateTimeUtc',
            access: readOnlyFieldAccess,
        },
        lastCommentAt: {
            schemaDoc: 'CreatedAt of the last TicketComment',
            type: 'DateTimeUtc',
            access: writeOnlyServerSideFieldAccess,
        },
        lastResidentCommentAt: {
            schemaDoc: 'CreatedAt of the last TicketComment from RESIDENT user (only with type=RESIDENT)',
            type: 'DateTimeUtc',
            access: writeOnlyServerSideFieldAccess,
        },
        lastCommentWithResidentTypeAt: {
            schemaDoc: 'CreatedAt of the last TicketComment with type=RESIDENT from STAFF or RESIDENT user',
            type: 'DateTimeUtc',
            access: writeOnlyServerSideFieldAccess,
        },
        lastCommentWithOrganizationTypeAt: {
            schemaDoc: 'CreatedAt of the last TicketComment with type=ORGANIZATION from STAFF user' +
            'Example: lastCommentWithOrganizationTypeAt will be set to 2025_01_01 if the most recent TicketComment with type=ORGANIZATION was created on 2025_01_01',
            type: 'DateTimeUtc',
            access: writeOnlyServerSideFieldAccess,
        },
        lastCommentWithResidentTypeCreatedByUserType: {
            schemaDoc: 'Type of the User who created last comment with type=RESIDENT' +
            'Example: `staff``, if last TicketComment with type=RESIDENT was from User.type = staff',
            type: 'Select',
            options: USER_TYPES,
            access: writeOnlyServerSideFieldAccess,
        },
        statusReason: {
            schemaDoc: 'Text reason for status changes. Sometimes you should describe the reason why you change the `status`',
            type: 'Text',
        },
        status: {
            schemaDoc: 'Status is the step of the ticket processing workflow. Companies may have different ticket processing workflows',
            type: 'Relationship',
            ref: 'TicketStatus',
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },
        deadline: {
            schemaDoc: 'Time after which the ticket must be completed',
            type: 'DateTimeUtc',
        },
        order: {
            schemaDoc: 'Field required for specific sorting of model objects',
            type: 'Integer',
            kmigratorOptions: { db_index: true },
            access: readOnlyFieldAccess,
        },
        number: {
            schemaDoc: 'Autogenerated ticket human readable ID',
            type: 'AutoIncrementInteger',
            isRequired: false,
            kmigratorOptions: { unique: true, null: false },
            access: readOnlyFieldAccess,
        },

        client: {
            ...CLIENT_FIELD,
            schemaDoc: CLIENT_FIELD.schemaDoc +
                ' This field indicates, that the Ticket is visible to a Resident and it has access to it. ' +
                'This field will be set to User of corresponding Resident in following cases: ' +
                '1) the Ticket was created by Resident from mobile app;' +
                '2) the Ticket was created by OrganizationEmployee with phone number, that matches some Resident;' +
                '3) a Resident was registered after this Ticket was created and the Resident have the same phone number as in this Ticket, so this Ticket will be automatically connected to it.',
        },
        contact: CONTACT_FIELD,
        clientName: CLIENT_NAME_FIELD,
        clientEmail:  CLIENT_EMAIL_FIELD,
        clientPhone: CLIENT_PHONE_LANDLINE_FIELD,

        // Integrations!?
        // hookStatus
        // hookResult

        // department?
        // who close
        // who accept

        assignee: {
            schemaDoc: 'Assignee/responsible employee/user who must ensure that the issue is fulfilled',
            type: 'Relationship',
            ref: 'User',
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },
        executor: {
            schemaDoc: 'Executor employee/user who perform the issue',
            type: 'Relationship',
            ref: 'User',
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },
        // TODO(zuch): make it required
        categoryClassifier: {
            schemaDoc: '@deprecated',
            type: 'Relationship',
            ref: 'TicketCategoryClassifier',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            access: readOnlyFieldAccess,
        },
        placeClassifier: {
            schemaDoc: '@deprecated',
            type: 'Relationship',
            ref: 'TicketPlaceClassifier',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            access: readOnlyFieldAccess,
        },
        problemClassifier: {
            schemaDoc: '@deprecated',
            type: 'Relationship',
            ref: 'TicketProblemClassifier',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            access: readOnlyFieldAccess,
        },
        classifier: {
            schemaDoc: 'Valid combination of 3 classifiers',
            type: 'Relationship',
            ref: 'TicketClassifier',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
        },
        isAutoClassified: {
            schemaDoc: 'Indicates that ticket has been classified automatically without human confirmation',
            type: 'Checkbox',
            defaultValue: false,
            isRequired: true,
            access: readOnlyFieldAccess,
        },
        // description / title
        title: {
            schemaDoc: 'Very short description of the issue. Will be filled via LLM in the future',
            type: 'Text',
            isRequired: false,
        },
        details: {
            schemaDoc: 'Text description of the issue. Maybe written by a user or an operator',
            type: 'Text',
            isRequired: true,
            hooks: {
                resolveInput: async ({ resolvedData }) => {
                    return normalizeText(resolvedData['details'])
                },
            },
        },
        related: {
            schemaDoc: 'Sometimes, it is important for us to show related issues. For example, to show related issues',
            type: 'Relationship',
            ref: 'Ticket',
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },

        /**
         * @deprecated Please use "isPayable"
         */
        isPaid: {
            schemaDoc: '@deprecated Please use "isPayable"' +
                '\nIndicates the ticket is payable',
            type: 'Checkbox',
            defaultValue: false,
            isRequired: true,
        },

        isPayable: {
            schemaDoc: 'Indicates the ticket is payable',
            type: 'Checkbox',
            defaultValue: false,
            isRequired: true,
        },
        isEmergency: {
            schemaDoc: 'Indicates the ticket is emergency',
            type: 'Checkbox',
            defaultValue: false,
            isRequired: true,
        },
        isWarranty: {
            schemaDoc: 'Indicates the ticket is warranty',
            type: 'Checkbox',
            defaultValue: false,
            isRequired: true,
        },
        isInsurance: {
            schemaDoc: 'Indicates the ticket is insurance',
            type: 'Checkbox',
            defaultValue: false,
            isRequired: true,
        },
        isResidentTicket: {
            schemaDoc: 'Determines who the ticket was created for: for a resident or not for a resident',
            type: 'Checkbox',
            defaultValue: false,
        },
        canReadByResident: {
            schemaDoc: 'Determines if a resident in the mobile app can see the ticket created in crm',
            type: 'Checkbox',
            defaultValue: false,
            isRequired: true,
        },

        meta: {
            schemaDoc: 'Extra analytics not related to remote system',
            type: 'Json',
            isRequired: false,
            hooks: {
                validateInput: ({ resolvedData, fieldPath, addFieldValidationError }) => {
                    if (!resolvedData.hasOwnProperty(fieldPath)) return // skip if on value
                    const value = resolvedData[fieldPath]
                    if (value === null) return // null is OK
                    if (typeof value !== 'object') {return addFieldValidationError(`${JSON_EXPECT_OBJECT_ERROR}${fieldPath}] ${fieldPath} field type error. We expect JSON Object`)}
                    const { dv } = value
                    if (dv === 1) {
                        // TODO(pahaz): need to checkIt!
                    } else {
                        return addFieldValidationError(`${JSON_UNKNOWN_VERSION_ERROR}${fieldPath}] Unknown \`dv\` attr inside JSON Object`)
                    }
                },
            },
        },

        priority: {
            schemaDoc: 'The number used to determine priority of this ticket. Like in JIRA. Default value is: 100. ' +
                'Preferred values are: 100, 200, 300, 400, 500. 500 is the highest. Used by custom integrations',
            type: 'Integer',
            isRequired: true,
            defaultValue: 300,
        },

        kanbanColumn: {
            schemaDoc: 'Custom id for kanban column. Should be used if it is not enough to map statuses to columns. Used by custom integrations',
            type: 'Text',
            isRequired: false,
        },

        kanbanOrder: {
            schemaDoc: 'The number used to determine the relative position of this ticket inside of kanban column. Used by custom integrations',
            type: 'Integer',
            isRequired: true,
            defaultValue: 1,
        },

        customClassifier: {
            schemaDoc: 'Custom type or classifier for ticket. Used by custom integrations',
            type: 'Text',
            isRequired: false,
        },

        // Where?
        // building/community
        // entrance/section
        // floor
        // premise/unit
        // placeDetail (behind the radiator, on the fifth step of the stairs)
        // Intercom code

        property: {
            schemaDoc: 'Property related to the Ticket',
            type: 'Relationship',
            ref: 'Property',
            isRequired: true,
            knexOptions: { isNotNullable: true },
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },
        propertyAddress: {
            schemaDoc: 'Address of property, which synced with property and displayed, if property is deleted',
            type: 'Text',
            isRequired: true,
            // USED TO REMOVE FIELDS FROM SCHEMA DOC FOR CREATE / UPDATE OPERATIONS
            access: readOnlyFieldAccess,
        },
        propertyAddressMeta: {
            ...ADDRESS_META_FIELD,
            schemaDoc: 'Address meta of property, which synced with property and used to form view of address, if property is deleted',
            isRequired: true,
            // USED TO REMOVE FIELDS FROM SCHEMA DOC FOR CREATE / UPDATE OPERATIONS
            access: readOnlyFieldAccess,
        },
        sectionName: {
            schemaDoc: 'Section name/number of an apartment building (property). You need to take from Property.map',
            type: 'Text',
        },
        sectionType: {
            schemaDoc: 'Type of section, such as parking or section. Default value: "section"',
            type: 'Select',
            options: SECTION_TYPES,
            dataType: 'string',
            isRequired: false,
            defaultValue: null,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true },
            hooks: {
                resolveInput: getSectionTypeFieldResolveInput(),
            },
        },

        floorName: {
            schemaDoc: 'Floor of an apartment building (property). You need to take from Property.map',
            type: 'Text',
        },
        // TODO(pahaz): make a link to property domain fields
        unitName: {
            schemaDoc: 'Flat number / door number of an apartment building (property). You need to take from Property.map',
            type: 'Text',
        },
        unitType: {
            ...UNIT_TYPE_FIELD,
            // Allow to set unitType to null
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true },
            defaultValue: null,
            hooks: {
                resolveInput: getUnitTypeFieldResolveInput(),
            },
        },
        source: {
            schemaDoc: 'Ticket source channel/system. Examples: call, email, visit, ...',
            type: 'Relationship',
            ref: 'TicketSource',
            isRequired: true,
            knexOptions: { isNotNullable: true },
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },
        sourceMeta: {
            schemaDoc: 'In the case of remote system sync, you can store some extra analytics. Examples: email, name, phone, ...',
            type: 'Json',
        },
        deferredUntil: {
            schemaDoc: 'Date until which the ticket is deferred',
            type: 'DateTimeUtc',
            hooks: {
                validateInput: async ({ resolvedData, addFieldValidationError }) => {
                    if (!resolvedData.deferredUntil) return

                    const deferredUntil = dayjs(resolvedData.deferredUntil)
                    const currentDate = dayjs()
                    const differenceInDays = deferredUntil.diff(currentDate, 'days')

                    if (differenceInDays < 0) {
                        return addFieldValidationError(`${WRONG_VALUE} the value of the "deferredUntil" field must be greater than the current date`)
                    }
                    if (differenceInDays > 365) {
                        return addFieldValidationError(`${WRONG_VALUE} the value of the "deferredUntil" field must be no more than 1 year old than the current date`)
                    }
                },
            },
        },
        isCompletedAfterDeadline: {
            schemaDoc: '(Auto-set) Used to filter tickets that were completed (,closed or cancelled) after the deadline. ',
            type: 'Checkbox',
            defaultValue: false,
            kmigratorOptions: { default: false },
            access: readOnlyFieldAccess,
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), webHooked()],
    hooks: {
        resolveInput: async ({ operation, context, resolvedData, existingItem, originalInput }) => {
            // NOTE(pahaz): can be undefined if you use it on worker or inside the scripts
            const user = get(context, ['req', 'user'])
            const userType = get(user, 'type')
            const userId = get(user, 'id')
            const isCreateOperation = operation === 'create'
            const isUpdateOperation = operation === 'update'

            if (isCreateOperation && !resolvedData.status) {
                resolvedData.status = STATUS_IDS.OPEN
            }

            // TODO(DOMA-5833):  delete this block when the mobile app will use 'feedback*' fields
            {
                /*
                NOTE: if you pass 'feedbackValue', 'feedbackAdditionalOptions' or 'feedbackComment'
                then reset 'reviewValue', 'reviewComment' and set value from feedback fields.

                If you pass only 'reviewValue' or 'reviewComment'
                then auto-set 'feedbackValue' and 'feedbackAdditionalOptions'
                 */
                if ('feedbackValue' in resolvedData || 'feedbackAdditionalOptions' in resolvedData || 'feedbackComment' in resolvedData) {
                    delete resolvedData.reviewValue
                    delete resolvedData.reviewComment

                    if ('feedbackValue' in resolvedData) {
                        resolvedData.reviewValue = resolvedData.feedbackValue
                    }
                    if ('feedbackAdditionalOptions' in resolvedData) {
                        resolvedData.reviewComment = isArray(resolvedData.feedbackAdditionalOptions)
                            ? resolvedData.feedbackAdditionalOptions
                                .map(key => convertFeedbackAdditionalOptionKeyToReviewCommentOption(key))
                                .filter(Boolean)
                                .join(';')
                            : null
                    }
                } else {
                    if ('reviewValue' in resolvedData) {
                        resolvedData.feedbackValue = resolvedData.reviewValue
                    }
                    if ('reviewComment' in resolvedData) {
                        const reviewComment = resolvedData.reviewComment
                        if (isString(reviewComment)) {
                            const option = reviewComment
                                .split(';')
                                .map(option => convertReviewCommentOptionToFeedbackAdditionalOptionKey(option))
                            if (isArray(option)) {
                                // NOTE: We clear the array of values from duplicates.
                                // Also sort values and convert empty arrays to null to get rid of changes history problems
                                const preparedValue = compact(uniq(option.sort()))
                                resolvedData.feedbackAdditionalOptions = isEmpty(preparedValue) ? null : preparedValue
                            }
                        }
                    }
                }
            }

            // TODO(DOMA-7224): delete this block when the mobile app will use 'isPayable' field
            {
                if ('isPayable' in originalInput) {
                    resolvedData.isPaid = resolvedData.isPayable
                } else if ('isPaid' in originalInput) {
                    resolvedData.isPayable = resolvedData.isPaid
                }
            }

            if (
                userType === RESIDENT
                && isUpdateOperation
                && resolvedData.feedbackValue
                && existingItem.status === STATUS_IDS.COMPLETED
            ) {
                updateStatusAfterResidentFeedback(resolvedData)
            }

            const newItem = { ...existingItem, ...resolvedData }
            const resolvedStatusId = get(newItem, 'status', null)
            const existedStatusId = get(existingItem, 'status', null)
            const resolvedClient = get(newItem, 'client', null)

            // Set isAutoClassified to false if classifier was passed
            if ((isCreateOperation || newItem.isAutoClassified) && resolvedData.classifier) {
                resolvedData.isAutoClassified = false
            }
            // Predict ticket classification if create ticket without classifier (ex: from mobile app)
            if (isCreateOperation && resolvedData.details && !resolvedData.classifier) {
                const classifierResult = await classifyTicket(context, resolvedData.details)

                const classifierResultId = get(classifierResult, 'id')

                if (classifierResultId) {
                    resolvedData.classifier = classifierResultId
                    resolvedData.isAutoClassified = true
                }
            }

            if (resolvedStatusId) {
                calculateTicketOrder(resolvedData, resolvedStatusId)

                const resolvedStatus = await getById('TicketStatus', resolvedStatusId)
                let existedStatus = null
                if (existedStatusId) {
                    existedStatus = await getById('TicketStatus', existedStatusId)

                    await calculateReopenedCounter(context, existingItem, resolvedData, existedStatus, resolvedStatus)
                    calculateStatusUpdatedAt(resolvedData, existedStatusId, resolvedStatusId)
                    calculateDeferredUntil(resolvedData, existedStatus, resolvedStatus)
                }
                calculateCompletedAt(resolvedData, existedStatus, resolvedStatus)
            }

            if (userType === RESIDENT && isCreateOperation) {
                overrideTicketFieldsForResidentUserType(context, resolvedData)
                await setSectionAndFloorFieldsByDataFromPropertyMap(context, resolvedData)
                setClientNamePhoneEmailFieldsByDataFromUser(get(context, ['req', 'user']), resolvedData)
                await setDeadline(resolvedData)
            }

            calculateIsCompletedAfterDeadline(resolvedData, existingItem)
            await connectContactToTicket(context, resolvedData, existingItem)

            // When creating ticket or updating ticket address,
            // if client is not passed in resolvedData,
            // we find a registered user with a phone number that matches the contact's phone number
            // and an address that matches the ticket address.
            if (userType !== RESIDENT && isNull(resolvedClient)) {
                const contactId = get(resolvedData, 'contact', null)
                const propertyId = get(resolvedData, 'property', null)
                const unitName = get(resolvedData, 'unitName', null)

                if (!isNull(contactId) || !isNull(propertyId) || !isNull(unitName)) {
                    await setClientIfContactPhoneAndTicketAddressMatchesResidentFields(operation, resolvedData, existingItem)
                }
            }

            const propertyId = get(newItem, 'property', null)
            if (!propertyId) {
                throw new Error(`${PROPERTY_REQUIRED_ERROR}] empty property for ticket`)
            }
            const property = await getByCondition('Property', {
                id: propertyId,
                deletedAt: null,
            })
            // If property was soft- or hard-deleted = keep existing data = don't modify propertyAddress and propertyAddressMeta
            if (property) {
                resolvedData.propertyAddress = property.address
                resolvedData.propertyAddressMeta = property.addressMeta
            }

            if (resolvedData.contact) {
                const contact = await Contact.getOne(context, { id: resolvedData.contact }, 'name email phone')

                if (!resolvedData.clientName) resolvedData.clientName = contact.name
                if (!resolvedData.clientEmail) resolvedData.clientEmail = contact.email
                if (!resolvedData.clientPhone) resolvedData.clientPhone = contact.phone
            }
            if (resolvedData.classifier) {
                const classifier = await getById('TicketClassifier', resolvedData.classifier)

                resolvedData.placeClassifier = get(classifier, 'place', null)
                resolvedData.problemClassifier = get(classifier, 'problem', null)
                resolvedData.categoryClassifier = get(classifier, 'category', null)
            }

            if ('qualityControlValue' in resolvedData || 'qualityControlComment' in resolvedData || 'qualityControlAdditionalOptions' in resolvedData) {
                resolvedData.qualityControlUpdatedAt = dayjs().toISOString()
                if (userId) {
                    resolvedData.qualityControlUpdatedBy = userId
                }
            }

            const hasUpdatedFeedbackFields = 'feedbackValue' in resolvedData || 'feedbackComment' in resolvedData || 'feedbackAdditionalOptions' in resolvedData
            if (hasUpdatedFeedbackFields) {
                resolvedData.feedbackUpdatedAt = dayjs().toISOString()
            }

            return resolvedData
        },
        validateInput: async ({ resolvedData, existingItem, addValidationError, context, operation, originalInput }) => {
            // Todo(zuch): add placeClassifier, categoryClassifier and classifierRule
            if (!hasDbFields(['organization', 'source', 'status', 'details'], resolvedData, existingItem, context, addValidationError)) return

            const user = get(context, ['req', 'user'])
            const userType = get(user, 'type')

            if (userType === RESIDENT && operation === 'create') {
                const locale = extractReqLocale(context.req) || conf.DEFAULT_LOCALE
                await checkDailyTicketLimit({
                    userId: get(user, 'id'),
                    organizationId: get(resolvedData, 'organization'),
                    details: get(resolvedData, 'details'),
                    isInvoiceTicket: get(resolvedData, 'details') === i18n('marketplace.invoice.newTicket.details', { locale }),
                    isPayable: get(resolvedData, 'isPayable'),
                    context,
                })
            }

            const newItem = { ...existingItem, ...resolvedData }
            const resolvedStatus = await getById('TicketStatus', newItem.status)

            if (newItem.deferredUntil) {
                if (operation === 'create') {
                    if (resolvedStatus.type !== DEFERRED_STATUS_TYPE) {
                        return addValidationError(`${WRONG_VALUE} should not create ticket with "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE}`)
                    }
                }

                if (operation === 'update') {
                    const existingStatus = await getById('TicketStatus', existingItem.status)
                    // we shouldn't change the deferredUntil field unless it's for deferred tickets (before or after update)
                    if (originalInput.deferredUntil && existingStatus.type !== DEFERRED_STATUS_TYPE && resolvedStatus.type !== DEFERRED_STATUS_TYPE) {
                        return addValidationError(`${WRONG_VALUE} should not change "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE} before or after changes`)
                    }
                }
            }

            const qualityControlAdditionalOptions = get(newItem, 'qualityControlAdditionalOptions')

            if ((!isEmpty(qualityControlAdditionalOptions) || !!newItem.qualityControlComment) && !newItem.qualityControlValue) {
                throw new GQLError(ERRORS.QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED, context)
            }

            const feedbackAdditionalOptions = get(newItem, 'feedbackAdditionalOptions')

            if ((!isEmpty(feedbackAdditionalOptions) || !!newItem.feedbackComment) && !newItem.feedbackValue) {
                throw new GQLError(ERRORS.FEEDBACK_VALUE_MUST_BE_SPECIFIED, context)
            }

            if (!newItem.deferredUntil && resolvedStatus.type === DEFERRED_STATUS_TYPE) {
                return addValidationError(`${WRONG_VALUE} deferredUntil is null, but status type is ${DEFERRED_STATUS_TYPE}`)
            }
        },
        // `beforeChange` cannot be used, because data can be manipulated during updating process somewhere inside a ticket
        // We need a final result after update
        afterChange: async (...args) => {
            /**
             * Creates a new TicketChange item.
             * 👉 When a new "single" or "many" relation field will be added to Ticket,
             * new resolver should be implemented in `ticketChangeDisplayNameResolversForSingleRelations` and `relatedManyToManyResolvers`
             */
            const { property, unitName, sectionName, sectionType, unitType, floorName, classifier } = Ticket.schema.fields

            const [requestData] = args

            const { existingItem, updatedItem, operation, context } = requestData

            if (operation === 'update') {
                const ticketId = updatedItem.id
                const isPropertyChanged = existingItem.property !== updatedItem.property
                const isUnitChanged = existingItem.unitName !== updatedItem.unitName || existingItem.unitType !== updatedItem.unitType
                const isClientInfoChanged = existingItem.clientName !== updatedItem.clientName || existingItem.clientPhone !== updatedItem.clientPhone
                const isTicketCanceled = existingItem.status !== STATUS_IDS.DECLINED && updatedItem.status === STATUS_IDS.DECLINED

                if (isPropertyChanged || isUnitChanged || isClientInfoChanged || isTicketCanceled) {
                    const invoicesWithTicket = await find('Invoice', {
                        ticket: { id: ticketId },
                        status_in: [INVOICE_STATUS_PUBLISHED, INVOICE_STATUS_DRAFT],
                        deletedAt: null,
                    })

                    const updateInvoicePayload = { dv: updatedItem.dv, sender: updatedItem.sender }
                    if (isPropertyChanged) {
                        updateInvoicePayload['property'] = { connect: { id: updatedItem.property } }
                    }
                    if (isUnitChanged) {
                        updateInvoicePayload['unitName'] = updatedItem.unitName
                        updateInvoicePayload['unitType'] = updatedItem.unitType
                    }
                    if (isClientInfoChanged) {
                        updateInvoicePayload['clientName'] = updatedItem.clientName
                        updateInvoicePayload['clientPhone'] = updatedItem.clientPhone
                    }

                    for (const invoice of invoicesWithTicket) {
                        await Invoice.update(context, invoice.id, updateInvoicePayload)
                    }
                }

                if (isTicketCanceled) {
                    const invoicesWithTicket = await find('Invoice', {
                        ticket: { id: ticketId },
                        status_not_in: [INVOICE_STATUS_PAID, INVOICE_STATUS_CANCELED],
                        deletedAt: null,
                    })

                    for (const invoice of invoicesWithTicket) {
                        await Invoice.update(context, invoice.id, {
                            status: INVOICE_STATUS_CANCELED,
                            dv: updatedItem.dv,
                            sender: updatedItem.sender,
                        })
                    }
                }
            }

            await storeChangesIfUpdated(
                buildSetOfFieldsToTrackFrom(Ticket.schema, { except: OMIT_TICKET_CHANGE_TRACKABLE_FIELDS }),
                createTicketChange,
                ticketChangeDisplayNameResolversForSingleRelations,
                relatedManyToManyResolvers,
                [
                    { property, unitName, sectionName, sectionType, unitType, floorName },
                    { classifier },
                ]
            )(...args)

            /* NOTE: this sends different kinds of notifications on ticket create/update except bulk update operation */
            const isBulkOperation = Array.isArray(get(context, ['req', 'body', 'variables', 'data'], null))
            if (!isBulkOperation) {
                await sendTicketChangedNotifications.delay({ ticketId: updatedItem.id, existingItem, operation })
            }
        },
    },
    access: {
        read: access.canReadTickets,
        create: access.canManageTickets,
        update: access.canManageTickets,
        delete: false,
        auth: true,
    },
    kmigratorOptions: {
        indexes: [
            // NOTE: popular filter on /ticket page
            {
                type: 'BTreeIndex',
                fields: ['unitName'],
                name: 'ticket_unitName',
            },
            // NOTE: used on /ticket page for "Own Tickets" fitler
            {
                type: 'BTreeIndex',
                fields: ['organization', 'assignee', 'executor', 'deletedAt'],
                name: 'ticket_org_assign_exec_deletedAt',
            },
            // NOTE: popular filter on /ticket page
            {
                type: 'BTreeIndex',
                fields: ['organization', 'status'],
                name: 'ticket_organization_status',
            },
            // NOTE: default CRM sorting on /ticket page 
            {
                type: 'BTreeIndex',
                fields: ['order', '-createdAt'],
                name: 'ticket_order_createdat',
            },
        ],
    },
})

module.exports = {
    Ticket,
    ERRORS,
    DAILY_TICKET_LIMIT,
    DAILY_SAME_TICKET_LIMIT,
}
