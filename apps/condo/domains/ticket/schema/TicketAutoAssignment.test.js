/**
 * Generated by `createschema ticket.TicketAutoAssignment 'assignee:Relationship:OrganizationEmployee:SET_NULL;executor:Relationship:OrganizationEmployee:SET_NULL;classifier:Relationship:TicketClassifier:CASCADE;'`
 */

const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowGQLError,
    expectToThrowUniqueConstraintViolationError,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const {
    makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    OrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const {
    TicketAutoAssignment,
    createTestTicketAutoAssignment,
    updateTestTicketAutoAssignment,
    createTestTicketClassifier,
    TicketClassifier,
    TicketCategoryClassifier,
    TicketPlaceClassifier,
    TicketProblemClassifier,
} = require('@condo/domains/ticket/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    registerNewUser,
} = require('@condo/domains/user/utils/testSchema')

const { ERRORS } = require('./TicketAutoAssignment')


describe('TicketAutoAssignment', () => {

    let admin, support, employeeWithPermission, employeeWithoutPermission, user, anonymous,
        organization, classifier, assignee, executor, otherClassifier,
        ticketAutoAssignment
    const classifiersToDelete = []

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()

        const { organization: createdOrganization, userClient, role } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({ canManageTickets: true })
        employeeWithPermission = userClient
        organization = createdOrganization

        const [roleWithoutPermissions] = await createTestOrganizationEmployeeRole(admin, organization, { canManageTickets: false })
        employeeWithoutPermission = await makeClientWithNewRegisteredAndLoggedInUser()
        await createTestOrganizationEmployee(admin, organization, employeeWithoutPermission.user, roleWithoutPermissions)

        const [assigneeUser] = await registerNewUser(await makeClient());
        [assignee] = await createTestOrganizationEmployee(admin, organization, assigneeUser, role)
        const [executorUser] = await registerNewUser(await makeClient());
        [executor] = await createTestOrganizationEmployee(admin, organization, executorUser, role);

        [classifier] = await createTestTicketClassifier(admin);
        [otherClassifier] = await createTestTicketClassifier(admin)
        classifiersToDelete.push(classifier, otherClassifier)
    })

    beforeEach(async () => {
        [ticketAutoAssignment] = await createTestTicketAutoAssignment(admin, organization, assignee, executor, classifier)
    })

    afterEach(async () => {
        const items = await TicketAutoAssignment.getAll(admin, { organization: { id: organization.id }, deletedAt: null })
        for (const item of items) {
            await TicketAutoAssignment.softDelete(admin, item.id)
        }
    })

    afterAll(async () => {
        for (const classifier of classifiersToDelete) {
            await TicketPlaceClassifier.delete(admin, classifier.place.id)
            await TicketCategoryClassifier.delete(admin, classifier.category.id)
            await TicketProblemClassifier.delete(admin, classifier.problem.id)
            await TicketClassifier.delete(admin, classifier.id)
        }
    })

    describe('Accesses', () => {
        describe('Admin', () => {
            test('can create', async () => {
                const [ticketAutoAssignment] = await createTestTicketAutoAssignment(admin, organization, assignee, executor, otherClassifier)
                expect(ticketAutoAssignment).toBeDefined()
                expect(ticketAutoAssignment).toHaveProperty('organization.id', organization.id)
                expect(ticketAutoAssignment).toHaveProperty('assignee.id', assignee.id)
                expect(ticketAutoAssignment).toHaveProperty('executor.id', executor.id)
                expect(ticketAutoAssignment).toHaveProperty('classifier.id', otherClassifier.id)
            })

            test('can read', async () => {
                const item = await TicketAutoAssignment.getOne(admin, { id: ticketAutoAssignment.id })
                expect(item).toHaveProperty('id', ticketAutoAssignment.id)
            })

            test('can update', async () => {
                const [updatedItem] = await updateTestTicketAutoAssignment(admin, ticketAutoAssignment.id)
                expect(updatedItem).toHaveProperty('id', ticketAutoAssignment.id)
                expect(updatedItem).toHaveProperty('sender.fingerprint', expect.not.stringMatching(ticketAutoAssignment.sender.fingerprint))
            })

            test('can soft-delete', async () => {
                const [updatedItem] = await TicketAutoAssignment.softDelete(admin, ticketAutoAssignment.id)
                expect(updatedItem).toHaveProperty('id', ticketAutoAssignment.id)
                expect(updatedItem.deletedAt).not.toBeNull()
            })

            test('cannot hard-delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await TicketAutoAssignment.delete(admin, ticketAutoAssignment.id)
                })
            })
        })

        describe('Support', () => {
            test('can create', async () => {
                const [ticketAutoAssignment] = await createTestTicketAutoAssignment(support, organization, assignee, executor, otherClassifier)
                expect(ticketAutoAssignment).toBeDefined()
            })

            test('can read', async () => {
                const item = await TicketAutoAssignment.getOne(support, { id: ticketAutoAssignment.id })
                expect(item).toHaveProperty('id', ticketAutoAssignment.id)
            })

            test('can update', async () => {
                const [updatedItem] = await updateTestTicketAutoAssignment(support, ticketAutoAssignment.id)
                expect(updatedItem).toHaveProperty('id', ticketAutoAssignment.id)
                expect(updatedItem).toHaveProperty('sender.fingerprint', expect.not.stringMatching(ticketAutoAssignment.sender.fingerprint))
            })

            test('can soft-delete', async () => {
                const [updatedItem] = await TicketAutoAssignment.softDelete(support, ticketAutoAssignment.id)
                expect(updatedItem).toHaveProperty('id', ticketAutoAssignment.id)
                expect(updatedItem.deletedAt).not.toBeNull()
            })

            test('cannot hard-delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await TicketAutoAssignment.delete(support, ticketAutoAssignment.id)
                })
            })
        })

        describe('Employee', () => {
            test('cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestTicketAutoAssignment(employeeWithPermission, organization, assignee, executor, otherClassifier)
                })
            })

            describe('read', () => {
                test('can with permission canManageTickets', async () => {
                    const item = await TicketAutoAssignment.getOne(employeeWithPermission, { id: ticketAutoAssignment.id })
                    expect(item).toBeDefined()
                })

                test('can not without permission canManageTickets', async () => {
                    const item = await TicketAutoAssignment.getOne(employeeWithoutPermission, { id: ticketAutoAssignment.id })
                    expect(item).toBeUndefined()
                })
            })

            test('cannot update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestTicketAutoAssignment(employeeWithPermission, ticketAutoAssignment.id)
                })
            })

            test('cannot soft-delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await TicketAutoAssignment.softDelete(employeeWithPermission, ticketAutoAssignment.id)
                })
            })

            test('cannot hard-delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await TicketAutoAssignment.delete(employeeWithPermission, ticketAutoAssignment.id)
                })
            })
        })

        describe('User', () => {
            test('cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestTicketAutoAssignment(user, organization, assignee, executor, otherClassifier)
                })
            })

            test('cannot read', async () => {
                const item = await TicketAutoAssignment.getOne(user, { id: ticketAutoAssignment.id })
                expect(item).toBeUndefined()
            })

            test('cannot update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestTicketAutoAssignment(user, ticketAutoAssignment.id)
                })
            })

            test('cannot soft-delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await TicketAutoAssignment.softDelete(user, ticketAutoAssignment.id)
                })
            })

            test('cannot hard-delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await TicketAutoAssignment.delete(user, ticketAutoAssignment.id)
                })
            })
        })

        describe('Anonymous', () => {
            test('cannot create', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestTicketAutoAssignment(anonymous, organization, assignee, executor, otherClassifier)
                })
            })

            test('cannot read', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await TicketAutoAssignment.getOne(anonymous, { id: ticketAutoAssignment.id })
                })
            })

            test('cannot update', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestTicketAutoAssignment(anonymous, ticketAutoAssignment.id)
                })
            })

            test('cannot soft-delete', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await TicketAutoAssignment.softDelete(anonymous, ticketAutoAssignment.id)
                })
            })

            test('cannot hard-delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await TicketAutoAssignment.delete(anonymous, ticketAutoAssignment.id)
                })
            })
        })
    })

    describe('Validations', () => {
        test('should be throw error if assignee are not from organization', async () => {
            const { employee: employeeFromOtherOrganization } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee()
            await expectToThrowGQLError(async () => {
                await createTestTicketAutoAssignment(admin, organization, employeeFromOtherOrganization, null, otherClassifier)
            }, ERRORS.ASSIGNEE_NOT_FOUND)
            await expectToThrowGQLError(async () => {
                await updateTestTicketAutoAssignment(admin, ticketAutoAssignment.id, {
                    assignee: { connect: { id: employeeFromOtherOrganization.id } },
                })
            }, ERRORS.ASSIGNEE_NOT_FOUND)
        })

        test('should be throw error if executor are not from organization', async () => {
            const { employee: employeeFromOtherOrganization } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee()
            await expectToThrowGQLError(async () => {
                await createTestTicketAutoAssignment(admin, organization, null, employeeFromOtherOrganization, otherClassifier)
            }, ERRORS.EXECUTOR_NOT_FOUND)
            await expectToThrowGQLError(async () => {
                await updateTestTicketAutoAssignment(admin, ticketAutoAssignment.id, {
                    executor: { connect: { id: employeeFromOtherOrganization.id } },
                })
            }, ERRORS.EXECUTOR_NOT_FOUND)
        })

        test('should be create/update record if assignee and executor are from organization', async () => {
            const [item] = await createTestTicketAutoAssignment(admin, organization, assignee, executor, otherClassifier)
            expect(item).toBeDefined()

            const employeeFromSameOrganization = await OrganizationEmployee.getOne(admin, {
                organization: { id: organization.id },
                user: { id: employeeWithPermission.user.id },
            })
            const [updatedItem] = await updateTestTicketAutoAssignment(admin, item.id, {
                assignee: { connect: { id: employeeFromSameOrganization.id } },
                executor: { connect: { id: employeeFromSameOrganization.id } },
            })
            expect(updatedItem).toHaveProperty('id', item.id)
            expect(updatedItem).toHaveProperty('assignee.id', employeeFromSameOrganization.id)
            expect(updatedItem).toHaveProperty('executor.id', employeeFromSameOrganization.id)
        })

        test('should be throw error if classifier is duplicating in organization', async () => {
            await createTestTicketAutoAssignment(admin, organization, assignee, executor, otherClassifier)
            await expectToThrowUniqueConstraintViolationError(async () => {
                await createTestTicketAutoAssignment(admin, organization, assignee, executor, otherClassifier)
            }, 'ticket_auto_assignment_unique_organization_classifier')
        })
    })
})
