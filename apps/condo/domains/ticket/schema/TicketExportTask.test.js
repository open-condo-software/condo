/**
 * Generated by `createschema ticket.TicketExportTask 'status:Select:processing,completed,error; format:Select:excel; exportedRecordsCount:Integer; totalRecordsCount:Integer; file?:File; meta?:Json'`
 */
const { get, difference } = require('lodash')
const os = require('os')
const xlsx = require('xlsx')
const fs = require('fs')
const dayjs = require('dayjs')
const fetch = require('node-fetch')

const conf = require('@condo/config')
const { i18n } = require('@condo/locales/loader')
const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, waitFor, getRandomString } = require('@condo/keystone/test.utils')

const { TicketExportTask, createTestTicketExportTask, updateTestTicketExportTask, createTestTicket } = require('@condo/domains/ticket/utils/testSchema')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
} = require('@condo/domains/common/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')
const { EXPORT_STATUS_VALUES, PROCESSING, CANCELLED, EXPORT_PROCESSING_BATCH_SIZE, EXCEL } = require('@condo/domains/common/constants/export')
const { createTestOrganization, createTestOrganizationEmployeeRole, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')

const { TicketStatus } = require('../utils/testSchema')

describe('TicketExportTask', () => {
    describe('validations', () => {
        test.todo('cannot have PROCESSING status on create')
    })

    describe('Create', () => {
        it('cannot be created by anonymous', async () => {
            const anonymousClient = await makeClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestTicketExportTask(anonymousClient, userClient.user)
            })
        })

        it('cannot be created by user for another user', async () => {
            const firstUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const secondUserClient = await makeClientWithNewRegisteredAndLoggedInUser()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketExportTask(firstUserClient, secondUserClient.user)
            })
        })

        it('can be created by user for itself', async () => {
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

            const [obj, attrs] = await createTestTicketExportTask(userClient, userClient.user)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
        })

        it('cannot be created by user for nobody', async () => {
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketExportTask(userClient, userClient.user, { user: null })
            })
        })

        it('can be created by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()

            const [obj, attrs] = await createTestTicketExportTask(adminClient, adminClient.user)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
        })
    })

    describe('Read', () => {
        it('can be read by user who is associated with this record', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient1 = await makeClientWithNewRegisteredAndLoggedInUser()
            const userClient2 = await makeClientWithNewRegisteredAndLoggedInUser()
            const userClient3 = await makeClientWithNewRegisteredAndLoggedInUser()

            const [obj1] = await createTestTicketExportTask(adminClient, userClient1.user)
            const [obj2] = await createTestTicketExportTask(adminClient, userClient2.user)

            const records1 = await TicketExportTask.getAll(userClient1)
            expect(records1).toHaveLength(1)
            expect(records1[0].id).toEqual(obj1.id)

            const records2 = await TicketExportTask.getAll(userClient2)
            expect(records2).toHaveLength(1)
            expect(records2[0].id).toEqual(obj2.id)

            const records3 = await TicketExportTask.getAll(userClient3)
            expect(records3).toHaveLength(0)
        })

        it('can be read by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

            await createTestTicketExportTask(adminClient, adminClient.user)
            await createTestTicketExportTask(adminClient, userClient.user)

            const records = await TicketExportTask.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })
            expect(records.length).toBeGreaterThanOrEqual(2)
        })

        it('cannot be read by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const anonymousClient = await makeClient()

            await createTestTicketExportTask(adminClient, adminClient.user)

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await TicketExportTask.getAll(anonymousClient)
            })
        })
    })

    describe('Update', () => {
        it('can be updated by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const [obj, attrs] = await createTestTicketExportTask(adminClient, adminClient.user)
            const newAttrs = {
                status: difference(EXPORT_STATUS_VALUES, [attrs.status])[0],
            }
            const [updatedObj] = await updateTestTicketExportTask(adminClient, obj.id, newAttrs)
            expect(updatedObj.status).toEqual(newAttrs.status)
        })

        it('can be updated by user with specifying "cancelled" value for "status" field', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user, {
                status: PROCESSING,
            })
            const [objUpdated] = await updateTestTicketExportTask(userClient, obj.id, { status: CANCELLED })
            expect(objUpdated.status).toEqual(CANCELLED)
        })

        const forbiddenFieldsToUpdateByUser = {
            exportedRecordsCount: 99,
            format: 'excel',
            totalRecordsCount: 99,
            meta: {},
            where: {},
            sortBy: ['order_ASC', 'createdAt_DESC'],
            locale: 'en',
            timeZone: 'Europe/Moscow',
            user: { connect: { id: '123' } },
        }

        test.each(Object.keys(forbiddenFieldsToUpdateByUser))('cannot be updated by user with specifying value for %p field', async (field) => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user, {
                status: PROCESSING,
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicketExportTask(userClient, obj.id, { [field]: forbiddenFieldsToUpdateByUser[field] })
            })
        })

        it('cannot be updated by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const anonymousClient = await makeClient()
            const [obj, attrs] = await createTestTicketExportTask(adminClient, adminClient.user)
            const newAttrs = {
                status: difference(EXPORT_STATUS_VALUES, [attrs.status])[0],
            }
            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestTicketExportTask(anonymousClient, obj.id, newAttrs)
            })
        })
    })

    describe('Delete', () => {

        it('can be soft-deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)

            const [objUpdated] = await TicketExportTask.softDelete(adminClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('cannot be soft-deleted by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketExportTask.softDelete(userClient, obj.id)
            })
        })

        it('cannot be soft-deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const anonymousClient = await makeClient()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAuthenticationErrorToObj(async () => {
                await TicketExportTask.softDelete(anonymousClient, obj.id)
            })
        })

        it('cannot be deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketExportTask.delete(adminClient, obj.id)
            })
        })

        it('cannot be deleted by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketExportTask.delete(userClient, obj.id)
            })
        })

        it('cannot be deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const anonymousClient = await makeClient()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketExportTask.delete(anonymousClient, obj.id)
            })
        })
    })

})

const downloadFile = async (url, path) => {
    const res = await fetch(url)
    if (res.status !== 200) throw new Error(`downloadFile(): status=${res.status}`)
    const buffer = await res.buffer()
    fs.writeFileSync(path, buffer)
}

const readXlsx = async (path) => {
    const workbook = xlsx.readFile(path)
    const sheet = workbook.Sheets[workbook.SheetNames[0]]
    return xlsx.utils.sheet_to_json(sheet, { header: 1, defval: '' }).filter(x => x.join(''))
}

const expectDataFormat = (data, res) => {
    expect(JSON.stringify(data, null, 2)).toEqual(JSON.stringify(res, null, 2))
}

describe('exportTickets', () => {
    it('create `TicketExportTask` and check the result xlsx file format', async () => {
        const locale = 'ru'
        const timeZone = 'Europe/Moscow'
        const adminClient = await makeLoggedInAdminClient()
        const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)
        const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
            canManageTickets: true,
            canManageTicketComments: true,
        })
        await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

        const ticketsCountFor2Chunks = Math.floor(EXPORT_PROCESSING_BATCH_SIZE * 1.5)
        const tickets = []
        for (let i = ticketsCountFor2Chunks; i > 0; i--) {
            const [ticket] = await createTestTicket(userClient, organization, property)
            tickets.push(ticket)
        }

        const [task] = await createTestTicketExportTask(userClient, userClient.user, {
            format: EXCEL,
            where: {
                organization: { id: organization.id },
            },
            sortBy: 'createdAt_ASC',
            locale,
            timeZone,
            status: PROCESSING,
        })

        await waitFor(async () => {
            const updatedTask = await TicketExportTask.getOne(userClient, { id: task.id })
            expect(updatedTask.file).toBeDefined()
            expect(updatedTask.file.publicUrl.length > 1).toBeTruthy()
            expect(updatedTask.exportedRecordsCount).toEqual(ticketsCountFor2Chunks)
            expect(updatedTask.totalRecordsCount).toEqual(ticketsCountFor2Chunks)
            expect(updatedTask.status).toEqual('completed')
        })

        // check excel format!
        const updatedTask = await TicketExportTask.getOne(userClient, { id: task.id })
        const url = updatedTask.file.publicUrl.replace(conf.SERVER_URL, userClient.serverUrl)
        const filename = `${os.tmpdir()}/${getRandomString()}.xlsx`
        await downloadFile(url, filename)
        const data = await readXlsx(filename)

        const empty = '—'
        const formatDate = (date) => dayjs(date).tz(timeZone).format('DD.MM.YYYY HH:mm')
        const YesMessage = i18n('Yes', { locale })
        const NoMessage = i18n('No', { locale })
        const statuses = await TicketStatus.getAll(userClient, {})
        const indexedStatuses = Object.fromEntries(statuses.map(status => ([status.type, status.name])))

        expectDataFormat(data, [
            ['Заявки за всё время', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            ['Номер заявки', 'Источник', 'Наименование УК', 'Адрес', 'Помещение', 'Тип помещения', 'Подъезд', 'Этаж', 'ФИО заявителя', 'Заявитель', 'Телефон', 'Описание проблемы', 'Аварийная', 'Платная', 'Гарантийная', 'Место инцидента', 'Тип работ', 'В чём проблема', 'Зарегистрирована', 'Поступила в работу', 'Выполнена', 'Закрыта', 'Дата изменения', 'Статус', 'Отложена до', 'Автор заявки', 'Исполнитель', 'Ответственный', 'Коммент. внутренний', 'Коммент. с жителем', 'Выполнить до', 'Оценка заявки', 'Комментарий к оценке', 'Возвратов заявки'],
            ...(tickets.map(ticket => [
                String(ticket.number),
                ticket.source.name,
                ticket.organization.name,
                ticket.property.address,
                ticket.unitName,
                ticket.unitType ? i18n(`pages.condo.ticket.field.unitType.${ticket.unitType}`, { locale }) : '',
                (ticket.sectionType && ticket.sectionName) ? `${i18n(`field.sectionType.${ticket.sectionType}`, { locale })} ${ticket.sectionName}` : '',
                ticket.floorName || '',
                ticket.clientName || '',
                ticket.contact ? i18n('excelExport.tickets.ticketFromResident', { locale }) : i18n('excelExport.tickets.ticketFromNonResident', { locale }),
                ticket.clientPhone || '',
                ticket.details,
                ticket.isEmergency ? YesMessage : NoMessage,
                ticket.isPaid ? YesMessage : NoMessage,
                ticket.isWarranty ? YesMessage : NoMessage,
                get(ticket, 'classifier.place.name', empty),
                get(ticket, 'classifier.category.name', empty),
                get(ticket, 'classifier.problem.name', empty),
                formatDate(ticket.createdAt),
                ticket.startedAt ? formatDate(ticket.startedAt) : empty,
                ticket.completedAt ? formatDate(ticket.completedAt) : empty,
                ticket.closedAt ? formatDate(ticket.closedAt) : empty,
                formatDate(ticket.updatedAt),
                indexedStatuses[ticket.status.type],
                ticket.deferredUntil ? formatDate(ticket.deferredUntil) : empty,
                ticket.operator && ticket.operator.name || ticket.createdBy.name || empty,
                ticket.executor && ticket.executor.name || empty,
                ticket.assignee && ticket.assignee.name || empty,
                empty, // organizationComments
                empty, // residentComments
                ticket.deadline ? formatDate(ticket.deadline) : empty,
                ticket.reviewValue || empty,
                ticket.reviewComment || empty,
                ticket.statusReopenedCounter || empty,
            ])),
        ])
    })
})
