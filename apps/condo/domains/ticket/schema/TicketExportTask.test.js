/**
 * Generated by `createschema ticket.TicketExportTask 'status:Select:processing,completed,error; format:Select:excel; exportedRecordsCount:Integer; totalRecordsCount:Integer; file?:File; meta?:Json'`
 */
const dayjs = require('dayjs')
const difference = require('lodash/difference')
const get = require('lodash/get')
const conf = require('@open-condo/config')
const { i18n } = require('@open-condo/locales/loader')
const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, waitFor } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects, catchErrorFrom, expectToThrowValidationFailureError,
} = require('@open-condo/keystone/test.utils')
const { EXPORT_STATUS_VALUES, CANCELLED, EXPORT_PROCESSING_BATCH_SIZE, EXCEL } = require('@condo/domains/common/constants/export')
const { downloadFile, readXlsx, expectDataFormat, getTmpFile } = require('@condo/domains/common/utils/testSchema/file')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { TicketExportTask, createTestTicketExportTask, updateTestTicketExportTask, TicketStatus, createTestTicket } = require('@condo/domains/ticket/utils/testSchema')
const { createTestOrganizationWithAccessToAnotherOrganization } = require('@condo/domains/organization/utils/testSchema')

describe('TicketExportTask', () => {
    describe('validations', () => {
        it('throw error if you trying to change status of already completed export', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTickets: true,
                canManageTicketComments: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

            const [obj] = await createTestTicketExportTask(userClient, userClient.user, {
                where: {
                    organization: {
                        id: organization.id,
                    },
                },
                // We need actual data here to get `exportTickets` worker succesfully be executed
                // Without `sortBy`, a `GqlWithKnexLoadList.loadChunk` util will be executed with error
                sortBy: 'createdAt_ASC',
                locale: 'ru',
                timeZone: 'Europe/Moscow',
            })
            // Worker `exportTickets`, that is launched in `afterChange` hook of `TicketExportTask`, will update this task to `COMPLETED` status
            await waitFor(async () => {
                const updatedTaskByWorker = await TicketExportTask.getOne(userClient, { id: obj.id })
                expect(updatedTaskByWorker.status).toEqual('completed')
            })

            await expectToThrowValidationFailureError(
                async () => await updateTestTicketExportTask(userClient, obj.id, { status: CANCELLED }),
                'status is already completed',
            )
        })
    })

    describe('Create', () => {
        it('cannot be created by anonymous', async () => {
            const anonymousClient = await makeClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestTicketExportTask(anonymousClient, userClient.user)
            })
        })

        it('cannot be created by user for another user', async () => {
            const firstUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const secondUserClient = await makeClientWithNewRegisteredAndLoggedInUser()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketExportTask(firstUserClient, secondUserClient.user)
            })
        })

        it('can be created by user for itself', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTickets: true,
                canManageTicketComments: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

            const [obj, attrs] = await createTestTicketExportTask(userClient, userClient.user, {
                where: {
                    organization: {
                        id: organization.id,
                    },
                },
            })
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
        })

        it('cannot be created if user does not belongs to requested organization in `where` field of `TicketExportTask`', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTickets: true,
                canManageTicketComments: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
            const [forbiddenOrganization] = await createTestOrganization(adminClient)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketExportTask(userClient, userClient.user, {
                    where: {
                        organization: { id: forbiddenOrganization.id },
                    },
                })
            })
        })

        it('can be created if user belongs as employee to requested organization in `where` field', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTickets: true,
                canManageTicketComments: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
            const [obj, attrs] = await createTestTicketExportTask(userClient, userClient.user, {
                where: {
                    organization: { id: organization.id },
                },
            })
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
        })

        it('can be created if user belongs as employee to all many requested organizations in `where` field', async () => {
            const {
                clientFrom: userClient,
                organizationTo,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [obj, attrs] = await createTestTicketExportTask(userClient, userClient.user, {
                where: {
                    // Check case when duplicated ids are specified in array, so, access checks should be resistant to it
                    organization: { id_in: [organizationTo.id, organizationFrom.id, organizationFrom.id] },
                },
            })
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
        })

        it('cannot be created if user belongs as employee to some of many requested organizations in `where` field', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const {
                clientFrom: userClient,
                organizationTo,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [forbiddenOrganization] = await createTestOrganization(adminClient)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketExportTask(userClient, userClient.user, {
                    where: {
                        organization: { id_in: [organizationTo.id, organizationFrom.id, forbiddenOrganization.id] },
                    },
                })
            })
        })

        it('cannot be created if `where.organization.id` value is not specified', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTickets: true,
                canManageTicketComments: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketExportTask(userClient, userClient.user, {
                    where: {
                        organization: { id: null },
                    },
                })
            })
        })

        it('cannot be created by user for nobody', async () => {
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketExportTask(userClient, userClient.user, { user: null })
            })
        })

        it('can be created by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()

            const [obj, attrs] = await createTestTicketExportTask(adminClient, adminClient.user)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
        })
    })

    describe('Read', () => {
        it('can be read by user who is associated with this record', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient1 = await makeClientWithNewRegisteredAndLoggedInUser()
            const userClient2 = await makeClientWithNewRegisteredAndLoggedInUser()
            const userClient3 = await makeClientWithNewRegisteredAndLoggedInUser()

            const [obj1] = await createTestTicketExportTask(adminClient, userClient1.user)
            const [obj2] = await createTestTicketExportTask(adminClient, userClient2.user)

            const records1 = await TicketExportTask.getAll(userClient1)
            expect(records1).toHaveLength(1)
            expect(records1[0].id).toEqual(obj1.id)

            const records2 = await TicketExportTask.getAll(userClient2)
            expect(records2).toHaveLength(1)
            expect(records2[0].id).toEqual(obj2.id)

            const records3 = await TicketExportTask.getAll(userClient3)
            expect(records3).toHaveLength(0)
        })

        it('can be read by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

            await createTestTicketExportTask(adminClient, adminClient.user)
            await createTestTicketExportTask(adminClient, userClient.user)

            const records = await TicketExportTask.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })
            expect(records.length).toBeGreaterThanOrEqual(2)
        })

        it('cannot be read by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const anonymousClient = await makeClient()

            await createTestTicketExportTask(adminClient, adminClient.user)

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await TicketExportTask.getAll(anonymousClient)
            })
        })
    })

    describe('Update', () => {
        it('cannot be updated by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const [obj, attrs] = await createTestTicketExportTask(adminClient, adminClient.user)
            const newAttrs = {
                status: difference(EXPORT_STATUS_VALUES, [attrs.status])[0],
            }
            const [updatedObj] = await updateTestTicketExportTask(adminClient, obj.id, newAttrs)
            expect(updatedObj.status).toEqual(newAttrs.status)
        })

        it('can be updated by user with specifying "cancelled" value for "status" field', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            const [objUpdated] = await updateTestTicketExportTask(userClient, obj.id, { status: CANCELLED })
            expect(objUpdated.status).toEqual(CANCELLED)
        })

        const forbiddenFieldsToUpdateByUser = {
            exportedRecordsCount: 99,
            totalRecordsCount: 99,
        }

        test.each(Object.keys(forbiddenFieldsToUpdateByUser))('restricts update value of %p field for user', async (field) => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicketExportTask(userClient, obj.id, { [field]: forbiddenFieldsToUpdateByUser[field] })
            })
        })

        const missingFieldsInUpdateInput = {
            meta: {},
            where: {},
            sortBy: ['order_ASC', 'createdAt_DESC'],
            locale: 'en',
            timeZone: 'Europe/Moscow',
            user: { connect: { id: '123' } },
        }

        test.each(Object.keys(missingFieldsInUpdateInput))('missing field %p in update input', async (field) => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await catchErrorFrom(async () => {
                await updateTestTicketExportTask(userClient, obj.id, { [field]: forbiddenFieldsToUpdateByUser[field] })
            }, ({ errors }) => {
                // TODO(antonal): figure out how to get name of restricted field
                expect(errors).toMatchObject([{
                    message: 'You do not have access to this resource',
                    name: 'AccessDeniedError',
                }])
            })
        })

        it('cannot be updated by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const anonymousClient = await makeClient()
            const [obj, attrs] = await createTestTicketExportTask(adminClient, adminClient.user)
            const newAttrs = {
                status: difference(EXPORT_STATUS_VALUES, [attrs.status])[0],
            }
            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestTicketExportTask(anonymousClient, obj.id, newAttrs)
            })
        })
    })

    describe('Delete', () => {

        it('can be soft-deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)

            const [objUpdated] = await TicketExportTask.softDelete(adminClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('cannot be soft-deleted by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketExportTask.softDelete(userClient, obj.id)
            })
        })

        it('cannot be soft-deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const anonymousClient = await makeClient()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAuthenticationErrorToObj(async () => {
                await TicketExportTask.softDelete(anonymousClient, obj.id)
            })
        })

        it('cannot be deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketExportTask.delete(adminClient, obj.id)
            })
        })

        it('cannot be deleted by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketExportTask.delete(userClient, obj.id)
            })
        })

        it('cannot be deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const anonymousClient = await makeClient()
            const [obj] = await createTestTicketExportTask(adminClient, adminClient.user)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketExportTask.delete(anonymousClient, obj.id)
            })
        })
    })
})

describe('exportTickets', () => {
    it('create `TicketExportTask` and check the result xlsx file format', async () => {
        const locale = 'ru'
        const timeZone = 'Europe/Moscow'
        const adminClient = await makeLoggedInAdminClient()
        const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)
        const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
            canManageTickets: true,
            canManageTicketComments: true,
        })
        await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

        const ticketsCountFor2Chunks = Math.floor(EXPORT_PROCESSING_BATCH_SIZE * 1.5)
        const tickets = []
        for (let i = ticketsCountFor2Chunks; i > 0; i--) {
            const [ticket] = await createTestTicket(userClient, organization, property)
            tickets.push(ticket)
        }

        const [task] = await createTestTicketExportTask(userClient, userClient.user, {
            format: EXCEL,
            where: {
                organization: { id: organization.id },
            },
            sortBy: 'createdAt_ASC',
            locale,
            timeZone,
        })

        await waitFor(async () => {
            const updatedTask = await TicketExportTask.getOne(userClient, { id: task.id })
            expect(updatedTask.file).toBeDefined()
            expect(updatedTask.file.publicUrl.length > 1).toBeTruthy()
            expect(updatedTask.exportedRecordsCount).toEqual(ticketsCountFor2Chunks)
            expect(updatedTask.totalRecordsCount).toEqual(ticketsCountFor2Chunks)
            expect(updatedTask.status).toEqual('completed')
        })

        // check excel format!
        const updatedTask = await TicketExportTask.getOne(userClient, { id: task.id })
        const url = updatedTask.file.publicUrl.replace(conf.SERVER_URL, userClient.serverUrl)
        const filename = getTmpFile('xlsx')
        await downloadFile(url, filename)
        const data = await readXlsx(filename)

        const empty = '—'
        const formatDate = (date) => dayjs(date).tz(timeZone).format('DD.MM.YYYY HH:mm')
        const YesMessage = i18n('Yes', { locale })
        const NoMessage = i18n('No', { locale })
        const statuses = await TicketStatus.getAll(userClient, {})
        const indexedStatuses = Object.fromEntries(statuses.map(status => ([status.type, status.name])))

        expectDataFormat(data, [
            ['Заявки за всё время', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            ['Номер заявки', 'Источник', 'Наименование УК', 'Адрес', 'Помещение', 'Тип помещения', 'Подъезд', 'Этаж', 'ФИО заявителя', 'Заявитель', 'Телефон', 'Описание проблемы', 'Аварийная', 'Платная', 'Гарантийная', 'Место инцидента', 'Тип работ', 'В чём проблема', 'Зарегистрирована', 'Поступила в работу', 'Выполнена', 'Закрыта', 'Дата изменения', 'Статус', 'Отложена до', 'Автор заявки', 'Исполнитель', 'Ответственный', 'Коммент. внутренний', 'Коммент. с жителем', 'Выполнить до', 'Оценка заявки', 'Комментарий к оценке', 'Возвратов заявки'],
            ...(tickets.map(ticket => [
                String(ticket.number),
                ticket.source.name,
                ticket.organization.name,
                ticket.property.address,
                ticket.unitName,
                ticket.unitType ? i18n(`pages.condo.ticket.field.unitType.${ticket.unitType}`, { locale }) : '',
                (ticket.sectionType && ticket.sectionName) ? `${i18n(`field.sectionType.${ticket.sectionType}`, { locale })} ${ticket.sectionName}` : '',
                ticket.floorName || '',
                ticket.clientName || '',
                ticket.contact ? i18n('excelExport.tickets.ticketFromResident', { locale }) : i18n('excelExport.tickets.ticketFromNonResident', { locale }),
                ticket.clientPhone || '',
                ticket.details,
                ticket.isEmergency ? YesMessage : NoMessage,
                ticket.isPaid ? YesMessage : NoMessage,
                ticket.isWarranty ? YesMessage : NoMessage,
                get(ticket, 'classifier.place.name', empty),
                get(ticket, 'classifier.category.name', empty),
                get(ticket, 'classifier.problem.name', empty),
                formatDate(ticket.createdAt),
                ticket.startedAt ? formatDate(ticket.startedAt) : empty,
                ticket.completedAt ? formatDate(ticket.completedAt) : empty,
                ticket.closedAt ? formatDate(ticket.closedAt) : empty,
                formatDate(ticket.updatedAt),
                indexedStatuses[ticket.status.type],
                ticket.deferredUntil ? formatDate(ticket.deferredUntil) : empty,
                ticket.operator && ticket.operator.name || ticket.createdBy.name || empty,
                ticket.executor && ticket.executor.name || empty,
                ticket.assignee && ticket.assignee.name || empty,
                empty, // organizationComments
                empty, // residentComments
                ticket.deadline ? formatDate(ticket.deadline) : empty,
                ticket.reviewValue || empty,
                ticket.reviewComment || empty,
                ticket.statusReopenedCounter || empty,
            ])),
        ])
    })
})