/**
 * Generated by `createschema ticket.CallRecord 'organization:Relationship:Organization:CASCADE;file?:File;callerPhone:Text;destCallerPhone:Text;talkTime:Integer;startDate:DateTimeUtc;isIncomingCall:Checkbox;callId:Text;'`
 */

const { Text, Relationship, Integer, Checkbox, DateTimeUtc, File } = require('@keystonejs/fields')

const { GQLError } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const FileAdapter = require('@condo/domains/common/utils/fileAdapter')
const { getFileMetaAfterChange } = require('@condo/domains/common/utils/fileAdapter')
const { normalizePhone } = require('@condo/domains/common/utils/phone')
const access = require('@condo/domains/ticket/access/CallRecord')
const { CALL_RECORD_ERRORS } = require('@condo/domains/ticket/constants/errors')

const TICKET_FILE_FOLDER_NAME = 'ticket-call-record'
const Adapter = new FileAdapter(TICKET_FILE_FOLDER_NAME)
const fileMetaAfterChange = getFileMetaAfterChange(Adapter)

const CallRecord = new GQLListSchema('CallRecord', {
    schemaDoc: 'Conversation record between operator and client',
    fields: {
        organization: {
            schemaDoc: 'Organization of the operator',
            type: Relationship,
            ref: 'Organization',
            isRequired: true,
            knexOptions: { isNotNullable: true },
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },
        file: {
            schemaDoc: 'Conversation file',
            type: File,
            adapter: Adapter,
        },
        callerPhone: {
            schemaDoc: 'Phone number of the person who called',
            type: Text,
            isRequired: true,
            hooks: {
                resolveInput: async ({ resolvedData }) => {
                    const newValue = normalizePhone(resolvedData['callerPhone'], true)
                    return newValue || resolvedData['callerPhone']
                },
            },
        },
        destCallerPhone: {
            schemaDoc: 'Phone number of the person to whom called',
            type: Text,
            isRequired: true,
            hooks: {
                resolveInput: async ({ resolvedData }) => {
                    const newValue = normalizePhone(resolvedData['destCallerPhone'], true)
                    return newValue || resolvedData['destCallerPhone']
                },
            },
        },
        talkTime: {
            schemaDoc: 'Time of conversation between operator and client (in seconds)',
            type: Integer,
            isRequired: true,
        },
        startedAt: {
            schemaDoc: 'Call start date in UTC',
            type: DateTimeUtc,
            isRequired: true,
        },
        isIncomingCall: {
            schemaDoc: 'Incoming or outgoing call for operator',
            type: Checkbox,
            isRequired: true,
        },
        callId: {
            schemaDoc: 'Call unique identifier',
            type: Text,
            isRequired: true,
        },
    },
    hooks: {
        validateInput: async ({ resolvedData }) => {
            const newCallerPhone = normalizePhone(resolvedData['callerPhone'], true)
            const newDestCallerPhone = normalizePhone(resolvedData['destCallerPhone'], true)

            if (resolvedData['callerPhone'] && newCallerPhone !== resolvedData['callerPhone']) {
                throw new GQLError(CALL_RECORD_ERRORS.INVALID_CALLER_PHONE_NUMBER_FORMAT)
            }
            if (resolvedData['destCallerPhone'] && newDestCallerPhone !== resolvedData['destCallerPhone']) {
                throw new GQLError(CALL_RECORD_ERRORS.INVALID_DEST_CALLER_PHONE_NUMBER_FORMAT)
            }
        },
        afterChange: fileMetaAfterChange,
        afterDelete: async ({ existingItem }) => {
            if (existingItem.file) {
                await Adapter.delete(existingItem.file)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadCallRecords,
        create: access.canManageCallRecords,
        update: access.canManageCallRecords,
        delete: false,
        auth: true,
    },
})

module.exports = {
    CallRecord,
}
