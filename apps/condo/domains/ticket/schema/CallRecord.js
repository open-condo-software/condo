/**
 * Generated by `createschema ticket.CallRecord 'organization:Relationship:Organization:CASCADE;file?:File;callerPhone:Text;destCallerPhone:Text;talkTime:Integer;startDate:DateTimeUtc;isIncomingCall:Checkbox;callId:Text;'`
 */

const { Text, Relationship, Integer, Checkbox, DateTimeUtc, File } = require('@keystonejs/fields')

const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const FileAdapter = require('@condo/domains/common/utils/fileAdapter')
const { getFileMetaAfterChange } = require('@condo/domains/common/utils/fileAdapter')
const access = require('@condo/domains/ticket/access/CallRecord')

const { PHONE_WRONG_FORMAT_ERROR } = require('../../common/constants/errors')
const { normalizePhone } = require('../../common/utils/phone')

const TICKET_FILE_FOLDER_NAME = 'ticket-call-record'
const Adapter = new FileAdapter(TICKET_FILE_FOLDER_NAME)
const fileMetaAfterChange = getFileMetaAfterChange(Adapter)

const CallRecord = new GQLListSchema('CallRecord', {
    schemaDoc: 'Conversation record between operator and client',
    fields: {
        organization: {
            schemaDoc: 'Organization of the operator',
            type: Relationship,
            ref: 'Organization',
            isRequired: true,
            knexOptions: { isNotNullable: true },
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },
        file: {
            schemaDoc: 'Conversation file',
            type: File,
            adapter: Adapter,
        },
        callerPhone: {
            schemaDoc: 'Phone number of the person who called',
            type: Text,
            isRequired: true,
            hooks: {
                resolveInput: async ({ resolvedData }) => {
                    const newValue = normalizePhone(resolvedData['phone'], true)
                    return newValue || resolvedData['phone']
                },
                validateInput: async ({ resolvedData, addFieldValidationError }) => {
                    const newValue = normalizePhone(resolvedData['phone'], true)
                    if (resolvedData['phone'] && newValue !== resolvedData['phone']) {
                        addFieldValidationError(`${PHONE_WRONG_FORMAT_ERROR}phone] invalid format`)
                    }
                },
            },
        },
        destCallerPhone: {
            schemaDoc: 'Phone number of the person to whom called',
            type: Text,
            isRequired: true,
            hooks: {
                resolveInput: async ({ resolvedData }) => {
                    const newValue = normalizePhone(resolvedData['phone'], true)
                    return newValue || resolvedData['phone']
                },
                validateInput: async ({ resolvedData, addFieldValidationError }) => {
                    const newValue = normalizePhone(resolvedData['phone'], true)
                    if (resolvedData['phone'] && newValue !== resolvedData['phone']) {
                        addFieldValidationError(`${PHONE_WRONG_FORMAT_ERROR}phone] invalid format`)
                    }
                },
            },
        },
        talkTime: {
            schemaDoc: 'Time of conversation between operator and client (in seconds)',
            type: Integer,
            isRequired: true,
        },
        startedAt: {
            schemaDoc: 'Call start date in UTC',
            type: DateTimeUtc,
            isRequired: true,
        },
        isIncomingCall: {
            schemaDoc: 'Incoming or outgoing call for operator',
            type: Checkbox,
            isRequired: true,
        },
        callId: {
            schemaDoc: 'Call unique identifier',
            type: Text,
            isRequired: true,
        },
    },
    hooks: {
        afterChange: fileMetaAfterChange,
        afterDelete: async ({ existingItem }) => {
            if (existingItem.file) {
                await Adapter.delete(existingItem.file)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadCallRecords,
        create: access.canManageCallRecords,
        update: access.canManageCallRecords,
        delete: false,
        auth: true,
    },
})

module.exports = {
    CallRecord,
}
