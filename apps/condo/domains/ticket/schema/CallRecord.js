/**
 * Generated by `createschema ticket.CallRecord 'organization:Relationship:Organization:CASCADE;file?:File;callerPhone:Text;destCallerPhone:Text;talkTime:Integer;startDate:DateTimeUtc;isIncomingCall:Checkbox;importId:Text;'`
 */

const { Text, Integer, Checkbox, DateTimeUtc, File } = require('@keystonejs/fields')
const { get } = require('lodash')

const { GQLError } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const { PHONE_FIELD } = require('@condo/domains/common/schema/fields')
const FileAdapter = require('@condo/domains/common/utils/fileAdapter')
const { ORGANIZATION_OWNED_FIELD } = require('@condo/domains/organization/schema/fields')
const access = require('@condo/domains/ticket/access/CallRecord')
const { CALL_RECORD_ERRORS } = require('@condo/domains/ticket/constants/errors')

const CALL_RECORDS_FOLDER_NAME = 'ticket-call-record'
const Adapter = new FileAdapter(CALL_RECORDS_FOLDER_NAME, false, true)

const CallRecord = new GQLListSchema('CallRecord', {
    schemaDoc: 'Conversation record between operator and client',
    fields: {
        organization: {
            ...ORGANIZATION_OWNED_FIELD,
            schemaDoc: 'Organization of the operator',
        },
        file: {
            schemaDoc: 'Conversation file',
            type: File,
            adapter: Adapter,
        },
        callerPhone: {
            ...PHONE_FIELD,
            schemaDoc: 'Phone number of the person who called',
        },
        destCallerPhone: {
            ...PHONE_FIELD,
            schemaDoc: 'Phone number of the person to whom called',
        },
        talkTime: {
            schemaDoc: 'Time of conversation between operator and client (in seconds)',
            type: Integer,
            isRequired: true,
            hooks: {
                validateInput: ({ resolvedData, context, fieldPath }) => {
                    if (resolvedData[fieldPath] && resolvedData[fieldPath] < 0) {
                        throw new GQLError(CALL_RECORD_ERRORS.NEGATIVE_TALK_TIME_VALUE, context)
                    }
                },
            },
        },
        startedAt: {
            schemaDoc: 'Call start date in UTC',
            type: DateTimeUtc,
            isRequired: true,
        },
        isIncomingCall: {
            schemaDoc: 'Incoming or outgoing call for operator',
            type: Checkbox,
            isRequired: true,
        },
        importId: {
            schemaDoc: 'Call unique identifier',
            type: Text,
            isRequired: true,
        },
    },
    hooks: {
        afterChange: async ({ updatedItem, listKey, operation }) => {
            if (operation === 'create' && updatedItem && Adapter.acl && Adapter.acl.setMeta) {
                const file = get(updatedItem, 'file')

                if (file) {
                    const { filename, _meta } = file
                    const folder = get(Adapter, 'folder', '')
                    const key = `${folder}/${filename}`
                    const itemId = updatedItem.id
                    const stringIds = get(_meta, 'ids') || ''
                    const ids = stringIds.split(',').filter(Boolean)

                    if (!ids.includes(itemId)) {
                        ids.push(itemId)
                    }

                    // set CallRecord ids in file meta to check access rights
                    await Adapter.acl.setMeta(key, {
                        listkey: listKey,
                        ids: ids.join(','),
                    })
                }
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadCallRecords,
        create: access.canManageCallRecords,
        update: access.canManageCallRecords,
        delete: false,
        auth: true,
    },
})

module.exports = {
    CallRecord,
}
