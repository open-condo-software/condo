/**
 * Generated by `createservice ticket.ExportIncidentsToExcelService`
 */

const dayjs = require('dayjs')
const { uniq } = require('lodash')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')
const { i18n } = require('@open-condo/locales/loader')

const { NOTHING_TO_EXPORT } = require('@condo/domains/common/constants/errors')
const { createExportFile } = require('@condo/domains/common/utils/createExportFile')
const { getHeadersTranslations, EXPORT_TYPE_INCIDENTS } = require('@condo/domains/common/utils/exportToExcel')
const access = require('@condo/domains/ticket/access/ExportIncidentsToExcelService')
const { INCIDENT_STATUS_ACTUAL } = require('@condo/domains/ticket/constants/incident')
const {
    loadIncidentsForExcelExport,
    loadIncidentClassifiersForExcelExport,
    loadIncidentPropertiesForExcelExport,
    loadClassifiersForExcelExport,
} = require('@condo/domains/ticket/utils/serverSchema')


const INCIDENTS_EXPORT_TEMPLATE_PATH = './domains/ticket/templates/IncidentsExportTemplate.xlsx'

const ERRORS = {
    NOTHING_TO_EXPORT: {
        query: 'exportIncidentsToExcel',
        code: BAD_USER_INPUT,
        type: NOTHING_TO_EXPORT,
        message: 'No property scopes found to export',
        messageForUser: 'api.contact.exportContactsToExcel.NOTHING_TO_EXPORT',
    },
}

const EMPTY_SYMBOL = '—'

const classifiersToString = (classifiers = []) => {
    if (classifiers.length < 1) {
        return EMPTY_SYMBOL
    }

    const place = classifiers[0].place
    const categories = uniq(classifiers
        .map(({ category }) => category))
        .join(', ')
    const problems = uniq(classifiers
        .map(({ problem }) => problem))
        .join(', ')

    const renderProblems = problems ? ` » ${problems}` : ''

    return `${place} » ${categories}${renderProblems}`
}

const formatDate = (date, timeZone, format = 'DD.MM.YYYY HH:mm') => {
    if (!date || !format) return EMPTY_SYMBOL
    if (!timeZone) return dayjs(date).format(format)
    return dayjs.tz(date, timeZone).format(format)
}

const ExportIncidentsToExcelService = new GQLCustomSchema('ExportIncidentsToExcelService', {
    types: [
        {
            access: true,
            type: 'input ExportIncidentsToExcelInput { dv: Int!, sender: SenderFieldInput!, where: IncidentWhereInput!, sortBy: [SortIncidentsBy!], timeZone: String }',
        },
        {
            access: true,
            type: 'type ExportIncidentsToExcelOutput { status: String!, linkToFile: String! }',
        },
    ],

    queries: [
        {
            access: access.canExportIncidentsToExcel,
            schema: 'exportIncidentsToExcel(data: ExportIncidentsToExcelInput!): ExportIncidentsToExcelOutput',
            resolver: async (parent, args, context) => {
                const { where, sortBy, timeZone } = args.data

                const locale = extractReqLocale(context.req) || conf.DEFAULT_LOCALE

                const HeaderMessage = i18n('excelExport.headers.incidents.title', { locale })
                const AllPropertiesMessage = i18n('incident.fields.properties.allSelected', { locale })
                const SheetNameMessage = i18n('excelExport.sheetNames.incidents', { locale })
                const ActualMessage = i18n('incident.status.actual', { locale })
                const NotActualMessage = i18n('incident.status.notActual', { locale })
                const YesMessage = i18n('Yes', { locale })
                const NoMessage = i18n('No', { locale })

                const incidents = await loadIncidentsForExcelExport({ where, sortBy })
                if (incidents.length < 1) {
                    throw new GQLError(ERRORS.NOTHING_TO_EXPORT, context)
                }

                const incidentIds = incidents.map(incident => incident.id)

                const incidentProperties = await loadIncidentPropertiesForExcelExport({
                    where: {
                        incident: { id_in: incidentIds },
                        deletedAt: null,
                    },
                })

                const incidentClassifiers = await loadIncidentClassifiersForExcelExport({
                    where: {
                        incident: { id_in: incidentIds },
                        deletedAt: null,
                    },
                })

                const classifierIds = uniq(incidentClassifiers.map(({ classifier }) => classifier))

                const classifiers = await loadClassifiersForExcelExport({ classifierRuleIds: classifierIds })

                const excelRows = incidents.map(incident => {
                    const properties = incidentProperties
                        .filter(incidentProperty => incidentProperty.incident === incident.id)
                        .map(({ property }) => property)
                    const classifiersIds = incidentClassifiers
                        .filter(incidentClassifier => incidentClassifier.incident === incident.id)
                        .map(({ classifier }) => classifier)
                    const filteredClassifiers = classifiers.filter(classifier => classifiersIds.includes(classifier.id))
                    const isActual = incident.status === INCIDENT_STATUS_ACTUAL

                    return {
                        number: incident.number,
                        addresses: incident.hasAllProperties
                            ? AllPropertiesMessage
                            : properties.join(',\n'),
                        classifiers: classifiersToString(filteredClassifiers),
                        details: incident.details,
                        status: isActual ? ActualMessage : NotActualMessage,
                        workStart: formatDate(incident.workStart, timeZone),
                        workFinish: formatDate(incident.workFinish, timeZone),
                        organization: incident.organization,
                        textForResident: incident.textForResident || EMPTY_SYMBOL,
                        createdBy: incident.createdBy,
                        createdAt: formatDate(incident.createdAt, timeZone),
                        isScheduled: incident.isScheduled ? YesMessage : NoMessage,
                        isEmergency: incident.isEmergency ? YesMessage : NoMessage,
                    }
                })

                const { url: linkToFile } = await createExportFile({
                    fileName: `incidents_${dayjs().format('DD_MM_YYYY')}.xlsx`,
                    templatePath: INCIDENTS_EXPORT_TEMPLATE_PATH,
                    replaces: {
                        incidents: excelRows,
                        header: HeaderMessage,
                        i18n: {
                            ...getHeadersTranslations(EXPORT_TYPE_INCIDENTS, locale),
                            sheetName: SheetNameMessage,
                        },
                    },
                    meta: {
                        listKey: 'Incident',
                        id: incidents[0].id,
                    },
                })

                return { status: 'ok', linkToFile }
            },
        },
    ],
    
})

module.exports = {
    ExportIncidentsToExcelService,
}
