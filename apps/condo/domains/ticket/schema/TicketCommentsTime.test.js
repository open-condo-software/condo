/**
 * Generated by `createschema ticket.TicketCommentsTime 'organization:Relationship:Organization:CASCADE; ticket:Relationship:Ticket:CASCADE; lastCommentAt:DateTimeUtc; lastResidentCommentAt:DateTimeUtc;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { makeLoggedInAdminClient, UUID_RE, DATETIME_RE } = require('@open-condo/keystone/test.utils')

const { createTestContact } = require('@condo/domains/contact/utils/testSchema')
const { createTestOrganization, createTestOrganizationEmployeeRole, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { createTestResident } = require('@condo/domains/resident/utils/testSchema')
const { TicketCommentsTime, createTestTicket, createTestTicketComment } = require('@condo/domains/ticket/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')

const { RESIDENT_COMMENT_TYPE, ORGANIZATION_COMMENT_TYPE } = require('../constants')


describe('TicketCommentsTime', () => {
    afterAll( () => {
        if (global.gc) {
            global.gc()
        }
    })
    describe('employee', () => {
        describe('create', () => {
            it('create ticketCommentsTime after create comment with resident type', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageTickets: true,
                    canManageTicketComments: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

                const content = faker.lorem.sentence()
                const [ticket] = await createTestTicket(userClient, organization, property)
                await createTestTicketComment(userClient, ticket, userClient.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTime = await TicketCommentsTime.getOne(userClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTime.id).toMatch(UUID_RE)
                expect(ticketCommentsTime.lastCommentAt).toMatch(DATETIME_RE)
                expect(ticketCommentsTime.lastResidentCommentAt).toBeNull()
                expect(ticketCommentsTime.organization.id).toEqual(organization.id)
            })

            it('does not create ticketCommentsTime after create comment with organization type', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageTickets: true,
                    canManageTicketComments: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

                const content = faker.lorem.sentence()
                const [ticket] = await createTestTicket(userClient, organization, property)
                await createTestTicketComment(userClient, ticket, userClient.user, {
                    type: ORGANIZATION_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTime = await TicketCommentsTime.getOne(userClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTime).toBeUndefined()
            })
        })

        describe('read', () => {
            it('can read ticketCommentsTime in the organization where he is an employee', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageTickets: true,
                    canManageTicketComments: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

                const content = faker.lorem.sentence()
                const [ticket] = await createTestTicket(userClient, organization, property)
                await createTestTicketComment(userClient, ticket, userClient.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTime = await TicketCommentsTime.getOne(userClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTime.id).toMatch(UUID_RE)
            })

            it('can not read ticketCommentsTime in the organization where he is not an employee', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [organization1] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization1, {
                    canManageTickets: true,
                    canManageTicketComments: true,
                })
                await createTestOrganizationEmployee(adminClient, organization1, userClient.user, role)

                const content = faker.lorem.sentence()
                const [ticket] = await createTestTicket(adminClient, organization, property)
                await createTestTicketComment(adminClient, ticket, userClient.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTime = await TicketCommentsTime.getOne(userClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTime).toBeUndefined()
            })
        })

        describe('update', () => {
            it('update ticketCommentsTime after create several comments with resident type', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const userClient1 = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageTickets: true,
                    canManageTicketComments: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                await createTestOrganizationEmployee(adminClient, organization, userClient1.user, role)

                const content = faker.lorem.sentence()
                const [ticket] = await createTestTicket(userClient, organization, property)
                await createTestTicketComment(userClient, ticket, userClient.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })
                const ticketCommentsTimeBeforeComment = await TicketCommentsTime.getOne(userClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTimeBeforeComment.lastCommentAt).toMatch(DATETIME_RE)
                expect(ticketCommentsTimeBeforeComment.lastResidentCommentAt).toBeNull()

                await createTestTicketComment(userClient, ticket, userClient.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTime = await TicketCommentsTime.getOne(userClient, {
                    ticket: { id: ticket.id },
                })

                expect(dayjs(ticketCommentsTime.lastCommentAt).isAfter(dayjs(ticketCommentsTimeBeforeComment.lastCommentAt))).toBeTruthy()
                expect(ticketCommentsTime.lastResidentCommentAt).toBeNull()
            })
        })
    })

    describe('resident', () => {
        describe('create', () => {
            it('create ticketCommentsTime after create comment with resident type', async () => {
                const admin = await makeLoggedInAdminClient()
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const { phone } = residentClient.userAttrs
                const content = faker.lorem.sentence()

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                })
                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })
                await createTestTicketComment(residentClient, ticket, residentClient.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTime = await TicketCommentsTime.getOne(residentClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTime.id).toMatch(UUID_RE)
                expect(ticketCommentsTime.lastCommentAt).toMatch(DATETIME_RE)
                expect(ticketCommentsTime.lastResidentCommentAt).toMatch(DATETIME_RE)
                expect(ticketCommentsTime.lastResidentCommentAt).toEqual(ticketCommentsTime.lastCommentAt)
            })
        })

        describe('read', () => {
            it('cannot read ticketCommentsTime in not his ticket', async () => {
                const admin = await makeLoggedInAdminClient()
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitName1 = faker.random.alphaNumeric(5)
                const { phone } = residentClient.userAttrs
                const content = faker.lorem.sentence()

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                })
                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName: unitName1,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })
                await createTestTicketComment(admin, ticket, admin.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTime = await TicketCommentsTime.getOne(residentClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTime).toBeUndefined()
            })
        })

        describe('update', () => {
            it('update ticketCommentsTime after create several comments with resident type', async () => {
                const admin = await makeLoggedInAdminClient()
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const { phone } = residentClient.userAttrs
                const content = faker.lorem.sentence()

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                })
                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })
                await createTestTicketComment(residentClient, ticket, residentClient.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTimeAfterFirstResidentComment = await TicketCommentsTime.getOne(residentClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTimeAfterFirstResidentComment.lastCommentAt).toMatch(DATETIME_RE)
                expect(ticketCommentsTimeAfterFirstResidentComment.lastResidentCommentAt).toMatch(DATETIME_RE)
                expect(ticketCommentsTimeAfterFirstResidentComment.lastResidentCommentAt).toEqual(ticketCommentsTimeAfterFirstResidentComment.lastCommentAt)

                await createTestTicketComment(admin, ticket, admin.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTimeAfterEmployeeComment = await TicketCommentsTime.getOne(residentClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTimeAfterEmployeeComment.lastCommentAt).toMatch(DATETIME_RE)
                expect(ticketCommentsTimeAfterEmployeeComment.lastResidentCommentAt).toMatch(DATETIME_RE)
                expect(dayjs(ticketCommentsTimeAfterEmployeeComment.lastResidentCommentAt).isBefore(ticketCommentsTimeAfterEmployeeComment.lastCommentAt)).toBeTruthy()

                await createTestTicketComment(residentClient, ticket, residentClient.user, {
                    type: RESIDENT_COMMENT_TYPE,
                    content,
                })

                const ticketCommentsTimeAfterSecondResidentComment = await TicketCommentsTime.getOne(residentClient, {
                    ticket: { id: ticket.id },
                })

                expect(ticketCommentsTimeAfterSecondResidentComment.lastCommentAt).toMatch(DATETIME_RE)
                expect(ticketCommentsTimeAfterSecondResidentComment.lastResidentCommentAt).toMatch(DATETIME_RE)
                expect(ticketCommentsTimeAfterSecondResidentComment.lastResidentCommentAt).toEqual(ticketCommentsTimeAfterSecondResidentComment.lastCommentAt)
                expect(dayjs(ticketCommentsTimeAfterEmployeeComment.lastCommentAt).isBefore(ticketCommentsTimeAfterSecondResidentComment.lastCommentAt)).toBeTruthy()
            })
        })
    })
})
