/**
 * Generated by `createschema ticket.Ticket organization:Text; statusReopenedCounter:Integer; statusReason?:Text; status:Relationship:TicketStatus:PROTECT; number?:Integer; client?:Relationship:User:SET_NULL; clientName:Text; clientEmail:Text; clientPhone:Text; operator:Relationship:User:SET_NULL; assignee?:Relationship:User:SET_NULL; classifier:Relationship:TicketClassifier:PROTECT; details:Text; meta?:Json;`
 */
const faker = require('faker')
const dayjs = require('dayjs')

const { NUMBER_RE, UUID_RE, DATETIME_RE, makeClient, makeLoggedInAdminClient } = require('@core/keystone/test.utils')

const { createTestContact, updateTestContact } = require('@condo/domains/contact/utils/testSchema')
const { makeClientWithProperty } = require('@condo/domains/property/utils/testSchema')
const { Ticket, createTestTicket, updateTestTicket } = require('@condo/domains/ticket/utils/testSchema')
const { expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects, expectToThrowUserInputError } = require('@condo/domains/common/utils/testSchema')
const { expectToThrowAccessDeniedErrorToObj } = require('@condo/domains/common/utils/testSchema')
const { createTestOrganizationLink, createTestOrganizationWithAccessToAnotherOrganization, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty, updateTestProperty } = require('@condo/domains/property/utils/testSchema')
const { createTestResident } = require('@condo/domains/resident/utils/testSchema')
const { makeClientWithResidentAccessAndProperty } = require('@condo/domains/property/utils/testSchema')
const { createTestOrganizationEmployeeRole } = require('@condo/domains/organization/utils/testSchema')
const { updateTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const {
    PUSH_TRANSPORT_FIREBASE,
    PUSH_FAKE_TOKEN_SUCCESS,
    PUSH_FAKE_TOKEN_FAIL,
    TICKET_ASSIGNEE_CONNECTED_TYPE,
    TICKET_EXECUTOR_CONNECTED_TYPE,
    TICKET_STATUS_IN_PROGRESS_TYPE,
    TICKET_STATUS_COMPLETED_TYPE,
    TICKET_STATUS_RETURNED_TYPE,
    TICKET_INDICATOR_ADDED_TYPE,
    TICKET_INDICATOR_REMOVED_TYPE,
    TICKET_COMMENT_ADDED_TYPE,
    MESSAGE_DELIVERED_STATUS,
    MESSAGE_ERROR_STATUS,
    MESSAGE_SENT_STATUS,
} = require('@condo/domains/notification/constants/constants')
const { getRandomTokenData } = require('@condo/domains/notification/utils/testSchema/helpers')
const { Message, syncDeviceByTestClient } = require('@condo/domains/notification/utils/testSchema')
const { sleep } = require('@condo/domains/common/utils/sleep')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { makeClientWithResidentUser, makeClientWithNewRegisteredAndLoggedInUser, createTestPhone } = require('@condo/domains/user/utils/testSchema')
const { createTestDivision } = require('@condo/domains/division/utils/testSchema')
const { STATUS_IDS } = require('../constants/statusTransitions')
const { REVIEW_VALUES } = require('../constants')
const { createTestTicketComment } = require('../utils/testSchema')

describe('Ticket', () => {
    describe('Crud', () => {
        test('user: create Ticket', async () => {
            const client = await makeClientWithProperty()
            const [contact] = await createTestContact(client, client.organization, client.property)
            const fields = {
                contact: { connect: { id: contact.id } },
            }
            const [obj, attrs] = await createTestTicket(client, client.organization, client.property, fields)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
            expect(obj.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(String(obj.number)).toMatch(NUMBER_RE)
            expect(obj.source).toEqual(expect.objectContaining({ id: attrs.source.connect.id }))
            expect(obj.sourceMeta).toEqual(null)
            expect(obj.classifier).toEqual(expect.objectContaining({ id: attrs.classifier.connect.id }))
            expect(obj.property).toEqual(expect.objectContaining({ id: client.property.id }))
            expect(obj.propertyAddress).toEqual(client.property.address)
            expect(obj.propertyAddressMeta).toEqual(client.property.addressMeta)
            expect(obj.status).toEqual(expect.objectContaining({ id: attrs.status.connect.id }))
            expect(obj.statusReopenedCounter).toEqual(0)
            expect(obj.statusReason).toEqual(null)
            expect(obj.statusUpdatedAt).toBeNull()
            expect(obj.details).toEqual(attrs.details)
            expect(obj.isPaid).toEqual(false)
            expect(obj.isEmergency).toEqual(false)
            expect(obj.isWarranty).toEqual(false)
            expect(obj.meta).toEqual(null)
            expect(obj.client).toEqual(null)
            expect(obj.contact).toEqual(expect.objectContaining({ id: attrs.contact.connect.id }))
            expect(obj.operator).toEqual(null)
            expect(obj.assignee).toEqual(null)
            expect(obj.executor).toEqual(null)
            expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
            expect(obj.watchers).toEqual([])
        })

        test('user: create Ticket without status', async () => {
            const client = await makeClientWithProperty()
            const [obj] = await createTestTicket(client, client.organization, client.property, { status: null })
            const TICKET_OPEN_STATUS_ID = '6ef3abc4-022f-481b-90fb-8430345ebfc2'

            expect(obj.status).toEqual(expect.objectContaining({ id: TICKET_OPEN_STATUS_ID }))
        })

        test('user with resident type without resident: cannot create Ticket', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, userClient.property)
            })
        })

        test('resident: can create Ticket and client info save in new ticket', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [obj] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            const user = userClient.user
            const { name, email, phone } = userClient.userAttrs

            expect(obj.client.id).toEqual(user.id)
            expect(obj.clientName).toEqual(name)
            expect(obj.clientPhone).toEqual(phone)
            expect(obj.clientEmail).toEqual(email)
        })

        test('user with 2 residents: can create Ticket for each resident', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName: unitName1,
            })
            await createTestResident(admin, userClient.user, organization, property, {
                unitName: unitName2,
            })

            const [ticket1] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName: unitName1,
            })
            const [ticket2] = await createTestTicket(userClient, organization, property, {
                unitName: unitName2,
            })

            expect(ticket1.id).toMatch(UUID_RE)
            expect(ticket2.id).toMatch(UUID_RE)
        })

        test('resident: cannot create Ticket without unitName', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, userClient.property)
            })
        })

        test('resident: cannot create Ticket in other unitName', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName: unitName1,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName: unitName2,
                })
            })
        })

        test('resident: cannot create Ticket in other property', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const [property] = await createTestProperty(admin, userClient.organization)
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, property, {
                    unitName,
                })
            })
        })

        test('resident: cannot update his Ticket details', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const newDetails = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient, ticket.id, {
                    details: newDetails,
                })
            })
        })

        test('resident: can update his Ticket reviewValue and reviewComment', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const reviewComment = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                reviewValue: REVIEW_VALUES.GOOD,
                reviewComment,
            })

            expect(ticket.id).toEqual(updatedTicket.id)
            expect(updatedTicket.reviewValue).toEqual(REVIEW_VALUES.GOOD)
            expect(updatedTicket.reviewComment).toEqual(reviewComment)
            expect(updatedTicket.status.id).toEqual(STATUS_IDS.CLOSED)
        })

        test('resident: return to work Ticket when reviewValue is \'returned\'', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                reviewValue: REVIEW_VALUES.RETURN,
            })

            expect(ticket.id).toEqual(updatedTicket.id)
            expect(updatedTicket.reviewValue).toEqual(REVIEW_VALUES.RETURN)
            expect(updatedTicket.status.id).toEqual(STATUS_IDS.OPEN)
        })

        test('employee: update statusReopenedCounter when update status from completed to open', async () => {
            const userClient = await makeClientWithProperty()

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(ticket.id).toEqual(updatedTicket.id)
            expect(updatedTicket.statusReopenedCounter).toEqual(1)

            await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })
            const [againUpdatedTicket] = await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(againUpdatedTicket.statusReopenedCounter).toEqual(2)
        })

        test('resident: cannot update his Ticket fields other than accessibleUpdatedFields', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            const newDetails = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient, ticket.id, {
                    details: newDetails,
                    unitName: unitName2,
                })
            })
        })

        test('resident: cannot update not his Ticket', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const userClient2 = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            const newDetails = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })
            await createTestResident(admin, userClient2.user, userClient.organization, userClient.property, {
                unitName: unitName2,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient2, ticket.id, {
                    details: newDetails,
                    unitName: unitName2,
                })
            })
        })

        test('resident: can read his Tickets', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })
            const [readTicket] = await Ticket.getAll(userClient, { id: ticket.id })

            expect(readTicket.id).toEqual(ticket.id)
        })

        test('resident: can read ticket with a contact whose phone number and address matches the resident phone number and address', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, organization, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

            expect(readTicket.id).toEqual(ticket.id)
        })

        test('resident: if no client data but with contact data, client data fills from resident', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone, email, name } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, organization, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

            expect(readTicket.clientPhone).toEqual(phone)
            expect(readTicket.clientEmail).toEqual(email)
            expect(readTicket.clientName).toEqual(name)
        })

        test('admin: if client data and contact data sended, client data not overwritted', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone, email, name } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, organization, property, {
                unitName,
            })
            const [anotherContact] = await createTestContact(admin, organization, property)
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: anotherContact.id } },
                canReadByResident: true,
                clientName: name,
                clientPhone: phone,
                clientEmail: email,
            })

            const [readTicket] = await Ticket.getAll(admin, { id: ticket.id })

            expect(readTicket.clientPhone).toEqual(phone)
            expect(readTicket.clientEmail).toEqual(email)
            expect(readTicket.clientName).toEqual(name)
        })

        test('admin: if client data sended without contact data, client data not overwritted', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone, email, name } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, organization, property, {
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                canReadByResident: true,
                clientName: name,
                clientPhone: phone,
                clientEmail: email,
            })

            const [readTicket] = await Ticket.getAll(admin, { id: ticket.id })

            expect(readTicket.clientPhone).toEqual(phone)
            expect(readTicket.clientEmail).toEqual(email)
            expect(readTicket.clientName).toEqual(name)
        })

        test('resident: cannot read ticket with a contact whose phone number did not matches the resident phone number', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient1 = await makeClientWithResidentUser()
            const { phone } = residentClient1.userAttrs
            const residentClient2 = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentClient1.user, organization, property, {
                unitName,
            })
            await createTestResident(admin, residentClient2.user, organization, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const [readTicket] = await Ticket.getAll(residentClient1, { })
            expect(readTicket.id).toEqual(ticket.id)

            const tickets = await Ticket.getAll(residentClient2, {})
            expect(tickets).toHaveLength(0)
        })

        test('resident: cannot read ticket with a contact whose property or unitName ' +
            'did not matches the resident property or unitName', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentWithTicketClient = await makeClientWithResidentUser()
            const residentFromAnotherPropertyClient = await makeClientWithResidentUser()
            const residentFromAnotherUnitClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property1] = await createTestProperty(admin, organization)
            const [property2] = await createTestProperty(admin, organization)
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)

            const [residentWithTicket] = await createTestResident(admin, residentWithTicketClient.user, organization, property1, {
                unitName: unitName1,
            })
            const [residentFromAnotherProperty] = await createTestResident(admin, residentFromAnotherPropertyClient.user, organization, property2, {
                unitName: unitName1,
            })
            const [residentFromAnotherUnit] = await createTestResident(admin, residentFromAnotherUnitClient.user, organization, property1, {
                unitName: unitName2,
            })
            const [contact] = await createTestContact(admin, organization, property1, {
                phone: residentWithTicketClient.userAttrs.phone,
                unitName: unitName1,
            })
            const [ticket] = await createTestTicket(admin, organization, property1, {
                unitName: unitName1,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const [ticketForResidentWithTicket] = await Ticket.getAll(residentWithTicketClient, { })
            expect(ticketForResidentWithTicket.id).toEqual(ticket.id)

            const ticketsForResidentFromAnotherProperty = await Ticket.getAll(residentFromAnotherPropertyClient, { })
            expect(ticketsForResidentFromAnotherProperty).toHaveLength(0)

            const ticketsForResidentFromAnotherUnit = await Ticket.getAll(residentFromAnotherUnitClient, { })
            expect(ticketsForResidentFromAnotherUnit).toHaveLength(0)
        })

        test('resident: user with 2 residents and 2 different contacts can read ticket for each resident', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient1 = await makeClientWithResidentUser()
            const { phone } = residentClient1.userAttrs

            const [organization] = await createTestOrganization(admin)
            const [property1] = await createTestProperty(admin, organization)
            const [property2] = await createTestProperty(admin, organization)
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)

            const [resident1] = await createTestResident(admin, residentClient1.user, organization, property1, {
                unitName: unitName1,
            })
            const [resident2] = await createTestResident(admin, residentClient1.user, organization, property2, {
                unitName: unitName2,
            })

            const [contact1] = await createTestContact(admin, organization, property1, {
                phone,
                unitName: unitName1,
            })
            const [contact2] = await createTestContact(admin, organization, property2, {
                phone,
                unitName: unitName2,
            })

            const [ticket1] = await createTestTicket(admin, organization, property1, {
                unitName: unitName1,
                contact: { connect: { id: contact1.id } },
                canReadByResident: true,
            })

            const [ticket2] = await createTestTicket(admin, organization, property2, {
                unitName: unitName2,
                contact: { connect: { id: contact2.id } },
                canReadByResident: true,
            })

            const [wrongContactTicket] = await createTestTicket(admin, organization, property1, {
                unitName: unitName2,
                contact: { connect: { id: contact1.id } },
                canReadByResident: true,
            })

            const tickets = await Ticket.getAll(residentClient1, { }, { sortBy: 'createdAt_ASC' })
            expect(tickets).toHaveLength(2)
            expect(tickets[0].id).toMatch(ticket1.id)
            expect(tickets[1].id).toMatch(ticket2.id)
        })

        test('resident: cannot read ticket from crm with "canReadByResident": false', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, organization, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: false,
            })
            const [visibleTicket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const tickets = await Ticket.getAll(residentClient, {})

            expect(tickets).toHaveLength(1)
            expect(tickets[0].id).toEqual(visibleTicket.id)
        })

        test('resident: can read ticket from crm if first it was hidden to him then it became showed', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, organization, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone: phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: false,
            })

            const tickets = await Ticket.getAll(residentClient, {})

            expect(tickets).toHaveLength(0)

            await updateTestTicket(admin, ticket.id, {
                canReadByResident: true,
            })

            const ticketsAfterShowedTicketToResident = await Ticket.getAll(residentClient, {})

            expect(ticketsAfterShowedTicketToResident).toHaveLength(1)
            expect(ticketsAfterShowedTicketToResident[0].id).toEqual(ticket.id)
        })

        test('resident: cannot read ticket from crm if first it was showed to him then it became hidden', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, organization, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone: phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const tickets = await Ticket.getAll(residentClient, {})

            expect(tickets).toHaveLength(1)
            expect(tickets[0].id).toEqual(ticket.id)

            await updateTestTicket(admin, ticket.id, {
                canReadByResident: false,
            })

            const ticketsAfterHiddenTicketToResident = await Ticket.getAll(residentClient, {})

            expect(ticketsAfterHiddenTicketToResident).toHaveLength(0)
        })

        test('resident: cannot update ticket from crm', async () => {
            const admin = await makeLoggedInAdminClient()
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs
            const newDetails = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentClient.user, organization, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(residentClient, ticket.id, {
                    details: newDetails,
                })
            })
        })

        test('resident: cannot read not his Tickets', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const userInOtherProperty = await makeClientWithResidentAccessAndProperty()
            const userInOtherUnit = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })
            await createTestResident(admin, userInOtherProperty.user, userInOtherProperty.organization, userInOtherProperty.property, {
                unitName,
            })
            await createTestResident(admin, userInOtherUnit.user, userClient.organization, userClient.property, {
                unitName: unitName2,
            })
            const [ticketInOtherProperty] = await createTestTicket(userInOtherProperty, userInOtherProperty.organization, userInOtherProperty.property, {
                unitName,
            })
            const [ticketInOtherUnit] = await createTestTicket(userInOtherUnit, userClient.organization, userClient.property, {
                unitName: unitName2,
            })

            const readTickets = await Ticket.getAll(userClient, { id_in: [ticketInOtherProperty.id, ticketInOtherUnit.id] })

            expect(readTickets).toHaveLength(0)
        })

        test('employee with division limited role: can read tickets only from his divisions', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithNewRegisteredAndLoggedInUser()

            const [organization] = await createTestOrganization(admin)
            const [propertyInDivision1] = await createTestProperty(admin, organization)
            const [propertyInDivision2] = await createTestProperty(admin, organization)
            const [propertyOutOfDivision] = await createTestProperty(admin, organization)
            const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                canReadEntitiesOnlyInScopeOfDivision: true,
            })
            const [employee] = await createTestOrganizationEmployee(admin, organization, client.user, role, {})
            await createTestDivision(admin, organization, employee, {
                properties: {
                    connect: [
                        { id: propertyInDivision1.id },
                    ],
                },
            })
            await createTestDivision(admin, organization, employee, {
                properties: {
                    connect: [
                        { id: propertyInDivision2.id },
                    ],
                },
            })
            const [ticketFromDivision1] = await createTestTicket(admin, organization, propertyInDivision1)
            const [ticketFromDivision2] = await createTestTicket(admin, organization, propertyInDivision2)
            await createTestTicket(admin, organization, propertyOutOfDivision)

            const tickets = await Ticket.getAll(client)
            expect(tickets).toHaveLength(2)

            const [readTicketFromDivision1] = await Ticket.getAll(client, { id: ticketFromDivision1.id })
            expect(readTicketFromDivision1.id).toBeDefined()

            const [readTicketFromDivision2] = await Ticket.getAll(client, { id: ticketFromDivision2.id })
            expect(readTicketFromDivision2.id).toBeDefined()
        })

        test('employee with division limited role: can read tickets where he is assignee or executor', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithNewRegisteredAndLoggedInUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                canReadEntitiesOnlyInScopeOfDivision: true,
            })
            await createTestOrganizationEmployee(admin, organization, client.user, role, {})

            const [ticket1] = await createTestTicket(admin, organization, property, { assignee: { connect: { id: client.user.id } } })
            const [ticket2] = await createTestTicket(admin, organization, property, { executor: { connect: { id: client.user.id } } })

            const tickets = await Ticket.getAll(client)
            expect(tickets).toHaveLength(2)

            const [readTicketFromDivision1] = await Ticket.getAll(client, { id: ticket1.id })
            expect(readTicketFromDivision1.id).toBeDefined()

            const [readTicketFromDivision2] = await Ticket.getAll(client, { id: ticket2.id })
            expect(readTicketFromDivision2.id).toBeDefined()
        })

        test('employee: can read all organization tickets if in other organization he has division limited role', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithNewRegisteredAndLoggedInUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const [divisionLimitedRole] = await createTestOrganizationEmployeeRole(admin, organization, {
                canReadEntitiesOnlyInScopeOfDivision: true,
            })
            const [divisionLimitedEmployee] = await createTestOrganizationEmployee(admin, organization, client.user, divisionLimitedRole, {})

            const [organization1] = await createTestOrganization(admin)
            const [property1] = await createTestProperty(admin, organization1)
            const [role] = await createTestOrganizationEmployeeRole(admin, organization1)
            const [employee] = await createTestOrganizationEmployee(admin, organization1, client.user, role, {})

            await createTestTicket(admin, organization, property)
            const [ticket] = await createTestTicket(admin, organization1, property1)

            const tickets = await Ticket.getAll(client)

            expect(tickets).toHaveLength(1)
            expect(tickets[0].id).toEqual(ticket.id)
        })

        test('anonymous: create Ticket', async () => {
            const client1 = await makeClientWithProperty()
            const client = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestTicket(client, client1.organization, client1.property)
            })
        })

        test('user: read Ticket', async () => {
            const client = await makeClientWithProperty()
            const [obj, attrs] = await createTestTicket(client, client.organization, client.property)
            const objs = await Ticket.getAll(client)
            expect(objs).toHaveLength(1)
            expect(objs[0].id).toMatch(obj.id)
            expect(objs[0].dv).toEqual(1)
            expect(objs[0].sender).toEqual(attrs.sender)
            expect(objs[0].v).toEqual(1)
            expect(objs[0].newId).toEqual(null)
            expect(objs[0].deletedAt).toEqual(null)
            expect(objs[0].createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objs[0].updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objs[0].createdAt).toMatch(obj.createdAt)
            expect(objs[0].updatedAt).toMatch(obj.updatedAt)
        })

        test('user: no access to another organization ticket', async () => {
            const hacker = await makeClientWithProperty()
            const client = await makeClientWithProperty()
            const [obj] = await createTestTicket(client, client.organization, client.property)

            const objs = await Ticket.getAll(hacker)
            expect(objs).toHaveLength(0)

            const objsFilteredById = await Ticket.getAll(hacker, { id: obj.id })
            expect(objsFilteredById).toHaveLength(0)
        })

        test('anonymous: read Ticket', async () => {
            const client = await makeClient()

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await Ticket.getAll(client)
            })
        })

        test('user: update Ticket', async () => {
            const client = await makeClientWithProperty()
            const payload = { details: 'new data' }
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            const [objUpdated, attrs] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.details).toEqual(payload.details)
            expect(objUpdated.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(objUpdated.number).toEqual(objCreated.number)
            // TODO(pahaz): check others fields ...
        })

        test('user: set ticket assignee', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            const payload = { details: 'new data', assignee: { connect: { id: client.user.id } } }
            const [objUpdated] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.assignee).toEqual(expect.objectContaining({ id: client.user.id }))
            const IN_PROGRESS = 'aa5ed9c2-90ca-4042-8194-d3ed23cb7919'
            expect(objUpdated.status).toEqual(expect.objectContaining({ id: IN_PROGRESS }))
        })

        test('admin: set ticket executor', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            const payload = { details: 'new data', executor: { connect: { id: client.user.id } } }
            const [objUpdated] = await updateTestTicket(admin, objCreated.id, payload)

            expect(objUpdated.executor).toEqual(expect.objectContaining({ id: client.user.id }))
        })

        test('user: set the same ticket number', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)
            const payload = { number: objCreated.number }
            const [objUpdated] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.number).toEqual(objCreated.number)
        })

        test('anonymous: update Ticket', async () => {
            const client1 = await makeClientWithProperty()
            const client = await makeClient()
            const payload = { details: 'new data' }
            const [objCreated] = await createTestTicket(client1, client1.organization, client1.property)
            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestTicket(client, objCreated.id, payload)
            })
        })

        test('user: delete Ticket', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Ticket.delete(client, objCreated.id)
            })
        })

        test('anonymous: delete Ticket', async () => {
            const client1 = await makeClientWithProperty()
            const client = await makeClient()
            const [objCreated] = await createTestTicket(client1, client1.organization, client1.property)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Ticket.delete(client, objCreated.id)
            })
        })
    })
    describe('Permissions', () => {
        test('user: create Ticket', async () => {
            const client = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(client, client.organization, client2.property)
            })
        })

        test('user: update Ticket', async () => {
            const client = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()
            const [obj] = await createTestTicket(client, client.organization, client.property)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(client, obj.id, { property: { connect: { id: client2.property.id } } })
            })
        })

        test('employee from "from" organization: can read tickets from "to" organizations', async () => {
            const admin = await makeLoggedInAdminClient()
            const {
                clientFrom,
                organizationTo,
                propertyTo,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const clientTo2 = await makeClientWithProperty()

            await createTestTicket(admin, organizationTo, propertyTo)
            await createTestTicket(admin, clientTo2.organization, clientTo2.property)

            await createTestOrganizationLink(admin, organizationFrom, clientTo2.organization)

            const tickets = await Ticket.getAll(clientFrom, { organization: { OR: [{ id: organizationTo.id }, { id: clientTo2.organization.id }] } })
            expect(tickets).toHaveLength(2)
        })

        test('employee from "to" organization: cannot read tickets from "from" organization', async () => {
            const admin = await makeLoggedInAdminClient()
            const {
                clientTo,
                organizationFrom,
                propertyFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            await createTestTicket(admin, organizationFrom, propertyFrom)

            const tickets = await Ticket.getAll(clientTo, { organization: { id: organizationFrom.id } })
            expect(tickets).toHaveLength(0)
        })

        test('employee from "from" organization: cannot read not its own "to" organizations', async () => {
            const admin = await makeLoggedInAdminClient()
            const { organizationTo, propertyTo } = await createTestOrganizationWithAccessToAnotherOrganization()
            const {
                clientFrom,
                organizationTo: organizationTo1,
            } = await createTestOrganizationWithAccessToAnotherOrganization()

            await createTestTicket(admin, organizationTo, propertyTo)

            const tickets = await Ticket.getAll(clientFrom, { organization: { OR: [{ id: organizationTo.id }, { id: organizationTo1.id }] } })
            expect(tickets).toHaveLength(0)
        })

        test('organization "from" employee with canManageTickets access: can create organization "to" tickets', async () => {
            const admin = await makeLoggedInAdminClient()
            const {
                clientFrom,
                organizationTo,
                propertyTo,
                employeeFrom,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const [ticket] = await createTestTicket(clientFrom, organizationTo, propertyTo)
            expect(ticket.id).toMatch(UUID_RE)
        })

        test('organization "to" employee: cannot create organization "from" tickets', async () => {
            const {
                organizationFrom,
                propertyFrom,
                clientTo,
            } = await createTestOrganizationWithAccessToAnotherOrganization()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(clientTo, organizationFrom, propertyFrom)
            })
        })

        test('user: cannot create tickets for "from" or "to" organizations', async () => {
            const admin = await makeLoggedInAdminClient()
            const {
                organizationFrom,
                propertyFrom,
                organizationTo,
                propertyTo,
                employeeFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const randomUser = await makeClientWithProperty()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(randomUser, organizationFrom, propertyFrom)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(randomUser, organizationTo, propertyTo)
            })
        })

        test('organization "from" employee: can update organization "to" tickets', async () => {
            const admin = await makeLoggedInAdminClient()
            const {
                clientFrom,
                organizationTo,
                propertyTo,
                organizationFrom,
                employeeFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const [ticket] = await createTestTicket(admin, organizationTo, propertyTo)
            const newDetails = faker.random.alphaNumeric(21)
            const [updatedTicket] = await updateTestTicket(clientFrom, ticket.id, { details: newDetails })

            expect(updatedTicket.id).toEqual(ticket.id)
            expect(updatedTicket.details).toEqual(newDetails)
        })

        test('blocked user: cannot read "to" tickets', async () => {
            const admin = await makeLoggedInAdminClient()
            const {
                employeeFrom,
                clientFrom,
                organizationTo,
                propertyTo,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            await createTestTicket(admin, organizationTo, propertyTo)
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                isBlocked: true,
            })

            const tickets = await Ticket.getAll(clientFrom)
            expect(tickets).toHaveLength(0)
        })


        test('deleted user: cannot read "to" tickets', async () => {
            const admin = await makeLoggedInAdminClient()
            const {
                employeeFrom,
                clientFrom,
                organizationFrom,
                propertyFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            await createTestTicket(admin, organizationFrom, propertyFrom)
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                deletedAt: 'true',
            })

            const tickets = await Ticket.getAll(clientFrom)
            expect(tickets).toHaveLength(0)
        })

        test('blocked user: cannot create "to" tickets', async () => {
            const admin = await makeLoggedInAdminClient()
            const {
                employeeFrom,
                clientFrom,
                organizationTo,
                propertyTo,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })
            await createTestTicket(clientFrom, organizationTo, propertyTo)
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                isBlocked: true,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(clientFrom, organizationTo, propertyTo)
            })
        })
    })
    describe('Validations', () => {
        describe('propertyAddress and propertyAddressMeta', () => {
            test('Should be filled resolved automatically on ticket creation', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                expect(ticket).toHaveProperty('propertyAddress', client.property.address)
                expect(ticket).toHaveProperty('propertyAddressMeta', client.property.addressMeta)
            })
            test('Should be changed after property changed', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                const [newProperty] = await createTestProperty(client, client.organization)
                const [updatedTicket] = await updateTestTicket(client, ticket.id, {
                    property: { connect: { id: newProperty.id } },
                })
                expect(updatedTicket).toHaveProperty('propertyAddress', newProperty.address)
                expect(updatedTicket).toHaveProperty('propertyAddressMeta', newProperty.addressMeta)
            })
            test('Should be changed after address of linked property changed', async () => {
                const client = await makeClientWithProperty()
                const client2 = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                await updateTestProperty(client, client.property.id, {
                    address: client2.property.address,
                    addressMeta: client2.property.addressMeta,
                })

                // NOTE: give worker some time
                // TODO(DOMA-2765) Get rid of sleep
                await sleep(1500)

                const [changedTicket] = await Ticket.getAll(client, { id: ticket.id })
                expect(changedTicket).toBeDefined()
                expect(changedTicket).toHaveProperty('propertyAddress', client2.property.address)
                expect(changedTicket).toHaveProperty('propertyAddressMeta', client2.property.addressMeta)
            })

            test('Cannot be created / changed manually', async () => {
                const client = await makeClientWithProperty()
                const [property] = await createTestProperty(client, client.organization)
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                await expectToThrowUserInputError(async () => {
                    await updateTestTicket(client, ticket.id, {
                        propertyAddress: property.address,
                    })
                }, 'Field "propertyAddress" is not defined by type "TicketUpdateInput"')
                await expectToThrowUserInputError(async () => {
                    await updateTestTicket(client, ticket.id, {
                        propertyAddressMeta: property.addressMeta,
                    })
                }, 'Field "propertyAddressMeta" is not defined by type "TicketUpdateInput"')
                await expectToThrowUserInputError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        propertyAddress: property.address,
                    })
                }, 'Field "propertyAddress" is not defined by type "TicketCreateInput"')
                await expectToThrowUserInputError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        propertyAddressMeta: property.addressMeta,
                    })
                }, 'Field "propertyAddressMeta" is not defined by type "TicketCreateInput"')
            })
            test('Should be unchanged on Property softDeletion', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                await updateTestProperty(client, client.property.id, {
                    deletedAt: dayjs().toISOString(),
                })

                const [refetchTicket] = await Ticket.getAll(client, { id: ticket.id })
                expect(refetchTicket).toBeDefined()
                expect(refetchTicket).toHaveProperty('propertyAddress', client.property.address)
                expect(refetchTicket).toHaveProperty('propertyAddressMeta', client.property.addressMeta)
            })
        })

        describe('client', () => {
            test('should be filled automatically on ticket creation if contact phone number and ticket address matches the resident phone number and address', async () => {
                const admin = await makeLoggedInAdminClient()
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone, name, email } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, organization, property, {
                    unitName,
                    unitType,
                })
                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
                expect(readTicket.clientName).toEqual(name)
                expect(readTicket.clientEmail).toEqual(email)
                expect(readTicket.clientPhone).toEqual(phone)
            })

            test('should be filled automatically on ticket update if contact phone number and updated ticket address matches the resident phone number and address', async () => {
                const admin = await makeLoggedInAdminClient()
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitName1 = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone, name, email } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, organization, property, {
                    unitName,
                    unitType,
                })
                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName: unitName1,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })

                expect(ticket.client).toBeNull()

                await updateTestTicket(admin, ticket.id, {
                    unitName,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
                expect(readTicket.clientName).toEqual(name)
                expect(readTicket.clientEmail).toEqual(email)
                expect(readTicket.clientPhone).toEqual(phone)
            })

            test('should be filled automatically on create resident with same contact phone and same ticket address', async () => {
                const admin = await makeLoggedInAdminClient()
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone, name, email } = residentClient.userAttrs

                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })

                expect(ticket.client).toBeNull()

                await createTestResident(admin, residentClient.user, organization, property, {
                    unitName,
                    unitType,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
                expect(readTicket.clientName).toEqual(name)
                expect(readTicket.clientEmail).toEqual(email)
                expect(readTicket.clientPhone).toEqual(phone)
            })
        })
    })

    describe( 'Notification', () => {
        test('assignee with registered pushToken and connected to ticket on create receives push notification', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithProperty()
            const assignee = await makeClientWithNewRegisteredAndLoggedInUser()
            const randomFakeSuccessPushtoken = `${PUSH_FAKE_TOKEN_SUCCESS}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushtoken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(assignee, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            const extraProps = { assignee: { connect: { id: assignee.user.id } } }
            const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

            expect(ticket.assignee.id).toEqual(assignee.user.id)

            const messageWhere = { user: { id: assignee.user.id }, type: TICKET_ASSIGNEE_CONNECTED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.id).toMatch(UUID_RE)

            // TODO(DOMA-2765) Get rid of sleep
            await sleep(1000)

            const message1 = await Message.getOne(admin, messageWhere)

            expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
            expect(message1.meta.data.ticketId).toEqual(ticket.id)
            expect(message1.processingMeta.transport).toEqual('push')
        })

        test('push message with error status is created when assignee with no registered pushToken is connected to ticket on create', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithProperty()
            const assignee = await makeClientWithNewRegisteredAndLoggedInUser()
            const extraProps = { assignee: { connect: { id: assignee.user.id } } }
            const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

            expect(ticket.assignee.id).toEqual(assignee.user.id)

            const messageWhere = { user: { id: assignee.user.id }, type: TICKET_ASSIGNEE_CONNECTED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.id).toMatch(UUID_RE)

            // TODO(DOMA-2765) Get rid of sleep
            await sleep(1000)

            const message1 = await Message.getOne(admin, messageWhere)

            expect(message1.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message1.meta.data.ticketId).toEqual(ticket.id)
            expect(message1.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('sms')
        })

        test('push message with error status is created when assignee with registered invalid pushToken is connected to ticket on create', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithProperty()
            const assignee = await makeClientWithNewRegisteredAndLoggedInUser()
            const randomFakeFailurePushtoken = `${PUSH_FAKE_TOKEN_FAIL}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeFailurePushtoken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(assignee, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            const extraProps = { assignee: { connect: { id: assignee.user.id } } }
            const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

            expect(ticket.assignee.id).toEqual(assignee.user.id)

            const messageWhere = { user: { id: assignee.user.id }, type: TICKET_ASSIGNEE_CONNECTED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.id).toMatch(UUID_RE)

            // TODO(DOMA-2765) Get rid of sleep
            await sleep(1000)

            const message1 = await Message.getOne(admin, messageWhere)

            expect(message1.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message1.meta.data.ticketId).toEqual(ticket.id)
            expect(message1.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('sms')

        })

        test('executor with registered pushToken and connected to ticket on create receives push notification with all required fields', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithProperty()
            const executor = await makeClientWithNewRegisteredAndLoggedInUser()
            const randomFakeSuccessPushtoken = `${PUSH_FAKE_TOKEN_SUCCESS}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushtoken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(executor, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            const extraProps = { executor: { connect: { id: executor.user.id } } }
            const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

            expect(ticket.executor.id).toEqual(executor.user.id)

            const messageWhere = { user: { id: executor.user.id }, type: TICKET_EXECUTOR_CONNECTED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.id).toMatch(UUID_RE)

            // TODO(DOMA-2765) Get rid of sleep
            await sleep(1000)

            const message1 = await Message.getOne(admin, messageWhere)

            expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
            expect(message1.meta.data.ticketId).toEqual(ticket.id)
            expect(message1.processingMeta.transport).toEqual('push')

            const content = message1.processingMeta.messageContext

            expect(content.data.url).toBeDefined()
            expect(content.data.ticketId).toBeDefined()
            expect(content.data.ticketNumber).toBeDefined()
            expect(content.data.userId).toBeDefined()
            expect(content.data.notificationId).toBeDefined()
        })

        test('executor with no registered pushToken and connected to ticket on create receives fallback sms instead of push notification', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithProperty()
            const executor = await makeClientWithNewRegisteredAndLoggedInUser()
            const extraProps = { executor: { connect: { id: executor.user.id } } }
            const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

            expect(ticket.executor.id).toEqual(executor.user.id)

            const messageWhere = { user: { id: executor.user.id }, type: TICKET_EXECUTOR_CONNECTED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.id).toMatch(UUID_RE)

            // TODO(DOMA-2765) Get rid of sleep
            await sleep(1000)

            const message1 = await Message.getOne(admin, messageWhere)

            expect(message1.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message1.meta.data.ticketId).toEqual(ticket.id)
            expect(message1.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('sms')
        })

        test('executor with registered invalid pushToken and connected to ticket on create receives fallback sms instead of push notification', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithProperty()
            const executor = await makeClientWithNewRegisteredAndLoggedInUser()
            const randomFakeFailurePushtoken = `${PUSH_FAKE_TOKEN_FAIL}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeFailurePushtoken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(executor, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            const extraProps = { executor: { connect: { id: executor.user.id } } }
            const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

            expect(ticket.executor.id).toEqual(executor.user.id)

            const messageWhere = { user: { id: executor.user.id }, type: TICKET_EXECUTOR_CONNECTED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.id).toMatch(UUID_RE)

            // TODO(DOMA-2765) Get rid of sleep
            await sleep(1000)

            const message1 = await Message.getOne(admin, messageWhere)

            expect(message1.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message1.meta.data.ticketId).toEqual(ticket.id)
            expect(message1.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('sms')
        })

    })
    describe( 'NotificationWhen', () => {
        it('update status to TICKET_STATUS_IN_PROGRESS and send push for resident with registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_SUCCESS}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_DELIVERED_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')
        })

        it('update status to TICKET_STATUS_IN_PROGRESS and send sms for resident with no registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('update status to TICKET_STATUS_IN_PROGRESS and send sms for resident with registered invalid pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_FAIL}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message1.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('update status to TICKET_STATUS_IN_PROGRESS and can`t send notification there is no resident', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const unitName = faker.random.alphaNumeric(5)

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client).toEqual(null)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
            const messageCount = await Message.count(admin, messageWhere)

            expect(messageCount).toEqual(0)
        })

        it('update status to TICKET_STATUS_COMPLETED and send push for resident with registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_SUCCESS}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_COMPLETED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_DELIVERED_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')
        })

        it('update status to TICKET_STATUS_COMPLETED and send sms for resident with no registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_COMPLETED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('update status to TICKET_STATUS_COMPLETED and send sms for resident with registered invalid pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_FAIL}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_COMPLETED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('update status to TICKET_STATUS_COMPLETED and can`t send notification there is no resident', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const unitName = faker.random.alphaNumeric(5)

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client).toEqual(null)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_COMPLETED_TYPE }
            const messageCount = await Message.count(admin, messageWhere)

            expect(messageCount).toEqual(0)
        })

        it('update status to TICKET_STATUS_RETURNED and send push for resident with registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_SUCCESS}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_RETURNED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_DELIVERED_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')
        })

        it('update status to TICKET_STATUS_RETURNED and send sms for resident with no registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_RETURNED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('update status to TICKET_STATUS_RETURNED and send sms for resident with registered invalid pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_FAIL}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_RETURNED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('update status to TICKET_STATUS_RETURNED and can`t send notification there is no resident', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const unitName = faker.random.alphaNumeric(5)

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            expect(ticket.client).toEqual(null)

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_RETURNED_TYPE }
            const messageCount = await Message.count(admin, messageWhere)

            expect(messageCount).toEqual(0)
        })

        it('update indicator waranty and send push for resident with registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_SUCCESS}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                isWarranty: true,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                isWarranty: false,
            })

            await sleep(1000)

            const messageWhereAddIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_ADDED_TYPE }
            const messageAddIndicate = await Message.getOne(admin, messageWhereAddIndicate)

            const messageWhereDeleteIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_REMOVED_TYPE }
            const messageDeleteIndicate = await Message.getOne(admin, messageWhereDeleteIndicate)

            expect(messageAddIndicate.status).toEqual(MESSAGE_DELIVERED_STATUS)
            expect(messageDeleteIndicate.status).toEqual(MESSAGE_DELIVERED_STATUS)

            expect(messageAddIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.indicatorType).toEqual(messageAddIndicate.meta.data.indicatorType)

            expect(messageAddIndicate.processingMeta.transport).toEqual('push')
            expect(messageDeleteIndicate.processingMeta.transport).toEqual('push')
        })

        it('update indicator waranty and send sms for resident with no registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                isWarranty: true,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                isWarranty: false,
            })

            await sleep(1000)

            const messageWhereAddIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_ADDED_TYPE }
            const messageAddIndicate = await Message.getOne(admin, messageWhereAddIndicate)

            const messageWhereDeleteIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_REMOVED_TYPE }
            const messageDeleteIndicate = await Message.getOne(admin, messageWhereDeleteIndicate)

            expect(messageAddIndicate.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(messageDeleteIndicate.status).toEqual(MESSAGE_ERROR_STATUS)

            expect(messageAddIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.indicatorType).toEqual(messageAddIndicate.meta.data.indicatorType)

            expect(messageAddIndicate.processingMeta.transport).toEqual('push')
            expect(messageDeleteIndicate.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('update indicator waranty and send sms for resident with registered invalid pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_FAIL}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                isWarranty: true,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                isWarranty: false,
            })

            await sleep(1000)

            const messageWhereAddIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_ADDED_TYPE }
            const messageAddIndicate = await Message.getOne(admin, messageWhereAddIndicate)

            const messageWhereDeleteIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_REMOVED_TYPE }
            const messageDeleteIndicate = await Message.getOne(admin, messageWhereDeleteIndicate)

            expect(messageAddIndicate.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(messageDeleteIndicate.status).toEqual(MESSAGE_ERROR_STATUS)

            expect(messageAddIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.indicatorType).toEqual(messageAddIndicate.meta.data.indicatorType)

            expect(messageAddIndicate.processingMeta.transport).toEqual('push')
            expect(messageDeleteIndicate.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('update indicator waranty and can`t send notification there is no resident', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const unitName = faker.random.alphaNumeric(5)

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                isWarranty: true,
            })

            expect(ticket.client).toEqual(null)

            await updateTestTicket(admin, ticket.id, {
                isWarranty: false,
            })

            await sleep(1000)

            const messageWhereAddIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_ADDED_TYPE }
            const messageAddIndicateCount = await Message.count(admin, messageWhereAddIndicate)

            const messageWhereDeleteIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_REMOVED_TYPE }
            const messageDeleteIndicateCount = await Message.count(admin, messageWhereDeleteIndicate)

            expect(messageAddIndicateCount).toEqual(0)
            expect(messageDeleteIndicateCount).toEqual(0)
        })

        it('update indicator paid and create message with TICKET_INDICATOR_ADDED and TICKET_INDICATOR_REMOVED type', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                isPaid: true,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                isPaid: false,
            })

            await sleep(1000)

            const messageWhereAddIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_ADDED_TYPE }
            const messageAddIndicate = await Message.getOne(admin, messageWhereAddIndicate)

            const messageWhereDeleteIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_REMOVED_TYPE }
            const messageDeleteIndicate = await Message.getOne(admin, messageWhereDeleteIndicate)

            expect(messageAddIndicate.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(messageDeleteIndicate.status).toEqual(MESSAGE_ERROR_STATUS)

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(messageAddIndicate.status).toEqual(MESSAGE_DELIVERED_STATUS)
            // expect(messageDeleteIndicate.status).toEqual(MESSAGE_DELIVERED_STATUS)

            expect(messageAddIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.indicatorType).toEqual(messageAddIndicate.meta.data.indicatorType)
        })

        it('update indicator emergency and create message with TICKET_INDICATOR_ADDED and TICKET_INDICATOR_REMOVED type', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
                isEmergency: true,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await updateTestTicket(admin, ticket.id, {
                isEmergency: false,
            })

            await sleep(1000)

            const messageWhereAddIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_ADDED_TYPE }
            const messageAddIndicate = await Message.getOne(admin, messageWhereAddIndicate)

            const messageWhereDeleteIndicate = { user: { id: userClient.user.id }, type: TICKET_INDICATOR_REMOVED_TYPE }
            const messageDeleteIndicate = await Message.getOne(admin, messageWhereDeleteIndicate)

            expect(messageAddIndicate.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(messageDeleteIndicate.status).toEqual(MESSAGE_ERROR_STATUS)

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(messageAddIndicate.status).toEqual(MESSAGE_DELIVERED_STATUS)
            // expect(messageDeleteIndicate.status).toEqual(MESSAGE_DELIVERED_STATUS)

            expect(messageAddIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.ticketId).toEqual(ticket.id)
            expect(messageDeleteIndicate.meta.data.indicatorType).toEqual(messageAddIndicate.meta.data.indicatorType)
        })

        it('admin create new comment and send push for resident with registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_SUCCESS}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await createTestTicketComment(admin, ticket, userClient.user)

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_COMMENT_ADDED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_DELIVERED_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')
        })

        it('admin create new comment and send sms for resident with no registered pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await createTestTicketComment(admin, ticket, userClient.user)

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_COMMENT_ADDED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('admin create new comment and send sms for resident with registered invalid pushToken', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const randomFakeSuccessPushToken = `${PUSH_FAKE_TOKEN_FAIL}-${faker.datatype.uuid()}`
            const tokenData = { pushToken: randomFakeSuccessPushToken, pushTransport: PUSH_TRANSPORT_FIREBASE }
            const payload = getRandomTokenData(tokenData)
            const [device] = await syncDeviceByTestClient(userClient, payload)

            expect(device.pushTransport).toEqual(payload.pushTransport)

            await createTestResident(admin, userClient.user, userClient.organization, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client.id).toEqual(userClient.user.id)

            await createTestTicketComment(admin, ticket, userClient.user)

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_COMMENT_ADDED_TYPE }
            const message = await Message.getOne(admin, messageWhere)

            expect(message.status).toEqual(MESSAGE_ERROR_STATUS)
            expect(message.meta.data.userId).toEqual(userClient.user.id)
            expect(message.meta.data.ticketId).toEqual(ticket.id)
            expect(message.meta.data.ticketNumber).toEqual(ticket.number)
            expect(message.processingMeta.transport).toEqual('push')

            // EMAIL was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('email')
            // SMS was disabled for a while as main fallback transport for push
            // expect(message.processingMeta.transport).toEqual('sms')
        })

        it('admin create new comment and can`t send notification there is no resident', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const unitName = faker.random.alphaNumeric(5)

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            expect(ticket.client).toEqual(null)

            await createTestTicketComment(admin, ticket, userClient.user)

            await sleep(1000)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_COMMENT_ADDED_TYPE }
            const messageCount = await Message.count(admin, messageWhere)

            expect(messageCount).toEqual(0)
        })

        it('resident create new comment and can`t send push to myself', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, organization)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTickets: true,
                canManageTicketComments: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

            await createTestResident(adminClient, userClient.user, organization, property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, organization, property, {
                unitName,
            })

            await createTestTicketComment(userClient, ticket, userClient.user)

            const messageWhere = { user: { id: userClient.user.id }, type: TICKET_COMMENT_ADDED_TYPE }
            const messageCount = await Message.count(userClient, messageWhere)

            expect(messageCount).toEqual(0)
        })
    })
})
