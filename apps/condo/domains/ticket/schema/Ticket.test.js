/**
 * Generated by `createschema ticket.Ticket organization:Text; statusReopenedCounter:Integer; statusReason?:Text; status:Relationship:TicketStatus:PROTECT; number?:Integer; client?:Relationship:User:SET_NULL; clientName:Text; clientEmail:Text; clientPhone:Text; operator:Relationship:User:SET_NULL; assignee?:Relationship:User:SET_NULL; classifier:Relationship:TicketClassifier:PROTECT; details:Text; meta?:Json;`
 */
const faker = require('faker')
const { makeClientWithProperty } = require('../../../schema/Property/Property.test')
const { NUMBER_RE, UUID_RE, DATETIME_RE } = require('@core/keystone/test.utils')

const { createTestTicket } = require('@condo/domains/ticket/utils/testSchema')

// async function updateTicket (client, ticket, values) {
//     const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
//
//     return await Ticket.update(client, ticket.id, { ...values, dv: 1, sender })
// }

test('user: createTicket()', async () => {
    const client = await makeClientWithProperty()
    const [ticket, attrs] = await createTestTicket(client, client.organization, client.property)
    expect(ticket.id).toMatch(UUID_RE)
    expect(String(ticket.number)).toMatch(NUMBER_RE)
    expect(ticket.dv).toEqual(1)
    expect(ticket.sender).toEqual(attrs.sender)
    expect(ticket.source).toEqual(expect.objectContaining({ id: attrs.source.connect.id }))
    expect(ticket.sourceMeta).toEqual(null)
    expect(ticket.classifier).toEqual(expect.objectContaining({ id: attrs.classifier.connect.id }))
    expect(ticket.property).toEqual(expect.objectContaining({ id: client.property.id }))
    expect(ticket.status).toEqual(expect.objectContaining({ id: attrs.status.connect.id }))
    expect(ticket.statusReopenedCounter).toEqual(0)
    expect(ticket.statusReason).toEqual(null)
    expect(ticket.statusUpdatedAt).toBeNull()
    expect(ticket.details).toEqual(attrs.details)
    expect(ticket.meta).toEqual(null)
    expect(ticket.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
    expect(ticket.client).toEqual(null)
    expect(ticket.operator).toEqual(null)
    expect(ticket.assignee).toEqual(null)
    expect(ticket.isPaid).toEqual(false)
    expect(ticket.isEmergency).toEqual(false)
    expect(ticket.executor).toEqual(null)
    expect(ticket.watchers).toEqual([])
    expect(ticket.v).toEqual(1)
    expect(ticket.newId).toEqual(null)
    expect(ticket.deletedAt).toEqual(null)
    expect(ticket.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
    expect(ticket.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
    expect(ticket.createdAt).toMatch(DATETIME_RE)
    expect(ticket.updatedAt).toMatch(DATETIME_RE)
})
//
// test('should correctly update ticket status without ticket number increment', async () => {
//     const client = await makeClientWithProperty()
//     const [ticket] = await createTicket(client, client.organization, client.property)
//     const prevTicketNmber = ticket.number
//     const obj = await updateTicket(client, ticket, { status: { connect: { id: 'f0fa0093-8d86-4e69-ae1a-70a2914da82f' } } })
//
//     expect(obj.number).toEqual(prevTicketNmber)
// })