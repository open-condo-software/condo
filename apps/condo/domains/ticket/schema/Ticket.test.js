/**
 * Generated by `createschema ticket.Ticket organization:Text; statusReopenedCounter:Integer; statusReason?:Text; status:Relationship:TicketStatus:PROTECT; number?:Integer; client?:Relationship:User:SET_NULL; clientName:Text; clientEmail:Text; clientPhone:Text; operator:Relationship:User:SET_NULL; assignee?:Relationship:User:SET_NULL;details:Text; meta?:Json;`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { get, pick } = require('lodash')

const conf = require('@open-condo/config')
const {
    NUMBER_RE, UUID_RE, DATETIME_RE,
    makeClient, makeLoggedInAdminClient, waitFor,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowGraphQLRequestError,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAccessDeniedErrorToObjects,
    expectToThrowValidationFailureError,
    expectToThrowGQLError,
    expectValuesOfCommonFields,
    setAllFeatureFlags,
} = require('@open-condo/keystone/test.utils')

const { WRONG_VALUE } = require('@app/condo/domains/common/constants/errors')
const { md5 } = require('@condo/domains/common/utils/crypto')
const { createTestContact } = require('@condo/domains/contact/utils/testSchema')
const {
    TICKET_ASSIGNEE_CONNECTED_TYPE,
    TICKET_EXECUTOR_CONNECTED_TYPE,
    TICKET_STATUS_IN_PROGRESS_TYPE,
    TICKET_STATUS_COMPLETED_TYPE,
    TICKET_STATUS_RETURNED_TYPE,
    TICKET_STATUS_DECLINED_TYPE,
    MESSAGE_SENT_STATUS,
    TRACK_TICKET_IN_DOMA_APP_TYPE,
    DEVICE_PLATFORM_ANDROID,
    APP_MASTER_ID_ANDROID,
    APP_RESIDENT_ID_ANDROID,
    PUSH_TRANSPORT,
    SMS_TRANSPORT,
} = require('@condo/domains/notification/constants/constants')
const {
    Message,
    MessageOrganizationBlackList,
    updateTestMessageOrganizationBlackList,
    syncRemoteClientWithPushTokenByTestClient,
} = require('@condo/domains/notification/utils/testSchema')
const {
    PROPERTY_TICKET_VISIBILITY,
    PROPERTY_AND_SPECIALIZATION_VISIBILITY,
    ASSIGNED_TICKET_VISIBILITY,
    ORGANIZATION_TICKET_VISIBILITY,
} = require('@condo/domains/organization/constants/common')
const {
    createTestOrganizationLink,
    createTestOrganizationWithAccessToAnotherOrganization,
    createTestOrganizationEmployee,
    createTestOrganizationEmployeeSpecialization,
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    updateTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE, WAREHOUSE_UNIT_TYPE, SECTION_SECTION_TYPE, COMMERCIAL_UNIT_TYPE, PARKING_SECTION_TYPE } = require('@condo/domains/property/constants/common')
const {
    makeClientWithProperty,
    createTestProperty,
    updateTestProperty,
    makeClientWithResidentAccessAndProperty,
} = require('@condo/domains/property/utils/testSchema')
const { createTestResident } = require('@condo/domains/resident/utils/testSchema')
const {
    createTestPropertyScope,
    createTestPropertyScopeOrganizationEmployee,
    createTestPropertyScopeProperty,
} = require('@condo/domains/scope/utils/testSchema')
const {
    REVIEW_VALUES,
    DEFERRED_STATUS_TYPE,
    CANCELED_STATUS_TYPE,
    NEW_OR_REOPENED_STATUS_TYPE,
    CLOSED_STATUS_TYPE,
} = require('@condo/domains/ticket/constants')
const { FEEDBACK_VALUES_BY_KEY, FEEDBACK_ADDITIONAL_OPTIONS, FEEDBACK_VALUES } = require('@condo/domains/ticket/constants/feedback')
const { QUALITY_CONTROL_ADDITIONAL_OPTIONS, QUALITY_CONTROL_VALUES } = require('@condo/domains/ticket/constants/qualityControl')
const { STATUS_IDS } = require('@condo/domains/ticket/constants/statusTransitions')
const { ERRORS, DAILY_SAME_TICKET_LIMIT, DAILY_TICKET_LIMIT } = require('@condo/domains/ticket/schema/Ticket')
const {
    Ticket,
    TicketOrganizationSetting,
    TicketComment,
    createTestTicket,
    updateTestTicket,
    createTestTicketComment,
    createTestTicketClassifier, TicketStatus,
} = require('@condo/domains/ticket/utils/testSchema')
const {
    makeClientWithResidentUser,
    makeClientWithNewRegisteredAndLoggedInUser,
    createTestPhone,
    makeClientWithSupportUser,
} = require('@condo/domains/user/utils/testSchema')


const FEEDBACK_VALUES_WITHOUT_RETURNED = FEEDBACK_VALUES.filter(item => item !== FEEDBACK_VALUES_BY_KEY.RETURNED)
// TODO(DOMA-5833): delete REVIEW_VALUES_WITHOUT_RETURNED when the mobile app will use 'feedback*' fields
/** @deprecated */
const REVIEW_VALUES_WITHOUT_RETURNED = [REVIEW_VALUES.GOOD, REVIEW_VALUES.BAD]
const MESSAGE_SENDING_DElAY = 1000 * 5
const TICKET_OTHER_SOURCE_ID = '7da1e3be-06ba-4c9e-bba6-f97f278ac6e4'

describe('Ticket', () => {
    let admin
    let organization
    let property
    let clientWithCanReadTicket
    let clientWithoutCanReadTicket

    beforeAll(async () => {
        setAllFeatureFlags(true)

        admin = await makeLoggedInAdminClient()
        clientWithCanReadTicket = await makeClientWithNewRegisteredAndLoggedInUser()
        clientWithoutCanReadTicket = await makeClientWithNewRegisteredAndLoggedInUser()
        const [testOrganization] = await createTestOrganization(admin)
        organization = testOrganization
        const [testProperty] = await createTestProperty(admin, organization)
        property = testProperty
        const [roleWithCanReadTickets] = await createTestOrganizationEmployeeRole(admin, organization, { canReadTickets: true })
        const [roleWithoutCanReadTickets] = await createTestOrganizationEmployeeRole(admin, organization, { canReadTickets: false })
        await createTestOrganizationEmployee(admin, organization, clientWithCanReadTicket.user, roleWithCanReadTickets)
        await createTestOrganizationEmployee(admin, organization, clientWithoutCanReadTicket.user, roleWithoutCanReadTickets)
    })

    describe('CRUD', () => {
        test('user: create Ticket', async () => {
            const client = await makeClientWithProperty()
            const [contact] = await createTestContact(client, client.organization, client.property)
            const fields = {
                contact: { connect: { id: contact.id } },

                priority: 200,
                isInsurance: true,
                title: 'sample ticket short title',
                kanbanOrder: 15,
                kanbanColumn: 'my-custom-column',
                customClassifier: 'feature',
            }
            const [obj, attrs] = await createTestTicket(client, client.organization, client.property, fields)

            expectValuesOfCommonFields(obj, attrs, client)
            expect(obj.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(String(obj.number)).toMatch(NUMBER_RE)
            expect(obj.source).toEqual(expect.objectContaining({ id: attrs.source.connect.id }))
            expect(obj.sourceMeta).toEqual(null)
            expect(obj.property).toEqual(expect.objectContaining({ id: client.property.id }))
            expect(obj.propertyAddress).toEqual(client.property.address)
            expect(obj.propertyAddressMeta).toEqual(client.property.addressMeta)
            expect(obj.status).toEqual(expect.objectContaining({ id: attrs.status.connect.id }))
            expect(obj.statusReopenedCounter).toEqual(0)
            expect(obj.statusReason).toEqual(null)
            expect(obj.statusUpdatedAt).toBeNull()
            expect(obj.details).toEqual(attrs.details)
            expect(obj.isPayable).toEqual(false)
            expect(obj.isEmergency).toEqual(false)
            expect(obj.isWarranty).toEqual(false)
            expect(obj.meta).toEqual(null)
            expect(obj.client).toEqual(null)
            expect(obj.contact).toEqual(expect.objectContaining({ id: attrs.contact.connect.id }))
            expect(obj.assignee).toEqual(null)
            expect(obj.executor).toEqual(null)
            expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
            expect(obj.completedAt).toEqual(null)
            expect(obj.deferredUntil).toEqual(null)
            expect(obj.feedbackValue).toBeNull()
            expect(obj.feedbackComment).toBeNull()
            expect(obj.feedbackAdditionalOptions).toBeNull()
            expect(obj.feedbackUpdatedAt).toBeNull()
            expect(obj.qualityControlValue).toBeNull()
            expect(obj.qualityControlComment).toBeNull()
            expect(obj.qualityControlAdditionalOptions).toBeNull()
            expect(obj.qualityControlUpdatedAt).toBeNull()
            expect(obj.qualityControlUpdatedBy).toBeNull()
            expect(obj.title).toEqual(attrs.title)
            expect(obj.priority).toEqual(attrs.priority)
            expect(obj.kanbanOrder).toEqual(attrs.kanbanOrder)
            expect(obj.kanbanColumn).toEqual(attrs.kanbanColumn)
            expect(obj.customClassifier).toEqual(attrs.customClassifier)
            expect(obj.isInsurance).toEqual(attrs.isInsurance)
        })

        test('user with resident type without resident: cannot create Ticket', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            await createTestResident(admin, userClient.user, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, userClient.property)
            })
        })
        test('resident: can create ticket without deadline and set default deadline', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })
            const ticketSetting = await TicketOrganizationSetting.getOne(admin, {
                organization: { id: userClient.organization.id },
            })
            const durationAsMs = dayjs.duration(ticketSetting.defaultDeadlineDuration).asMilliseconds()
            const expectedDeadline = dayjs().add(durationAsMs, 'ms').toISOString()
            expect(ticket.deadline).not.toBeNull()
            expect(dayjs(ticket.deadline).diff(expectedDeadline, 'days')).toEqual(0)
        })

        test('resident: can create Ticket and client info save in new ticket', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [obj] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            const user = userClient.user
            const { name, email, phone } = userClient.userAttrs

            expect(obj.client.id).toEqual(user.id)
            expect(obj.clientName).toEqual(name)
            expect(obj.clientPhone).toEqual(phone)
            expect(obj.clientEmail).toEqual(email)
        })

        test('user with 2 residents: can create Ticket for each resident', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName: unitName1,
            })
            await createTestResident(admin, userClient.user, property, {
                unitName: unitName2,
            })

            const [ticket1] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName: unitName1,
            })
            const [ticket2] = await createTestTicket(userClient, organization, property, {
                unitName: unitName2,
            })

            expect(ticket1.id).toMatch(UUID_RE)
            expect(ticket2.id).toMatch(UUID_RE)
        })

        test('resident: cannot create Ticket without unitName', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, userClient.property)
            })
        })

        test('resident: cannot create Ticket in other unitName', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName: unitName1,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName: unitName2,
                })
            })
        })

        test('resident: cannot create Ticket in other property', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const [property] = await createTestProperty(admin, userClient.organization)
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, property, {
                    unitName,
                })
            })
        })
        test('resident: cannot update his Ticket details', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const newDetails = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient, ticket.id, {
                    details: newDetails,
                })
            })
        })
        test('employee: update statusReopenedCounter when update status from completed to open', async () => {
            const userClient = await makeClientWithProperty()

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(ticket.id).toEqual(updatedTicket.id)
            expect(updatedTicket.statusReopenedCounter).toEqual(1)

            await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })
            const [againUpdatedTicket] = await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(againUpdatedTicket.statusReopenedCounter).toEqual(2)
        })

        test('resident: cannot update his Ticket fields other than accessibleUpdatedFields', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            const newDetails = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient, ticket.id, {
                    details: newDetails,
                    unitName: unitName2,
                })
            })
        })

        test('resident: can update his Ticket status to a "canceled" status', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            const [canceledStatus] = await TicketStatus.getAll(userClient, {
                type: CANCELED_STATUS_TYPE,
            })

            const [canceledTicket] = await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: canceledStatus.id } },
            })

            expect(canceledTicket.id).toEqual(ticket.id)
            expect(canceledTicket.status.type).toEqual(CANCELED_STATUS_TYPE)
        })

        test('resident: cannot update his Ticket status to a status other than "cancelled"', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            const [closedStatus] = await TicketStatus.getAll(userClient, {
                type: CLOSED_STATUS_TYPE,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient, ticket.id, {
                    status: { connect: { id: closedStatus.id } },
                })
            })
        })

        test('resident: cannot update not his Ticket', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const userClient2 = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            const newDetails = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })
            await createTestResident(admin, userClient2.user, userClient.property, {
                unitName: unitName2,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient2, ticket.id, {
                    details: newDetails,
                    unitName: unitName2,
                })
            })
        })

        test('resident: can read his Tickets', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })
            const [readTicket] = await Ticket.getAll(userClient, { id: ticket.id })

            expect(readTicket.id).toEqual(ticket.id)
        })

        test('resident: can read ticket with a contact whose phone number and address matches the resident phone number and address', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

            expect(readTicket.id).toEqual(ticket.id)
        })

        test('resident: if no client data but with contact data, client data fills from contact', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

            expect(readTicket.clientPhone).toEqual(contact.phone)
            expect(readTicket.clientEmail).toEqual(contact.email)
            expect(readTicket.clientName).toEqual(contact.name)
        })

        test('admin: if client data and contact data sended, client data not overwritted', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone, email, name } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [anotherContact] = await createTestContact(admin, organization, property)
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: anotherContact.id } },
                canReadByResident: true,
                clientName: name,
                clientPhone: phone,
                clientEmail: email,
            })

            const [readTicket] = await Ticket.getAll(admin, { id: ticket.id })

            expect(readTicket.clientPhone).toEqual(phone)
            expect(readTicket.clientEmail).toEqual(email)
            expect(readTicket.clientName).toEqual(name)
        })

        test('admin: if client data sended without contact data, client data not overwritted', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone, email, name } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                canReadByResident: true,
                clientName: name,
                clientPhone: phone,
                clientEmail: email,
            })

            const [readTicket] = await Ticket.getAll(admin, { id: ticket.id })

            expect(readTicket.clientPhone).toEqual(phone)
            expect(readTicket.clientEmail).toEqual(email)
            expect(readTicket.clientName).toEqual(name)
        })

        test('resident: cannot read ticket with a contact whose phone number did not matches the resident phone number', async () => {
            const residentClient1 = await makeClientWithResidentUser()
            const { phone } = residentClient1.userAttrs
            const residentClient2 = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentClient1.user, property, {
                unitName,
            })
            await createTestResident(admin, residentClient2.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const [readTicket] = await Ticket.getAll(residentClient1, {})
            expect(readTicket.id).toEqual(ticket.id)

            const tickets = await Ticket.getAll(residentClient2, {})
            expect(tickets).toHaveLength(0)
        })

        test('resident: cannot read ticket with a contact whose property or unitName ' +
            'did not matches the resident property or unitName', async () => {
            const residentWithTicketClient = await makeClientWithResidentUser()
            const residentFromAnotherPropertyClient = await makeClientWithResidentUser()
            const residentFromAnotherUnitClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property1] = await createTestProperty(admin, organization)
            const [property2] = await createTestProperty(admin, organization)
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentWithTicketClient.user, property1, {
                unitName: unitName1,
            })
            await createTestResident(admin, residentFromAnotherPropertyClient.user, property2, {
                unitName: unitName1,
            })
            await createTestResident(admin, residentFromAnotherUnitClient.user, property1, {
                unitName: unitName2,
            })
            const [contact] = await createTestContact(admin, organization, property1, {
                phone: residentWithTicketClient.userAttrs.phone,
                unitName: unitName1,
            })
            const [ticket] = await createTestTicket(admin, organization, property1, {
                unitName: unitName1,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const [ticketForResidentWithTicket] = await Ticket.getAll(residentWithTicketClient, {})
            expect(ticketForResidentWithTicket.id).toEqual(ticket.id)

            const ticketsForResidentFromAnotherProperty = await Ticket.getAll(residentFromAnotherPropertyClient, {})
            expect(ticketsForResidentFromAnotherProperty).toHaveLength(0)

            const ticketsForResidentFromAnotherUnit = await Ticket.getAll(residentFromAnotherUnitClient, {})
            expect(ticketsForResidentFromAnotherUnit).toHaveLength(0)
        })

        test('resident: user with 2 residents and 2 different contacts can read ticket for each resident', async () => {
            const residentClient1 = await makeClientWithResidentUser()
            const { phone } = residentClient1.userAttrs

            const [organization] = await createTestOrganization(admin)
            const [property1] = await createTestProperty(admin, organization)
            const [property2] = await createTestProperty(admin, organization)
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentClient1.user, property1, { unitName: unitName1 })
            await createTestResident(admin, residentClient1.user, property2, { unitName: unitName2 })

            const [contact1] = await createTestContact(admin, organization, property1, { phone, unitName: unitName1 })
            const [contact2] = await createTestContact(admin, organization, property2, { phone, unitName: unitName2 })

            const [ticket1] = await createTestTicket(admin, organization, property1, {
                unitName: unitName1,
                contact: { connect: { id: contact1.id } },
                canReadByResident: true,
            })

            const [ticket2] = await createTestTicket(admin, organization, property2, {
                unitName: unitName2,
                contact: { connect: { id: contact2.id } },
                canReadByResident: true,
            })

            await createTestTicket(admin, organization, property1, {
                unitName: unitName2,
                contact: { connect: { id: contact1.id } },
                canReadByResident: true,
            })

            const tickets = await Ticket.getAll(residentClient1, {}, { sortBy: 'createdAt_ASC' })
            expect(tickets).toHaveLength(2)
            expect(tickets[0].id).toMatch(ticket1.id)
            expect(tickets[1].id).toMatch(ticket2.id)
        })

        test('resident: cannot read ticket from crm with "canReadByResident": false', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: false,
            })
            const [visibleTicket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const tickets = await Ticket.getAll(residentClient, {})

            expect(tickets).toHaveLength(1)
            expect(tickets[0].id).toEqual(visibleTicket.id)
        })

        test('resident: can read ticket from crm if first it was hidden to him then it became showed', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone: phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: false,
            })

            const tickets = await Ticket.getAll(residentClient, {})

            expect(tickets).toHaveLength(0)

            await updateTestTicket(admin, ticket.id, {
                canReadByResident: true,
            })

            const ticketsAfterShowedTicketToResident = await Ticket.getAll(residentClient, {})

            expect(ticketsAfterShowedTicketToResident).toHaveLength(1)
            expect(ticketsAfterShowedTicketToResident[0].id).toEqual(ticket.id)
        })

        test('resident: cannot read ticket from crm if first it was showed to him then it became hidden', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone: phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const tickets = await Ticket.getAll(residentClient, {})

            expect(tickets).toHaveLength(1)
            expect(tickets[0].id).toEqual(ticket.id)

            await updateTestTicket(admin, ticket.id, {
                canReadByResident: false,
            })

            const ticketsAfterHiddenTicketToResident = await Ticket.getAll(residentClient, {})

            expect(ticketsAfterHiddenTicketToResident).toHaveLength(0)
        })

        test('resident: cannot update ticket from crm', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs
            const newDetails = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(residentClient, ticket.id, {
                    details: newDetails,
                })
            })
        })

        test('resident: cannot read not his Tickets', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const userInOtherProperty = await makeClientWithResidentAccessAndProperty()
            const userInOtherUnit = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })
            await createTestResident(admin, userInOtherProperty.user, userInOtherProperty.property, {
                unitName,
            })
            await createTestResident(admin, userInOtherUnit.user, userClient.property, {
                unitName: unitName2,
            })
            const [ticketInOtherProperty] = await createTestTicket(userInOtherProperty, userInOtherProperty.organization, userInOtherProperty.property, {
                unitName,
            })
            const [ticketInOtherUnit] = await createTestTicket(userInOtherUnit, userClient.organization, userClient.property, {
                unitName: unitName2,
            })

            const readTickets = await Ticket.getAll(userClient, { id_in: [ticketInOtherProperty.id, ticketInOtherUnit.id] })

            expect(readTickets).toHaveLength(0)
        })

        test('anonymous: create Ticket', async () => {
            const client1 = await makeClientWithProperty()
            const client = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestTicket(client, client1.organization, client1.property)
            })
        })

        test('employee with canReadTicket: can read Ticket', async () => {
            const [ticket] = await createTestTicket(admin, organization, property)
            const readTicket = await Ticket.getOne(clientWithCanReadTicket, { id: ticket.id })

            expect(readTicket).toBeDefined()
        })

        test('employee without canReadTicket: can not read Ticket', async () => {
            const [ticket] = await createTestTicket(admin, organization, property)
            const readTicket = await Ticket.getOne(clientWithoutCanReadTicket, { id: ticket.id })

            expect(readTicket).toBeUndefined()
        })

        test('user: no access to another organization ticket', async () => {
            const hacker = await makeClientWithProperty()
            const client = await makeClientWithProperty()
            const [obj] = await createTestTicket(client, client.organization, client.property)

            const objs = await Ticket.getAll(hacker)
            expect(objs).toHaveLength(0)

            const objsFilteredById = await Ticket.getAll(hacker, { id: obj.id })
            expect(objsFilteredById).toHaveLength(0)
        })

        test('anonymous: read Ticket', async () => {
            const client = await makeClient()

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await Ticket.getAll(client)
            })
        })

        test('user: update Ticket', async () => {
            const client = await makeClientWithProperty()
            const payload = { details: 'new data' }
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            const [objUpdated, attrs] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.details).toEqual(payload.details)
            expect(objUpdated.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(objUpdated.number).toEqual(objCreated.number)
            // TODO(pahaz): check others fields ...
        })
        test('user: can change unitType to null', async () => {
            const client = await makeClientWithProperty()
            const payload = { details: 'new data', unitType: null, unitName: null }
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            expect(objCreated.unitType).toEqual(FLAT_UNIT_TYPE)

            const [objUpdated, attrs] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.details).toEqual(payload.details)
            expect(objUpdated.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(objUpdated.number).toEqual(objCreated.number)
            expect(objUpdated.unitType).toBeNull()
            expect(objUpdated.unitName).toBeNull()
        })

        test('user: set ticket assignee', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            const payload = { details: 'new data', assignee: { connect: { id: client.user.id } } }
            const [objUpdated] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.assignee).toEqual(expect.objectContaining({ id: client.user.id }))
        })

        test('admin: set ticket executor', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            const payload = { details: 'new data', executor: { connect: { id: client.user.id } } }
            const [objUpdated] = await updateTestTicket(admin, objCreated.id, payload)

            expect(objUpdated.executor).toEqual(expect.objectContaining({ id: client.user.id }))
        })

        test('user: can not set ticket number', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)
            const payload = { number: objCreated.number }

            await expectToThrowGraphQLRequestError(
                async () => await updateTestTicket(client, objCreated.id, payload),
                'Field "number" is not defined by type "TicketUpdateInput"',
            )
        })

        test('anonymous: update Ticket', async () => {
            const client1 = await makeClientWithProperty()
            const client = await makeClient()
            const payload = { details: 'new data' }
            const [objCreated] = await createTestTicket(client1, client1.organization, client1.property)
            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestTicket(client, objCreated.id, payload)
            })
        })

        test('user: delete Ticket', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Ticket.delete(client, objCreated.id)
            })
        })

        test('anonymous: delete Ticket', async () => {
            const client1 = await makeClientWithProperty()
            const client = await makeClient()
            const [objCreated] = await createTestTicket(client1, client1.organization, client1.property)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Ticket.delete(client, objCreated.id)
            })
        })

        test('should auto generating statusUpdatedAt when update status', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const [openTicket] = await createTestTicket(admin, userClient.organization, userClient.property, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            const [inProgressTicket] = await updateTestTicket(admin, openTicket.id, {
                status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
            })

            expect(dayjs(inProgressTicket.statusUpdatedAt).isValid()).toBe(true)
            expect(dayjs(inProgressTicket.statusUpdatedAt).diff(openTicket.createdAt)).toBeGreaterThanOrEqual(0)

            const [completedTicket] = await updateTestTicket(admin, openTicket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            expect(dayjs(completedTicket.statusUpdatedAt).isValid()).toBe(true)
            expect(dayjs(completedTicket.statusUpdatedAt).diff(inProgressTicket.statusUpdatedAt)).toBeGreaterThanOrEqual(0)
        })

        test('resident: can update feedback fields', async () => {
            const residentClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, residentClient.user, residentClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(residentClient, residentClient.organization, residentClient.property, {
                unitName,
            })

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
            })
            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            const [updatedTicket, attrs] = await updateTestTicket(residentClient, ticket.id, {
                feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED),
                feedbackComment: faker.lorem.sentence(),
                feedbackAdditionalOptions: faker.helpers.arrayElements(FEEDBACK_ADDITIONAL_OPTIONS),
            })

            expect(updatedTicket.feedbackValue).toEqual(attrs.feedbackValue)
            expect(updatedTicket.feedbackComment).toEqual(attrs.feedbackComment)
            expect(updatedTicket.feedbackAdditionalOptions).toEqual(attrs.feedbackAdditionalOptions.sort())
        })

        test('resident: should close ticket when set feedback', async () => {
            const residentClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, residentClient.user, residentClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(residentClient, residentClient.organization, residentClient.property, {
                unitName,
            })

            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
            })
            await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            const [updatedTicket] = await updateTestTicket(residentClient, ticket.id, {
                feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED),
            })

            expect(updatedTicket.status.id).toEqual(STATUS_IDS.CLOSED)
        })

        describe('resident: auto-set "feedbackUpdatedAt" when updated "feedbackValue" or "feedbackAdditionalOptions" or "feedbackComment"', () => {
            const cases = [
                ['feedbackValue', { feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED) }],
                ['feedbackAdditionalOptions', { feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED), feedbackAdditionalOptions: faker.helpers.arrayElements(FEEDBACK_ADDITIONAL_OPTIONS) }],
                ['feedbackComment', { feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED), feedbackComment: faker.lorem.sentence() }],
            ]

            test.each(cases)('%s', async (_, payload) => {
                const residentClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, residentClient.user, residentClient.property, {
                    unitName,
                })
                const [ticket] = await createTestTicket(residentClient, residentClient.organization, residentClient.property, {
                    unitName,
                })

                await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
                })
                await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                const timeBefore = dayjs()
                const [updatedTicket] = await updateTestTicket(residentClient, ticket.id, payload)
                const timeAfter = dayjs()

                expect(updatedTicket.feedbackUpdatedAt).not.toBeNull()
                expect(updatedTicket.feedbackUpdatedAt).not.toEqual(ticket.feedbackUpdatedAt)
                expect(dayjs(updatedTicket.feedbackUpdatedAt).isBetween(timeBefore, timeAfter)).toBeTruthy()
            })
        })

        test('user: can delete ticket', async () => {
            const client = await makeClientWithProperty()
            const [ticket] = await createTestTicket(client, client.organization, client.property)

            const payload = { deletedAt: 'true' }
            const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

            expect(updatedTicket.deletedAt).toBeDefined()
        })

        test('user: set qualityControlValue', async () => {
            const client = await makeClientWithProperty()
            const [ticket] = await createTestTicket(client, client.organization, client.property)

            const payload = { qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES) }
            const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

            expect(updatedTicket.qualityControlValue).toEqual(payload.qualityControlValue)
        })

        test('user: set qualityControlAdditionalOptions', async () => {
            const client = await makeClientWithProperty()
            const [ticket] = await createTestTicket(client, client.organization, client.property)

            const payload = {
                qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                qualityControlAdditionalOptions: faker.helpers.arrayElements(QUALITY_CONTROL_ADDITIONAL_OPTIONS),
            }
            const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

            expect(updatedTicket.qualityControlValue).toEqual(payload.qualityControlValue)
            expect(updatedTicket.qualityControlAdditionalOptions).toEqual(payload.qualityControlAdditionalOptions.sort())
        })

        test('user: set and update qualityControlAdditionalOptions', async () => {
            const client = await makeClientWithProperty()
            const [ticket, ticketAttrs] = await createTestTicket(client, client.organization, client.property, {
                qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                qualityControlAdditionalOptions: faker.helpers.arrayElements(QUALITY_CONTROL_ADDITIONAL_OPTIONS),
            })

            expect(ticket.qualityControlValue).toEqual(ticketAttrs.qualityControlValue)
            expect(ticket.qualityControlAdditionalOptions).toEqual(ticketAttrs.qualityControlAdditionalOptions.sort())

            const payload = {
                qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                qualityControlAdditionalOptions: faker.helpers.arrayElements(QUALITY_CONTROL_ADDITIONAL_OPTIONS),
            }
            const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

            expect(updatedTicket.qualityControlValue).toEqual(payload.qualityControlValue)
            expect(updatedTicket.qualityControlAdditionalOptions).toEqual(payload.qualityControlAdditionalOptions.sort())
        })

        test('user: set qualityControlComment', async () => {
            const client = await makeClientWithProperty()
            const [ticket] = await createTestTicket(client, client.organization, client.property)

            const payload = {
                qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                qualityControlComment: faker.lorem.sentence(),
            }
            const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

            expect(updatedTicket.qualityControlComment).toEqual(payload.qualityControlComment)
        })

        describe('user: auto-set "qualityControlUpdatedAt" and "qualityControlUpdatedBy" when updated "qualityControlValue" or "qualityControlAdditionalOptions" or "qualityControlComment"', () => {
            const cases = [
                ['qualityControlValue', { qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES) }],
                ['qualityControlAdditionalOptions', { qualityControlAdditionalOptions: faker.helpers.arrayElements(QUALITY_CONTROL_ADDITIONAL_OPTIONS) }],
                ['qualityControlComment', { qualityControlComment: faker.lorem.sentence() }],
            ]

            test.each(cases)('%s', async (_, payload) => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                })

                const timeBefore = dayjs()
                const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)
                const timeAfter = dayjs()

                expect(updatedTicket.qualityControlUpdatedAt).not.toBeNull()
                expect(updatedTicket.qualityControlUpdatedAt).not.toEqual(ticket.qualityControlUpdatedAt)
                expect(dayjs(updatedTicket.qualityControlUpdatedAt).isBetween(timeBefore, timeAfter)).toBeTruthy()
                expect(updatedTicket.qualityControlUpdatedBy.id).toEqual(client.user.id)
            })
        })
    })

    describe('Permissions', () => {
        test('user: create Ticket', async () => {
            const client = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(client, client.organization, client2.property)
            })
        })

        // TODO: DOMA-10832 add check employee organization in Ticket access
        test.skip('user: cannot create ticket executor field with user from different organization', async () => {
            const client = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()

            await createTestTicket(client, client.organization, client.property, { executor: { connect: { id: client2.user.id } } })
        })

        test('user: update Ticket', async () => {
            const client = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()
            const [obj] = await createTestTicket(client, client.organization, client.property)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(client, obj.id, { property: { connect: { id: client2.property.id } } })
            })
        })

        // TODO: DOMA-10832 add check employee organization in Ticket access
        test.skip('user: cannot update ticket executor field with user from different organization', async () => {
            const client = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()

            const [ticket1] = await createTestTicket(client, client.organization, client.property)

            await updateTestTicket(client, ticket1.id, { executor: { connect: { id: client2.user.id } } })
        })

        test('employee from "from" organization: can read tickets from "to" organizations', async () => {
            const {
                clientFrom,
                organizationTo,
                propertyTo,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const clientTo2 = await makeClientWithProperty()

            await createTestTicket(admin, organizationTo, propertyTo)
            await createTestTicket(admin, clientTo2.organization, clientTo2.property)

            await createTestOrganizationLink(admin, organizationFrom, clientTo2.organization)

            const tickets = await Ticket.getAll(clientFrom, { organization: { OR: [{ id: organizationTo.id }, { id: clientTo2.organization.id }] } })
            expect(tickets).toHaveLength(2)
        })

        test('employee from "to" organization: cannot read tickets from "from" organization', async () => {
            const {
                clientTo,
                organizationFrom,
                propertyFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            await createTestTicket(admin, organizationFrom, propertyFrom)

            const tickets = await Ticket.getAll(clientTo, { organization: { id: organizationFrom.id } })
            expect(tickets).toHaveLength(0)
        })

        test('employee from "from" organization: cannot read not its own "to" organizations', async () => {
            const { organizationTo, propertyTo } = await createTestOrganizationWithAccessToAnotherOrganization()
            const {
                clientFrom,
                organizationTo: organizationTo1,
            } = await createTestOrganizationWithAccessToAnotherOrganization()

            await createTestTicket(admin, organizationTo, propertyTo)

            const tickets = await Ticket.getAll(clientFrom, { organization: { OR: [{ id: organizationTo.id }, { id: organizationTo1.id }] } })
            expect(tickets).toHaveLength(0)
        })

        test('organization "from" employee with canManageTickets access: can create organization "to" tickets', async () => {
            const {
                clientFrom,
                organizationTo,
                propertyTo,
                employeeFrom,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const [ticket] = await createTestTicket(clientFrom, organizationTo, propertyTo)
            expect(ticket.id).toMatch(UUID_RE)
        })

        test('organization "to" employee: cannot create organization "from" tickets', async () => {
            const {
                organizationFrom,
                propertyFrom,
                clientTo,
            } = await createTestOrganizationWithAccessToAnotherOrganization()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(clientTo, organizationFrom, propertyFrom)
            })
        })

        test('user: cannot create tickets for "from" or "to" organizations', async () => {
            const {
                organizationFrom,
                propertyFrom,
                organizationTo,
                propertyTo,
                employeeFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const randomUser = await makeClientWithProperty()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(randomUser, organizationFrom, propertyFrom)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(randomUser, organizationTo, propertyTo)
            })
        })

        test('organization "from" employee: can update organization "to" tickets', async () => {
            const {
                clientFrom,
                organizationTo,
                propertyTo,
                organizationFrom,
                employeeFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const [ticket] = await createTestTicket(admin, organizationTo, propertyTo)
            const newDetails = faker.random.alphaNumeric(21)
            const [updatedTicket] = await updateTestTicket(clientFrom, ticket.id, { details: newDetails })

            expect(updatedTicket.id).toEqual(ticket.id)
            expect(updatedTicket.details).toEqual(newDetails)
        })

        test('blocked user: cannot read "to" tickets', async () => {
            const {
                employeeFrom,
                clientFrom,
                organizationTo,
                propertyTo,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            await createTestTicket(admin, organizationTo, propertyTo)
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                isBlocked: true,
            })

            const tickets = await Ticket.getAll(clientFrom)
            expect(tickets).toHaveLength(0)
        })

        test('deleted user: cannot read "to" tickets', async () => {
            const {
                employeeFrom,
                clientFrom,
                organizationFrom,
                propertyFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            await createTestTicket(admin, organizationFrom, propertyFrom)
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                deletedAt: 'true',
            })

            const tickets = await Ticket.getAll(clientFrom)
            expect(tickets).toHaveLength(0)
        })

        test('blocked user: cannot create "to" tickets', async () => {
            const {
                employeeFrom,
                clientFrom,
                organizationTo,
                propertyTo,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })
            await createTestTicket(clientFrom, organizationTo, propertyTo)
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                isBlocked: true,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(clientFrom, organizationTo, propertyTo)
            })
        })

        test.skip('user: can read assigned tickets if he is not organization employee', async () => {
            const user = await makeClientWithNewRegisteredAndLoggedInUser()

            const [organization1] = await createTestOrganization(admin)
            const [role] = await createTestOrganizationEmployeeRole(admin, organization1)
            await createTestOrganizationEmployee(admin, organization1, user.user, role)

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const [ticket] = await createTestTicket(admin, organization, property, {
                assignee: { connect: { id: user.user.id } },
            })

            const readTicket = await Ticket.getOne(user, {
                id: ticket.id,
            })

            expect(readTicket).toBeDefined()
        })

        test('admin: cannot updated auto-set field "feedbackUpdatedAt"', async () => {
            const client = await makeClientWithProperty()

            await expectToThrowGraphQLRequestError(async () => {
                await createTestTicket(admin, client.organization, client.property, { feedbackUpdatedAt: dayjs().toISOString() })
            }, 'Field "feedbackUpdatedAt" is not defined')
        })

        test('admin: cannot update auto-set field "qualityControlUpdatedAt"', async () => {
            const client = await makeClientWithProperty()

            await expectToThrowGraphQLRequestError(async () => {
                await createTestTicket(admin, client.organization, client.property, { qualityControlUpdatedAt: dayjs().toISOString() })
            }, 'Field "qualityControlUpdatedAt" is not defined')
        })

        test('admin: cannot update auto-set field "qualityControlUpdatedBy"', async () => {
            const client = await makeClientWithProperty()

            await expectToThrowGraphQLRequestError(async () => {
                await createTestTicket(admin, client.organization, client.property, { qualityControlUpdatedBy: { id: client.user.id } })
            }, 'Field "qualityControlUpdatedBy" is not defined')
        })

        describe('resident: cannot set quality control fields', () => {
            const cases = [
                ['qualityControlValue', { qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES) }],
                ['qualityControlComment', { qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES), qualityControlComment: faker.lorem.sentence() }],
                ['qualityControlAdditionalOptions', { qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES), qualityControlAdditionalOptions: faker.helpers.arrayElements(QUALITY_CONTROL_ADDITIONAL_OPTIONS) }],
            ]

            test.each(cases)('cannot create ticket with "%s"', async (_, payload) => {
                const residentClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, residentClient.user, residentClient.property, {
                    unitName,
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestTicket(residentClient, residentClient.organization, residentClient.property, payload)
                })
            })

            test.each(cases)('cannot update ticket with "%s"', async (field, payload) => {
                const residentClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, residentClient.user, residentClient.property, {
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, residentClient.organization, residentClient.property, {
                    qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestTicket(residentClient, ticket.id, pick(payload, field))
                })
            })
        })

        describe('staff: cannot set feedback fields', () => {
            const cases = [
                ['feedbackValue', { feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED) }],
                ['feedbackComment', { feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED), feedbackComment: faker.lorem.sentence() }],
                ['feedbackAdditionalOptions', { feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED), feedbackAdditionalOptions: faker.helpers.arrayElements(FEEDBACK_ADDITIONAL_OPTIONS) }],
            ]

            test.each(cases)('cannot create ticket with "%s"', async (_, payload) => {
                const client = await makeClientWithProperty()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestTicket(client, client.organization, client.property, payload)
                })
            })

            test.each(cases)('cannot update ticket with "%s"', async (field, payload) => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(admin, client.organization, client.property, {
                    feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED),
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestTicket(client, ticket.id, pick(payload, field))
                })
            })
        })
    })

    describe('Bulk-operation', () => {
        test('anonymous: cannot bulk create Tickets', async () => {
            const client = await makeClientWithProperty()
            const anonymous = await makeClient()

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                details: faker.random.alphaNumeric(10),
                unitType: FLAT_UNIT_TYPE,
                organization: { connect: { id: client.organization.id } },
                property: { connect: { id: client.property.id } },
                status: { connect: { id: STATUS_IDS.OPEN } },
                source: { connect: { id: TICKET_OTHER_SOURCE_ID } },
                isResidentTicket: false,
            }

            const payload = [
                { data: attrs },
                { data: attrs },
            ]

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await Ticket.createMany(anonymous, payload)
            })
        })

        test('anonymous: cannot bulk update Tickets', async () => {
            const client1 = await makeClientWithProperty()
            const anonymous = await makeClient()

            const [ticket1] = await createTestTicket(client1, client1.organization, client1.property)
            const [ticket2] = await createTestTicket(client1, client1.organization, client1.property)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                details: 'new data',
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await Ticket.updateMany(anonymous, payload)
            })
        })

        test('resident: cannot bulk create Tickets', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                details: faker.random.alphaNumeric(10),
                unitName,
                unitType: FLAT_UNIT_TYPE,
                organization: { connect: { id: userClient.organization.id } },
                property: { connect: { id: userClient.property.id } },
                status: { connect: { id: STATUS_IDS.OPEN } },
                source: { connect: { id: TICKET_OTHER_SOURCE_ID } },
                isResidentTicket: true,
            }

            const payload = [
                { data: attrs },
                { data: attrs },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.createMany(userClient, payload)
            })
        })

        test('resident: cannot bulk update Tickets', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [ticket1] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })
            const [ticket2] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            const [canceledStatus] = await TicketStatus.getAll(userClient, {
                type: CANCELED_STATUS_TYPE,
            })

            const payload = [
                { id: ticket1.id, data: { status: { connect: { id: canceledStatus.id } } } },
                { id: ticket2.id, data: { status: { connect: { id: canceledStatus.id } } } },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.updateMany(userClient, payload)
            })
        })

        test.skip('admin: cannot bulk create Tickets', async () => {
            const client = await makeClientWithProperty()

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                details: faker.random.alphaNumeric(10),
                unitType: FLAT_UNIT_TYPE,
                organization: { connect: { id: client.organization.id } },
                property: { connect: { id: client.property.id } },
                status: { connect: { id: STATUS_IDS.OPEN } },
                source: { connect: { id: TICKET_OTHER_SOURCE_ID } },
                isResidentTicket: false,
            }

            const payload = [
                { data: attrs },
                { data: attrs },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.createMany(admin, payload)
            })
        })

        test('admin: can bulk update Tickets', async () => {
            const client = await makeClientWithProperty()

            const [ticket1] = await createTestTicket(client, client.organization, client.property)
            const [ticket2] = await createTestTicket(client, client.organization, client.property)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                executor: { connect: { id: client.user.id } },
                assignee: { connect: { id: client.user.id } },
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            const [updatedTicket1, updatedTicket2] = await Ticket.updateMany(admin, payload)

            expect(ticket1.id).toEqual(updatedTicket1.id)
            expect(ticket2.id).toEqual(updatedTicket2.id)
            expect(get(updatedTicket1, ['executor', 'id'], null)).toEqual(client.user.id)
            expect(get(updatedTicket2, ['executor', 'id'], null)).toEqual(client.user.id)
            expect(get(updatedTicket1, ['assignee', 'id'], null)).toEqual(client.user.id)
            expect(get(updatedTicket2, ['assignee', 'id'], null)).toEqual(client.user.id)
        })

        // TODO: DOMA-10832 add check employee organization in Ticket access
        test.skip('admin: cannot bulk update tickets executor field with user from different organization ', async () => {
            const client1 = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()
            const userFromDifferentOrganization = await makeClientWithNewRegisteredAndLoggedInUser()
            const [roleForDifferentOrganization] = await createTestOrganizationEmployeeRole(client2, client2.organization)
            const [employeeFromDifferentOrganization] = await createTestOrganizationEmployee(admin, client2.organization, userFromDifferentOrganization.user, roleForDifferentOrganization)

            const [ticket1] = await createTestTicket(client1, client1.organization, client1.property)
            const [ticket2] = await createTestTicket(client1, client1.organization, client1.property)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                executor: { connect: { id: employeeFromDifferentOrganization.user.id } },
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.updateMany(admin, payload)
            })
        })

        test('admin: cannot bulk delete Tickets', async () => {
            const client = await makeClientWithProperty()

            const [ticket1] = await createTestTicket(client, client.organization, client.property)
            const [ticket2] = await createTestTicket(client, client.organization, client.property)

            const payload = [
                ticket1.id,
                ticket2.id,
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.deleteMany(admin, payload)
            })
        })

        test('employee with role "canManageTickets": can bulk update Tickets', async () => {
            const client = await makeClientWithProperty()
            const user = await makeClientWithNewRegisteredAndLoggedInUser()

            const [role] = await createTestOrganizationEmployeeRole(client, client.organization, {
                canManageTickets: true,
            })
            await createTestOrganizationEmployee(admin, client.organization, user.user, role)

            const [ticket1] = await createTestTicket(client, client.organization, client.property)
            const [ticket2] = await createTestTicket(client, client.organization, client.property)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                assignee: { connect: { id: client.user.id } },
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            const [updatedTicket1, updatedTicket2] = await Ticket.updateMany(user, payload)

            expect(ticket1.id).toEqual(updatedTicket1.id)
            expect(ticket2.id).toEqual(updatedTicket2.id)
            expect(get(updatedTicket1, ['assignee', 'id'], null)).toEqual(client.user.id)
            expect(get(updatedTicket2, ['assignee', 'id'], null)).toEqual(client.user.id)
        })

        test('employee without role "canManageTickets": cannot bulk update Tickets', async () => {
            const client = await makeClientWithProperty()
            const user = await makeClientWithNewRegisteredAndLoggedInUser()

            const [role] = await createTestOrganizationEmployeeRole(admin, client.organization, {
                canManageTickets: false,
            })
            await createTestOrganizationEmployee(admin, client.organization, user.user, role)
            const [ticket1] = await createTestTicket(client, client.organization, client.property)
            const [ticket2] = await createTestTicket(client, client.organization, client.property)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                assignee: { connect: { id: client.user.id } },
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.updateMany(user, payload)
            })
        })

        test('employee with role "canManageTickets": can bulk update only the executor and assignee fields in Tickets', async () => {
            const client = await makeClientWithProperty()
            const user = await makeClientWithNewRegisteredAndLoggedInUser()

            const [role] = await createTestOrganizationEmployeeRole(admin, client.organization, {
                canManageTickets: true,
            })
            await createTestOrganizationEmployee(admin, client.organization, user.user, role)

            const [ticket1] = await createTestTicket(client, client.organization, client.property)
            const [ticket2] = await createTestTicket(client, client.organization, client.property)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                executor: { connect: { id: client.user.id } },
                assignee: { connect: { id: client.user.id } },
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            const [updatedTicket1, updatedTicket2] = await Ticket.updateMany(user, payload)

            expect(ticket1.id).toEqual(updatedTicket1.id)
            expect(ticket2.id).toEqual(updatedTicket2.id)
            expect(get(updatedTicket1, ['executor', 'id'], null)).toEqual(client.user.id)
            expect(get(updatedTicket2, ['executor', 'id'], null)).toEqual(client.user.id)
            expect(get(updatedTicket1, ['assignee', 'id'], null)).toEqual(client.user.id)
            expect(get(updatedTicket2, ['assignee', 'id'], null)).toEqual(client.user.id)
        })

        test('employee with role "canManageTickets": cannot bulk update other fields except for executor or assignee', async () => {
            const client = await makeClientWithProperty()
            const user = await makeClientWithNewRegisteredAndLoggedInUser()

            const [role] = await createTestOrganizationEmployeeRole(admin, client.organization, {
                canManageTickets: true,
            })
            await createTestOrganizationEmployee(admin, client.organization, user.user, role)

            const [ticket1] = await createTestTicket(client, client.organization, client.property)
            const [ticket2] = await createTestTicket(client, client.organization, client.property)

            const payload = [
                { id: ticket1.id, data: { details: 'new data' } },
                { id: ticket2.id, data: { details: 'new data' } },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.updateMany(user, payload)
            })
        })

        test('employee with role "canManageTickets": cannot bulk update executor and assignee fields with other fields', async () => {
            const client = await makeClientWithProperty()
            const user = await makeClientWithNewRegisteredAndLoggedInUser()

            const [role] = await createTestOrganizationEmployeeRole(admin, client.organization, {
                canManageTickets: true,
            })
            await createTestOrganizationEmployee(admin, client.organization, user.user, role)

            const [ticket1] = await createTestTicket(client, client.organization, client.property)
            const [ticket2] = await createTestTicket(client, client.organization, client.property)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                executor: { connect: { id: client.user.id } },
                details: 'new data',
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.updateMany(user, payload)
            })
        })

        test('employee with role "canManageTickets": cannot bulk update one ticket from own organization and one ticket from other organization', async () => {
            const client1 = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()

            const user = await makeClientWithNewRegisteredAndLoggedInUser()

            const [role] = await createTestOrganizationEmployeeRole(admin, client1.organization, {
                canManageTickets: true,
            })
            await createTestOrganizationEmployee(admin, client1.organization, user.user, role)

            const [ticket1] = await createTestTicket(client1, client1.organization, client1.property)
            const [ticket2] = await createTestTicket(client2, client2.organization, client2.property)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.updateMany(user, payload)
            })
        })

        test('organization "from" employee: can bulk update organization "to" tickets', async () => {
            const {
                organizationTo,
                propertyTo,
                employeeTo,
                clientFrom,
                organizationFrom,
                employeeFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })

            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const [ticket1] = await createTestTicket(admin, organizationTo, propertyTo)
            const [ticket2] = await createTestTicket(admin, organizationTo, propertyTo)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                executor: { connect: { id: employeeTo.user.id } },
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            const [updatedTicket1, updatedTicket2] = await Ticket.updateMany(clientFrom, payload)

            expect(updatedTicket1.id).toEqual(ticket1.id)
            expect(updatedTicket2.id).toEqual(ticket2.id)
            expect(get(updatedTicket1, ['executor', 'id'], null)).toEqual(employeeTo.user.id)
            expect(get(updatedTicket2, ['executor', 'id'], null)).toEqual(employeeTo.user.id)
        })

        test('organization "from" employee: can update organization "to" tickets if employee is "from" organization', async () => {
            const {
                organizationTo,
                propertyTo,
                clientFrom,
                organizationFrom,
                employeeFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })

            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const [ticket1] = await createTestTicket(admin, organizationTo, propertyTo)
            const [ticket2] = await createTestTicket(admin, organizationTo, propertyTo)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                executor: { connect: { id: employeeFrom.user.id } },
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            const [updatedTicket1, updatedTicket2] = await Ticket.updateMany(clientFrom, payload)

            expect(updatedTicket1.id).toEqual(ticket1.id)
            expect(updatedTicket2.id).toEqual(ticket2.id)
            expect(get(updatedTicket1, ['executor', 'id'], null)).toEqual(employeeFrom.user.id)
            expect(get(updatedTicket2, ['executor', 'id'], null)).toEqual(employeeFrom.user.id)

        })

        test('blocked employee: cannot bulk create Tickets', async () => {
            const client = await makeClientWithProperty()

            const user = await makeClientWithNewRegisteredAndLoggedInUser()
            const [role] = await createTestOrganizationEmployeeRole(admin, client.organization, {
                canManageTickets: true,
            })

            await createTestOrganizationEmployee(admin, client.organization, user.user, role, {
                isBlocked: true,
            })

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                details: faker.random.alphaNumeric(10),
                unitType: FLAT_UNIT_TYPE,
                organization: { connect: { id: client.organization.id } },
                property: { connect: { id: client.property.id } },
                status: { connect: { id: STATUS_IDS.OPEN } },
                source: { connect: { id: TICKET_OTHER_SOURCE_ID } },
                isResidentTicket: false,
            }

            const payload = [
                { data: attrs },
                { data: attrs },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.createMany(user, payload)
            })
        })

        test('blocked employee: cannot bulk update Tickets', async () => {
            const client = await makeClientWithProperty()

            const user = await makeClientWithNewRegisteredAndLoggedInUser()
            const [role] = await createTestOrganizationEmployeeRole(admin, client.organization, {
                canManageTickets: true,
            })

            await createTestOrganizationEmployee(admin, client.organization, user.user, role, {
                isBlocked: true,
            })

            const [ticket1] = await createTestTicket(client, client.organization, client.property)
            const [ticket2] = await createTestTicket(client, client.organization, client.property)

            const attrs = {
                dv: 1,
                sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                executor: { connect: { id: client.user.id } },
            }

            const payload = [
                { id: ticket1.id, data: attrs },
                { id: ticket2.id, data: attrs },
            ]

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await Ticket.updateMany(user, payload)
            })
        })

    })

    describe.skip('ticket visibility type', () => {
        describe('organization', () => {
            it('can read tickets and related to ticket objects in organization where user is employee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: ORGANIZATION_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property)
                const [ticketComment] = await createTestTicketComment(userClient, ticket, userClient.user)

                const readTicket = await Ticket.getOne(userClient, { id: ticket.id })
                expect(readTicket.id).toMatch(ticket.id)

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment.id).toMatch(ticketComment.id)
            })

            it('cannot read tickets and related to ticket objects in organization where user is not employee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [organization1] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: ORGANIZATION_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization1)
                const [ticket] = await createTestTicket(admin, organization1, property)
                const [ticketComment] = await createTestTicketComment(admin, ticket, admin.user)

                const readTicket = await Ticket.getOne(userClient, { id: ticket.id })
                expect(readTicket).toBeUndefined()

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment).toBeUndefined()
            })
        })

        describe('property', () => {
            it('can read all tickets and related to ticket objects in organization if employee in PropertyScope with hasAllProperties flag', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization, {
                    hasAllProperties: true,
                })
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)

                const [ticket1] = await createTestTicket(admin, organization, property)
                const [ticket2] = await createTestTicket(admin, organization, property2)
                const [ticketComment] = await createTestTicketComment(userClient, ticket1, userClient.user)

                const tickets = await Ticket.getAll(userClient, {
                    id_in: [ticket1.id, ticket2.id],
                }, { sortBy: 'createdAt_ASC' })

                expect(tickets).toHaveLength(2)
                expect(tickets[0].id).toEqual(ticket1.id)
                expect(tickets[1].id).toEqual(ticket2.id)

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment.id).toMatch(ticketComment.id)
            })

            it('can read tickets and related to ticket objects in properties from PropertyScope where this employee is', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)
                const [property3] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)
                await createTestPropertyScopeProperty(admin, propertyScope, property2)
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)

                const [ticket1] = await createTestTicket(admin, organization, property)
                const [ticket2] = await createTestTicket(admin, organization, property2)
                const [ticket3] = await createTestTicket(admin, organization, property3)

                const [ticketComment] = await createTestTicketComment(userClient, ticket1, userClient.user)

                const tickets = await Ticket.getAll(userClient, {
                    id_in: [ticket1.id, ticket2.id, ticket3.id],
                }, { sortBy: 'createdAt_ASC' })
                expect(tickets).toHaveLength(2)
                expect(tickets[0].id).toEqual(ticket1.id)
                expect(tickets[1].id).toEqual(ticket2.id)

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment.id).toMatch(ticketComment.id)
            })

            it('can read tickets and related to ticket objects where employee is executor or assignee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property, {
                    assignee: { connect: { id: userClient.user.id } },
                })
                const [ticket1] = await createTestTicket(admin, organization, property, {
                    executor: { connect: { id: userClient.user.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property)

                const [ticketComment] = await createTestTicketComment(userClient, ticket1, userClient.user)

                const readTickets = await Ticket.getAll(userClient, { id_in: [ticket.id, ticket1.id, ticket2.id] },
                    { sortBy: 'createdAt_ASC' })
                expect(readTickets).toHaveLength(2)
                expect(readTickets[0].id).toEqual(ticket.id)
                expect(readTickets[1].id).toEqual(ticket1.id)

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment.id).toMatch(ticketComment.id)
            })

            it('cannot read tickets and related to ticket objects if there no PropertyScope in which employee is', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property)
                const [ticketComment] = await createTestTicketComment(admin, ticket, admin.user)

                const readTicket = await Ticket.getOne(userClient, { id: ticket.id })
                expect(readTicket).toBeUndefined()

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment).toBeUndefined()
            })

            it('cannot read tickets and related to ticket objects with properties which are in the PropertyScope where employee is not', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)

                const [ticket] = await createTestTicket(admin, organization, property)
                const [ticketComment] = await createTestTicketComment(admin, ticket, admin.user)

                const readTicketsByClient = await Ticket.getOne(userClient, {
                    id: ticket.id,
                })
                expect(readTicketsByClient).toBeUndefined()

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment).toBeUndefined()
            })
        })

        describe('property and specialization', () => {
            it('can read tickets with TicketCategoryClassifier matches to employee OrganizationEmployeeSpecialization ' +
                'and property from PropertyScope where this employee is', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                const [classifier1] = await createTestTicketClassifier(admin)
                const [classifier2] = await createTestTicketClassifier(admin)
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)
                await createTestOrganizationEmployeeSpecialization(admin, employee, classifier1.category)

                const [ticket1] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier1.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier2.id } },
                })
                const [ticket3] = await createTestTicket(admin, organization, property2, {
                    classifier: { connect: { id: classifier2.id } },
                })

                const tickets = await Ticket.getAll(userClient, {
                    id_in: [ticket1.id, ticket2.id, ticket3.id],
                }, { sortBy: 'createdAt_ASC' })

                expect(tickets).toHaveLength(1)
                expect(tickets[0].id).toEqual(ticket1.id)
            })

            it('can read tickets where employee is executor or assignee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property, {
                    assignee: { connect: { id: userClient.user.id } },
                })
                const [ticket1] = await createTestTicket(admin, organization, property, {
                    executor: { connect: { id: userClient.user.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property)

                const readTickets = await Ticket.getAll(userClient, { id_in: [ticket.id, ticket1.id, ticket2.id] },
                    { sortBy: 'createdAt_ASC' })

                expect(readTickets).toHaveLength(2)
                expect(readTickets[0].id).toEqual(ticket.id)
                expect(readTickets[1].id).toEqual(ticket1.id)
            })

            it('cannot read tickets with TicketCategoryClassifier matches to employee OrganizationEmployeeSpecialization ' +
                'and there no property from PropertyScope where this employee is', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                const [classifier1] = await createTestTicketClassifier(admin)
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)

                await createTestOrganizationEmployeeSpecialization(admin, employee, classifier1.category)

                const [ticket1] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier1.id } },
                })

                const readTicket = await Ticket.getOne(userClient, {
                    id: ticket1.id,
                })

                expect(readTicket).toBeUndefined()
            })

            it('cannot read tickets with property from PropertyScope where this employee is ' +
                'and TicketCategoryClassifier not matches to employee OrganizationEmployeeSpecialization', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                const [classifier] = await createTestTicketClassifier(admin)
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)

                const [ticket] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier.id } },
                })

                const readTicket = await Ticket.getOne(userClient, {
                    id: ticket.id,
                })

                expect(readTicket).toBeUndefined()
            })
        })

        describe('assigned', () => {
            it('can read only tickets where employee is executor or assignee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: ASSIGNED_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property, {
                    assignee: { connect: { id: userClient.user.id } },
                })
                const [ticket1] = await createTestTicket(admin, organization, property, {
                    executor: { connect: { id: userClient.user.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property)

                const readTickets = await Ticket.getAll(userClient, { id_in: [ticket.id, ticket1.id, ticket2.id] },
                    { sortBy: 'createdAt_ASC' })

                expect(readTickets).toHaveLength(2)
                expect(readTickets[0].id).toEqual(ticket.id)
                expect(readTickets[1].id).toEqual(ticket1.id)
            })
        })
    })

    describe('Validations', () => {
        describe('guards', () => {
            test('user: resident should not be able to create tickets with identical text over the limit', async () => {
                const details = 'I have some problems with hot water!'

                // User, should be banned from creating tickets to organization if he exceeds the limits.
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, userClient.property, {
                    unitName,
                })
                for (let i = 0; i < DAILY_SAME_TICKET_LIMIT; ++i) {
                    await createTestTicket(userClient, userClient.organization, userClient.property, { unitName, details })
                }

                await expectToThrowGQLError(async () => {
                    await createTestTicket(userClient, userClient.organization, userClient.property, { unitName, details })
                }, ERRORS.SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED)

                // TICKET_FOR_PHONE_DAY_LIMIT_REACHED should be the top priority error
                for (let i = 0; i < DAILY_TICKET_LIMIT - DAILY_SAME_TICKET_LIMIT - 1; ++i) {
                    await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })
                }

                await expectToThrowGQLError(async () => {
                    await createTestTicket(userClient, userClient.organization, userClient.property, { unitName, details })
                }, ERRORS.SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED)

                // User, banned from creating tickets to organization 1, can still create tickets to organization 2
                const client2 = await makeClientWithProperty()
                const unitName2 = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, client2.property, {
                    unitName: unitName2,
                })

                const [secondOrgTicket] = await createTestTicket(userClient, client2.organization, client2.property, { unitName: unitName2, details })

                expect(secondOrgTicket).toBeDefined()
                expect(secondOrgTicket.id).toBeDefined()
                expect(secondOrgTicket.details).toEqual(details)
                expect(secondOrgTicket.organization.id).toEqual(client2.organization.id)
                expect(secondOrgTicket.property.id).toEqual(client2.property.id)
            })

            test('user: resident should not be able to create tickets in single day over the limit', async () => {
                // User, should be banned from creating tickets to organization if he exceeds the limits.
                const organization1 = await makeClientWithProperty()

                const residentClient1 = await makeClientWithResidentUser()
                const unitName1 = faker.random.alphaNumeric(5)
                await createTestResident(admin, residentClient1.user, organization1.property, {
                    unitName: unitName1,
                })

                for (let i = 0; i < DAILY_TICKET_LIMIT; ++i) {
                    await createTestTicket(residentClient1, organization1.organization, organization1.property, { unitName: unitName1 })
                }

                await expectToThrowGQLError(async () => {
                    await createTestTicket(residentClient1, organization1.organization, organization1.property, { unitName: unitName1 })
                }, ERRORS.TICKET_FOR_PHONE_DAY_LIMIT_REACHED)

                // User, banned from creating tickets to organization 1, can still create tickets to organization 2
                const organization2 = await makeClientWithProperty()

                const unitName2 = faker.random.alphaNumeric(5)
                await createTestResident(admin, residentClient1.user, organization2.property, {
                    unitName: unitName2,
                })

                const [secondOrgTicket] = await createTestTicket(residentClient1, organization2.organization, organization2.property, { unitName: unitName2 })

                expect(secondOrgTicket).toBeDefined()
                expect(secondOrgTicket.id).toBeDefined()
                expect(secondOrgTicket.organization.id).toEqual(organization2.organization.id)
                expect(secondOrgTicket.property.id).toEqual(organization2.property.id)

                // Another user is able to send tickets to organization 1

                const residentClient2 = await makeClientWithResidentUser()
                const unitName3 = faker.random.alphaNumeric(5)
                await createTestResident(admin, residentClient2.user, organization1.property, {
                    unitName: unitName3,
                })

                const [firstOrgTicketFromSecondResident] = await createTestTicket(residentClient2, organization1.organization, organization1.property, { unitName: unitName3 })

                expect(firstOrgTicketFromSecondResident).toBeDefined()
                expect(firstOrgTicketFromSecondResident.id).toBeDefined()
                expect(firstOrgTicketFromSecondResident.organization.id).toEqual(organization1.organization.id)
                expect(firstOrgTicketFromSecondResident.property.id).toEqual(organization1.property.id)
            })
        })

        describe('new ticket without status', () => {
            test('user: can create Ticket without status and status set to OPEN on server-side', async () => {
                const client = await makeClientWithProperty()
                const [obj] = await createTestTicket(client, client.organization, client.property, { status: null })

                expect(obj.status).toEqual(expect.objectContaining({ id: STATUS_IDS.OPEN }))
            })
        })

        // TODO(DOMA-5833): delete this describe when the mobile app will use 'feedback*' fields
        describe('change status after resident review', () => {
            test('status changed to CLOSED after resident left GOOD review value', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const reviewComment = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, userClient.property, {
                    unitName,
                })

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                    reviewValue: REVIEW_VALUES.GOOD,
                    reviewComment,
                })

                expect(ticket.id).toEqual(updatedTicket.id)
                expect(updatedTicket.reviewValue).toEqual(REVIEW_VALUES.GOOD)
                expect(updatedTicket.reviewComment).toEqual(reviewComment)
                expect(updatedTicket.status.id).toEqual(STATUS_IDS.CLOSED)
            })

            test('status changed to OPEN after resident return ticket to work', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, userClient.property, {
                    unitName,
                })

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                    reviewValue: REVIEW_VALUES.RETURN,
                })

                expect(ticket.id).toEqual(updatedTicket.id)
                expect(updatedTicket.reviewValue).toEqual(REVIEW_VALUES.RETURN)
                expect(updatedTicket.status.id).toEqual(STATUS_IDS.OPEN)
            })
        })

        describe('change status after resident feedback', () => {
            test('status changed to CLOSED after resident left GOOD or BAD feedback value', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, userClient.property, {
                    unitName,
                })

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                const [updatedTicket, ticketAttr] = await updateTestTicket(userClient, ticket.id, {
                    feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED),
                })

                expect(ticket.id).toEqual(updatedTicket.id)
                expect(updatedTicket.feedbackValue).toEqual(ticketAttr.feedbackValue)
                expect(updatedTicket.status.id).toEqual(STATUS_IDS.CLOSED)
            })

            test('status changed to OPEN after resident return ticket to work', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, userClient.property, {
                    unitName,
                })

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                    feedbackValue: FEEDBACK_VALUES_BY_KEY.RETURNED,
                })

                expect(ticket.id).toEqual(updatedTicket.id)
                expect(updatedTicket.feedbackValue).toEqual(FEEDBACK_VALUES_BY_KEY.RETURNED)
                expect(updatedTicket.status.id).toEqual(STATUS_IDS.OPEN)
            })
        })

        describe('propertyAddress and propertyAddressMeta', () => {
            test('Should be filled resolved automatically on ticket creation', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                expect(ticket).toHaveProperty('propertyAddress', client.property.address)
                expect(ticket).toHaveProperty('propertyAddressMeta', client.property.addressMeta)
            })
            test('Should be changed after property changed', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                const [newProperty] = await createTestProperty(client, client.organization)
                const [updatedTicket] = await updateTestTicket(client, ticket.id, {
                    property: { connect: { id: newProperty.id } },
                })
                expect(updatedTicket).toHaveProperty('propertyAddress', newProperty.address)
                expect(updatedTicket).toHaveProperty('propertyAddressMeta', newProperty.addressMeta)
            })
            test('Should be changed after address of linked property changed', async () => {
                const client = await makeClientWithProperty()
                const client2 = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                await updateTestProperty(client, client.property.id, {
                    address: client2.property.address,
                    addressMeta: client2.property.addressMeta,
                })

                // NOTE: give worker some time
                await waitFor(async () => {
                    const [changedTicket] = await Ticket.getAll(client, { id: ticket.id })
                    expect(changedTicket).toBeDefined()
                    expect(changedTicket).toHaveProperty('propertyAddress', client2.property.address)
                    expect(changedTicket).toHaveProperty('propertyAddressMeta', client2.property.addressMeta)
                })
            })

            test('Cannot be created / changed manually', async () => {
                const client = await makeClientWithProperty()
                const [property] = await createTestProperty(client, client.organization)
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestTicket(client, ticket.id, {
                        propertyAddress: property.address,
                    })
                }, 'Field "propertyAddress" is not defined by type "TicketUpdateInput"')
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestTicket(client, ticket.id, {
                        propertyAddressMeta: property.addressMeta,
                    })
                }, 'Field "propertyAddressMeta" is not defined by type "TicketUpdateInput"')
                await expectToThrowGraphQLRequestError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        propertyAddress: property.address,
                    })
                }, 'Field "propertyAddress" is not defined by type "TicketCreateInput"')
                await expectToThrowGraphQLRequestError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        propertyAddressMeta: property.addressMeta,
                    })
                }, 'Field "propertyAddressMeta" is not defined by type "TicketCreateInput"')
            })
            test('Should be unchanged on Property softDeletion', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                await updateTestProperty(client, client.property.id, {
                    deletedAt: dayjs().toISOString(),
                })

                const [refetchTicket] = await Ticket.getAll(client, { id: ticket.id })
                expect(refetchTicket).toBeDefined()
                expect(refetchTicket).toHaveProperty('propertyAddress', client.property.address)
                expect(refetchTicket).toHaveProperty('propertyAddressMeta', client.property.addressMeta)
            })
        })

        describe('client', () => {
            test('should be filled automatically on ticket creation if contact phone number and ticket address matches the resident phone number and address', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })
                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
            })

            test('should be filled automatically on ticket update if contact phone number and updated ticket address matches the resident phone number and address', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitName1 = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })
                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName: unitName1,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })

                expect(ticket.client).toBeNull()

                await updateTestTicket(admin, ticket.id, {
                    unitName,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
                expect(readTicket.clientName).toEqual(ticket.clientName)
                expect(readTicket.clientPhone).toEqual(ticket.clientPhone)
                expect(readTicket.clientEmail).toEqual(ticket.clientEmail)
            })

            test('should be filled automatically on create resident with same contact phone and same ticket address', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })

                expect(ticket.client).toBeNull()

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })

                await waitFor(async () => {
                    const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })
                    expect(readTicket.client.id).toEqual(residentClient.user.id)
                })
            })

            test('should be filled automatically on ticket with isResidentTicket creation if clientPhone number and ticket address matches the resident phone number and address', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone, name } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    unitType,
                    clientPhone: phone,
                    clientName: name,
                    isResidentTicket: true,
                    canReadByResident: true,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
            })

            test('ticket creating with sectionName, sectionType and floorName by resident user' +
                'when unitName and unitType match in map and resident', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)

                const unitName = faker.random.alphaNumeric(5)
                const unitType = WAREHOUSE_UNIT_TYPE
                const sectionName = faker.random.alphaNumeric(5)
                const sectionType = SECTION_SECTION_TYPE
                const floorName = faker.random.alphaNumeric(5)

                const [property] = await createTestProperty(admin, organization, {
                    map: {
                        dv: 1,
                        type: 'building',
                        sections: [
                            {
                                id: '1',
                                type: sectionType,
                                index: 1,
                                name: String(sectionName + 1),
                                preview: null,
                                floors: [
                                    {
                                        id: String(0),
                                        type: 'floor',
                                        index: 0,
                                        name: String(floorName + 1),
                                        units: [
                                            {
                                                id: String(0),
                                                type: 'unit',
                                                name: null,
                                                label: unitName,
                                                preview: null,
                                                unitType: FLAT_UNIT_TYPE,
                                            },
                                        ],
                                    },
                                ],
                            },
                            {
                                id: '2',
                                type: sectionType,
                                index: 2,
                                name: sectionName,
                                preview: null,
                                floors: [
                                    {
                                        id: String(1),
                                        type: 'floor',
                                        index: 1,
                                        name: floorName,
                                        units: [
                                            {
                                                id: String(1),
                                                type: 'unit',
                                                name: null,
                                                label: unitName,
                                                preview: null,
                                                unitType: unitType,
                                            },
                                        ],
                                    },
                                ],
                            },
                        ],
                    },
                })

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })

                const [ticket] = await createTestTicket(residentClient, organization, property, {
                    unitName,
                    unitType,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
                expect(readTicket.unitName).toEqual(unitName)
                expect(readTicket.unitType).toEqual(unitType)
                expect(readTicket.sectionName).toEqual(sectionName)
                expect(readTicket.sectionType).toEqual(sectionType)
                expect(readTicket.floorName).toEqual(floorName)
            })

            test('ticket creating without sectionName, sectionType and floorName by resident user' +
                'when unitType did not match in map and resident, but unitName the same', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)

                const unitName = faker.random.alphaNumeric(5)
                const unitType = WAREHOUSE_UNIT_TYPE

                const [property] = await createTestProperty(admin, organization, {
                    map: {
                        dv: 1,
                        type: 'building',
                        sections: [
                            {
                                id: '1',
                                type: SECTION_SECTION_TYPE,
                                index: 1,
                                name: '1',
                                preview: null,
                                floors: [
                                    {
                                        id: String(0),
                                        type: 'floor',
                                        index: 0,
                                        name: String(0),
                                        units: [
                                            {
                                                id: String(0),
                                                type: 'unit',
                                                name: null,
                                                label: unitName,
                                                preview: null,
                                                unitType: FLAT_UNIT_TYPE,
                                            },
                                        ],
                                    },
                                ],
                            },
                        ],
                    },
                })

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })

                const [ticket] = await createTestTicket(residentClient, organization, property, {
                    unitName,
                    unitType,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
                expect(readTicket.unitName).toEqual(unitName)
                expect(readTicket.unitType).toEqual(unitType)
                expect(readTicket.sectionName).toBeNull()
                expect(readTicket.sectionType).toBeNull()
                expect(readTicket.floorName).toBeNull()
            })

            test('ticket creating without sectionName, sectionType and floorName by resident user' +
                'when unitName did not match in map and resident, but unitType the same', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)

                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE

                const [property] = await createTestProperty(admin, organization, {
                    map: {
                        dv: 1,
                        type: 'building',
                        sections: [
                            {
                                id: '1',
                                type: SECTION_SECTION_TYPE,
                                index: 1,
                                name: '1',
                                preview: null,
                                floors: [
                                    {
                                        id: String(0),
                                        type: 'floor',
                                        index: 0,
                                        name: String(0),
                                        units: [
                                            {
                                                id: String(0),
                                                type: 'unit',
                                                name: null,
                                                label: faker.random.alphaNumeric(5),
                                                preview: null,
                                                unitType: FLAT_UNIT_TYPE,
                                            },
                                        ],
                                    },
                                ],
                            },
                        ],
                    },
                })

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })

                const [ticket] = await createTestTicket(residentClient, organization, property, {
                    unitName,
                    unitType,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
                expect(readTicket.unitName).toEqual(unitName)
                expect(readTicket.unitType).toEqual(unitType)
                expect(readTicket.sectionName).toBeNull()
                expect(readTicket.sectionType).toBeNull()
                expect(readTicket.floorName).toBeNull()
            })
        })

        describe('contact', () => {
            describe('isResident ticket is true', function () {
                it('should be created and connected if no contact matches with clientPhone, unitName and unitType', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: true,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact.id).toMatch(UUID_RE)
                    expect(ticket.contact.name).toEqual(name)
                    expect(ticket.contact.phone).toEqual(phone)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })

                it('should be connected if contact with same clientPhone, unitName and unitType exists', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [contact] = await createTestContact(admin, organization, property, {
                        phone,
                        name,
                        unitName,
                    })

                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: true,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact.id).toEqual(contact.id)
                    expect(ticket.contact.name).toEqual(name)
                    expect(ticket.contact.phone).toEqual(phone)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })

                it('should create and connect new contact if clientPhone, unitName or unitType are different than connected contact\'s', async () => {

                    const { userAttrs: { phone: phone1, name: name1 } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const { userAttrs: { phone: phone2, name: name2 } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [contact1] = await createTestContact(admin, organization, property, {
                        phone: phone1,
                        name: name1,
                        unitName,
                    })

                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: true,
                        clientName: name1,
                        clientPhone: phone1,
                        unitName,
                    })

                    expect(ticket.contact.id).toEqual(contact1.id)
                    expect(ticket.contact.name).toEqual(name1)
                    expect(ticket.contact.phone).toEqual(phone1)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)

                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        clientName: name2,
                        clientPhone: phone2,
                        unitName,
                    })

                    expect(updatedTicket.contact.id).not.toEqual(contact1.id)
                    expect(updatedTicket.contact.name).toEqual(name2)
                    expect(updatedTicket.contact.phone).toEqual(phone2)
                    expect(updatedTicket.contact.unitName).toEqual(unitName)
                    expect(updatedTicket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })

                it('should be connected if resident user creates ticket', async () => {

                    const residentClient = await makeClientWithResidentUser()
                    const { name, phone } = residentClient.userAttrs

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const unitName = faker.random.alphaNumeric(5)

                    await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })

                    const [createdTicket] = await createTestTicket(residentClient, organization, property, {
                        unitName,
                    })

                    const ticket = await Ticket.getOne(admin, { id: createdTicket.id })

                    expect(ticket.contact.id).toMatch(UUID_RE)
                    expect(ticket.contact.name).toEqual(name)
                    expect(ticket.contact.phone).toEqual(phone)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })

                it('should be disconnected if isResidentTicket changed to false', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: true,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact.id).toMatch(UUID_RE)
                    expect(ticket.contact.name).toEqual(name)
                    expect(ticket.contact.phone).toEqual(phone)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)

                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        isResidentTicket: false,
                    })

                    expect(updatedTicket.contact).toBeNull()
                })
            })

            describe('isResidentTicket is false', () => {
                it('should not be created if no contact matches witch clientPhone, unitName and unitType', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: false,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact).toBeNull()
                })

                it('should not be connected if contact with same clientPhone, unitName and unitType is exist', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    await createTestContact(admin, organization, property, {
                        phone,
                        name,
                        unitName,
                    })

                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: false,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact).toBeNull()
                })

                it('should be connected if isResidentTicket changed to true', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [contact] = await createTestContact(admin, organization, property, {
                        phone,
                        name,
                        unitName,
                    })

                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: false,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact).toBeNull()

                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        isResidentTicket: true,
                    })

                    expect(updatedTicket.contact.id).toEqual(contact.id)
                    expect(updatedTicket.contact.name).toEqual(name)
                    expect(updatedTicket.contact.phone).toEqual(phone)
                    expect(updatedTicket.contact.unitName).toEqual(unitName)
                    expect(updatedTicket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })
            })

        })

        describe('completedAt', () => {
            test('should be filled and updated automatically when ticket status changes to "completed" value', async () => {
                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property)

                expect(ticket.completedAt).toBeNull()

                const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(updatedTicket.completedAt).toBeDefined()
                expect(updatedTicket.completedAt).toMatch(DATETIME_RE)

                const [updatedTicket1] = await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
                })

                expect(updatedTicket1.completedAt).toEqual(updatedTicket.completedAt)

                const [updatedTicket2] = await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(updatedTicket2.completedAt).toBeDefined()
                expect(updatedTicket2.completedAt).toMatch(DATETIME_RE)
                expect(dayjs(updatedTicket2.completedAt).isAfter(updatedTicket.completedAt)).toBeTruthy()

                const [completedTicket] = await createTestTicket(admin, organization, property, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })
                expect(completedTicket.completedAt).toMatch(DATETIME_RE)
            })

            test('should not be updated automatically when ticket status was "completed" before change', async () => {
                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property)

                expect(ticket.completedAt).toBeNull()

                const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(updatedTicket.completedAt).toBeDefined()
                expect(updatedTicket.completedAt).toMatch(DATETIME_RE)

                const [updatedTicket1] = await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(updatedTicket1.completedAt).toEqual(updatedTicket.completedAt)
                expect(dayjs(updatedTicket1.completedAt).isSame(updatedTicket.completedAt)).toBeTruthy()
            })
        })

        describe('deferredUntil and status', () => {
            test('deferredUntil is null should not be with status "deferred"', async () => {
                const client = await makeClientWithProperty()

                await expectToThrowValidationFailureError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        status: { connect: { id: STATUS_IDS.DEFERRED } },
                    })
                }, `${WRONG_VALUE} deferredUntil is null, but status type is ${DEFERRED_STATUS_TYPE}`)
            })
            test(`should not create ticket with "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE}`, async () => {
                const deferredUntil = dayjs().add(2, 'days').toISOString()
                const client = await makeClientWithProperty()

                await expectToThrowValidationFailureError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        status: { connect: { id: STATUS_IDS.OPEN } }, deferredUntil,
                    })
                }, `${WRONG_VALUE} should not create ticket with "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE}`)
            })
            test(`should not change "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE} before or after changes`, async () => {
                const deferredUntil = dayjs().add(2, 'days').toISOString()
                const client = await makeClientWithProperty()

                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    status: { connect: { id: STATUS_IDS.OPEN } },
                })

                await expectToThrowValidationFailureError(async () => {
                    await updateTestTicket(client, ticket.id, {
                        deferredUntil,
                    })
                }, `${WRONG_VALUE} should not change "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE} before or after changes`)
            })
            test('"deferredUntil" field must be no more than 1 year old than the current date', async () => {
                const deferredUntil = dayjs().add(2, 'years').toISOString()
                const client = await makeClientWithProperty()

                await expectToThrowValidationFailureError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
                    })
                }, `${WRONG_VALUE} the value of the "deferredUntil" field must be no more than 1 year old than the current date`)
            })
            test('the value of the "deferredUntil" field must be greater than the current date', async () => {
                const deferredUntil = dayjs().subtract(1, 'days').toISOString()
                const client = await makeClientWithProperty()

                await expectToThrowValidationFailureError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
                    })
                }, `${WRONG_VALUE} the value of the "deferredUntil" field must be greater than the current date`)
            })
        })

        describe('isAutoClassified', () => {
            let mlEnabled
            beforeAll(() => {
                try {
                    const raw = conf['ML_SPACE_TICKET_CLASSIFIER']
                    if (!raw) return (mlEnabled = false)

                    const { endpoint, authKey, workspace } = JSON.parse(raw)
                    mlEnabled = Boolean(endpoint && authKey && workspace)
                } catch {
                    mlEnabled = false
                }
            })
            test('CREATE: flag equals ML service availability', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)

                expect(ticket.isAutoClassified).toBe(mlEnabled)
            })
            test('CREATE: false when ticket classified manually', async () => {
                const client = await makeClientWithProperty()
                const [classifier] = await createTestTicketClassifier(admin)
                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    classifier: { connect: { id: classifier.id } },
                })

                expect(ticket.isAutoClassified).toBe(false)
            })
            test('UPDATE: toggles to false after manual classifier added', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)

                expect(ticket.isAutoClassified).toBe(mlEnabled)

                const [classifier] = await createTestTicketClassifier(admin)
                const [updatedTicket] = await updateTestTicket(client, ticket.id, {
                    classifier: { connect: { id: classifier.id } },
                })

                expect(updatedTicket.isAutoClassified).toBe(false)
            })
            test('UPDATE: flag remains unchanged when classifier not touched', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)

                expect(ticket.isAutoClassified).toBe(mlEnabled)

                const details = faker.lorem.sentence()
                const [updatedTicket] = await updateTestTicket(client, ticket.id, {
                    details,
                })

                expect(updatedTicket.isAutoClassified).toBe(mlEnabled)
            })
        })

        describe('feedback', () => {
            describe('feedbackAdditionalOptions', () => {
                describe('Should pass "feedbackAdditionalOptions"', () => {
                    const cases = [
                        [null, null],
                        [[], null],
                        [[FEEDBACK_ADDITIONAL_OPTIONS[0]], [FEEDBACK_ADDITIONAL_OPTIONS[0]]],
                        [[FEEDBACK_ADDITIONAL_OPTIONS[0], FEEDBACK_ADDITIONAL_OPTIONS[1]], [FEEDBACK_ADDITIONAL_OPTIONS[0], FEEDBACK_ADDITIONAL_OPTIONS[1]].sort()],
                        [[FEEDBACK_ADDITIONAL_OPTIONS[0], FEEDBACK_ADDITIONAL_OPTIONS[0]], [FEEDBACK_ADDITIONAL_OPTIONS[0]]],
                    ]

                    test.each(cases)('value: %j', async (additionalOptions, expected) => {
                        const userClient = await makeClientWithResidentAccessAndProperty()
                        const unitName = faker.random.alphaNumeric(5)
                        await createTestResident(admin, userClient.user, userClient.property, {
                            unitName,
                        })

                        const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                            unitName,
                            status: { connect: { id: STATUS_IDS.COMPLETED } },
                        })

                        const payload = {
                            feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED),
                            feedbackAdditionalOptions: additionalOptions,
                        }
                        const [updatedTicket] = await updateTestTicket(userClient, ticket.id, payload)

                        expect(updatedTicket.feedbackValue).toEqual(payload.feedbackValue)
                        expect(updatedTicket.feedbackAdditionalOptions).toEqual(expected)
                    })
                })

                describe('Should not pass "feedbackAdditionalOptions"', () => {
                    const cases = [
                        {},
                        faker.datatype.number(),
                        '',
                        faker.lorem.sentence(),
                        [faker.lorem.sentence()],
                        [faker.datatype.boolean()],
                        [faker.datatype.number()],
                        [[]],
                        [faker.helpers.arrayElements(FEEDBACK_ADDITIONAL_OPTIONS)],
                    ]

                    test.each(cases)('value: %j', async (additionalOptions) => {
                        const client = await makeClientWithProperty()
                        const [ticket] = await createTestTicket(client, client.organization, client.property)

                        const payload = {
                            feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED),
                            feedbackAdditionalOptions: additionalOptions,
                        }

                        await expectToThrowGraphQLRequestError(async () => {
                            await updateTestTicket(client, ticket.id, payload)
                        }, 'got invalid value')
                    })
                })

                test('"feedbackAdditionalOptions" should not be passed if there is no "feedbackValue"', async () => {
                    const userClient = await makeClientWithResidentAccessAndProperty()
                    const unitName = faker.random.alphaNumeric(5)
                    await createTestResident(admin, userClient.user, userClient.property, {
                        unitName,
                    })

                    const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                        unitName,
                        status: { connect: { id: STATUS_IDS.COMPLETED } },
                    })

                    const payload = {
                        feedbackAdditionalOptions: faker.helpers.arrayElements(FEEDBACK_ADDITIONAL_OPTIONS),
                    }

                    await expectToThrowGQLError(async () => {
                        await updateTestTicket(userClient, ticket.id, payload)
                    }, ERRORS.FEEDBACK_VALUE_MUST_BE_SPECIFIED)
                })

                test('"feedbackAdditionalOptions" can be passed if there is "feedbackValue"', async () => {
                    const userClient = await makeClientWithResidentAccessAndProperty()
                    const unitName = faker.random.alphaNumeric(5)
                    await createTestResident(admin, userClient.user, userClient.property, {
                        unitName,
                    })

                    const [completedTicket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                        unitName,
                        status: { connect: { id: STATUS_IDS.COMPLETED } },
                    })

                    const [ticket] = await updateTestTicket(userClient, completedTicket.id, {
                        feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED),
                    })

                    const payload = {
                        feedbackAdditionalOptions: faker.helpers.arrayElements(FEEDBACK_ADDITIONAL_OPTIONS),
                    }
                    const [updatedTicket] = await updateTestTicket(userClient, ticket.id, payload)

                    expect(updatedTicket.feedbackAdditionalOptions).toEqual(payload.feedbackAdditionalOptions.sort())
                })
            })

            describe('feedbackComment', () => {
                test('"feedbackComment" should not be passed if there is no "feedbackValue"', async () => {
                    const userClient = await makeClientWithResidentAccessAndProperty()
                    const unitName = faker.random.alphaNumeric(5)
                    await createTestResident(admin, userClient.user, userClient.property, {
                        unitName,
                    })

                    const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                        unitName,
                        status: { connect: { id: STATUS_IDS.COMPLETED } },
                    })

                    const payload = {
                        feedbackComment: faker.lorem.sentence(),
                    }

                    await expectToThrowGQLError(async () => {
                        await updateTestTicket(userClient, ticket.id, payload)
                    }, ERRORS.FEEDBACK_VALUE_MUST_BE_SPECIFIED)
                })

                test('"feedbackComment" can be passed if there is "feedbackValue"', async () => {
                    const userClient = await makeClientWithResidentAccessAndProperty()
                    const unitName = faker.random.alphaNumeric(5)
                    await createTestResident(admin, userClient.user, userClient.property, {
                        unitName,
                    })

                    const [completedTicket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                        unitName,
                        status: { connect: { id: STATUS_IDS.COMPLETED } },
                    })

                    const [ticket] = await updateTestTicket(userClient, completedTicket.id, {
                        feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED),
                    })

                    const payload = {
                        feedbackComment: faker.lorem.sentence(),
                    }
                    const [updatedTicket] = await updateTestTicket(userClient, ticket.id, payload)

                    expect(updatedTicket.feedbackComment).toEqual(payload.feedbackComment)
                })
            })
        })

        describe('quality control', () => {
            describe('qualityControlAdditionalOptions', () => {
                describe('Should pass "qualityControlAdditionalOptions"', () => {
                    const cases = [
                        [null, null],
                        [[], null],
                        [[QUALITY_CONTROL_ADDITIONAL_OPTIONS[0]], [QUALITY_CONTROL_ADDITIONAL_OPTIONS[0]]],
                        [[QUALITY_CONTROL_ADDITIONAL_OPTIONS[0], QUALITY_CONTROL_ADDITIONAL_OPTIONS[1]], [QUALITY_CONTROL_ADDITIONAL_OPTIONS[0], QUALITY_CONTROL_ADDITIONAL_OPTIONS[1]].sort()],
                        [[QUALITY_CONTROL_ADDITIONAL_OPTIONS[0], QUALITY_CONTROL_ADDITIONAL_OPTIONS[0]], [QUALITY_CONTROL_ADDITIONAL_OPTIONS[0]]],
                    ]

                    test.each(cases)('value: %j', async (additionalOptions, expected) => {
                        const client = await makeClientWithProperty()
                        const [ticket] = await createTestTicket(client, client.organization, client.property)

                        const payload = {
                            qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                            qualityControlAdditionalOptions: additionalOptions,
                        }
                        const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

                        expect(updatedTicket.qualityControlValue).toEqual(payload.qualityControlValue)
                        expect(updatedTicket.qualityControlAdditionalOptions).toEqual(expected)
                    })
                })

                describe('Should not pass "qualityControlAdditionalOptions"', () => {
                    const cases = [
                        {},
                        faker.datatype.number(),
                        '',
                        faker.lorem.sentence(),
                        [faker.lorem.sentence()],
                        [faker.datatype.boolean()],
                        [faker.datatype.number()],
                        [[]],
                        [faker.helpers.arrayElements(QUALITY_CONTROL_ADDITIONAL_OPTIONS)],
                    ]

                    test.each(cases)('value: %j', async (additionalOptions) => {
                        const client = await makeClientWithProperty()
                        const [ticket] = await createTestTicket(client, client.organization, client.property)

                        const payload = {
                            qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                            qualityControlAdditionalOptions: additionalOptions,
                        }

                        await expectToThrowGraphQLRequestError(async () => {
                            await updateTestTicket(client, ticket.id, payload)
                        }, 'got invalid value')
                    })
                })

                test('"qualityControlAdditionalOptions" should not be passed if there is no "qualityControlValue"', async () => {
                    const client = await makeClientWithProperty()
                    const [ticket] = await createTestTicket(client, client.organization, client.property)

                    const payload = {
                        qualityControlAdditionalOptions: faker.helpers.arrayElements(QUALITY_CONTROL_ADDITIONAL_OPTIONS),
                    }

                    await expectToThrowGQLError(async () => {
                        await updateTestTicket(client, ticket.id, payload)
                    }, ERRORS.QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED)
                })

                test('"qualityControlAdditionalOptions" can be passed if there is "qualityControlValue"', async () => {
                    const client = await makeClientWithProperty()
                    const [ticket] = await createTestTicket(client, client.organization, client.property, {
                        qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                    })

                    const payload = {
                        qualityControlAdditionalOptions: faker.helpers.arrayElements(QUALITY_CONTROL_ADDITIONAL_OPTIONS),
                    }
                    const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

                    expect(updatedTicket.qualityControlAdditionalOptions).toEqual(payload.qualityControlAdditionalOptions.sort())
                })
            })

            describe('qualityControlComment', () => {
                test('"qualityControlComment" should not be passed if there is no "qualityControlValue"', async () => {
                    const client = await makeClientWithProperty()
                    const [ticket] = await createTestTicket(client, client.organization, client.property)

                    const payload = {
                        qualityControlComment: faker.lorem.sentence(),
                    }

                    await expectToThrowGQLError(async () => {
                        await updateTestTicket(client, ticket.id, payload)
                    }, ERRORS.QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED)
                })

                test('"qualityControlComment" can be passed if there is "qualityControlValue"', async () => {
                    const client = await makeClientWithProperty()
                    const [ticket] = await createTestTicket(client, client.organization, client.property, {
                        qualityControlValue: faker.helpers.arrayElement(QUALITY_CONTROL_VALUES),
                    })

                    const payload = {
                        qualityControlComment: faker.lorem.sentence(),
                    }
                    const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

                    expect(updatedTicket.qualityControlComment).toEqual(payload.qualityControlComment)
                })
            })
        })

        describe('sectionType and sectionName', () => {
            let organization, property

            beforeAll(async () => {
                [organization] = await createTestOrganization(admin);
                [property] = await createTestProperty(admin, organization)
            })

            describe('create', () => {
                test('sectionType must be reset if not pass sectionName', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        sectionType: PARKING_SECTION_TYPE,
                        sectionName: null,
                    })
                    expect(ticket).toHaveProperty('sectionType', null)
                    expect(ticket).toHaveProperty('sectionName', null)
                })

                test('sectionType must be set to default values if pass sectionName and not pass sectionType', async () => {
                    const [ticket, attrs] = await createTestTicket(admin, organization, property, {
                        sectionType: null,
                        sectionName: faker.random.alphaNumeric(5),
                    })
                    expect(ticket).toHaveProperty('sectionType', SECTION_SECTION_TYPE)
                    expect(ticket).toHaveProperty('sectionName', attrs.sectionName)
                })

                test('sectionType and sectionName must be empty if they were not passed', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        sectionType: null,
                        sectionName: null,
                    })
                    expect(ticket).toHaveProperty('sectionType', null)
                    expect(ticket).toHaveProperty('sectionName', null)
                })

                test('sectionType and sectionName must not be empty if they were passed', async () => {
                    const [ticket, attrs] = await createTestTicket(admin, organization, property, {
                        sectionType: PARKING_SECTION_TYPE,
                        sectionName: faker.random.alphaNumeric(5),
                    })
                    expect(ticket).toHaveProperty('sectionType', PARKING_SECTION_TYPE)
                    expect(ticket).toHaveProperty('sectionName', attrs.sectionName)
                })
            })

            describe('update', () => {
                test('sectionType must not be update if sectionName is not null and sectionType try update to null', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        sectionType: PARKING_SECTION_TYPE,
                        sectionName: faker.random.alphaNumeric(5),
                    })
                    expect(ticket).toHaveProperty('sectionType', PARKING_SECTION_TYPE)
                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        sectionType: null,
                    })
                    expect(updatedTicket).toHaveProperty('sectionType', PARKING_SECTION_TYPE)
                    expect(updatedTicket).toHaveProperty('sectionName', ticket.sectionName)
                })

                test('sectionType must be set null if sectionType is not null and sectionName update to null', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        sectionType: PARKING_SECTION_TYPE,
                        sectionName: faker.random.alphaNumeric(5),
                    })
                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        sectionName: null,
                    })
                    expect(updatedTicket).toHaveProperty('sectionType', null)
                    expect(updatedTicket).toHaveProperty('sectionName', null)
                })

                test('sectionType and sectionName must be set null if sectionType and sectionName update to null', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        sectionType: PARKING_SECTION_TYPE,
                        sectionName: faker.random.alphaNumeric(5),
                    })
                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        sectionType: null,
                        sectionName: null,
                    })
                    expect(updatedTicket).toHaveProperty('sectionType', null)
                    expect(updatedTicket).toHaveProperty('sectionName', null)
                })

                test('sectionType must be updatable', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        sectionType: SECTION_SECTION_TYPE,
                        sectionName: faker.random.alphaNumeric(5),
                    })
                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        sectionType: PARKING_SECTION_TYPE,
                    })
                    expect(updatedTicket).toHaveProperty('sectionType', PARKING_SECTION_TYPE)
                    expect(updatedTicket).toHaveProperty('sectionName', ticket.sectionName)
                })

                test('sectionName must be updatable', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        sectionType: PARKING_SECTION_TYPE,
                        sectionName: faker.random.alphaNumeric(5),
                    })
                    const [updatedTicket, attrs] = await updateTestTicket(admin, ticket.id, {
                        sectionName: faker.random.alphaNumeric(5),
                    })
                    expect(updatedTicket).toHaveProperty('sectionType', PARKING_SECTION_TYPE)
                    expect(updatedTicket).toHaveProperty('sectionName', attrs.sectionName)
                })
            })
        })

        describe('unitType and unitName', () => {
            let organization, property

            beforeAll(async () => {
                [organization] = await createTestOrganization(admin);
                [property] = await createTestProperty(admin, organization)
            })

            describe('create', () => {
                test('unitType must be reset if not pass unitName', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        unitType: COMMERCIAL_UNIT_TYPE,
                        unitName: null,
                    })
                    expect(ticket).toHaveProperty('unitType', null)
                    expect(ticket).toHaveProperty('unitName', null)
                })

                test('unitType must be set to default values if pass unitName and not pass unitType', async () => {
                    const [ticket, attrs] = await createTestTicket(admin, organization, property, {
                        unitType: null,
                        unitName: faker.random.alphaNumeric(5),
                    })
                    expect(ticket).toHaveProperty('unitType', FLAT_UNIT_TYPE)
                    expect(ticket).toHaveProperty('unitName', attrs.unitName)
                })

                test('unitType and unitName must be empty if they were not passed', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        unitType: null,
                        unitName: null,
                    })
                    expect(ticket).toHaveProperty('unitType', null)
                    expect(ticket).toHaveProperty('unitName', null)
                })

                test('unitType and unitName must not be empty if they were passed', async () => {
                    const [ticket, attrs] = await createTestTicket(admin, organization, property, {
                        unitType: COMMERCIAL_UNIT_TYPE,
                        unitName: faker.random.alphaNumeric(5),
                    })
                    expect(ticket).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    expect(ticket).toHaveProperty('unitName', attrs.unitName)
                })
            })

            describe('update', () => {
                test('unitType must not be update if unitName is not null and unitType try update to null', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, { unitType: COMMERCIAL_UNIT_TYPE })
                    expect(ticket).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        unitType: null,
                    })
                    expect(updatedTicket).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    expect(updatedTicket).toHaveProperty('unitName', ticket.unitName)
                })

                test('unitType must be set null if unitType is not null and unitName update to null', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, { unitType: COMMERCIAL_UNIT_TYPE })
                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        unitName: null,
                    })
                    expect(updatedTicket).toHaveProperty('unitType', null)
                    expect(updatedTicket).toHaveProperty('unitName', null)
                })

                test('unitType and unitName must be set null if unitType and unitName update to null', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, { unitType: COMMERCIAL_UNIT_TYPE })
                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        unitType: null,
                        unitName: null,
                    })
                    expect(updatedTicket).toHaveProperty('unitType', null)
                    expect(updatedTicket).toHaveProperty('unitName', null)
                })

                test('unitType must be updatable', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, { unitType: FLAT_UNIT_TYPE })
                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        unitType: COMMERCIAL_UNIT_TYPE,
                    })
                    expect(updatedTicket).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    expect(updatedTicket).toHaveProperty('unitName', ticket.unitName)
                })

                test('unitName must be updatable', async () => {
                    const [ticket] = await createTestTicket(admin, organization, property, { unitType: COMMERCIAL_UNIT_TYPE })
                    const [updatedTicket, attrs] = await updateTestTicket(admin, ticket.id, {
                        unitName: faker.random.alphaNumeric(5),
                    })
                    expect(updatedTicket).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    expect(updatedTicket).toHaveProperty('unitName', attrs.unitName)
                })
            })
        })

        describe('isCompletedAfterDeadline', () => {
            let organization, property

            beforeAll(async () => {
                [organization] = await createTestOrganization(admin);
                [property] = await createTestProperty(admin, organization)
            })

            test('can be read', async () => {
                const [ticket] = await createTestTicket(admin, organization, property)
                expect(ticket).toHaveProperty('isCompletedAfterDeadline', false)
            })

            test('can not be update', async () => {
                await expectToThrowGraphQLRequestError(async () => {
                    await createTestTicket(admin, organization, property, { isCompletedAfterDeadline: false })
                }, 'Field "isCompletedAfterDeadline" is not defined by type "TicketCreateInput"')

                const [ticket] = await createTestTicket(admin, organization, property)
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestTicket(admin, ticket.id, { isCompletedAfterDeadline: true })
                }, 'Field "isCompletedAfterDeadline" is not defined by type "TicketUpdateInput"')
            })

            test('Should be auto-updated if "deadline" is updated', async () => {
                const [ticket] = await createTestTicket(admin, organization, property, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })
                expect(ticket).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                    deadline: dayjs().subtract(1, 'minute'),
                })
                expect(updatedTicket).toHaveProperty('isCompletedAfterDeadline', true)

                const [updatedTicket3] = await updateTestTicket(admin, ticket.id, {
                    deadline: dayjs().add(1, 'day'),
                })
                expect(updatedTicket3).toHaveProperty('isCompletedAfterDeadline', false)
            })

            test('Should be auto-set true if status changed to "completed", "closed" or "cancelled" after deadline', async () => {
                const [ticket] = await createTestTicket(admin, organization, property, { deadline: dayjs().subtract(1, 'minute') })
                expect(ticket).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.DECLINED } } })
                expect(updatedTicket).toHaveProperty('isCompletedAfterDeadline', true)

                const [updatedTicket2] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })
                expect(updatedTicket2).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket3] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil: dayjs().add(1, 'day') })
                expect(updatedTicket3).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket4] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })
                expect(updatedTicket4).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket5] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.IN_PROGRESS } } })
                expect(updatedTicket5).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket6] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.COMPLETED } } })
                expect(updatedTicket6).toHaveProperty('isCompletedAfterDeadline', true)

                const [updatedTicket7] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })
                expect(updatedTicket7).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket8] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.CLOSED } } })
                expect(updatedTicket8).toHaveProperty('isCompletedAfterDeadline', true)
            })

            test('Should be auto-set false if status changed to "completed", "closed" or "canceled" before deadline', async () => {
                const [ticket] = await createTestTicket(admin, organization, property, { deadline: dayjs().add(1, 'day') })
                expect(ticket).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.DECLINED } } })
                expect(updatedTicket).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket2] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })
                expect(updatedTicket2).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket3] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil: dayjs().add(1, 'day') })
                expect(updatedTicket3).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket4] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })
                expect(updatedTicket4).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket5] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.IN_PROGRESS } } })
                expect(updatedTicket5).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket6] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.COMPLETED } } })
                expect(updatedTicket6).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket7] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })
                expect(updatedTicket7).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket8] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.CLOSED } } })
                expect(updatedTicket8).toHaveProperty('isCompletedAfterDeadline', false)
            })

            test('Should be auto-set false if deadline is null', async () => {
                const [ticket] = await createTestTicket(admin, organization, property)
                expect(ticket).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.DECLINED } } })
                expect(updatedTicket).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket2] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })
                expect(updatedTicket2).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket3] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil: dayjs().add(1, 'day') })
                expect(updatedTicket3).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket4] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })
                expect(updatedTicket4).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket5] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.IN_PROGRESS } } })
                expect(updatedTicket5).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket6] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.COMPLETED } } })
                expect(updatedTicket6).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket7] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })
                expect(updatedTicket7).toHaveProperty('isCompletedAfterDeadline', false)

                const [updatedTicket8] = await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.CLOSED } } })
                expect(updatedTicket8).toHaveProperty('isCompletedAfterDeadline', false)
            })
        })
    })

    describe('backward compatibility', () => {
        // TODO(DOMA-7224): delete this describe when the mobile app will use 'isPayable' field
        describe('isPaid and isPayable', () => {
            test('isPayable should override isPaid', async () => {
                const client = await makeClientWithProperty()
                const [contact] = await createTestContact(client, client.organization, client.property)
                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    contact: { connect: { id: contact.id } },
                })
                expect(ticket.isPaid).toBeFalsy()
                expect(ticket.isPayable).toBeFalsy()

                const [updatedTicket] = await updateTestTicket(client, ticket.id, { isPaid: true })
                expect(updatedTicket.isPaid).toBeTruthy()
                expect(updatedTicket.isPayable).toBeTruthy()

                const [updatedTicket2] = await updateTestTicket(client, ticket.id, { isPayable: false })
                expect(updatedTicket2.isPaid).toBeFalsy()
                expect(updatedTicket2.isPayable).toBeFalsy()

                const [updatedTicket3] = await updateTestTicket(client, ticket.id, { isPayable: true, isPaid: false })
                expect(updatedTicket3.isPaid).toBeTruthy()
                expect(updatedTicket3.isPayable).toBeTruthy()

                const [updatedTicket4] = await updateTestTicket(client, ticket.id, { details: faker.random.word() })
                expect(updatedTicket4.isPaid).toBeTruthy()
                expect(updatedTicket4.isPayable).toBeTruthy()

                const [ticket2] = await createTestTicket(client, client.organization, client.property, {
                    contact: { connect: { id: contact.id } },
                    isPaid: false,
                    isPayable: true,
                })
                expect(ticket2.isPaid).toBeTruthy()
                expect(ticket2.isPayable).toBeTruthy()
            })
        })

        // TODO(DOMA-5833): delete this describe when the mobile app will use 'feedback*' fields
        describe('feedback and review', () => {
            test('feedback should override review', async () => {
                const residentClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, residentClient.user, residentClient.property, {
                    unitName,
                })
                const [ticket] = await createTestTicket(residentClient, residentClient.organization, residentClient.property, {
                    unitName,
                })

                await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
                })
                await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                const [updatedTicket, attrs] = await updateTestTicket(residentClient, ticket.id, {
                    feedbackValue: faker.helpers.arrayElement(FEEDBACK_VALUES_WITHOUT_RETURNED),
                    reviewValue: faker.helpers.arrayElement(REVIEW_VALUES_WITHOUT_RETURNED),
                    reviewComment: faker.lorem.sentence(),
                })

                expect(updatedTicket.feedbackValue).toEqual(attrs.feedbackValue)
                expect(updatedTicket.reviewValue).toEqual(attrs.feedbackValue)
                expect(updatedTicket.reviewComment).toBeNull()
                expect(updatedTicket.feedbackComment).toBeNull()
                expect(updatedTicket.feedbackAdditionalOptions).toBeNull()
            })
        })
    })

    describe('deferred tickets', () => {
        describe('changing the status from "deferred" to any other without "deferredUntil", the value of the "deferredUntil" field is changed to null', () => {
            const cases = [[NEW_OR_REOPENED_STATUS_TYPE, STATUS_IDS.OPEN], [CANCELED_STATUS_TYPE, STATUS_IDS.DECLINED]]
            test.each(cases)('change ticket status from "deferred" to %p', async (statusType, statusId) => {
                const client = await makeClientWithProperty()
                const deferredUntil = dayjs().add(2, 'days').toISOString()

                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
                })

                const [updatedTicket, updatedAttrs] = await updateTestTicket(client, ticket.id, {
                    status: { connect: { id: statusId } },
                })

                expect(updatedTicket.status).toEqual(expect.objectContaining({ id: updatedAttrs.status.connect.id }))
                expect(updatedTicket.deferredUntil).toBe(null)
            })
        })
        test('deferredUntil is null should not be with status "deferred"', async () => {
            const client = await makeClientWithProperty()

            const [ticket, attrs] = await createTestTicket(client, client.organization, client.property, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(ticket.deferredUntil).toEqual(null)
            expect(ticket.status).toEqual(expect.objectContaining({ id: attrs.status.connect.id }))
        })
        test('should can change "postponedUntil" field', async () => {
            const client = await makeClientWithProperty()
            let deferredUntil = dayjs().add(2, 'days').toISOString()

            const [ticket, attrs] = await createTestTicket(client, client.organization, client.property, {
                status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
            })

            deferredUntil = dayjs().add(10, 'days').toISOString()

            const [updatedTicket] = await updateTestTicket(client, ticket.id, {
                deferredUntil,
            })

            expect(updatedTicket.deferredUntil).toEqual(deferredUntil)
            expect(updatedTicket.status).toEqual(expect.objectContaining({ id: attrs.status.connect.id }))
        })
        test('ticket with "deferredUntil" field and with status not "deferred" should can edit without "deferredUntil" field', async () => {
            const client = await makeClientWithProperty()
            let deferredUntil = dayjs().add(2, 'days').toISOString()

            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
            })

            await updateTestTicket(client, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })
            const [secondUpdatedTicket] = await updateTestTicket(client, ticket.id, {
                deadline: deferredUntil,
            })

            expect(secondUpdatedTicket.deadline).toEqual(deferredUntil)
        })
    })

    describe('reopened ticket', () => {
        test('reset dismissed employees when update status from completed to open', async () => {
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const [role] = await createTestOrganizationEmployeeRole(admin, organization)

            const [employee] = await createTestOrganizationEmployee(admin, organization, client.user, role, {})

            const [ticket] = await createTestTicket(admin, organization, property, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
                executor: { connect: { id: employee.user.id } },
                assignee: { connect: { id: employee.user.id } },
            })

            await updateTestOrganizationEmployee(admin, employee.id, { deletedAt: dayjs().toISOString() })

            const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(ticket.id).toEqual(updatedTicket.id)
            expect(updatedTicket.statusReopenedCounter).toEqual(1)
            expect(get(updatedTicket, ['executor', 'id'], null)).toBeNull()
            expect(get(updatedTicket, ['assignee', 'id'], null)).toBeNull()
        })

        test('non-dismissed employees are not being reset on updating ticket status from completed to open', async () => {
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const [role] = await createTestOrganizationEmployeeRole(admin, organization)

            const [employee] = await createTestOrganizationEmployee(admin, organization, client.user, role, {})

            const [ticket] = await createTestTicket(admin, organization, property, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
                executor: { connect: { id: employee.user.id } },
                assignee: { connect: { id: employee.user.id } },
            })

            const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(ticket.id).toEqual(updatedTicket.id)
            expect(updatedTicket.statusReopenedCounter).toEqual(1)
            expect(get(updatedTicket, ['executor', 'id'], null)).toEqual(get(ticket, ['executor', 'id'], null))
            expect(get(updatedTicket, ['assignee', 'id'], null)).toEqual(get(ticket, ['assignee', 'id'], null))
        })
    })

    describe('notifications', () => {
        describe('Assignee or executor was changed', () => {

            test('push message to assignee', async () => {
                const client = await makeClientWithProperty()
                const assignee = await makeClientWithNewRegisteredAndLoggedInUser()
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_MASTER_ID_ANDROID,
                }

                await syncRemoteClientWithPushTokenByTestClient(assignee, payload)

                const extraProps = { assignee: { connect: { id: assignee.user.id } } }
                const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

                expect(ticket.assignee.id).toEqual(assignee.user.id)

                let message
                const messageWhere = { user: { id: assignee.user.id }, type: TICKET_ASSIGNEE_CONNECTED_TYPE }
                await waitFor(async () => {
                    message = await Message.getOne(admin, messageWhere)

                    expect(message.id).toMatch(UUID_RE)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })

                await waitFor(async () => {
                    const message1 = await Message.getOne(admin, messageWhere)

                    // Testing processingMeta old way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message1.processingMeta.transport).toEqual('push')
                    expect(message1.processingMeta.transports).toEqual(['push'])
                    expect(message1.processingMeta.transportsMeta[0]).toMatchObject({
                        transport: 'push',
                        status: 'sent',
                    })

                    const content = message1.processingMeta.messageContext

                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.userId).toEqual(assignee.user.id)
                    expect(content.data.notificationId).toEqual(message.id)

                    const transportMeta = message1.processingMeta.transportsMeta[0]
                    const content1 = transportMeta.messageContext

                    // Testing processingMeta ADR-7 way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content1.data.url).toBeDefined()
                    expect(content1.data.ticketId).toEqual(ticket.id)
                    expect(content1.data.ticketNumber).toEqual(ticket.number)
                    expect(content1.data.userId).toEqual(assignee.user.id)
                    expect(content1.data.notificationId).toEqual(message.id)
                })
            })

            test('push message to executor', async () => {
                const client = await makeClientWithProperty()
                const executor = await makeClientWithNewRegisteredAndLoggedInUser()
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_MASTER_ID_ANDROID,
                }

                await syncRemoteClientWithPushTokenByTestClient(executor, payload)

                const extraProps = { executor: { connect: { id: executor.user.id } } }
                const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

                expect(ticket.executor.id).toEqual(executor.user.id)

                let message
                const messageWhere = { user: { id: executor.user.id }, type: TICKET_EXECUTOR_CONNECTED_TYPE }

                await waitFor(async () => {
                    message = await Message.getOne(admin, messageWhere)

                    expect(message.id).toMatch(UUID_RE)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })

                await waitFor(async () => {
                    const message1 = await Message.getOne(admin, messageWhere)

                    // Testing processingMeta old way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message1.processingMeta.transport).toEqual('push')

                    const content = message1.processingMeta.messageContext

                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.userId).toEqual(executor.user.id)
                    expect(content.data.notificationId).toEqual(message.id)

                    const transportMeta = message1.processingMeta.transportsMeta[0]
                    const content1 = transportMeta.messageContext

                    // Testing processingMeta ADR-7 way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content1.data.url).toBeDefined()
                    expect(content1.data.ticketId).toEqual(ticket.id)
                    expect(content1.data.ticketNumber).toEqual(ticket.number)
                    expect(content1.data.userId).toEqual(executor.user.id)
                    expect(content1.data.notificationId).toEqual(message.id)
                })
            })

            test('push two message if executor and assignee is the same user', async () => {
                const client = await makeClientWithProperty()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const extraProps = { assignee: { connect: { id: client2.user.id } }, executor: { connect: { id: client2.user.id } } }
                const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

                expect(ticket.assignee.id).toEqual(client2.user.id)

                await waitFor(async () => {
                    const messageWhere = { user: { id: client2.user.id }, type_in: [TICKET_EXECUTOR_CONNECTED_TYPE, TICKET_ASSIGNEE_CONNECTED_TYPE] }
                    const message = await Message.getAll(admin, messageWhere)

                    expect(message).toHaveLength(2)
                    expect(message[0].organization.id).toEqual(ticket.organization.id)
                    expect(message[1].organization.id).toEqual(ticket.organization.id)
                })
            })

            test('do not send push message if it bulk-update assignee or executor', async () => {
                const client = await makeClientWithProperty()
                const executor = await makeClientWithNewRegisteredAndLoggedInUser()
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_MASTER_ID_ANDROID,
                }

                await syncRemoteClientWithPushTokenByTestClient(executor, payload)

                const [ticket1] = await createTestTicket(client, client.organization, client.property)
                const [ticket2] = await createTestTicket(client, client.organization, client.property)

                const attrs = {
                    dv: 1,
                    sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    executor: { connect: { id: executor.user.id } },
                    assignee: { connect: { id: executor.user.id } },
                }

                const updatePayload = [
                    { id: ticket1.id, data: attrs },
                    { id: ticket2.id, data: attrs },
                ]

                const [updateTicket1, updateTicket2] = await Ticket.updateMany(client, updatePayload)

                expect(updateTicket1.executor.id).toEqual(executor.user.id)
                expect(updateTicket2.executor.id).toEqual(executor.user.id)

                let messageCount
                const messageWhere = { user: { id: executor.user.id }, type: TICKET_EXECUTOR_CONNECTED_TYPE }

                await waitFor(async () => {
                    messageCount = await Message.count(admin, messageWhere)
                    expect(messageCount).toEqual(0)
                }, { delay: MESSAGE_SENDING_DElAY })
            })
        })

        describe('Ticket status changed to TICKET_STATUS_IN_PROGRESS', () => {
            it('send push to resident if created Ticket with status == TICKET_STATUS_IN_PROGRESS', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_RESIDENT_ID_ANDROID,
                }

                await syncRemoteClientWithPushTokenByTestClient(userClient, payload)

                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
                const [resident] = await createTestResident(admin, userClient.user, userClient.property, { unitName })
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client.id).toEqual(userClient.user.id)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.IN_PROGRESS } } })

                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)
                    const transportMeta = message.processingMeta.transportsMeta[0]
                    const content = transportMeta.messageContext

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)

                    // Testing processingMeta old way structure
                    expect(message.meta.data.userId).toEqual(userClient.user.id)
                    expect(message.meta.data.residentId).toEqual(resident.id)
                    expect(message.meta.data.ticketId).toEqual(ticket.id)
                    expect(message.meta.data.ticketNumber).toEqual(ticket.number)
                    expect(message.processingMeta.transport).toEqual('push')
                    expect(message.processingMeta.transports).toEqual(['push'])

                    // Testing processingMeta ADR-7 way structure
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.residentId).toEqual(resident.id)
                    expect(content.data.userId).toEqual(userClient.user.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.notificationId).toEqual(message.id)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })
            })

            it('does not send push if there is no resident', async () => {
                const userClient = await makeClientWithProperty()
                const unitName = faker.random.alphaNumeric(5)
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client).toEqual(null)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.IN_PROGRESS } } })

                await waitFor(async () => {
                    const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
                    const messageCount = await Message.count(admin, messageWhere)

                    expect(messageCount).toEqual(0)
                }, { delay: MESSAGE_SENDING_DElAY })
            })

            it('does not send push if Ticket.canReadByResident == false', async () => {
                const residentClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, residentClient.property, {
                    unitName,
                    unitType,
                })
                const [contact] = await createTestContact(admin, residentClient.organization, residentClient.property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, residentClient.organization, residentClient.property, {
                    unitName,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: false,
                })

                const readTicket = await Ticket.getOne(admin, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.IN_PROGRESS } } })

                await waitFor(async () => {
                    const messageWhere = { user: { id: residentClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
                    const messageCount = await Message.count(admin, messageWhere)

                    expect(messageCount).toEqual(0)
                }, { delay: MESSAGE_SENDING_DElAY })
            })
        })

        describe('Ticket status changed to TICKET_STATUS_COMPLETED', () => {
            it('send push to resident', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_RESIDENT_ID_ANDROID,
                }
                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_COMPLETED_TYPE }

                await syncRemoteClientWithPushTokenByTestClient(userClient, payload)

                const [resident] = await createTestResident(admin, userClient.user, userClient.property, { unitName })
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client.id).toEqual(userClient.user.id)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.COMPLETED } } })

                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)
                    const transportMeta = message.processingMeta.transportsMeta[0]
                    const content = transportMeta.messageContext

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)

                    // Testing processingMeta old way structure
                    expect(message.meta.data.userId).toEqual(userClient.user.id)
                    expect(message.meta.data.residentId).toEqual(resident.id)
                    expect(message.meta.data.ticketId).toEqual(ticket.id)
                    expect(message.meta.data.ticketNumber).toEqual(ticket.number)
                    expect(message.processingMeta.transport).toEqual('push')
                    expect(message.processingMeta.transports).toEqual(['push'])

                    // Testing processingMeta ADR-7 way structure
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.residentId).toEqual(resident.id)
                    expect(content.data.userId).toEqual(userClient.user.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.notificationId).toEqual(message.id)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })
            })

            it('does not send if no resident', async () => {
                const userClient = await makeClientWithProperty()
                const unitName = faker.random.alphaNumeric(5)
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client).toEqual(null)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.COMPLETED } } })

                await waitFor(async () => {
                    const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_COMPLETED_TYPE }
                    const messageCount = await Message.count(admin, messageWhere)

                    expect(messageCount).toEqual(0)
                }, { delay: MESSAGE_SENDING_DElAY })
            })
        })

        describe('Ticket status changed to TICKET_STATUS_RETURNED', () => {
            it('send push to resident', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_RESIDENT_ID_ANDROID,
                }
                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_RETURNED_TYPE }

                await syncRemoteClientWithPushTokenByTestClient(userClient, payload)

                const [resident] = await createTestResident(admin, userClient.user, userClient.property, { unitName })
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(ticket.client.id).toEqual(userClient.user.id)

                await waitFor(async () => {
                    const message = await Message.getOne(admin, { user: { id: userClient.user.id }, type: TICKET_STATUS_COMPLETED_TYPE })
                    expect(message.meta.data.userId).toEqual(userClient.user.id)
                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)
                })

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })

                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)
                    const transportMeta = message.processingMeta.transportsMeta[0]
                    const content = transportMeta.messageContext

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)

                    // Testing processingMeta old way structure
                    expect(message.meta.data.userId).toEqual(userClient.user.id)
                    expect(message.meta.data.residentId).toEqual(resident.id)
                    expect(message.meta.data.ticketId).toEqual(ticket.id)
                    expect(message.meta.data.ticketNumber).toEqual(ticket.number)
                    expect(message.processingMeta.transport).toEqual('push')
                    expect(message.processingMeta.transports).toEqual(['push'])

                    // Testing processingMeta ADR-7 way structure
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.residentId).toEqual(resident.id)
                    expect(content.data.userId).toEqual(userClient.user.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.notificationId).toEqual(message.id)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })
            })

            it('does not send if no resident', async () => {
                const userClient = await makeClientWithProperty()
                const unitName = faker.random.alphaNumeric(5)

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(ticket.client).toEqual(null)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })

                await waitFor(async () => {
                    const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_RETURNED_TYPE }
                    const messageCount = await Message.count(admin, messageWhere)

                    expect(messageCount).toEqual(0)
                }, { delay: MESSAGE_SENDING_DElAY })
            })
        })

        describe('Ticket status changed to TICKET_STATUS_DECLINED', () => {
            it('send push to resident', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_RESIDENT_ID_ANDROID,
                }
                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_DECLINED_TYPE }

                await syncRemoteClientWithPushTokenByTestClient(userClient, payload)

                const [resident] = await createTestResident(admin, userClient.user, userClient.property, { unitName })
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client.id).toEqual(userClient.user.id)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.DECLINED } } })

                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)
                    const transportMeta = message.processingMeta.transportsMeta[0]
                    const content = transportMeta.messageContext

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)

                    // Testing processingMeta old way structure
                    expect(message.meta.data.userId).toEqual(userClient.user.id)
                    expect(message.meta.data.residentId).toEqual(resident.id)
                    expect(message.meta.data.ticketId).toEqual(ticket.id)
                    expect(message.meta.data.ticketNumber).toEqual(ticket.number)
                    expect(message.processingMeta.transport).toEqual('push')
                    expect(message.processingMeta.transports).toEqual(['push'])

                    // Testing processingMeta ADR-7 way structure
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.residentId).toEqual(resident.id)
                    expect(content.data.userId).toEqual(userClient.user.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.notificationId).toEqual(message.id)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })
            })

            it('does not send if no resident', async () => {
                const userClient = await makeClientWithProperty()
                const unitName = faker.random.alphaNumeric(5)

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                })

                expect(ticket.client).toEqual(null)

                await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.DECLINED } },
                })

                await waitFor(async () => {
                    const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_DECLINED_TYPE }
                    const messageCount = await Message.count(admin, messageWhere)
                    expect(messageCount).toEqual(0)
                }, { delay: MESSAGE_SENDING_DElAY })
            })
        })

        describe('Ticket created', () => {

            beforeAll(async () => {
                const supportClient = await makeClientWithSupportUser()
                const allOrganizationsBlackList = await MessageOrganizationBlackList.getAll(supportClient, {
                    organization_is_null: true,
                })

                for (const blackListRule of allOrganizationsBlackList) {
                    await updateTestMessageOrganizationBlackList(supportClient, blackListRule.id, {
                        deletedAt: 'true',
                    })
                }
            })

            test('send sms after create ticket with isResidentTicket is true and without resident matches contact data', async () => {
                const client = await makeClientWithProperty()
                const clientName = faker.name.firstName()
                const clientPhone = createTestPhone()
                const today = dayjs().format('YYYY-MM-DD')

                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    isResidentTicket: true,
                    canReadByResident: true,
                    clientName,
                    clientPhone,
                })

                expect(ticket.client).toBeNull()

                const messageWhere = {
                    phone: clientPhone,
                    type: TRACK_TICKET_IN_DOMA_APP_TYPE,
                    uniqKey: `${today}_${md5(clientPhone)}`,
                }
                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)

                    expect(message).toBeDefined()
                    expect(message.id).toMatch(UUID_RE)
                })

                await waitFor(async () => {
                    const message1 = await Message.getOne(admin, messageWhere)

                    // Testing processingMeta old way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message1.processingMeta.transport).toEqual('sms')

                    const content = message1.processingMeta.messageContext

                    expect(content.phone).toEqual(clientPhone)
                    expect(content.message).toBeDefined()

                    // Testing processingMeta ADR-7 way structure
                    const transportMeta = message1.processingMeta.transportsMeta[0]

                    expect(transportMeta.transport).toEqual(SMS_TRANSPORT)

                    const content1 = transportMeta.messageContext

                    expect(content1.phone).toEqual(clientPhone)
                    expect(content1.message).toBeDefined()
                })
            })

            test('dont send sms 2 times a day to same number', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithProperty()

                const clientName = faker.name.firstName()
                const clientPhone = createTestPhone()
                const today = dayjs().format('YYYY-MM-DD')

                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    isResidentTicket: true,
                    canReadByResident: true,
                    clientName,
                    clientPhone,
                })

                expect(ticket.client).toBeNull()

                const messageWhere = {
                    phone: clientPhone,
                    type: TRACK_TICKET_IN_DOMA_APP_TYPE,
                }
                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)

                    expect(message.id).toMatch(UUID_RE)
                    expect(message.uniqKey).toEqual(`${today}_${md5(clientPhone)}`)
                })

                await createTestTicket(client, client.organization, client.property, {
                    isResidentTicket: true,
                    canReadByResident: true,
                    clientName,
                    clientPhone,
                })

                await waitFor(async () => {
                    const messages = await Message.getAll(admin, messageWhere)

                    expect(messages).toHaveLength(1)
                }, { delay: MESSAGE_SENDING_DElAY })
            })

            test('dont send sms if ticket.isResidentTicket is false', async () => {
                const client = await makeClientWithProperty()

                const clientName = faker.name.firstName()
                const clientPhone = createTestPhone()

                await createTestTicket(client, client.organization, client.property, {
                    isResidentTicket: false,
                    clientName,
                    clientPhone,
                })

                await waitFor(async () => {
                    const messageWhere = { phone: clientPhone, type: TRACK_TICKET_IN_DOMA_APP_TYPE }
                    const message = await Message.getOne(admin, messageWhere)

                    expect(message).toBeUndefined()
                }, { delay: MESSAGE_SENDING_DElAY })
            })

            test('dont send sms if resident matches ticket contact data', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone, name } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })

                await createTestTicket(admin, organization, property, {
                    isResidentTicket: true,
                    canReadByResident: true,
                    clientName: name,
                    clientPhone: phone,
                    unitName,
                    unitType,
                })

                await waitFor(async () => {
                    const messageWhere = { phone, type: TRACK_TICKET_IN_DOMA_APP_TYPE }
                    const message = await Message.getOne(admin, messageWhere)

                    expect(message).toBeUndefined()
                }, { delay: MESSAGE_SENDING_DElAY })
            })

            test('dont send sms if resident user create ticket', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })

                await createTestTicket(residentClient, organization, property, {
                    unitName,
                    unitType,
                })

                await waitFor(async () => {
                    const messageWhere = { phone, type: TRACK_TICKET_IN_DOMA_APP_TYPE }
                    const message = await Message.getOne(admin, messageWhere)

                    expect(message).toBeUndefined()
                }, { delay: MESSAGE_SENDING_DElAY })
            })
        })
    })
})
