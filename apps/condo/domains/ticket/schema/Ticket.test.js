/**
 * Generated by `createschema ticket.Ticket organization:Text; statusReopenedCounter:Integer; statusReason?:Text; status:Relationship:TicketStatus:PROTECT; number?:Integer; client?:Relationship:User:SET_NULL; clientName:Text; clientEmail:Text; clientPhone:Text; operator:Relationship:User:SET_NULL; assignee?:Relationship:User:SET_NULL;details:Text; meta?:Json;`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { get, isInteger, omit } = require('lodash')

const {
    NUMBER_RE, UUID_RE, DATETIME_RE,
    makeClient, makeLoggedInAdminClient, waitFor,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowGraphQLRequestError,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowValidationFailureError,
    expectToThrowGQLError,
    expectValuesOfCommonFields,
} = require('@open-condo/keystone/test.utils')

const { WRONG_VALUE } = require('@app/condo/domains/common/constants/errors')
const { md5 } = require('@condo/domains/common/utils/crypto')
const { createTestContact } = require('@condo/domains/contact/utils/testSchema')
const {
    TICKET_ASSIGNEE_CONNECTED_TYPE,
    TICKET_EXECUTOR_CONNECTED_TYPE,
    TICKET_STATUS_IN_PROGRESS_TYPE,
    TICKET_STATUS_COMPLETED_TYPE,
    TICKET_STATUS_RETURNED_TYPE,
    TICKET_STATUS_DECLINED_TYPE,
    MESSAGE_SENT_STATUS,
    TRACK_TICKET_IN_DOMA_APP_TYPE,
    DEVICE_PLATFORM_ANDROID,
    APP_MASTER_ID_ANDROID,
    APP_RESIDENT_ID_ANDROID,
    PUSH_TRANSPORT,
    SMS_TRANSPORT,
} = require('@condo/domains/notification/constants/constants')
const {
    Message,
    MessageOrganizationBlackList,
    updateTestMessageOrganizationBlackList,
    syncRemoteClientWithPushTokenByTestClient,
} = require('@condo/domains/notification/utils/testSchema')
const {
    PROPERTY_TICKET_VISIBILITY,
    PROPERTY_AND_SPECIALIZATION_VISIBILITY,
    ASSIGNED_TICKET_VISIBILITY,
    ORGANIZATION_TICKET_VISIBILITY,
} = require('@condo/domains/organization/constants/common')
const {
    createTestOrganizationLink,
    createTestOrganizationWithAccessToAnotherOrganization,
    createTestOrganizationEmployee,
    createTestOrganizationEmployeeSpecialization,
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    updateTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const {
    makeClientWithProperty,
    createTestProperty,
    updateTestProperty,
    makeClientWithResidentAccessAndProperty,
} = require('@condo/domains/property/utils/testSchema')
const { createTestResident } = require('@condo/domains/resident/utils/testSchema')
const {
    createTestPropertyScope,
    createTestPropertyScopeOrganizationEmployee,
    createTestPropertyScopeProperty,
} = require('@condo/domains/scope/utils/testSchema')
const {
    REVIEW_VALUES,
    DEFERRED_STATUS_TYPE,
    CANCELED_STATUS_TYPE,
    NEW_OR_REOPENED_STATUS_TYPE,
    CLOSED_STATUS_TYPE,
} = require('@condo/domains/ticket/constants')
const { QUALITY_CONTROL_ADDITIONAL_OPTIONS, QUALITY_CONTROL_VALUES } = require('@condo/domains/ticket/constants/qualityControl')
const { STATUS_IDS } = require('@condo/domains/ticket/constants/statusTransitions')
const { ERRORS } = require('@condo/domains/ticket/schema/Ticket')
const {
    Ticket,
    TicketOrganizationSetting,
    TicketComment,
    createTestTicket,
    updateTestTicket,
    createTestTicketComment,
    createTestTicketClassifier, TicketStatus,
} = require('@condo/domains/ticket/utils/testSchema')
const {
    makeClientWithResidentUser,
    makeClientWithNewRegisteredAndLoggedInUser,
    createTestPhone,
    makeClientWithSupportUser,
} = require('@condo/domains/user/utils/testSchema')


// todo(doma-5748): uncomment and remove temporary solution after update "faker"
// const getRandomQualityControlAdditionalOptions = (count) => faker.helpers.arrayElements(
//     QUALITY_CONTROL_ADDITIONAL_OPTIONS,
//     faker.datatype.number({
//         min: isInteger(count) && QUALITY_CONTROL_ADDITIONAL_OPTIONS.length > count ? count : 1,
//         max: isInteger(count) && QUALITY_CONTROL_ADDITIONAL_OPTIONS.length > count ? count : QUALITY_CONTROL_ADDITIONAL_OPTIONS.length,
//     })
// )
//
// const getRandomQualityControlValue = () => faker.helpers.arrayElement(QUALITY_CONTROL_VALUES)

// NOTE: temporary solution
const getRandomQualityControlAdditionalOptions = (count) => {
    return QUALITY_CONTROL_ADDITIONAL_OPTIONS.slice(0, isInteger(count) ? count : QUALITY_CONTROL_ADDITIONAL_OPTIONS.length)
}

// NOTE: temporary solution
const getRandomQualityControlValue = () => {
    return QUALITY_CONTROL_VALUES[0]
}

describe('Ticket', () => {
    let admin

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
    })

    describe('CRUD', () => {
        test('user: create Ticket', async () => {
            const client = await makeClientWithProperty()
            const [contact] = await createTestContact(client, client.organization, client.property)
            const fields = {
                contact: { connect: { id: contact.id } },
            }
            const [obj, attrs] = await createTestTicket(client, client.organization, client.property, fields)

            expectValuesOfCommonFields(obj, attrs, client)
            expect(obj.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(String(obj.number)).toMatch(NUMBER_RE)
            expect(obj.source).toEqual(expect.objectContaining({ id: attrs.source.connect.id }))
            expect(obj.sourceMeta).toEqual(null)
            expect(obj.property).toEqual(expect.objectContaining({ id: client.property.id }))
            expect(obj.propertyAddress).toEqual(client.property.address)
            expect(obj.propertyAddressMeta).toEqual(client.property.addressMeta)
            expect(obj.status).toEqual(expect.objectContaining({ id: attrs.status.connect.id }))
            expect(obj.statusReopenedCounter).toEqual(0)
            expect(obj.statusReason).toEqual(null)
            expect(obj.statusUpdatedAt).toBeNull()
            expect(obj.details).toEqual(attrs.details)
            expect(obj.isPaid).toEqual(false)
            expect(obj.isEmergency).toEqual(false)
            expect(obj.isWarranty).toEqual(false)
            expect(obj.meta).toEqual(null)
            expect(obj.client).toEqual(null)
            expect(obj.contact).toEqual(expect.objectContaining({ id: attrs.contact.connect.id }))
            expect(obj.assignee).toEqual(null)
            expect(obj.executor).toEqual(null)
            expect(obj.unitType).toEqual(FLAT_UNIT_TYPE)
            expect(obj.completedAt).toEqual(null)
            expect(obj.deferredUntil).toEqual(null)
            expect(obj.qualityControlValue).toBeNull()
            expect(obj.qualityControlComment).toBeNull()
            expect(obj.qualityControlAdditionalOptions).toBeNull()
            expect(obj.qualityControlUpdatedAt).toBeNull()
            expect(obj.qualityControlUpdatedBy).toBeNull()
        })

        test('user with resident type without resident: cannot create Ticket', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            await createTestResident(admin, userClient.user, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, userClient.property)
            })
        })

        test('resident: can create ticket without deadline and set default deadline', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })
            const ticketSetting = await TicketOrganizationSetting.getOne(admin, {
                organization: { id: userClient.organization.id },
            })
            const durationAsMs = dayjs.duration(ticketSetting.defaultDeadlineDuration).asMilliseconds()
            const expectedDeadline = dayjs().add(durationAsMs, 'ms').toISOString()
            expect(ticket.deadline).not.toBeNull()
            expect(dayjs(ticket.deadline).diff(expectedDeadline, 'days')).toEqual(0)
        })

        test('resident: can create Ticket and client info save in new ticket', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [obj] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            const user = userClient.user
            const { name, email, phone } = userClient.userAttrs

            expect(obj.client.id).toEqual(user.id)
            expect(obj.clientName).toEqual(name)
            expect(obj.clientPhone).toEqual(phone)
            expect(obj.clientEmail).toEqual(email)
        })

        test('user with 2 residents: can create Ticket for each resident', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName: unitName1,
            })
            await createTestResident(admin, userClient.user, property, {
                unitName: unitName2,
            })

            const [ticket1] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName: unitName1,
            })
            const [ticket2] = await createTestTicket(userClient, organization, property, {
                unitName: unitName2,
            })

            expect(ticket1.id).toMatch(UUID_RE)
            expect(ticket2.id).toMatch(UUID_RE)
        })

        test('resident: cannot create Ticket without unitName', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, userClient.property)
            })
        })

        test('resident: cannot create Ticket in other unitName', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName: unitName1,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName: unitName2,
                })
            })
        })

        test('resident: cannot create Ticket in other property', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const [property] = await createTestProperty(admin, userClient.organization)
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(userClient, userClient.organization, property, {
                    unitName,
                })
            })
        })

        test('resident: cannot update his Ticket details', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const newDetails = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient, ticket.id, {
                    details: newDetails,
                })
            })
        })

        test('employee: update statusReopenedCounter when update status from completed to open', async () => {
            const userClient = await makeClientWithProperty()

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(ticket.id).toEqual(updatedTicket.id)
            expect(updatedTicket.statusReopenedCounter).toEqual(1)

            await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })
            const [againUpdatedTicket] = await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(againUpdatedTicket.statusReopenedCounter).toEqual(2)
        })

        test('resident: cannot update his Ticket fields other than accessibleUpdatedFields', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            const newDetails = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient, ticket.id, {
                    details: newDetails,
                    unitName: unitName2,
                })
            })
        })

        test('resident: can update his Ticket status to a "canceled" status', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            const [canceledStatus] = await TicketStatus.getAll(userClient, {
                type: CANCELED_STATUS_TYPE,
            })

            const [canceledTicket] = await updateTestTicket(userClient, ticket.id, {
                status: { connect: { id: canceledStatus.id } },
            })

            expect(canceledTicket.id).toEqual(ticket.id)
            expect(canceledTicket.status.type).toEqual(CANCELED_STATUS_TYPE)
        })

        test('resident: cannot update his Ticket status to a status other than "cancelled"', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            const [closedStatus] = await TicketStatus.getAll(userClient, {
                type: CLOSED_STATUS_TYPE,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient, ticket.id, {
                    status: { connect: { id: closedStatus.id } },
                })
            })
        })

        test('resident: cannot update not his Ticket', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const userClient2 = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            const newDetails = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })
            await createTestResident(admin, userClient2.user, userClient.property, {
                unitName: unitName2,
            })

            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(userClient2, ticket.id, {
                    details: newDetails,
                    unitName: unitName2,
                })
            })
        })

        test('resident: can read his Tickets', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })
            const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                unitName,
            })
            const [readTicket] = await Ticket.getAll(userClient, { id: ticket.id })

            expect(readTicket.id).toEqual(ticket.id)
        })

        test('resident: can read ticket with a contact whose phone number and address matches the resident phone number and address', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

            expect(readTicket.id).toEqual(ticket.id)
        })

        test('resident: if no client data but with contact data, client data fills from contact', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

            expect(readTicket.clientPhone).toEqual(contact.phone)
            expect(readTicket.clientEmail).toEqual(contact.email)
            expect(readTicket.clientName).toEqual(contact.name)
        })

        test('admin: if client data and contact data sended, client data not overwritted', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone, email, name } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [anotherContact] = await createTestContact(admin, organization, property)
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: anotherContact.id } },
                canReadByResident: true,
                clientName: name,
                clientPhone: phone,
                clientEmail: email,
            })

            const [readTicket] = await Ticket.getAll(admin, { id: ticket.id })

            expect(readTicket.clientPhone).toEqual(phone)
            expect(readTicket.clientEmail).toEqual(email)
            expect(readTicket.clientName).toEqual(name)
        })

        test('admin: if client data sended without contact data, client data not overwritted', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone, email, name } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                canReadByResident: true,
                clientName: name,
                clientPhone: phone,
                clientEmail: email,
            })

            const [readTicket] = await Ticket.getAll(admin, { id: ticket.id })

            expect(readTicket.clientPhone).toEqual(phone)
            expect(readTicket.clientEmail).toEqual(email)
            expect(readTicket.clientName).toEqual(name)
        })

        test('resident: cannot read ticket with a contact whose phone number did not matches the resident phone number', async () => {
            const residentClient1 = await makeClientWithResidentUser()
            const { phone } = residentClient1.userAttrs
            const residentClient2 = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentClient1.user, property, {
                unitName,
            })
            await createTestResident(admin, residentClient2.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const [readTicket] = await Ticket.getAll(residentClient1, {})
            expect(readTicket.id).toEqual(ticket.id)

            const tickets = await Ticket.getAll(residentClient2, {})
            expect(tickets).toHaveLength(0)
        })

        test('resident: cannot read ticket with a contact whose property or unitName ' +
            'did not matches the resident property or unitName', async () => {
            const residentWithTicketClient = await makeClientWithResidentUser()
            const residentFromAnotherPropertyClient = await makeClientWithResidentUser()
            const residentFromAnotherUnitClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property1] = await createTestProperty(admin, organization)
            const [property2] = await createTestProperty(admin, organization)
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentWithTicketClient.user, property1, {
                unitName: unitName1,
            })
            await createTestResident(admin, residentFromAnotherPropertyClient.user, property2, {
                unitName: unitName1,
            })
            await createTestResident(admin, residentFromAnotherUnitClient.user, property1, {
                unitName: unitName2,
            })
            const [contact] = await createTestContact(admin, organization, property1, {
                phone: residentWithTicketClient.userAttrs.phone,
                unitName: unitName1,
            })
            const [ticket] = await createTestTicket(admin, organization, property1, {
                unitName: unitName1,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const [ticketForResidentWithTicket] = await Ticket.getAll(residentWithTicketClient, {})
            expect(ticketForResidentWithTicket.id).toEqual(ticket.id)

            const ticketsForResidentFromAnotherProperty = await Ticket.getAll(residentFromAnotherPropertyClient, {})
            expect(ticketsForResidentFromAnotherProperty).toHaveLength(0)

            const ticketsForResidentFromAnotherUnit = await Ticket.getAll(residentFromAnotherUnitClient, {})
            expect(ticketsForResidentFromAnotherUnit).toHaveLength(0)
        })

        test('resident: user with 2 residents and 2 different contacts can read ticket for each resident', async () => {
            const residentClient1 = await makeClientWithResidentUser()
            const { phone } = residentClient1.userAttrs

            const [organization] = await createTestOrganization(admin)
            const [property1] = await createTestProperty(admin, organization)
            const [property2] = await createTestProperty(admin, organization)
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentClient1.user, property1, { unitName: unitName1 })
            await createTestResident(admin, residentClient1.user, property2, { unitName: unitName2 })

            const [contact1] = await createTestContact(admin, organization, property1, { phone, unitName: unitName1 })
            const [contact2] = await createTestContact(admin, organization, property2, { phone, unitName: unitName2 })

            const [ticket1] = await createTestTicket(admin, organization, property1, {
                unitName: unitName1,
                contact: { connect: { id: contact1.id } },
                canReadByResident: true,
            })

            const [ticket2] = await createTestTicket(admin, organization, property2, {
                unitName: unitName2,
                contact: { connect: { id: contact2.id } },
                canReadByResident: true,
            })

            await createTestTicket(admin, organization, property1, {
                unitName: unitName2,
                contact: { connect: { id: contact1.id } },
                canReadByResident: true,
            })

            const tickets = await Ticket.getAll(residentClient1, {}, { sortBy: 'createdAt_ASC' })
            expect(tickets).toHaveLength(2)
            expect(tickets[0].id).toMatch(ticket1.id)
            expect(tickets[1].id).toMatch(ticket2.id)
        })

        test('resident: cannot read ticket from crm with "canReadByResident": false', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: false,
            })
            const [visibleTicket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const tickets = await Ticket.getAll(residentClient, {})

            expect(tickets).toHaveLength(1)
            expect(tickets[0].id).toEqual(visibleTicket.id)
        })

        test('resident: can read ticket from crm if first it was hidden to him then it became showed', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone: phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: false,
            })

            const tickets = await Ticket.getAll(residentClient, {})

            expect(tickets).toHaveLength(0)

            await updateTestTicket(admin, ticket.id, {
                canReadByResident: true,
            })

            const ticketsAfterShowedTicketToResident = await Ticket.getAll(residentClient, {})

            expect(ticketsAfterShowedTicketToResident).toHaveLength(1)
            expect(ticketsAfterShowedTicketToResident[0].id).toEqual(ticket.id)
        })

        test('resident: cannot read ticket from crm if first it was showed to him then it became hidden', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone: phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            const tickets = await Ticket.getAll(residentClient, {})

            expect(tickets).toHaveLength(1)
            expect(tickets[0].id).toEqual(ticket.id)

            await updateTestTicket(admin, ticket.id, {
                canReadByResident: false,
            })

            const ticketsAfterHiddenTicketToResident = await Ticket.getAll(residentClient, {})

            expect(ticketsAfterHiddenTicketToResident).toHaveLength(0)
        })

        test('resident: cannot update ticket from crm', async () => {
            const residentClient = await makeClientWithResidentUser()

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const unitName = faker.random.alphaNumeric(5)
            const { phone } = residentClient.userAttrs
            const newDetails = faker.random.alphaNumeric(5)

            await createTestResident(admin, residentClient.user, property, {
                unitName,
            })
            const [contact] = await createTestContact(admin, organization, property, {
                phone,
                unitName,
            })
            const [ticket] = await createTestTicket(admin, organization, property, {
                unitName,
                contact: { connect: { id: contact.id } },
                canReadByResident: true,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(residentClient, ticket.id, {
                    details: newDetails,
                })
            })
        })

        test('resident: cannot read not his Tickets', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const userInOtherProperty = await makeClientWithResidentAccessAndProperty()
            const userInOtherUnit = await makeClientWithResidentAccessAndProperty()
            const unitName = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)
            await createTestResident(admin, userClient.user, userClient.property, {
                unitName,
            })
            await createTestResident(admin, userInOtherProperty.user, userInOtherProperty.property, {
                unitName,
            })
            await createTestResident(admin, userInOtherUnit.user, userClient.property, {
                unitName: unitName2,
            })
            const [ticketInOtherProperty] = await createTestTicket(userInOtherProperty, userInOtherProperty.organization, userInOtherProperty.property, {
                unitName,
            })
            const [ticketInOtherUnit] = await createTestTicket(userInOtherUnit, userClient.organization, userClient.property, {
                unitName: unitName2,
            })

            const readTickets = await Ticket.getAll(userClient, { id_in: [ticketInOtherProperty.id, ticketInOtherUnit.id] })

            expect(readTickets).toHaveLength(0)
        })

        test('anonymous: create Ticket', async () => {
            const client1 = await makeClientWithProperty()
            const client = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestTicket(client, client1.organization, client1.property)
            })
        })

        test('user: read Ticket', async () => {
            const client = await makeClientWithProperty()
            const [obj, attrs] = await createTestTicket(client, client.organization, client.property)
            const objs = await Ticket.getAll(client)
            expect(objs).toHaveLength(1)
            expect(objs[0].id).toMatch(obj.id)
            expect(objs[0].dv).toEqual(1)
            expect(objs[0].sender).toEqual(attrs.sender)
            expect(objs[0].v).toEqual(1)
            expect(objs[0].newId).toEqual(null)
            expect(objs[0].deletedAt).toEqual(null)
            expect(objs[0].createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objs[0].updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objs[0].createdAt).toMatch(obj.createdAt)
            expect(objs[0].updatedAt).toMatch(obj.updatedAt)
        })

        test('user: no access to another organization ticket', async () => {
            const hacker = await makeClientWithProperty()
            const client = await makeClientWithProperty()
            const [obj] = await createTestTicket(client, client.organization, client.property)

            const objs = await Ticket.getAll(hacker)
            expect(objs).toHaveLength(0)

            const objsFilteredById = await Ticket.getAll(hacker, { id: obj.id })
            expect(objsFilteredById).toHaveLength(0)
        })

        test('anonymous: read Ticket', async () => {
            const client = await makeClient()

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await Ticket.getAll(client)
            })
        })

        test('user: update Ticket', async () => {
            const client = await makeClientWithProperty()
            const payload = { details: 'new data' }
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            const [objUpdated, attrs] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.details).toEqual(payload.details)
            expect(objUpdated.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(objUpdated.number).toEqual(objCreated.number)
            // TODO(pahaz): check others fields ...
        })

        test('user: can change unitType to null', async () => {
            const client = await makeClientWithProperty()
            const payload = { details: 'new data', unitType: null }
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            expect(objCreated.unitType).toEqual(FLAT_UNIT_TYPE)

            const [objUpdated, attrs] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.details).toEqual(payload.details)
            expect(objUpdated.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(objUpdated.number).toEqual(objCreated.number)
            expect(objUpdated.unitType).toBeNull()
        })

        test('user: set ticket assignee', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            const payload = { details: 'new data', assignee: { connect: { id: client.user.id } } }
            const [objUpdated] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.assignee).toEqual(expect.objectContaining({ id: client.user.id }))
        })

        test('admin: set ticket executor', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)

            const payload = { details: 'new data', executor: { connect: { id: client.user.id } } }
            const [objUpdated] = await updateTestTicket(admin, objCreated.id, payload)

            expect(objUpdated.executor).toEqual(expect.objectContaining({ id: client.user.id }))
        })

        test('user: set the same ticket number', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)
            const payload = { number: objCreated.number }
            const [objUpdated] = await updateTestTicket(client, objCreated.id, payload)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.number).toEqual(objCreated.number)
        })

        test('anonymous: update Ticket', async () => {
            const client1 = await makeClientWithProperty()
            const client = await makeClient()
            const payload = { details: 'new data' }
            const [objCreated] = await createTestTicket(client1, client1.organization, client1.property)
            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestTicket(client, objCreated.id, payload)
            })
        })

        test('user: delete Ticket', async () => {
            const client = await makeClientWithProperty()
            const [objCreated] = await createTestTicket(client, client.organization, client.property)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Ticket.delete(client, objCreated.id)
            })
        })

        test('anonymous: delete Ticket', async () => {
            const client1 = await makeClientWithProperty()
            const client = await makeClient()
            const [objCreated] = await createTestTicket(client1, client1.organization, client1.property)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Ticket.delete(client, objCreated.id)
            })
        })

        test('should auto generating statusUpdatedAt when update status', async () => {
            const userClient = await makeClientWithResidentAccessAndProperty()
            const [openTicket] = await createTestTicket(admin, userClient.organization, userClient.property, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            const [inProgressTicket] = await updateTestTicket(admin, openTicket.id, {
                status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
            })

            expect(dayjs(inProgressTicket.statusUpdatedAt).isValid()).toBe(true)
            expect(dayjs(inProgressTicket.statusUpdatedAt).diff(openTicket.createdAt)).toBeGreaterThanOrEqual(0)

            const [completedTicket] = await updateTestTicket(admin, openTicket.id, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
            })

            expect(dayjs(completedTicket.statusUpdatedAt).isValid()).toBe(true)
            expect(dayjs(completedTicket.statusUpdatedAt).diff(inProgressTicket.statusUpdatedAt)).toBeGreaterThanOrEqual(0)
        })

        test('user: set qualityControlValue', async () => {
            const client = await makeClientWithProperty()
            const [ticket] = await createTestTicket(client, client.organization, client.property)

            const payload = { qualityControlValue: getRandomQualityControlValue() }
            const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

            expect(updatedTicket.qualityControlValue).toEqual(payload.qualityControlValue)
        })

        test('user: set qualityControlAdditionalOptions', async () => {
            const client = await makeClientWithProperty()
            const [ticket] = await createTestTicket(client, client.organization, client.property)

            const payload = {
                qualityControlValue: getRandomQualityControlValue(),
                qualityControlAdditionalOptions: getRandomQualityControlAdditionalOptions(),
            }
            const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)


            expect(updatedTicket.qualityControlValue).toEqual(payload.qualityControlValue)
            expect(updatedTicket.qualityControlAdditionalOptions).toEqual(payload.qualityControlAdditionalOptions.sort())
        })

        test('user: set and update qualityControlAdditionalOptions', async () => {
            const client = await makeClientWithProperty()
            const [ticket, ticketAttrs] = await createTestTicket(client, client.organization, client.property, {
                qualityControlValue: getRandomQualityControlValue(),
                qualityControlAdditionalOptions: getRandomQualityControlAdditionalOptions(),
            })

            expect(ticket.qualityControlValue).toEqual(ticketAttrs.qualityControlValue)
            expect(ticket.qualityControlAdditionalOptions).toEqual(ticketAttrs.qualityControlAdditionalOptions.sort())

            const payload = {
                qualityControlValue: getRandomQualityControlValue(),
                qualityControlAdditionalOptions: getRandomQualityControlAdditionalOptions(),
            }
            const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

            expect(updatedTicket.qualityControlValue).toEqual(payload.qualityControlValue)
            expect(updatedTicket.qualityControlAdditionalOptions).toEqual(payload.qualityControlAdditionalOptions.sort())
        })

        test('user: set qualityControlComment', async () => {
            const client = await makeClientWithProperty()
            const [ticket] = await createTestTicket(client, client.organization, client.property)

            const payload = {
                qualityControlValue: getRandomQualityControlValue(),
                qualityControlComment: faker.lorem.sentence(),
            }
            const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

            expect(updatedTicket.qualityControlComment).toEqual(payload.qualityControlComment)
        })

        describe('user: auto-set "qualityControlUpdatedAt" and "qualityControlUpdatedBy" when updated "qualityControlValue" or "qualityControlAdditionalOptions" or "qualityControlComment"', () => {
            const cases = [
                ['qualityControlValue', { qualityControlValue: getRandomQualityControlValue() }],
                ['qualityControlAdditionalOptions', { qualityControlAdditionalOptions: getRandomQualityControlAdditionalOptions() }],
                ['qualityControlComment', { qualityControlComment: faker.lorem.sentence() }],
            ]

            test.each(cases)('%s', async (_, payload) => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    qualityControlValue: getRandomQualityControlValue(),
                })

                const timeBefore = dayjs()
                const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)
                const timeAfter = dayjs()

                expect(updatedTicket.qualityControlUpdatedAt).not.toBeNull()
                expect(updatedTicket.qualityControlUpdatedAt).not.toEqual(ticket.qualityControlUpdatedAt)
                expect(dayjs(updatedTicket.qualityControlUpdatedAt).isBetween(timeBefore, timeAfter)).toBeTruthy()
                expect(updatedTicket.qualityControlUpdatedBy.id).toEqual(client.user.id)
            })
        })
    })

    describe('Permissions', () => {
        test('user: create Ticket', async () => {
            const client = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(client, client.organization, client2.property)
            })
        })

        test('user: update Ticket', async () => {
            const client = await makeClientWithProperty()
            const client2 = await makeClientWithProperty()
            const [obj] = await createTestTicket(client, client.organization, client.property)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicket(client, obj.id, { property: { connect: { id: client2.property.id } } })
            })
        })

        test('employee from "from" organization: can read tickets from "to" organizations', async () => {
            const {
                clientFrom,
                organizationTo,
                propertyTo,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const clientTo2 = await makeClientWithProperty()

            await createTestTicket(admin, organizationTo, propertyTo)
            await createTestTicket(admin, clientTo2.organization, clientTo2.property)

            await createTestOrganizationLink(admin, organizationFrom, clientTo2.organization)

            const tickets = await Ticket.getAll(clientFrom, { organization: { OR: [{ id: organizationTo.id }, { id: clientTo2.organization.id }] } })
            expect(tickets).toHaveLength(2)
        })

        test('employee from "to" organization: cannot read tickets from "from" organization', async () => {
            const {
                clientTo,
                organizationFrom,
                propertyFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            await createTestTicket(admin, organizationFrom, propertyFrom)

            const tickets = await Ticket.getAll(clientTo, { organization: { id: organizationFrom.id } })
            expect(tickets).toHaveLength(0)
        })

        test('employee from "from" organization: cannot read not its own "to" organizations', async () => {
            const { organizationTo, propertyTo } = await createTestOrganizationWithAccessToAnotherOrganization()
            const {
                clientFrom,
                organizationTo: organizationTo1,
            } = await createTestOrganizationWithAccessToAnotherOrganization()

            await createTestTicket(admin, organizationTo, propertyTo)

            const tickets = await Ticket.getAll(clientFrom, { organization: { OR: [{ id: organizationTo.id }, { id: organizationTo1.id }] } })
            expect(tickets).toHaveLength(0)
        })

        test('organization "from" employee with canManageTickets access: can create organization "to" tickets', async () => {
            const {
                clientFrom,
                organizationTo,
                propertyTo,
                employeeFrom,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const [ticket] = await createTestTicket(clientFrom, organizationTo, propertyTo)
            expect(ticket.id).toMatch(UUID_RE)
        })

        test('organization "to" employee: cannot create organization "from" tickets', async () => {
            const {
                organizationFrom,
                propertyFrom,
                clientTo,
            } = await createTestOrganizationWithAccessToAnotherOrganization()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(clientTo, organizationFrom, propertyFrom)
            })
        })

        test('user: cannot create tickets for "from" or "to" organizations', async () => {
            const {
                organizationFrom,
                propertyFrom,
                organizationTo,
                propertyTo,
                employeeFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const randomUser = await makeClientWithProperty()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(randomUser, organizationFrom, propertyFrom)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(randomUser, organizationTo, propertyTo)
            })
        })

        test('organization "from" employee: can update organization "to" tickets', async () => {
            const {
                clientFrom,
                organizationTo,
                propertyTo,
                organizationFrom,
                employeeFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })

            const [ticket] = await createTestTicket(admin, organizationTo, propertyTo)
            const newDetails = faker.random.alphaNumeric(21)
            const [updatedTicket] = await updateTestTicket(clientFrom, ticket.id, { details: newDetails })

            expect(updatedTicket.id).toEqual(ticket.id)
            expect(updatedTicket.details).toEqual(newDetails)
        })

        test('blocked user: cannot read "to" tickets', async () => {
            const {
                employeeFrom,
                clientFrom,
                organizationTo,
                propertyTo,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            await createTestTicket(admin, organizationTo, propertyTo)
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                isBlocked: true,
            })

            const tickets = await Ticket.getAll(clientFrom)
            expect(tickets).toHaveLength(0)
        })

        test('deleted user: cannot read "to" tickets', async () => {
            const {
                employeeFrom,
                clientFrom,
                organizationFrom,
                propertyFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            await createTestTicket(admin, organizationFrom, propertyFrom)
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                deletedAt: 'true',
            })

            const tickets = await Ticket.getAll(clientFrom)
            expect(tickets).toHaveLength(0)
        })

        test('blocked user: cannot create "to" tickets', async () => {
            const {
                employeeFrom,
                clientFrom,
                organizationTo,
                propertyTo,
                organizationFrom,
            } = await createTestOrganizationWithAccessToAnotherOrganization()
            const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                canManageTickets: true,
            })
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                role: { connect: { id: role.id } },
            })
            await createTestTicket(clientFrom, organizationTo, propertyTo)
            await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                isBlocked: true,
            })

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicket(clientFrom, organizationTo, propertyTo)
            })
        })

        test.skip('user: can read assigned tickets if he is not organization employee', async () => {
            const user = await makeClientWithNewRegisteredAndLoggedInUser()

            const [organization1] = await createTestOrganization(admin)
            const [role] = await createTestOrganizationEmployeeRole(admin, organization1)
            await createTestOrganizationEmployee(admin, organization1, user.user, role)

            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const [ticket] = await createTestTicket(admin, organization, property, {
                assignee: { connect: { id: user.user.id } },
            })

            const readTicket = await Ticket.getOne(user, {
                id: ticket.id,
            })

            expect(readTicket).toBeDefined()
        })

        test('admin: cannot update auto-set field "qualityControlUpdatedAt"', async () => {
            const client = await makeClientWithProperty()

            await expectToThrowGraphQLRequestError(async () => {
                await createTestTicket(admin, client.organization, client.property, { qualityControlUpdatedAt: dayjs().toISOString() })
            }, 'Field "qualityControlUpdatedAt" is not defined')
        })

        test('admin: cannot update auto-set field "qualityControlUpdatedBy"', async () => {
            const client = await makeClientWithProperty()

            await expectToThrowGraphQLRequestError(async () => {
                await createTestTicket(admin, client.organization, client.property, { qualityControlUpdatedBy: { id: client.user.id } })
            }, 'Field "qualityControlUpdatedBy" is not defined')
        })

        describe('resident: cannot set fields for quality control fields', () => {
            const cases = [
                ['qualityControlValue', { qualityControlValue: getRandomQualityControlValue() }],
                ['qualityControlComment', { qualityControlValue: getRandomQualityControlValue(), qualityControlComment: faker.lorem.sentence() }],
                ['qualityControlAdditionalOptions', { qualityControlValue: getRandomQualityControlValue(), qualityControlAdditionalOptions: getRandomQualityControlAdditionalOptions() }],
            ]

            test.each(cases)('cannot create ticket with "%s"', async (_, payload) => {
                const residentClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, residentClient.user, residentClient.property, {
                    unitName,
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestTicket(residentClient, residentClient.organization, residentClient.property, payload)
                })
            })

            test.each(cases)('cannot update ticket with "%s"', async (_, payload) => {
                const residentClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, residentClient.user, residentClient.property, {
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, residentClient.organization, residentClient.property, {
                    qualityControlValue: getRandomQualityControlValue(),
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestTicket(residentClient, ticket.id, omit(payload, 'qualityControlValue'))
                })
            })
        })
    })

    describe.skip('ticket visibility type', () => {
        describe('organization', () => {
            it('can read tickets and related to ticket objects in organization where user is employee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: ORGANIZATION_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property)
                const [ticketComment] = await createTestTicketComment(userClient, ticket, userClient.user)

                const readTicket = await Ticket.getOne(userClient, { id: ticket.id })
                expect(readTicket.id).toMatch(ticket.id)

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment.id).toMatch(ticketComment.id)
            })

            it('cannot read tickets and related to ticket objects in organization where user is not employee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [organization1] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: ORGANIZATION_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization1)
                const [ticket] = await createTestTicket(admin, organization1, property)
                const [ticketComment] = await createTestTicketComment(admin, ticket, admin.user)

                const readTicket = await Ticket.getOne(userClient, { id: ticket.id })
                expect(readTicket).toBeUndefined()

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment).toBeUndefined()
            })
        })

        describe('property', () => {
            it('can read all tickets and related to ticket objects in organization if employee in PropertyScope with hasAllProperties flag', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization, {
                    hasAllProperties: true,
                })
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)

                const [ticket1] = await createTestTicket(admin, organization, property)
                const [ticket2] = await createTestTicket(admin, organization, property2)
                const [ticketComment] = await createTestTicketComment(userClient, ticket1, userClient.user)

                const tickets = await Ticket.getAll(userClient, {
                    id_in: [ticket1.id, ticket2.id],
                }, { sortBy: 'createdAt_ASC' })

                expect(tickets).toHaveLength(2)
                expect(tickets[0].id).toEqual(ticket1.id)
                expect(tickets[1].id).toEqual(ticket2.id)

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment.id).toMatch(ticketComment.id)
            })

            it('can read tickets and related to ticket objects in properties from PropertyScope where this employee is', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)
                const [property3] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)
                await createTestPropertyScopeProperty(admin, propertyScope, property2)
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)

                const [ticket1] = await createTestTicket(admin, organization, property)
                const [ticket2] = await createTestTicket(admin, organization, property2)
                const [ticket3] = await createTestTicket(admin, organization, property3)

                const [ticketComment] = await createTestTicketComment(userClient, ticket1, userClient.user)

                const tickets = await Ticket.getAll(userClient, {
                    id_in: [ticket1.id, ticket2.id, ticket3.id],
                }, { sortBy: 'createdAt_ASC' })
                expect(tickets).toHaveLength(2)
                expect(tickets[0].id).toEqual(ticket1.id)
                expect(tickets[1].id).toEqual(ticket2.id)

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment.id).toMatch(ticketComment.id)
            })

            it('can read tickets and related to ticket objects where employee is executor or assignee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property, {
                    assignee: { connect: { id: userClient.user.id } },
                })
                const [ticket1] = await createTestTicket(admin, organization, property, {
                    executor: { connect: { id: userClient.user.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property)

                const [ticketComment] = await createTestTicketComment(userClient, ticket1, userClient.user)

                const readTickets = await Ticket.getAll(userClient, { id_in: [ticket.id, ticket1.id, ticket2.id] },
                    { sortBy: 'createdAt_ASC' })
                expect(readTickets).toHaveLength(2)
                expect(readTickets[0].id).toEqual(ticket.id)
                expect(readTickets[1].id).toEqual(ticket1.id)

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment.id).toMatch(ticketComment.id)
            })

            it('cannot read tickets and related to ticket objects if there no PropertyScope in which employee is', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property)
                const [ticketComment] = await createTestTicketComment(admin, ticket, admin.user)

                const readTicket = await Ticket.getOne(userClient, { id: ticket.id })
                expect(readTicket).toBeUndefined()

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment).toBeUndefined()
            })

            it('cannot read tickets and related to ticket objects with properties which are in the PropertyScope where employee is not', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)

                const [ticket] = await createTestTicket(admin, organization, property)
                const [ticketComment] = await createTestTicketComment(admin, ticket, admin.user)

                const readTicketsByClient = await Ticket.getOne(userClient, {
                    id: ticket.id,
                })
                expect(readTicketsByClient).toBeUndefined()

                const readTicketComment = await TicketComment.getOne(userClient, { id: ticketComment.id })
                expect(readTicketComment).toBeUndefined()
            })
        })

        describe('property and specialization', () => {
            it('can read tickets with TicketCategoryClassifier matches to employee OrganizationEmployeeSpecialization ' +
                'and property from PropertyScope where this employee is', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                const [classifier1] = await createTestTicketClassifier(admin)
                const [classifier2] = await createTestTicketClassifier(admin)
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)
                await createTestOrganizationEmployeeSpecialization(admin, employee, classifier1.category)

                const [ticket1] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier1.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier2.id } },
                })
                const [ticket3] = await createTestTicket(admin, organization, property2, {
                    classifier: { connect: { id: classifier2.id } },
                })

                const tickets = await Ticket.getAll(userClient, {
                    id_in: [ticket1.id, ticket2.id, ticket3.id],
                }, { sortBy: 'createdAt_ASC' })

                expect(tickets).toHaveLength(1)
                expect(tickets[0].id).toEqual(ticket1.id)
            })

            it('can read tickets where employee is executor or assignee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property, {
                    assignee: { connect: { id: userClient.user.id } },
                })
                const [ticket1] = await createTestTicket(admin, organization, property, {
                    executor: { connect: { id: userClient.user.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property)

                const readTickets = await Ticket.getAll(userClient, { id_in: [ticket.id, ticket1.id, ticket2.id] },
                    { sortBy: 'createdAt_ASC' })

                expect(readTickets).toHaveLength(2)
                expect(readTickets[0].id).toEqual(ticket.id)
                expect(readTickets[1].id).toEqual(ticket1.id)
            })

            it('cannot read tickets with TicketCategoryClassifier matches to employee OrganizationEmployeeSpecialization ' +
                'and there no property from PropertyScope where this employee is', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                const [classifier1] = await createTestTicketClassifier(admin)
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)

                await createTestOrganizationEmployeeSpecialization(admin, employee, classifier1.category)

                const [ticket1] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier1.id } },
                })

                const readTicket = await Ticket.getOne(userClient, {
                    id: ticket1.id,
                })

                expect(readTicket).toBeUndefined()
            })

            it('cannot read tickets with property from PropertyScope where this employee is ' +
                'and TicketCategoryClassifier not matches to employee OrganizationEmployeeSpecialization', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                const [classifier] = await createTestTicketClassifier(admin)
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)

                const [ticket] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier.id } },
                })

                const readTicket = await Ticket.getOne(userClient, {
                    id: ticket.id,
                })

                expect(readTicket).toBeUndefined()
            })
        })

        describe('assigned', () => {
            it('can read only tickets where employee is executor or assignee', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: ASSIGNED_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property, {
                    assignee: { connect: { id: userClient.user.id } },
                })
                const [ticket1] = await createTestTicket(admin, organization, property, {
                    executor: { connect: { id: userClient.user.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property)

                const readTickets = await Ticket.getAll(userClient, { id_in: [ticket.id, ticket1.id, ticket2.id] },
                    { sortBy: 'createdAt_ASC' })

                expect(readTickets).toHaveLength(2)
                expect(readTickets[0].id).toEqual(ticket.id)
                expect(readTickets[1].id).toEqual(ticket1.id)
            })
        })
    })

    describe('Validations', () => {
        describe('guards', () => {
            test('user: resident should not be able to create tickets with identical text over the limit', async () => {
                const details = 'I have some problems with hot water!'

                // User, should be banned from creating tickets to organization if he exceeds the limits.
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, userClient.property, {
                    unitName,
                })
                for (let i = 0; i < DAILY_SAME_TICKET_LIMIT; ++i) {
                    await createTestTicket(userClient, userClient.organization, userClient.property, { unitName, details })
                }

                await expectToThrowGQLError(async () => {
                    await createTestTicket(userClient, userClient.organization, userClient.property, { unitName, details })
                }, ERRORS.SAME_TICKET_FOR_PHONE_DAY_LIMIT_REACHED)

                // User, banned from creating tickets to organization 1, can still create tickets to organization 2
                const client2 = await makeClientWithProperty()
                const unitName2 = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, client2.property, {
                    unitName: unitName2,
                })

                const [secondOrgTicket] = await createTestTicket(userClient, client2.organization, client2.property, { unitName: unitName2, details })

                expect(secondOrgTicket).toBeDefined()
                expect(secondOrgTicket.id).toBeDefined()
                expect(secondOrgTicket.details).toEqual(details)
                expect(secondOrgTicket.organization.id).toEqual(client2.organization.id)
                expect(secondOrgTicket.property.id).toEqual(client2.property.id)
            })

            test('user: resident should not be able to create tickets in single day over the limit', async () => {
                // User, should be banned from creating tickets to organization if he exceeds the limits.
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, userClient.property, {
                    unitName,
                })
                for (let i = 0; i < DAILY_TICKET_LIMIT; ++i) {
                    await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })
                }

                await expectToThrowGQLError(async () => {
                    await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })
                }, ERRORS.TICKET_FOR_PHONE_DAY_LIMIT_REACHED)

                // User, banned from creating tickets to organization 1, can still create tickets to organization 2
                const client2 = await makeClientWithProperty()
                const unitName2 = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, client2.property, {
                    unitName: unitName2,
                })

                const [secondOrgTicket] = await createTestTicket(userClient, client2.organization, client2.property, { unitName: unitName2 })

                expect(secondOrgTicket).toBeDefined()
                expect(secondOrgTicket.id).toBeDefined()
                expect(secondOrgTicket.organization.id).toEqual(client2.organization.id)
                expect(secondOrgTicket.property.id).toEqual(client2.property.id)
            })
        })

        describe('new ticket without status', () => {
            test('user: can create Ticket without status and status set to OPEN on server-side', async () => {
                const client = await makeClientWithProperty()
                const [obj] = await createTestTicket(client, client.organization, client.property, { status: null })

                expect(obj.status).toEqual(expect.objectContaining({ id: STATUS_IDS.OPEN }))
            })
        })

        describe('change status after resident review', () => {
            test('status changed to CLOSED after resident left GOOD review value', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const reviewComment = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, userClient.property, {
                    unitName,
                })

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                    reviewValue: REVIEW_VALUES.GOOD,
                    reviewComment,
                })

                expect(ticket.id).toEqual(updatedTicket.id)
                expect(updatedTicket.reviewValue).toEqual(REVIEW_VALUES.GOOD)
                expect(updatedTicket.reviewComment).toEqual(reviewComment)
                expect(updatedTicket.status.id).toEqual(STATUS_IDS.CLOSED)
            })

            test('status changed to OPEN after resident return ticket to work', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                await createTestResident(admin, userClient.user, userClient.property, {
                    unitName,
                })

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                const [updatedTicket] = await updateTestTicket(userClient, ticket.id, {
                    reviewValue: REVIEW_VALUES.RETURN,
                })

                expect(ticket.id).toEqual(updatedTicket.id)
                expect(updatedTicket.reviewValue).toEqual(REVIEW_VALUES.RETURN)
                expect(updatedTicket.status.id).toEqual(STATUS_IDS.OPEN)
            })
        })

        describe('propertyAddress and propertyAddressMeta', () => {
            test('Should be filled resolved automatically on ticket creation', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                expect(ticket).toHaveProperty('propertyAddress', client.property.address)
                expect(ticket).toHaveProperty('propertyAddressMeta', client.property.addressMeta)
            })
            test('Should be changed after property changed', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                const [newProperty] = await createTestProperty(client, client.organization)
                const [updatedTicket] = await updateTestTicket(client, ticket.id, {
                    property: { connect: { id: newProperty.id } },
                })
                expect(updatedTicket).toHaveProperty('propertyAddress', newProperty.address)
                expect(updatedTicket).toHaveProperty('propertyAddressMeta', newProperty.addressMeta)
            })
            test('Should be changed after address of linked property changed', async () => {
                const client = await makeClientWithProperty()
                const client2 = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                await updateTestProperty(client, client.property.id, {
                    address: client2.property.address,
                    addressMeta: client2.property.addressMeta,
                })

                // NOTE: give worker some time
                await waitFor(async () => {
                    const [changedTicket] = await Ticket.getAll(client, { id: ticket.id })
                    expect(changedTicket).toBeDefined()
                    expect(changedTicket).toHaveProperty('propertyAddress', client2.property.address)
                    expect(changedTicket).toHaveProperty('propertyAddressMeta', client2.property.addressMeta)
                })
            })

            test('Cannot be created / changed manually', async () => {
                const client = await makeClientWithProperty()
                const [property] = await createTestProperty(client, client.organization)
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestTicket(client, ticket.id, {
                        propertyAddress: property.address,
                    })
                }, 'Field "propertyAddress" is not defined by type "TicketUpdateInput"')
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestTicket(client, ticket.id, {
                        propertyAddressMeta: property.addressMeta,
                    })
                }, 'Field "propertyAddressMeta" is not defined by type "TicketUpdateInput"')
                await expectToThrowGraphQLRequestError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        propertyAddress: property.address,
                    })
                }, 'Field "propertyAddress" is not defined by type "TicketCreateInput"')
                await expectToThrowGraphQLRequestError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        propertyAddressMeta: property.addressMeta,
                    })
                }, 'Field "propertyAddressMeta" is not defined by type "TicketCreateInput"')
            })
            test('Should be unchanged on Property softDeletion', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)
                await updateTestProperty(client, client.property.id, {
                    deletedAt: dayjs().toISOString(),
                })

                const [refetchTicket] = await Ticket.getAll(client, { id: ticket.id })
                expect(refetchTicket).toBeDefined()
                expect(refetchTicket).toHaveProperty('propertyAddress', client.property.address)
                expect(refetchTicket).toHaveProperty('propertyAddressMeta', client.property.addressMeta)
            })
        })

        describe('client', () => {
            test('should be filled automatically on ticket creation if contact phone number and ticket address matches the resident phone number and address', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })
                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
            })

            test('should be filled automatically on ticket update if contact phone number and updated ticket address matches the resident phone number and address', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitName1 = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })
                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName: unitName1,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })

                expect(ticket.client).toBeNull()

                await updateTestTicket(admin, ticket.id, {
                    unitName,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
                expect(readTicket.clientName).toEqual(ticket.clientName)
                expect(readTicket.clientPhone).toEqual(ticket.clientPhone)
                expect(readTicket.clientEmail).toEqual(ticket.clientEmail)
            })

            test('should be filled automatically on create resident with same contact phone and same ticket address', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                const [contact] = await createTestContact(admin, organization, property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: true,
                })

                expect(ticket.client).toBeNull()

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })

                await waitFor(async () => {
                    const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })
                    expect(readTicket.client.id).toEqual(residentClient.user.id)
                })
            })

            test('should be filled automatically on ticket with isResidentTicket creation if clientPhone number and ticket address matches the resident phone number and address', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone, name } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })
                const [ticket] = await createTestTicket(admin, organization, property, {
                    unitName,
                    unitType,
                    clientPhone: phone,
                    clientName: name,
                    isResidentTicket: true,
                    canReadByResident: true,
                })

                const readTicket = await Ticket.getOne(residentClient, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)
            })
        })

        describe('contact', () => {
            describe('isResident ticket is true', function () {
                it('should be created and connected if no contact matches with clientPhone, unitName and unitType', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: true,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact.id).toMatch(UUID_RE)
                    expect(ticket.contact.name).toEqual(name)
                    expect(ticket.contact.phone).toEqual(phone)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })

                it('should be connected if contact with same clientPhone, unitName and unitType exists', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [contact] = await createTestContact(admin, organization, property, {
                        phone,
                        name,
                        unitName,
                    })

                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: true,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact.id).toEqual(contact.id)
                    expect(ticket.contact.name).toEqual(name)
                    expect(ticket.contact.phone).toEqual(phone)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })

                it('should create and connect new contact if clientPhone, unitName or unitType are different than connected contact\'s', async () => {

                    const { userAttrs: { phone: phone1, name: name1 } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const { userAttrs: { phone: phone2, name: name2 } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [contact1] = await createTestContact(admin, organization, property, {
                        phone: phone1,
                        name: name1,
                        unitName,
                    })

                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: true,
                        clientName: name1,
                        clientPhone: phone1,
                        unitName,
                    })

                    expect(ticket.contact.id).toEqual(contact1.id)
                    expect(ticket.contact.name).toEqual(name1)
                    expect(ticket.contact.phone).toEqual(phone1)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)

                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        clientName: name2,
                        clientPhone: phone2,
                        unitName,
                    })

                    expect(updatedTicket.contact.id).not.toEqual(contact1.id)
                    expect(updatedTicket.contact.name).toEqual(name2)
                    expect(updatedTicket.contact.phone).toEqual(phone2)
                    expect(updatedTicket.contact.unitName).toEqual(unitName)
                    expect(updatedTicket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })

                it('should be connected if resident user creates ticket', async () => {

                    const residentClient = await makeClientWithResidentUser()
                    const { name, phone } = residentClient.userAttrs

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const unitName = faker.random.alphaNumeric(5)

                    await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })

                    const [createdTicket] = await createTestTicket(residentClient, organization, property, {
                        unitName,
                    })

                    const ticket = await Ticket.getOne(admin, { id: createdTicket.id })

                    expect(ticket.contact.id).toMatch(UUID_RE)
                    expect(ticket.contact.name).toEqual(name)
                    expect(ticket.contact.phone).toEqual(phone)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })

                it('should be disconnected if isResidentTicket changed to false', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: true,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact.id).toMatch(UUID_RE)
                    expect(ticket.contact.name).toEqual(name)
                    expect(ticket.contact.phone).toEqual(phone)
                    expect(ticket.contact.unitName).toEqual(unitName)
                    expect(ticket.contact.unitType).toEqual(FLAT_UNIT_TYPE)

                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        isResidentTicket: false,
                    })

                    expect(updatedTicket.contact).toBeNull()
                })
            })

            describe('isResidentTicket is false', () => {
                it('should not be created if no contact matches witch clientPhone, unitName and unitType', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: false,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact).toBeNull()
                })

                it('should not be connected if contact with same clientPhone, unitName and unitType is exist', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    await createTestContact(admin, organization, property, {
                        phone,
                        name,
                        unitName,
                    })

                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: false,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact).toBeNull()
                })

                it('should be connected if isResidentTicket changed to true', async () => {

                    const { userAttrs: { phone, name } } = await makeClientWithNewRegisteredAndLoggedInUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [contact] = await createTestContact(admin, organization, property, {
                        phone,
                        name,
                        unitName,
                    })

                    const [ticket] = await createTestTicket(admin, organization, property, {
                        isResidentTicket: false,
                        clientName: name,
                        clientPhone: phone,
                        unitName,
                    })

                    expect(ticket.contact).toBeNull()

                    const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                        isResidentTicket: true,
                    })

                    expect(updatedTicket.contact.id).toEqual(contact.id)
                    expect(updatedTicket.contact.name).toEqual(name)
                    expect(updatedTicket.contact.phone).toEqual(phone)
                    expect(updatedTicket.contact.unitName).toEqual(unitName)
                    expect(updatedTicket.contact.unitType).toEqual(FLAT_UNIT_TYPE)
                })
            })

        })

        describe('completedAt', () => {
            test('should be filled and updated automatically when ticket status changes to "completed" value', async () => {


                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property)

                expect(ticket.completedAt).toBeNull()

                const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(updatedTicket.completedAt).toBeDefined()
                expect(updatedTicket.completedAt).toMatch(DATETIME_RE)

                const [updatedTicket1] = await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.IN_PROGRESS } },
                })

                expect(updatedTicket1.completedAt).toEqual(updatedTicket.completedAt)

                const [updatedTicket2] = await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(updatedTicket2.completedAt).toBeDefined()
                expect(updatedTicket2.completedAt).toMatch(DATETIME_RE)
                expect(dayjs(updatedTicket2.completedAt).isAfter(updatedTicket.completedAt)).toBeTruthy()
            })
        })

        describe('deferredUntil and status', () => {
            test('deferredUntil is null should not be with status "deferred"', async () => {
                const client = await makeClientWithProperty()

                await expectToThrowValidationFailureError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        status: { connect: { id: STATUS_IDS.DEFERRED } },
                    })
                }, `${WRONG_VALUE} deferredUntil is null, but status type is ${DEFERRED_STATUS_TYPE}`)
            })
            test(`should not create ticket with "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE}`, async () => {
                const deferredUntil = dayjs().add(2, 'days').toISOString()
                const client = await makeClientWithProperty()

                await expectToThrowValidationFailureError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        status: { connect: { id: STATUS_IDS.OPEN } }, deferredUntil,
                    })
                }, `${WRONG_VALUE} should not create ticket with "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE}`)
            })
            test(`should not change "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE} before or after changes`, async () => {
                const deferredUntil = dayjs().add(2, 'days').toISOString()
                const client = await makeClientWithProperty()

                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    status: { connect: { id: STATUS_IDS.OPEN } },
                })

                await expectToThrowValidationFailureError(async () => {
                    await updateTestTicket(client, ticket.id, {
                        deferredUntil,
                    })
                }, `${WRONG_VALUE} should not change "deferredUntil" field if status type is not ${DEFERRED_STATUS_TYPE} before or after changes`)
            })
            test('"deferredUntil" field must be no more than 1 year old than the current date', async () => {
                const deferredUntil = dayjs().add(2, 'years').toISOString()
                const client = await makeClientWithProperty()

                await expectToThrowValidationFailureError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
                    })
                }, `${WRONG_VALUE} the value of the "deferredUntil" field must be no more than 1 year old than the current date`)
            })
            test('the value of the "deferredUntil" field must be greater than the current date', async () => {
                const deferredUntil = dayjs().subtract(1, 'days').toISOString()
                const client = await makeClientWithProperty()

                await expectToThrowValidationFailureError(async () => {
                    await createTestTicket(client, client.organization, client.property, {
                        status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
                    })
                }, `${WRONG_VALUE} the value of the "deferredUntil" field must be greater than the current date`)
            })
        })

        describe('isAutoClassified', () => {
            test('Set to true if the ticket was classified on the server side when the ticket was created', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)

                expect(ticket.isAutoClassified).toEqual(true)
            })
            test('Set to false if the ticket was classified manually', async () => {
                const client = await makeClientWithProperty()
                const [classifier] = await createTestTicketClassifier(admin)
                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    classifier: { connect: { id: classifier.id } },
                })

                expect(ticket.isAutoClassified).toEqual(false)
            })
            test('Set to true if the ticket was updated with classifier', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)

                expect(ticket.isAutoClassified).toEqual(true)

                const [classifier] = await createTestTicketClassifier(admin)
                const [updatedTicket] = await updateTestTicket(client, ticket.id, {
                    classifier: { connect: { id: classifier.id } },
                })

                expect(updatedTicket.isAutoClassified).toEqual(false)
            })
            test('Doesn\'t set to true if the ticket was updated without classifier', async () => {
                const client = await makeClientWithProperty()
                const [ticket] = await createTestTicket(client, client.organization, client.property)

                expect(ticket.isAutoClassified).toEqual(true)

                const details = faker.lorem.sentence()
                const [updatedTicket] = await updateTestTicket(client, ticket.id, {
                    details,
                })

                expect(updatedTicket.isAutoClassified).toEqual(true)
            })
        })

        describe('quality control', () => {
            describe('qualityControlAdditionalOptions', () => {
                describe('Should pass "qualityControlAdditionalOptions"', () => {
                    const cases = [
                        [null, null],
                        [[], null],
                        [[QUALITY_CONTROL_ADDITIONAL_OPTIONS[0]], [QUALITY_CONTROL_ADDITIONAL_OPTIONS[0]]],
                        [[QUALITY_CONTROL_ADDITIONAL_OPTIONS[0], QUALITY_CONTROL_ADDITIONAL_OPTIONS[1]], [QUALITY_CONTROL_ADDITIONAL_OPTIONS[0], QUALITY_CONTROL_ADDITIONAL_OPTIONS[1]].sort()],
                        [[QUALITY_CONTROL_ADDITIONAL_OPTIONS[0], QUALITY_CONTROL_ADDITIONAL_OPTIONS[0]], [QUALITY_CONTROL_ADDITIONAL_OPTIONS[0]]],
                    ]

                    test.each(cases)('value: %j', async (additionalOptions, expected) => {
                        const client = await makeClientWithProperty()
                        const [ticket] = await createTestTicket(client, client.organization, client.property)

                        const payload = {
                            qualityControlValue: getRandomQualityControlValue(),
                            qualityControlAdditionalOptions: additionalOptions,
                        }
                        const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

                        expect(updatedTicket.qualityControlValue).toEqual(payload.qualityControlValue)
                        expect(updatedTicket.qualityControlAdditionalOptions).toEqual(expected)
                    })
                })

                describe('Should not pass "qualityControlAdditionalOptions"', () => {
                    const cases = [
                        {},
                        faker.datatype.number(),
                        '',
                        faker.lorem.sentence(),
                        [faker.lorem.sentence()],
                        [faker.datatype.boolean()],
                        [faker.datatype.number()],
                        [[]],
                        [getRandomQualityControlAdditionalOptions()],
                    ]

                    test.each(cases)('value: %j', async (additionalOptions) => {
                        const client = await makeClientWithProperty()
                        const [ticket] = await createTestTicket(client, client.organization, client.property)

                        const payload = {
                            qualityControlValue: getRandomQualityControlValue(),
                            qualityControlAdditionalOptions: additionalOptions,
                        }

                        await expectToThrowGraphQLRequestError(async () => {
                            await updateTestTicket(client, ticket.id, payload)
                        }, 'got invalid value')
                    })
                })

                test('"qualityControlAdditionalOptions" should not be passed if there is no "qualityControlValue"', async () => {
                    const client = await makeClientWithProperty()
                    const [ticket] = await createTestTicket(client, client.organization, client.property)

                    const payload = {
                        qualityControlAdditionalOptions: getRandomQualityControlAdditionalOptions(),
                    }

                    await expectToThrowGQLError(async () => {
                        await updateTestTicket(client, ticket.id, payload)
                    }, ERRORS.QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED)
                })

                test('"qualityControlAdditionalOptions" can be passed if there is "qualityControlValue"', async () => {
                    const client = await makeClientWithProperty()
                    const [ticket] = await createTestTicket(client, client.organization, client.property, {
                        qualityControlValue: getRandomQualityControlValue(),
                    })

                    const payload = {
                        qualityControlAdditionalOptions: getRandomQualityControlAdditionalOptions(),
                    }
                    const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

                    expect(updatedTicket.qualityControlAdditionalOptions).toEqual(payload.qualityControlAdditionalOptions.sort())
                })
            })

            describe('qualityControlComment', () => {
                test('"qualityControlComment" should not be passed if there is no "qualityControlValue"', async () => {
                    const client = await makeClientWithProperty()
                    const [ticket] = await createTestTicket(client, client.organization, client.property)

                    const payload = {
                        qualityControlComment: faker.lorem.sentence(),
                    }

                    await expectToThrowGQLError(async () => {
                        await updateTestTicket(client, ticket.id, payload)
                    }, ERRORS.QUALITY_CONTROL_VALUE_MUST_BE_SPECIFIED)
                })

                test('"qualityControlComment" can be passed if there is "qualityControlValue"', async () => {
                    const client = await makeClientWithProperty()
                    const [ticket] = await createTestTicket(client, client.organization, client.property, {
                        qualityControlValue: getRandomQualityControlValue(),
                    })

                    const payload = {
                        qualityControlComment: faker.lorem.sentence(),
                    }
                    const [updatedTicket] = await updateTestTicket(client, ticket.id, payload)

                    expect(updatedTicket.qualityControlComment).toEqual(payload.qualityControlComment)
                })
            })
        })
    })

    describe('deferred tickets', () => {
        describe('changing the status from "deferred" to any other without "deferredUntil", the value of the "deferredUntil" field is changed to null', () => {
            const cases = [[NEW_OR_REOPENED_STATUS_TYPE, STATUS_IDS.OPEN], [CANCELED_STATUS_TYPE, STATUS_IDS.DECLINED]]
            test.each(cases)('change ticket status from "deferred" to %p', async (statusType, statusId) => {
                const client = await makeClientWithProperty()
                const deferredUntil = dayjs().add(2, 'days').toISOString()

                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
                })

                const [updatedTicket, updatedAttrs] = await updateTestTicket(client, ticket.id, {
                    status: { connect: { id: statusId } },
                })

                expect(updatedTicket.status).toEqual(expect.objectContaining({ id: updatedAttrs.status.connect.id }))
                expect(updatedTicket.deferredUntil).toBe(null)
            })
        })
        test('deferredUntil is null should not be with status "deferred"', async () => {
            const client = await makeClientWithProperty()

            const [ticket, attrs] = await createTestTicket(client, client.organization, client.property, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(ticket.deferredUntil).toEqual(null)
            expect(ticket.status).toEqual(expect.objectContaining({ id: attrs.status.connect.id }))
        })
        test('should can change "postponedUntil" field', async () => {
            const client = await makeClientWithProperty()
            let deferredUntil = dayjs().add(2, 'days').toISOString()

            const [ticket, attrs] = await createTestTicket(client, client.organization, client.property, {
                status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
            })

            deferredUntil = dayjs().add(10, 'days').toISOString()

            const [updatedTicket] = await updateTestTicket(client, ticket.id, {
                deferredUntil,
            })

            expect(updatedTicket.deferredUntil).toEqual(deferredUntil)
            expect(updatedTicket.status).toEqual(expect.objectContaining({ id: attrs.status.connect.id }))
        })
        test('ticket with "deferredUntil" field and with status not "deferred" should can edit without "deferredUntil" field', async () => {
            const client = await makeClientWithProperty()
            let deferredUntil = dayjs().add(2, 'days').toISOString()

            const [ticket] = await createTestTicket(client, client.organization, client.property, {
                status: { connect: { id: STATUS_IDS.DEFERRED } }, deferredUntil,
            })

            await updateTestTicket(client, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })
            const [secondUpdatedTicket] = await updateTestTicket(client, ticket.id, {
                deadline: deferredUntil,
            })

            expect(secondUpdatedTicket.deadline).toEqual(deferredUntil)
        })
    })

    describe('reopened ticket', () => {
        test('reset dismissed employees when update status from completed to open', async () => {
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const [role] = await createTestOrganizationEmployeeRole(admin, organization)

            const [employee] = await createTestOrganizationEmployee(admin, organization, client.user, role, {})

            const [ticket] = await createTestTicket(admin, organization, property, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
                executor: { connect: { id: employee.user.id } },
                assignee: { connect: { id: employee.user.id } },
            })

            await updateTestOrganizationEmployee(admin, employee.id, { deletedAt: dayjs().toISOString() })

            const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(ticket.id).toEqual(updatedTicket.id)
            expect(updatedTicket.statusReopenedCounter).toEqual(1)
            expect(get(updatedTicket, ['executor', 'id'], null)).toBeNull()
            expect(get(updatedTicket, ['assignee', 'id'], null)).toBeNull()
        })

        test('non-dismissed employees are not being reset on updating ticket status from completed to open', async () => {
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const [role] = await createTestOrganizationEmployeeRole(admin, organization)

            const [employee] = await createTestOrganizationEmployee(admin, organization, client.user, role, {})

            const [ticket] = await createTestTicket(admin, organization, property, {
                status: { connect: { id: STATUS_IDS.COMPLETED } },
                executor: { connect: { id: employee.user.id } },
                assignee: { connect: { id: employee.user.id } },
            })

            const [updatedTicket] = await updateTestTicket(admin, ticket.id, {
                status: { connect: { id: STATUS_IDS.OPEN } },
            })

            expect(ticket.id).toEqual(updatedTicket.id)
            expect(updatedTicket.statusReopenedCounter).toEqual(1)
            expect(get(updatedTicket, ['executor', 'id'], null)).toEqual(get(ticket, ['executor', 'id'], null))
            expect(get(updatedTicket, ['assignee', 'id'], null)).toEqual(get(ticket, ['assignee', 'id'], null))
        })
    })

    describe('notifications', () => {
        describe('Assignee or executor was changed', () => {

            test('push message to assignee', async () => {
                const client = await makeClientWithProperty()
                const assignee = await makeClientWithNewRegisteredAndLoggedInUser()
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_MASTER_ID_ANDROID,
                }

                await syncRemoteClientWithPushTokenByTestClient(assignee, payload)

                const extraProps = { assignee: { connect: { id: assignee.user.id } } }
                const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

                expect(ticket.assignee.id).toEqual(assignee.user.id)

                const messageWhere = { user: { id: assignee.user.id }, type: TICKET_ASSIGNEE_CONNECTED_TYPE }
                const message = await Message.getOne(admin, messageWhere)

                expect(message.id).toMatch(UUID_RE)
                expect(message.organization.id).toEqual(ticket.organization.id)

                await waitFor(async () => {
                    const message1 = await Message.getOne(admin, messageWhere)

                    // Testing processingMeta old way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message1.processingMeta.transport).toEqual('push')
                    expect(message1.processingMeta.transports).toEqual(['push'])
                    expect(message1.processingMeta.transportsMeta[0]).toMatchObject({
                        transport: 'push',
                        status: 'sent',
                    })

                    const content = message1.processingMeta.messageContext

                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.userId).toEqual(assignee.user.id)
                    expect(content.data.notificationId).toEqual(message.id)

                    const transportMeta = message1.processingMeta.transportsMeta[0]
                    const content1 = transportMeta.messageContext

                    // Testing processingMeta ADR-7 way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content1.data.url).toBeDefined()
                    expect(content1.data.ticketId).toEqual(ticket.id)
                    expect(content1.data.ticketNumber).toEqual(ticket.number)
                    expect(content1.data.userId).toEqual(assignee.user.id)
                    expect(content1.data.notificationId).toEqual(message.id)

                })
            })

            test('push message to executor', async () => {
                const client = await makeClientWithProperty()
                const executor = await makeClientWithNewRegisteredAndLoggedInUser()
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_MASTER_ID_ANDROID,
                }

                await syncRemoteClientWithPushTokenByTestClient(executor, payload)

                const extraProps = { executor: { connect: { id: executor.user.id } } }
                const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

                expect(ticket.executor.id).toEqual(executor.user.id)

                const messageWhere = { user: { id: executor.user.id }, type: TICKET_EXECUTOR_CONNECTED_TYPE }
                const message = await Message.getOne(admin, messageWhere)

                expect(message.id).toMatch(UUID_RE)
                expect(message.organization.id).toEqual(ticket.organization.id)

                await waitFor(async () => {
                    const message1 = await Message.getOne(admin, messageWhere)

                    // Testing processingMeta old way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message1.processingMeta.transport).toEqual('push')

                    const content = message1.processingMeta.messageContext

                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.userId).toEqual(executor.user.id)
                    expect(content.data.notificationId).toEqual(message.id)

                    const transportMeta = message1.processingMeta.transportsMeta[0]
                    const content1 = transportMeta.messageContext

                    // Testing processingMeta ADR-7 way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content1.data.url).toBeDefined()
                    expect(content1.data.ticketId).toEqual(ticket.id)
                    expect(content1.data.ticketNumber).toEqual(ticket.number)
                    expect(content1.data.userId).toEqual(executor.user.id)
                    expect(content1.data.notificationId).toEqual(message.id)

                })
            })

            test('push two message if executor and assignee is the same user', async () => {
                const client = await makeClientWithProperty()
                const client2 = await makeClientWithNewRegisteredAndLoggedInUser()

                const extraProps = { assignee: { connect: { id: client2.user.id } }, executor: { connect: { id: client2.user.id } } }
                const [ticket] = await createTestTicket(client, client.organization, client.property, extraProps)

                expect(ticket.assignee.id).toEqual(client2.user.id)

                const messageWhere = { user: { id: client2.user.id }, type_in: [TICKET_EXECUTOR_CONNECTED_TYPE, TICKET_ASSIGNEE_CONNECTED_TYPE] }
                const message = await Message.getAll(admin, messageWhere)

                expect(message).toHaveLength(2)
                expect(message[0].organization.id).toEqual(ticket.organization.id)
                expect(message[1].organization.id).toEqual(ticket.organization.id)
            })
        })

        describe('Ticket status changed to TICKET_STATUS_IN_PROGRESS', () => {
            it('send push to resident if created Ticket with status == TICKET_STATUS_IN_PROGRESS', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_RESIDENT_ID_ANDROID,
                }

                await syncRemoteClientWithPushTokenByTestClient(userClient, payload)

                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
                const [resident] = await createTestResident(admin, userClient.user, userClient.property, { unitName })
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client.id).toEqual(userClient.user.id)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.IN_PROGRESS } } })

                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)
                    const transportMeta = message.processingMeta.transportsMeta[0]
                    const content = transportMeta.messageContext

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)

                    // Testing processingMeta old way structure
                    expect(message.meta.data.userId).toEqual(userClient.user.id)
                    expect(message.meta.data.residentId).toEqual(resident.id)
                    expect(message.meta.data.ticketId).toEqual(ticket.id)
                    expect(message.meta.data.ticketNumber).toEqual(ticket.number)
                    expect(message.processingMeta.transport).toEqual('push')
                    expect(message.processingMeta.transports).toEqual(['push'])

                    // Testing processingMeta ADR-7 way structure
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.residentId).toEqual(resident.id)
                    expect(content.data.userId).toEqual(userClient.user.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.notificationId).toEqual(message.id)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })
            })

            it('does not send push if there is no resident', async () => {
                const userClient = await makeClientWithProperty()
                const unitName = faker.random.alphaNumeric(5)
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client).toEqual(null)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.IN_PROGRESS } } })

                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
                const messageCount = await Message.count(admin, messageWhere)

                expect(messageCount).toEqual(0)
            })

            it('does not send push if Ticket.canReadByResident == false', async () => {
                const residentClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, residentClient.property, {
                    unitName,
                    unitType,
                })
                const [contact] = await createTestContact(admin, residentClient.organization, residentClient.property, {
                    phone,
                    unitName,
                })
                const [ticket] = await createTestTicket(admin, residentClient.organization, residentClient.property, {
                    unitName,
                    unitType,
                    contact: { connect: { id: contact.id } },
                    canReadByResident: false,
                })

                const readTicket = await Ticket.getOne(admin, { id: ticket.id })

                expect(readTicket.client.id).toEqual(residentClient.user.id)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.IN_PROGRESS } } })

                const messageWhere = { user: { id: residentClient.user.id }, type: TICKET_STATUS_IN_PROGRESS_TYPE }
                const messageCount = await Message.count(admin, messageWhere)

                expect(messageCount).toEqual(0)
            })
        })

        describe('Ticket status changed to TICKET_STATUS_COMPLETED', () => {
            it('send push to resident', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_RESIDENT_ID_ANDROID,
                }
                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_COMPLETED_TYPE }

                await syncRemoteClientWithPushTokenByTestClient(userClient, payload)

                const [resident] = await createTestResident(admin, userClient.user, userClient.property, { unitName })
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client.id).toEqual(userClient.user.id)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.COMPLETED } } })

                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)
                    const transportMeta = message.processingMeta.transportsMeta[0]
                    const content = transportMeta.messageContext

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)

                    // Testing processingMeta old way structure
                    expect(message.meta.data.userId).toEqual(userClient.user.id)
                    expect(message.meta.data.residentId).toEqual(resident.id)
                    expect(message.meta.data.ticketId).toEqual(ticket.id)
                    expect(message.meta.data.ticketNumber).toEqual(ticket.number)
                    expect(message.processingMeta.transport).toEqual('push')
                    expect(message.processingMeta.transports).toEqual(['push'])

                    // Testing processingMeta ADR-7 way structure
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.residentId).toEqual(resident.id)
                    expect(content.data.userId).toEqual(userClient.user.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.notificationId).toEqual(message.id)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })
            })

            it('does not send if no resident', async () => {
                const userClient = await makeClientWithProperty()
                const unitName = faker.random.alphaNumeric(5)
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client).toEqual(null)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.COMPLETED } } })

                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_COMPLETED_TYPE }
                const messageCount = await Message.count(admin, messageWhere)

                expect(messageCount).toEqual(0)
            })
        })

        describe('Ticket status changed to TICKET_STATUS_RETURNED', () => {
            it('send push to resident', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_RESIDENT_ID_ANDROID,
                }
                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_RETURNED_TYPE }

                await syncRemoteClientWithPushTokenByTestClient(userClient, payload)

                const [resident] = await createTestResident(admin, userClient.user, userClient.property, { unitName })
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(ticket.client.id).toEqual(userClient.user.id)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })

                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)
                    const transportMeta = message.processingMeta.transportsMeta[0]
                    const content = transportMeta.messageContext

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)

                    // Testing processingMeta old way structure
                    expect(message.meta.data.userId).toEqual(userClient.user.id)
                    expect(message.meta.data.residentId).toEqual(resident.id)
                    expect(message.meta.data.ticketId).toEqual(ticket.id)
                    expect(message.meta.data.ticketNumber).toEqual(ticket.number)
                    expect(message.processingMeta.transport).toEqual('push')
                    expect(message.processingMeta.transports).toEqual(['push'])

                    // Testing processingMeta ADR-7 way structure
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.residentId).toEqual(resident.id)
                    expect(content.data.userId).toEqual(userClient.user.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.notificationId).toEqual(message.id)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })
            })

            it('does not send if no resident', async () => {
                const userClient = await makeClientWithProperty()
                const unitName = faker.random.alphaNumeric(5)

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                    status: { connect: { id: STATUS_IDS.COMPLETED } },
                })

                expect(ticket.client).toEqual(null)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.OPEN } } })

                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_RETURNED_TYPE }
                const messageCount = await Message.count(admin, messageWhere)

                expect(messageCount).toEqual(0)
            })
        })

        describe('Ticket status changed to TICKET_STATUS_DECLINED', () => {
            it('send push to resident', async () => {
                const userClient = await makeClientWithResidentAccessAndProperty()
                const unitName = faker.random.alphaNumeric(5)
                const payload = {
                    devicePlatform: DEVICE_PLATFORM_ANDROID,
                    appId: APP_RESIDENT_ID_ANDROID,
                }
                const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_DECLINED_TYPE }

                await syncRemoteClientWithPushTokenByTestClient(userClient, payload)

                const [resident] = await createTestResident(admin, userClient.user, userClient.property, { unitName })
                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, { unitName })

                expect(ticket.client.id).toEqual(userClient.user.id)

                await updateTestTicket(admin, ticket.id, { status: { connect: { id: STATUS_IDS.DECLINED } } })

                await waitFor(async () => {
                    const message = await Message.getOne(admin, messageWhere)
                    const transportMeta = message.processingMeta.transportsMeta[0]
                    const content = transportMeta.messageContext

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)

                    // Testing processingMeta old way structure
                    expect(message.meta.data.userId).toEqual(userClient.user.id)
                    expect(message.meta.data.residentId).toEqual(resident.id)
                    expect(message.meta.data.ticketId).toEqual(ticket.id)
                    expect(message.meta.data.ticketNumber).toEqual(ticket.number)
                    expect(message.processingMeta.transport).toEqual('push')
                    expect(message.processingMeta.transports).toEqual(['push'])

                    // Testing processingMeta ADR-7 way structure
                    expect(transportMeta.transport).toEqual(PUSH_TRANSPORT)
                    expect(transportMeta.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(content.data.url).toBeDefined()
                    expect(content.data.ticketId).toEqual(ticket.id)
                    expect(content.data.residentId).toEqual(resident.id)
                    expect(content.data.userId).toEqual(userClient.user.id)
                    expect(content.data.ticketNumber).toEqual(ticket.number)
                    expect(content.data.notificationId).toEqual(message.id)
                    expect(message.organization.id).toEqual(ticket.organization.id)
                })
            })

            it('does not send if no resident', async () => {
                const userClient = await makeClientWithProperty()
                const unitName = faker.random.alphaNumeric(5)

                const [ticket] = await createTestTicket(userClient, userClient.organization, userClient.property, {
                    unitName,
                })

                expect(ticket.client).toEqual(null)

                await updateTestTicket(admin, ticket.id, {
                    status: { connect: { id: STATUS_IDS.DECLINED } },
                })

                await waitFor(async () => {
                    const messageWhere = { user: { id: userClient.user.id }, type: TICKET_STATUS_DECLINED_TYPE }
                    const messageCount = await Message.count(admin, messageWhere)
                    expect(messageCount).toEqual(0)
                })
            })
        })

        describe('Ticket created', () => {
            beforeAll(async () => {
                const supportClient = await makeClientWithSupportUser()
                const allOrganizationsBlackList = await MessageOrganizationBlackList.getAll(supportClient, {
                    organization_is_null: true,
                })

                for (const blackListRule of allOrganizationsBlackList) {
                    await updateTestMessageOrganizationBlackList(supportClient, blackListRule.id, {
                        deletedAt: 'true',
                    })
                }
            })

            test('send sms after create ticket with isResidentTicket is true and without resident matches contact data', async () => {
                const client = await makeClientWithProperty()
                const clientName = faker.name.firstName()
                const clientPhone = createTestPhone()
                const today = dayjs().format('YYYY-MM-DD')

                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    isResidentTicket: true,
                    canReadByResident: true,
                    clientName,
                    clientPhone,
                })

                expect(ticket.client).toBeNull()

                const messageWhere = {
                    phone: clientPhone,
                    type: TRACK_TICKET_IN_DOMA_APP_TYPE,
                    uniqKey: `${today}_${md5(clientPhone)}`,
                }
                const message = await Message.getOne(admin, messageWhere)

                expect(message).toBeDefined()
                expect(message.id).toMatch(UUID_RE)

                await waitFor(async () => {
                    const message1 = await Message.getOne(admin, messageWhere)

                    // Testing processingMeta old way structure
                    expect(message1.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message1.processingMeta.transport).toEqual('sms')

                    const content = message1.processingMeta.messageContext

                    expect(content.phone).toEqual(clientPhone)
                    expect(content.message).toBeDefined()

                    // Testing processingMeta ADR-7 way structure
                    const transportMeta = message1.processingMeta.transportsMeta[0]

                    expect(transportMeta.transport).toEqual(SMS_TRANSPORT)

                    const content1 = transportMeta.messageContext

                    expect(content1.phone).toEqual(clientPhone)
                    expect(content1.message).toBeDefined()
                })
            })

            test('dont send sms 2 times a day to same number', async () => {
                const admin = await makeLoggedInAdminClient()
                const client = await makeClientWithProperty()

                const clientName = faker.name.firstName()
                const clientPhone = createTestPhone()
                const today = dayjs().format('YYYY-MM-DD')

                const [ticket] = await createTestTicket(client, client.organization, client.property, {
                    isResidentTicket: true,
                    canReadByResident: true,
                    clientName,
                    clientPhone,
                })

                expect(ticket.client).toBeNull()

                const messageWhere = {
                    phone: clientPhone,
                    type: TRACK_TICKET_IN_DOMA_APP_TYPE,
                }
                const message = await Message.getOne(admin, messageWhere)

                expect(message.id).toMatch(UUID_RE)
                expect(message.uniqKey).toEqual(`${today}_${md5(clientPhone)}`)

                await createTestTicket(client, client.organization, client.property, {
                    isResidentTicket: true,
                    canReadByResident: true,
                    clientName,
                    clientPhone,
                })

                const messages = await Message.getAll(admin, messageWhere)

                expect(messages).toHaveLength(1)
            })

            test('dont send sms if ticket.isResidentTicket is false', async () => {
                const client = await makeClientWithProperty()

                const clientName = faker.name.firstName()
                const clientPhone = createTestPhone()

                await createTestTicket(client, client.organization, client.property, {
                    isResidentTicket: false,
                    clientName,
                    clientPhone,
                })

                const messageWhere = { phone: clientPhone, type: TRACK_TICKET_IN_DOMA_APP_TYPE }
                const message = await Message.getOne(admin, messageWhere)

                expect(message).toBeUndefined()
            })

            test('dont send sms if resident matches ticket contact data', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone, name } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })

                await createTestTicket(admin, organization, property, {
                    isResidentTicket: true,
                    canReadByResident: true,
                    clientName: name,
                    clientPhone: phone,
                    unitName,
                    unitType,
                })

                const messageWhere = { phone, type: TRACK_TICKET_IN_DOMA_APP_TYPE }
                const message = await Message.getOne(admin, messageWhere)

                expect(message).toBeUndefined()
            })

            test('dont send sms if resident user create ticket', async () => {
                const residentClient = await makeClientWithResidentUser()

                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(5)
                const unitType = FLAT_UNIT_TYPE
                const { phone } = residentClient.userAttrs

                await createTestResident(admin, residentClient.user, property, {
                    unitName,
                    unitType,
                })

                await createTestTicket(residentClient, organization, property, {
                    unitName,
                    unitType,
                })

                const messageWhere = { phone, type: TRACK_TICKET_IN_DOMA_APP_TYPE }
                const message = await Message.getOne(admin, messageWhere)

                expect(message).toBeUndefined()
            })
        })
    })
})
