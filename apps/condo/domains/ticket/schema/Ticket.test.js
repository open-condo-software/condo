/**
 * Generated by `createschema ticket.Ticket organization:Text; statusReopenedCounter:Integer; statusReason?:Text; status:Relationship:TicketStatus:PROTECT; number?:Integer; client?:Relationship:User:SET_NULL; clientName:Text; clientEmail:Text; clientPhone:Text; operator:Relationship:User:SET_NULL; assignee?:Relationship:User:SET_NULL; classifier:Relationship:TicketClassifier:PROTECT; details:Text; meta?:Json;`
 */
const { makeClientWithProperty } = require('../../../schema/Property/Property.test')
const { NUMBER_RE, UUID_RE, DATETIME_RE, makeClient } = require('@core/keystone/test.utils')

const { createTestTicket, updateTestTicket, Ticket } = require('@condo/domains/ticket/utils/testSchema')

describe('Ticket', () => {
    test('user: create Ticket', async () => {
        const client = await makeClientWithProperty()
        const [ticket, attrs] = await createTestTicket(client, client.organization, client.property)
        expect(ticket.id).toMatch(UUID_RE)
        expect(String(ticket.number)).toMatch(NUMBER_RE)
        expect(ticket.dv).toEqual(1)
        expect(ticket.sender).toEqual(attrs.sender)
        expect(ticket.source).toEqual(expect.objectContaining({ id: attrs.source.connect.id }))
        expect(ticket.sourceMeta).toEqual(null)
        expect(ticket.classifier).toEqual(expect.objectContaining({ id: attrs.classifier.connect.id }))
        expect(ticket.property).toEqual(expect.objectContaining({ id: client.property.id }))
        expect(ticket.status).toEqual(expect.objectContaining({ id: attrs.status.connect.id }))
        expect(ticket.statusReopenedCounter).toEqual(0)
        expect(ticket.statusReason).toEqual(null)
        expect(ticket.statusUpdatedAt).toBeNull()
        expect(ticket.details).toEqual(attrs.details)
        expect(ticket.meta).toEqual(null)
        expect(ticket.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
        expect(ticket.client).toEqual(null)
        expect(ticket.operator).toEqual(null)
        expect(ticket.assignee).toEqual(null)
        expect(ticket.isPaid).toEqual(false)
        expect(ticket.isEmergency).toEqual(false)
        expect(ticket.executor).toEqual(null)
        expect(ticket.watchers).toEqual([])
        expect(ticket.v).toEqual(1)
        expect(ticket.newId).toEqual(null)
        expect(ticket.deletedAt).toEqual(null)
        expect(ticket.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
        expect(ticket.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
        expect(ticket.createdAt).toMatch(DATETIME_RE)
        expect(ticket.updatedAt).toMatch(DATETIME_RE)
    })

    test('anonymous: create Ticket', async () => {
        const client1 = await makeClientWithProperty()
        const client = await makeClient()
        try {
            await createTestTicket(client, client1.organization, client1.property)
        } catch (e) {
            expect(e.errors[0]).toMatchObject({
                'message': 'You do not have access to this resource',
                'name': 'AccessDeniedError',
                'path': ['obj'],
            })
            expect(e.data).toEqual({ 'obj': null })
        }
    })

    test.skip('user: read Ticket', async () => {
        const client = await makeClientWithProperty()
        const [obj] = await createTestTicket(client, client.organization, client.property)
        const objs = await Ticket.getAll(client)
        expect(objs).toHaveLength(1)
        expect(objs).toEqual([expect.objectContaining({ id: obj.id })])
    })

    test('anonymous: read Ticket', async () => {
        const client = await makeClient()

        try {
            await Ticket.getAll(client)
        } catch (e) {
            expect(e.errors[0]).toMatchObject({
                'message': 'You do not have access to this resource',
                'name': 'AccessDeniedError',
                'path': ['objs'],
            })
            expect(e.data).toEqual({ 'objs': null })
        }
    })

    test.skip('user: update Ticket', async () => {
        const client = await makeClientWithProperty()
        const payload = { details: 'new data' }
        const [objCreated] = await createTestTicket(client, client.organization, client.property)
        const [objUpdated] = await updateTestTicket(client, objCreated.id, payload)
        expect(objUpdated).toEqual(expect.objectContaining({
            id: objCreated.id,
            details: payload.details,
            // TODO(pahaz): should correctly update ticket without ticket number increment!
            number: objCreated.number,
            v: 2,
        }))
    })

    test('anonymous: update Ticket', async () => {
        const client1 = await makeClientWithProperty()
        const client = await makeClient()
        const payload = { details: 'new data' }
        const [objCreated] = await createTestTicket(client1, client1.organization, client1.property)
        try {
            await updateTestTicket(client, objCreated.id, payload)
        } catch (e) {
            expect(e.errors[0]).toMatchObject({
                'message': 'You do not have access to this resource',
                'name': 'AccessDeniedError',
                'path': ['obj'],
            })
            expect(e.data).toEqual({ 'obj': null })
        }
    })

    test('user: delete Ticket', async () => {
        const client = await makeClientWithProperty()
        const [objCreated] = await createTestTicket(client, client.organization, client.property)
        try {
            await Ticket.delete(client, objCreated.id)
        } catch (e) {
            expect(e.errors[0]).toMatchObject({
                'message': 'You do not have access to this resource',
                'name': 'AccessDeniedError',
                'path': ['obj'],
            })
            expect(e.data).toEqual({ 'obj': null })
        }
    })

    test('anonymous: delete Ticket', async () => {
        const client1 = await makeClientWithProperty()
        const client = await makeClient()
        const [objCreated] = await createTestTicket(client1, client1.organization, client1.property)
        try {
            await Ticket.delete(client, objCreated.id)
        } catch (e) {
            expect(e.errors[0]).toMatchObject({
                'message': 'You do not have access to this resource',
                'name': 'AccessDeniedError',
                'path': ['obj'],
            })
            expect(e.data).toEqual({ 'obj': null })
        }
    })
})

//
// test('should correctly update ticket status without ticket number increment', async () => {
//     const client = await makeClientWithProperty()
//     const [ticket] = await createTicket(client, client.organization, client.property)
//     const prevTicketNmber = ticket.number
//     const obj = await updateTicket(client, ticket, { status: { connect: { id: 'f0fa0093-8d86-4e69-ae1a-70a2914da82f' } } })
//
//     expect(obj.number).toEqual(prevTicketNmber)
// })
