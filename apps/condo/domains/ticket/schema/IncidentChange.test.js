/**
 * Generated by `createschema ticket.IncidentChange 'incident:Relationship:Incident:CASCADE;'`
 */
const { faker } = require('@faker-js/faker')

const { makeLoggedInAdminClient, makeClient, catchErrorFrom } = require('@open-condo/keystone/test.utils')
const { expectToThrowAuthenticationErrorToObjects, expectToThrowAccessDeniedErrorToObj } = require('@open-condo/keystone/test.utils')

const { createTestOrganization, createTestOrganizationEmployeeRole, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { INCIDENT_CHANGE_DATA_FIELDS } = require('@condo/domains/ticket/gql')
const { IncidentChange, createTestIncidentChange, updateTestIncidentChange, updateTestIncident, createTestIncident } = require('@condo/domains/ticket/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')


const expectToThrowAccessDeniedErrorToDeleteObj = async (testFunction) => {
    await catchErrorFrom(async () => {
        await testFunction()
    }, ({ errors }) => {
        // Custom match should be used here, because error message contains
        // suggestions, like "Did you mean â€¦", that cannot be known in advance
        // So, just inspect basic part of the message
        expect(errors[0].message).toMatch('Cannot query field "deleteIncidentChange" on type "Mutation"')
    })
}

const INCIDENT_PAYLOAD = {
    details: faker.lorem.sentence(),
    workStart: faker.date.recent().toISOString(),
}

const UPDATED_INCIDENT_PAYLOAD = {
    details: faker.lorem.sentence() + faker.lorem.sentence(),
}

describe('IncidentChange', () => {
    let admin, support, employeeUser, notEmployeeUser, anonymous, organization, incidentByAdmin

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        employeeUser = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()

        const [testOrganization] = await createTestOrganization(admin)
        organization = testOrganization

        const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageIncidents: true,
        })

        await createTestOrganizationEmployee(admin, organization, employeeUser.user, role)

        notEmployeeUser = await makeClientWithNewRegisteredAndLoggedInUser()
        const [secondTestOrganization] = await createTestOrganization(admin)
        const [secondRole] = await createTestOrganizationEmployeeRole(admin, secondTestOrganization)
        await createTestOrganizationEmployee(admin, secondTestOrganization, notEmployeeUser.user, secondRole)

        const [testIncident] = await createTestIncident(admin, organization, INCIDENT_PAYLOAD)
        incidentByAdmin = testIncident
        await updateTestIncident(admin, testIncident.id, UPDATED_INCIDENT_PAYLOAD)
    })
    afterAll( () => {
        if (global.gc) {
            global.gc()
        }
    })
    describe('Accesses', () => {
        describe('Admin', () => {
            test('Can not create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestIncidentChange(admin, incidentByAdmin)
                })
            })
            test('Can read', async () => {
                const incidentChange = await IncidentChange.getAll(admin, { incident: { id: incidentByAdmin.id } })
                expect(incidentChange).toHaveLength(1)
                expect(incidentChange[0]).toHaveProperty('incident.id', incidentByAdmin.id)
            })
            test('Can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestIncidentChange(admin, incidentByAdmin.id)
                })
            })
            test('Can not delete', async () => {
                await expectToThrowAccessDeniedErrorToDeleteObj(async () => {
                    await IncidentChange.delete(admin, incidentByAdmin.id)
                })
            })
        })

        describe('Support', () => {
            test('Can not create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestIncidentChange(support, incidentByAdmin)
                })
            })
            test('Can read', async () => {
                const incidentChange = await IncidentChange.getAll(support, { incident: { id: incidentByAdmin.id } })
                expect(incidentChange).toHaveLength(1)
                expect(incidentChange[0]).toHaveProperty('incident.id', incidentByAdmin.id)
            })
            test('Can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestIncidentChange(support, incidentByAdmin.id)
                })
            })
            test('Can not delete', async () => {
                await expectToThrowAccessDeniedErrorToDeleteObj(async () => {
                    await IncidentChange.delete(support, incidentByAdmin.id)
                })
            })
        })

        describe('Employee', () => {
            test('Can not create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestIncidentChange(employeeUser, incidentByAdmin)
                })
            })
            test('Can read', async () => {
                const incidentChange = await IncidentChange.getAll(employeeUser, { incident: { id: incidentByAdmin.id } })
                expect(incidentChange).toHaveLength(1)
                expect(incidentChange[0]).toHaveProperty('incident.id', incidentByAdmin.id)
            })
            test('Can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestIncidentChange(employeeUser, incidentByAdmin.id)
                })
            })
            test('Can not delete', async () => {
                await expectToThrowAccessDeniedErrorToDeleteObj(async () => {
                    await IncidentChange.delete(employeeUser, incidentByAdmin.id)
                })
            })
        })

        describe('Not employee', () => {
            test('Can not create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestIncidentChange(notEmployeeUser, incidentByAdmin)
                })
            })
            test('Can not read', async () => {
                const incidentChange = await IncidentChange.getAll(notEmployeeUser, { incident: { id: incidentByAdmin.id } })
                expect(incidentChange).toHaveLength(0)
            })
            test('Can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestIncidentChange(notEmployeeUser, incidentByAdmin.id)
                })
            })
            test('Can not delete', async () => {
                await expectToThrowAccessDeniedErrorToDeleteObj(async () => {
                    await IncidentChange.delete(notEmployeeUser, incidentByAdmin.id)
                })
            })
        })

        describe('Anonymous', () => {
            test('Can not create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestIncidentChange(anonymous, incidentByAdmin)
                })
            })
            test('Can not read', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await IncidentChange.getOne(anonymous, { incident: { id: incidentByAdmin.id } })
                })
            })
            test('Can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestIncidentChange(anonymous, incidentByAdmin.id)
                })
            })
            test('Can not delete', async () => {
                await expectToThrowAccessDeniedErrorToDeleteObj(async () => {
                    await IncidentChange.delete(anonymous, incidentByAdmin.id)
                })
            })
        })
    })

    describe('Logic', () => {
        describe('Creation', () => {
            let incident
            let incidentChanges
            beforeAll(async () => {
                const [testIncident] = await createTestIncident(employeeUser, organization, INCIDENT_PAYLOAD)
                incident = testIncident

                await updateTestIncident(employeeUser, testIncident.id, UPDATED_INCIDENT_PAYLOAD)
                incidentChanges = await IncidentChange.getAll(employeeUser, { incident: { id: testIncident.id } })
            })
            test('Must be created after incident updating', async () => {
                expect(incidentChanges).toHaveLength(1)
                expect(incidentChanges[0]).toHaveProperty('incident.id', incident.id)
            })

            describe('Must be have all tracked fields', () => {
                test.each(INCIDENT_CHANGE_DATA_FIELDS)('Must be have field %p', (fieldName) => {
                    expect(incidentChanges).toHaveLength(1)
                    expect(incidentChanges[0]).toHaveProperty(fieldName)
                })
            })
        })
    })
})
