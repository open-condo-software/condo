/**
 * Generated by `createservice ticket.TicketAnalyticsReportService`
 */

const { GQLCustomSchema, getByCondition } = require('@core/keystone/schema')
const access = require('@condo/domains/ticket/access/TicketAnalyticsReportService')

const dayjs = require('dayjs')

const {
    sortStatusesByType,
    aggregateData,
    TicketGqlToKnexAdapter,
    getCombinations,
    enumerateDaysBetweenDates,
} = require('@condo/domains/ticket/utils/serverSchema/analytics.helper')
const { DATE_DISPLAY_FORMAT } = require('@condo/domains/ticket/constants/common')
const { TicketStatus: TicketStatusServerUtils, Ticket } = require('@condo/domains/ticket/utils/serverSchema')
const isEmpty = require('lodash/isEmpty')
const get = require('lodash/get')
const sum = require('lodash/sum')
const { createExportFile } = require('@condo/domains/common/utils/createExportFile')
const propertySummaryDataMapper = require('@condo/domains/ticket/utils/serverSchema/propertySummaryDataMapper')
const propertySingleDataMapper = require('@condo/domains/ticket/utils/serverSchema/propertySingleDataMapper')
const dayGroupDataMapper = require('@condo/domains/ticket/utils/serverSchema/dayGroupDataMapper')
const { GqlWithKnexLoadList } = require('@condo/domains/common/utils/serverSchema')
const propertyPercentDataMapper = require('@condo/domains/ticket/utils/serverSchema/propertyPercentDataMapper')
const propertySummaryPercentDataMapper = require('@condo/domains/ticket/utils/serverSchema/propertySummaryPercentDataMapper')
const categoryClassifierSingleDataMapper = require('@condo/domains/ticket/utils/serverSchema/categoryClassifierSingleDataMapper')
const categoryClassifierSummaryDataMapper = require('@condo/domains/ticket/utils/serverSchema/categoryClassifierSummaryDataMapper')
const categoryClassifierPercentSingleDataMapper = require('@condo/domains/ticket/utils/serverSchema/categoryClassifierPercentSingleDataMapper')
const categoryClassifierPercentSummaryDataMapper = require('@condo/domains/ticket/utils/serverSchema/categoryClassifierPercentSummaryDataMapper')
const executorSingleDataMapper = require('@condo/domains/ticket/utils/serverSchema/executorSingleDataMapper')
const executorSummaryDataMapper = require('@condo/domains/ticket/utils/serverSchema/executorSummaryDataMapper')
const executorPercentSingleDataMapper = require('@condo/domains/ticket/utils/serverSchema/executorPercentSingleDataMapper')
const executorPercentSummaryDataMapper = require('@condo/domains/ticket/utils/serverSchema/executorPercentSummaryDataMapper')
const assigneeSingleDataMapper = require('@condo/domains/ticket/utils/serverSchema/assigneeSingleDataMapper')
const assigneeSummaryDataMapper = require('@condo/domains/ticket/utils/serverSchema/assigneeSummaryDataMapper')
const assigneePercentSingleDataMapper = require('@condo/domains/ticket/utils/serverSchema/assigneePercentSingleDataMapper')
const assigneePercentSummaryDataMapper = require('@condo/domains/ticket/utils/serverSchema/assigneePercentSummaryDataMapper')

const NULLABLE_GROUP_KEYS = ['categoryClassifier', 'executor', 'assignee']

const createPropertyRange = async (organizationWhereInput, whereIn) => {
    const gqlLoaderOptions = {
        listKey: 'Property',
        fields: 'id address',
        where: { organization: organizationWhereInput, deletedAt: null },
    }
    const propertyFilter = get(whereIn, 'property', false)
    if (propertyFilter) {
        gqlLoaderOptions['where']['id_in'] = propertyFilter.flatMap(id => id)
    }
    const propertyLoader = new GqlWithKnexLoadList(gqlLoaderOptions)
    const properties = await propertyLoader.load()
    return properties.map( property => ({ label: property.address, value: property.id }))
}

const createStatusRange = async (context, organizationWhereInput, labelKey = 'name') => {
    const statuses = await TicketStatusServerUtils.getAll(context, { OR: [
        { organization: organizationWhereInput },
        { organization_is_null: true },
    ] })
    // We use organization specific statuses if they exists
    // or default if there is no organization specific status with a same type
    const allStatuses = statuses.filter(status => {
        if (!status.organization) {
            return true
        }
        return !statuses
            .find(organizationStatus => organizationStatus.organization !== null && organizationStatus.type === status.type)
    })
    return sortStatusesByType(allStatuses).map(status => ({ label: status[labelKey], value: status.id, color: status.colors.primary }))
}

const createCategoryClassifierRange = async (organizationWhereInput, whereIn) => {
    const gqlLoaderOptions = {
        listKey: 'TicketCategoryClassifier',
        fields: 'id name organization',
    }
    const categoryClassifierFilter = get(whereIn, 'categoryClassifier', false)
    if (categoryClassifierFilter) {
        gqlLoaderOptions['where'] = {
            id_in: categoryClassifierFilter.flatMap(id => id),
        }
    }
    const categoryClassifierLoader = new GqlWithKnexLoadList(gqlLoaderOptions)
    const classifiers = await categoryClassifierLoader.load()
    return classifiers.map(classifier => ({ label: classifier.name, value: classifier.id }))
}

const createExecutorRange = async (organizationWhereInput, whereIn) => {
    const gqlLoaderOptions = {
        listKey: 'OrganizationEmployee',
        fields: 'id name',
        singleRelations: [['User', 'user', 'id']],
        where: { organization: organizationWhereInput, role: { canBeAssignedAsExecutor: true } },
    }
    const executorFilter = get(whereIn, 'executor', false)
    const executorLoader = new GqlWithKnexLoadList(gqlLoaderOptions)
    const executors = await executorLoader.load()
    const executorLambda = (executor) => ({ label: executor.name, value: executor.user })

    if (executorFilter) {
        const executorIds = executorFilter.flatMap(id => id)
        return executors.filter(executor => executorIds.includes(executor.user)).map(executorLambda)
    }
    return executors.map(executorLambda)
}

const createAssigneeRange = async (organizationWhereInput, whereIn) => {
    const gqlLoaderOptions = {
        listKey: 'OrganizationEmployee',
        fields: 'id name',
        singleRelations: [['User', 'user', 'id']],
        where: { organization: organizationWhereInput, role: { canBeAssignedAsResponsible: true } },
    }
    const assigneeFilter = get(whereIn, 'assignee', false)
    const assigneeLoader = new GqlWithKnexLoadList(gqlLoaderOptions)
    const assignees = await assigneeLoader.load()
    const assigneeLambda = (assignee) => ({ label: assignee.name, value: assignee.user })

    if (assigneeFilter) {
        const assigneeIds = assigneeFilter.flatMap(id => id)
        return assignees.filter(assignee => assigneeIds.includes(assignee.user)).map(assigneeLambda)
    }
    return assignees.map(assigneeLambda)
}

const getTicketCounts = async ({ context, where, groupBy, extraLabels = {}, nullReplaces = {} }) => {
    const ticketGqlToKnexAdapter = new TicketGqlToKnexAdapter(where, groupBy)
    await ticketGqlToKnexAdapter.loadData()

    const translates = {}
    const options = {
        count: [0],
        property: [null],
        categoryClassifier: [null],
        executor: [null],
        assignee: [null],
        dayGroup: [dayjs().format('DD.MM.YYYY')],
    }

    for (const group of groupBy) {
        switch (group) {
            case 'property':
                translates[group] = await createPropertyRange(where.organization, ticketGqlToKnexAdapter.whereIn)
                options[group] = translates[group].map(({ label }) => label)
                break
            case 'status':
                translates[group] = await createStatusRange(
                    context, where.organization, isEmpty(extraLabels) ? 'name' :  extraLabels[group]
                )
                options[group] = translates[group].map(({ label }) => label)
                break
            case 'day':
            case 'week':
                options['dayGroup'] = enumerateDaysBetweenDates(
                    ticketGqlToKnexAdapter.dateRange.from, ticketGqlToKnexAdapter.dateRange.to, group
                )
                break
            case 'categoryClassifier':
                translates[group] = await createCategoryClassifierRange(
                    where.organization,  ticketGqlToKnexAdapter.whereIn
                )
                options[group] = translates[group].map(({ label }) => label)
                break
            case 'executor':
                translates[group] = await createExecutorRange(where.organization, ticketGqlToKnexAdapter.whereIn)
                options[group] = translates[group].map(({ label }) => label)
                break
            case 'assignee':
                translates[group] = await createAssigneeRange(where.organization, ticketGqlToKnexAdapter.whereIn)
                options[group] = translates[group].map(({ label }) => label)
                break
            default:
                break
        }
    }
    const ticketGqlResult = ticketGqlToKnexAdapter
        .getResult(({ count, dayGroup, ...searchResult }) =>
        {
            if (!isEmpty(translates)) {
                Object.entries(searchResult).forEach(([groupName, value]) => {
                    const translateMapping = get(translates, groupName, false)
                    if (translateMapping) {
                        const translation = translateMapping.find(translate => translate.value === value)
                        searchResult[groupName] = get(translation, 'label', null)
                    }
                })
                return {
                    ...searchResult,
                    dayGroup: dayjs(dayGroup).format(DATE_DISPLAY_FORMAT),
                    count: parseInt(count),
                }
            }
            return {
                ...searchResult,
                dayGroup: dayjs(dayGroup).format(DATE_DISPLAY_FORMAT),
                count: parseInt(count),
            }
        })
        // This is hack to process old database records with tickets with user organization and property from another org
        .filter(ticketCount => ticketCount.property !== null)
    const fullCombinationsResult = getCombinations({ options })

    const ticketMap = new Map()
    const transformedGroupBy = groupBy.map(group => ['day', 'week'].includes(group) ? 'dayGroup' : group)
    fullCombinationsResult.concat(ticketGqlResult).forEach(ticketCount => {
        const [mainGroup, childGroup] = transformedGroupBy
        const mapKey = (ticketCount[mainGroup] + ticketCount[childGroup]).toString()
        ticketMap.set(mapKey, ticketCount)
    })

    const ticketCounts = Array.from(ticketMap.values())
        .map(ticketCount => {
            if (groupBy.some(group => NULLABLE_GROUP_KEYS.includes(group))) {
                const categoryClassifier = ticketCount.categoryClassifier !== null
                    ? ticketCount.categoryClassifier
                    : get(nullReplaces, 'categoryClassifier')
                const executor = ticketCount.executor !== null ? ticketCount.executor : get(nullReplaces, 'executor')
                const assignee = ticketCount.assignee !== null ? ticketCount.assignee : get(nullReplaces, 'assignee')
                return {
                    ...ticketCount,
                    categoryClassifier,
                    executor,
                    assignee,
                }
            }
            return ticketCount
        })
        .sort((a, b) =>
            dayjs(a.dayGroup, DATE_DISPLAY_FORMAT).unix() - dayjs(b.dayGroup, DATE_DISPLAY_FORMAT).unix()
        )
    return { ticketCounts, translates }
}

const getXLSXDataMapper = (groupByToken, isSummary = false) => {
    let dataMapper = null
    switch (groupByToken) {
        case 'status-day':
        case 'status-week':
            dataMapper = dayGroupDataMapper
            break
        case 'status-property':
            dataMapper = isSummary ? propertySummaryDataMapper : propertySingleDataMapper
            break
        case 'property-status':
            dataMapper = isSummary ? propertySummaryPercentDataMapper : propertyPercentDataMapper
            break
        case 'status-categoryClassifier':
            dataMapper = isSummary ? categoryClassifierSummaryDataMapper : categoryClassifierSingleDataMapper
            break
        case 'categoryClassifier-status':
            dataMapper = isSummary ? categoryClassifierPercentSummaryDataMapper : categoryClassifierPercentSingleDataMapper
            break
        case 'status-executor':
            dataMapper = isSummary ? executorSummaryDataMapper : executorSingleDataMapper
            break
        case 'executor-status':
            dataMapper = isSummary ? executorPercentSummaryDataMapper : executorPercentSingleDataMapper
            break
        case 'status-assignee':
            dataMapper = isSummary ? assigneeSummaryDataMapper : assigneeSingleDataMapper
            break
        case 'assignee-status':
            dataMapper = isSummary ? assigneePercentSummaryDataMapper : assigneePercentSingleDataMapper
            break
        default:
            throw new Error('Unknown groupBy token ' + groupByToken)
    }
    return dataMapper
}

const TicketAnalyticsReportService = new GQLCustomSchema('TicketAnalyticsReportService', {
    types: [
        {
            access: true,
            type: 'enum TicketAnalyticsGroupBy { day week month status property categoryClassifier executor assignee }',
        },
        {
            access: true,
            type: 'input TicketAnalyticsReportInput { where: TicketWhereInput!, groupBy: [TicketAnalyticsGroupBy!], nullReplaces: TicketAnalyticsNullReplaces! }',
        },
        {
            access: true,
            type: 'type TicketLabel { label: String!, color: String!, value: String! }',
        },
        {
            access: true,
            type: 'type TicketAnalyticsReportOutput { groups: [TicketGroupedCounter!], ticketLabels: [TicketLabel] }',
        },
        {
            access: true,
            type: 'type TicketGroupedCounter { count: Int!, status: String, property: String, dayGroup: String!, categoryClassifier: String, executor: String, assignee: String  }',
        },
        {
            access: true,
            type: 'input TicketAnalyticsNullReplaces { categoryClassifier: String!, executor: String!, assignee: String! }',
        },
        {
            access: true,
            type: 'input ExportTicketAnalyticsToExcelTranslates { property: String, assignee: String, executor: String, categoryClassifier: String }',
        },
        {
            access: true,
            type: 'input ExportTicketAnalyticsToExcelInput { where: TicketWhereInput!, groupBy: [TicketAnalyticsGroupBy!], translates: ExportTicketAnalyticsToExcelTranslates!, nullReplaces: TicketAnalyticsNullReplaces! }',
        },
        {
            access: true,
            type: 'type ExportTicketAnalyticsToExcelOutput { link: String! }',
        },
    ],
    queries: [
        {
            access: access.canReadTicketAnalyticsReport,
            schema: 'ticketAnalyticsReport(data: TicketAnalyticsReportInput): TicketAnalyticsReportOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { where = {}, groupBy = [], nullReplaces = {} } } = args
                const { ticketCounts: groups, translates } = await getTicketCounts({
                    context, where, groupBy, nullReplaces,
                })
                const ticketLabels = get(translates, 'status', [])
                return { groups, ticketLabels }
            },
        },
        {
            access: access.canReadExportTicketAnalyticsToExcel,
            schema: 'exportTicketAnalyticsToExcel(data: ExportTicketAnalyticsToExcelInput): ExportTicketAnalyticsToExcelOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { where = {}, groupBy = [], translates = {}, nullReplaces } } = args
                const { ticketCounts } = await getTicketCounts({
                    context, where, groupBy, nullReplaces, extraLabels: { status: 'type' },
                })
                const { result, groupKeys } = aggregateData(ticketCounts, groupBy)
                const ticketAccessCheck = await Ticket.getAll(context, where, { first: 1 })
                const [groupBy1, groupBy2] = groupKeys

                // TODO(sitozzz): find way to collect organization locale without additional request
                const organization = await getByCondition('Organization', {
                    id: where.organization.id,
                })

                let rowColumns = []
                const groupByToken = groupBy.join('-')
                const address = get(translates, 'property', '')
                const categoryClassifier = get(translates, 'categoryClassifier', '')
                const assignee = get(translates, 'assignee', '')
                const executor = get(translates, 'executor', '')

                switch (groupByToken) {
                    case 'status-day':
                    case 'status-week':
                        rowColumns = [...new Set(Object.values(result).flatMap(e => Object.keys(e)))]
                        break
                    case 'status-property':
                    case 'property-status':
                        rowColumns = address.includes('@') ? address.split('@') : []
                        break
                    case 'status-categoryClassifier':
                    case 'categoryClassifier-status':
                        rowColumns = categoryClassifier.includes('@') ? categoryClassifier.split('@') : []
                        break
                    case 'status-executor':
                    case 'executor-status':
                        rowColumns = executor.includes('@') ? executor.split('@') : []
                        break
                    case 'status-assignee':
                    case 'assignee-status':
                        rowColumns = assignee.includes('@') ? assignee.split('@') : []
                        break
                    default:
                        throw new Error('unsupported filter')
                }

                const tickets = []
                const totalCount = Object.values(result)
                    .reduce((prevCount, currentAggregateObject) =>
                        prevCount + sum(Object.values(currentAggregateObject)), 0)

                const isSummary = rowColumns.length === 0
                const mapperInstance = getXLSXDataMapper(groupByToken, isSummary)
                if (isSummary) {
                    const tableColumns = {}
                    Object.entries(result).forEach(([ticketType, dataObject]) => {
                        const { rows } = mapperInstance({
                            row: dataObject,
                            constants: { totalCount, address, categoryClassifier, executor, assignee },
                        })
                        Object.entries(rows).filter(([rowType]) => rowType === ticketType).forEach(([tableRow, getValue]) => {
                            tableColumns[tableRow] = getValue()
                        })
                        tableColumns.address = rows.address()
                        tableColumns.executor = rows.executor !== undefined ? rows.executor() : ''
                        tableColumns.assignee = rows.assignee !== undefined ? rows.assignee() : ''
                        tableColumns.categoryClassifier = rows.categoryClassifier !== undefined ? rows.categoryClassifier() : ''
                    })
                    tickets.push(tableColumns)
                } else {
                    const totalCounts = {}
                    Object.values(result).forEach((dataObj) => {
                        Object.entries(dataObj).forEach(([groupByField, count]) => {
                            get(totalCounts, groupByField, false)
                                ? (totalCounts[groupByField] += count)
                                : (totalCounts[groupByField] = count)
                        })
                    })
                    rowColumns.forEach(filterColumn => {
                        const tableColumns = {}
                        Object.entries(result).forEach(([ticketType, dataObj]) => {
                            const mapperData = { row: dataObj, constants: { totalCounts, address } }
                            switch (groupBy2) {
                                case 'status':
                                case 'property':
                                    mapperData['constants']['address'] = filterColumn
                                    break
                                case 'categoryClassifier':
                                    mapperData['constants']['categoryClassifier'] = filterColumn
                                    break
                                case 'executor':
                                    mapperData['constants']['executor'] = filterColumn
                                    break
                                case 'assignee':
                                    mapperData['constants']['assignee'] = filterColumn
                                    break
                                case 'dayGroup':
                                    mapperData['row'] = result
                                    mapperData['constants']['date'] = filterColumn
                                    break
                                default:
                                    throw new Error('Unknown filter ' + groupBy2)
                            }
                            const { rows } = mapperInstance(mapperData)

                            tableColumns.address = rows.address()
                            tableColumns.date = rows.date !== undefined ? rows.date() : ''
                            tableColumns.executor = rows.executor !== undefined ? rows.executor() : ''
                            tableColumns.assignee = rows.assignee !== undefined ? rows.assignee() : ''
                            tableColumns.categoryClassifier = rows.categoryClassifier !== undefined ? rows.categoryClassifier() : ''
                            tableColumns[ticketType] = rows[ticketType]()
                        })
                        tickets.push(tableColumns)
                    })
                }

                const link = await createExportFile({
                    fileName: `ticket_analytics_${dayjs().format('DD_MM')}.xlsx`,
                    templatePath: `./domains/ticket/templates/${organization.country}/TicketAnalyticsExportTemplate[${groupBy1}_${groupBy2}].xlsx`,
                    replaces: { tickets },
                    meta: {
                        listkey: 'Ticket',
                        id: ticketAccessCheck[0].id,
                    },
                })
                return { link }
            },
        },
    ],
})

module.exports = {
    TicketAnalyticsReportService,
}
