/**
 * Generated by `createservice ticket.TicketAnalyticsReportService`
 */

const { GQLCustomSchema } = require('@core/keystone/schema')
const access = require('@condo/domains/ticket/access/TicketAnalyticsReportService')
const moment = require('moment')
const { sortStatusesByType } = require('@condo/domains/ticket/utils/serverSchema/analytics.helper')
const { TicketAnalyticsQueryBuilder } = require('@condo/domains/ticket/utils/serverSchema/analytics.helper')
const { DATE_DISPLAY_FORMAT } = require('@condo/domains/ticket/constants/common')
const { Property: PropertyServerUtils } = require('@condo/domains/property/utils/serverSchema')
const { TicketStatus: TicketStatusServerUtils } = require('@condo/domains/ticket/utils/serverSchema')
const isEmpty = require('lodash/isEmpty')
const get = require('lodash/get')

const createPropertyRange = async (context, organizationWhereInput) => {
    const properties = await PropertyServerUtils.getAll(context, { organization:  organizationWhereInput  })
    return properties.map( property => ({ label: property.address, value: property.id }))
}

const createStatusRange = async (context, organizationWhereInput) => {
    const statuses = await TicketStatusServerUtils.getAll(context, { OR: [
        { organization: organizationWhereInput },
        { organization_is_null: true },
    ] })
    // We use organization specific statuses if they exists
    // or default if there is no organization specific status with a same type
    const allStatuses = statuses.filter(status => {
        if (!status.organization) {
            return true
        }
        return !statuses
            .find(organizationStatus => organizationStatus.organization !== null && organizationStatus.type === status.type)
    })
    return sortStatusesByType(allStatuses).map(status => ({ label: status.name, value: status.id }))
}

const TicketAnalyticsReportService = new GQLCustomSchema('TicketAnalyticsReportService', {
    types: [
        {
            access: true,
            type: 'enum TicketAnalyticsGroupBy { day week month status property }',
        },
        {
            access: true,
            type: 'input TicketAnalyticsReportInput { where: TicketWhereInput!, groupBy: [TicketAnalyticsGroupBy!] }',
        },
        {
            access: true,
            type: 'type TicketAnalyticsReportOutput { result: [TicketGroupedCounter!] }',
        },
        {
            access: true,
            type: 'type TicketGroupedCounter { count: Int!, status: String, property: String, dayGroup: String!  }',
        },
    ],
    queries: [
        {
            access: access.canReadTicketAnalyticsReport,
            schema: 'ticketAnalyticsReport(data: TicketAnalyticsReportInput): TicketAnalyticsReportOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { where = {}, groupBy = [] } } = args

                const analyticsQueryBuilder = new TicketAnalyticsQueryBuilder(where, groupBy)
                await analyticsQueryBuilder.loadData()

                const translates = {}
                for (const group of groupBy) {
                    switch (group) {
                        case 'property':
                            translates[group] = await createPropertyRange(context, where.organization)
                            break
                        case 'status':
                            translates[group] = await createStatusRange(context, where.organization)
                            break
                        default:
                            break
                    }
                }

                const result = analyticsQueryBuilder
                    .getResult(({ count, dayGroup, ...searchResult }) =>
                    {
                        if (!isEmpty(translates)) {
                            Object.entries(searchResult).forEach(([groupName, value]) => {
                                const translateMapping = get(translates, groupName, false)
                                if (translateMapping) {
                                    searchResult[groupName] = translateMapping.find(translate => translate.value === value).label
                                }
                            })
                            return {
                                ...searchResult,
                                dayGroup: moment(dayGroup).format(DATE_DISPLAY_FORMAT),
                                count: parseInt(count),
                            }
                        }
                        return {
                            ...searchResult,
                            dayGroup: moment(dayGroup).format(DATE_DISPLAY_FORMAT),
                            count:parseInt(count),
                        }
                    })
                return { result }
                // let allTickets = await fetchTicketsForAnalytics(context, where)
                // allTickets = allTickets.map( ticket => {
                //     ticket.interval = {
                //         day: moment(ticket.createdAt).format(DATE_FORMATS.day),
                //         week: moment(ticket.createdAt).endOf('week').format(DATE_FORMATS.week),
                //         month: moment(ticket.createdAt).format(DATE_FORMATS.month),
                //     }
                //     return ticket
                // })
                // const groupByFields = {
                //     status: 'status.type',
                //     property: 'property.id',
                //     day: 'interval.day',
                //     week: 'interval.week',
                //     month: 'interval.month',
                // }
                // const allDates = allTickets.map(ticket => new Date(ticket.createdAt))
                // const { groupedCounters, translates } = await createCountersStructure({
                //     context,
                //     organization: where.organization,
                //     groups: groupBy,
                //     datesRange: {
                //         min: new Date(Math.min.apply(null, allDates)),
                //         max: new Date(Math.max.apply(null, allDates)),
                //     },
                // })
                // const result = {}
                // // TODO(sitozzz): rewrite to support `n` levels of groupping
                // const [group1Name, group2Name] = groupBy
                // for (const group1Option in groupedCounters) {
                //     result[translates[group1Name][group1Option]] = {}
                //     for (const group2Option in groupedCounters[group1Option]) {
                //         result[translates[group1Name][group1Option]][translates[group2Name][group2Option]] = allTickets.filter(
                //             ticket =>
                //                 get(ticket, groupByFields[group1Name]) === group1Option &&
                //                 get(ticket, groupByFields[group2Name]) === group2Option
                //         ).length
                //     }
                // }
                // return { result }
            },
        },
    ],

})

module.exports = {
    TicketAnalyticsReportService,
}
