/**
 * Generated by `createservice ticket.SyncTicketObserversService`
 */

const uniq = require('lodash/uniq')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/ticket/access/SyncTicketObserversService')
const { TicketObserver, Ticket, TicketChange } = require('@condo/domains/ticket/utils/serverSchema')
const { User } = require('@condo/domains/user/utils/serverSchema')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    TICKET_NOT_FOUND: { mutation: 'syncTicketObservers',
        variable: ['data', 'ticketId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Ticket not found',
        messageForUser: 'api.ticket.syncTicketObservers.TICKET_NOT_FOUND',
    },
    USER_NOT_FOUND: { mutation: 'syncTicketObservers',
        variable: ['data', 'userIds'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'User not found',
        messageForUser: 'api.ticket.syncTicketObservers.USER_NOT_FOUND',
    },
}

const SyncTicketObserversService = new GQLCustomSchema('SyncTicketObserversService', {
    types: [
        {
            access: true,
            type: 'input SyncTicketObserversInput { dv: Int!, sender: JSON!, ticketId: ID!, userIds: [ID!]!, shouldCreateTicketChange: Boolean = true }',
        },
        {
            access: true,
            type: 'type SyncTicketObserversOutput { status: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canSyncTicketObservers,
            schema: 'syncTicketObservers(data: SyncTicketObserversInput!): SyncTicketObserversOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data } = args

                const { dv, sender, ticketId, userIds, shouldCreateTicketChange } = data

                const ticket = await Ticket.getOne(context, { id: ticketId, deletedAt: null }, 'id')
                if (!ticket) {
                    throw new GQLError(ERRORS.TICKET_NOT_FOUND)
                }

                const uniqUserIds = uniq(userIds)

                const users = await User.getAll(context, { id_in: uniqUserIds, deletedAt: null }, 'id')
                if (users.length !== uniqUserIds.length) {
                    throw new GQLError(ERRORS.USER_NOT_FOUND)
                }

                const existingTicketObservers = await TicketObserver.getAll(context, { ticket: { id: ticketId }, deletedAt: null }, 'id user { id name }')
                if (existingTicketObservers.length === 0) {
                    const createTicketObserversInput = uniqUserIds.map(userId => ({
                        data: {
                            dv,
                            sender,
                            ticket: { connect: { id: ticketId } },
                            user: { connect: { id: userId } },
                        },
                    }))
                    const createdTicketObservers = await TicketObserver.createMany(context, createTicketObserversInput, 'id user { id name }')
                    if (shouldCreateTicketChange) { 
                        await TicketChange.create(
                            context, 
                            {
                                dv,
                                sender,
                                ticket: { connect: { id: ticketId } },
                                observersIdsFrom: [],
                                observersIdsTo: createdTicketObservers.map(observer => observer.id),
                                observersDisplayNamesFrom: [],
                                observersDisplayNamesTo: createdTicketObservers.map(observer => observer.user.name),
                            }
                        )
                    }
                    return {
                        status: 'success',
                    }
                }

                const existingByUserId = new Map()
                for (const o of existingTicketObservers) {
                    existingByUserId.set(o.user.id, o.id)
                }

                const existingUserIdSet = new Set(existingByUserId.keys())
                const desiredUserIdSet = new Set(uniqUserIds)

                let createTicketObserversInput = []
                for (const userId of desiredUserIdSet) {
                    if (!existingUserIdSet.has(userId)) {
                        createTicketObserversInput.push({
                            data: {
                                dv,
                                sender,
                                ticket: { connect: { id: ticketId } },
                                user: { connect: { id: userId } },
                            },
                        })
                    }
                }

                let deleteTicketObserversInput = []
                for (const userId of existingUserIdSet) {
                    if (!desiredUserIdSet.has(userId)) {
                        const ticketObserverId = existingByUserId.get(userId)
                        deleteTicketObserversInput.push({
                            id: ticketObserverId,
                            data: {
                                dv,
                                sender,
                                deletedAt: 'true',
                            },
                        })
                    }
                }

                const updatedTicketObservers = []
                if (createTicketObserversInput.length > 0) {
                    updatedTicketObservers.push(...await TicketObserver.createMany(context, createTicketObserversInput, 'id user { id name }'))
                }
                if (deleteTicketObserversInput.length > 0) {
                    updatedTicketObservers.push(...await TicketObserver.updateMany(context, deleteTicketObserversInput, 'id user { id name } '))
                }

                if (shouldCreateTicketChange) {
                    await TicketChange.create(
                        context, 
                        {
                            dv,
                            sender,
                            ticket: { connect: { id: ticketId } },
                            observersIdsFrom: existingTicketObservers.map(observer => observer.id),
                            observersIdsTo: updatedTicketObservers.map(observer => observer.id),
                            observersDisplayNamesFrom: existingTicketObservers.map(observer => observer.user.name),
                            observersDisplayNamesTo: updatedTicketObservers.map(observer => observer.user.name),
                        }
                    ) 
                }

                
                return {
                    status: 'success',
                }
            },
        },
    ],
    
})

module.exports = {
    SyncTicketObserversService,
}
