/**
 * Generated by `createservice ticket.TicketAnalyticsReportService`
 */

const { TICKET_ANALYTICS_REPORT_MUTATION } = require(('@condo/domains/ticket/gql'))
const moment = require('moment')
const { makeClientWithProperty } = require('@condo/domains/property/utils/testSchema')
const { createTestTicket } = require('@condo/domains/ticket/utils/testSchema')
const { TICKET_STATUS_TYPES } = require('@condo/domains/ticket/constants')
const DATE_FORMAT = 'DD.MM.YYYY'
const NOW_DATE = moment().format(DATE_FORMAT)

test('Groupped counts [day, status]', async () => {
    const client = await makeClientWithProperty()
    await createTestTicket(client, client.organization, client.property)
    const dateStart = moment().startOf('week')
    const dateEnd = moment().endOf('week')
    const { data: { result: { result } } } = await client.query(TICKET_ANALYTICS_REPORT_MUTATION, {
        dv: 1,
        sender: { dv: 1, fingerprint: 'tests' },
        data: {
            where: {
                AND: [
                    { organization: { id: client.organization.id } },
                    { createdAt_gte: dateStart.toISOString() },
                    { createdAt_lte: dateEnd.toISOString() },
                ],
            },
            groupBy: [ 'day', 'status' ],
        },
    })
    expect(result).toBeDefined()
    expect(Object.keys(result)).toStrictEqual([NOW_DATE])
    expect(Object.values(result[NOW_DATE])).toHaveLength(TICKET_STATUS_TYPES.length)
})

test('Groupped counts [status, day]', async () => {
    const client = await makeClientWithProperty()
    await createTestTicket(client, client.organization, client.property)
    await createTestTicket(client, client.organization, client.property, { isPaid: true })
    await createTestTicket(client, client.organization, client.property, { isEmergency: true })
    const dateStart = moment().startOf('week')
    const dateEnd = moment().endOf('week')
    const { data: { result: { result } } } = await client.query(TICKET_ANALYTICS_REPORT_MUTATION, {
        dv: 1,
        sender: { dv: 1, fingerprint: 'tests' },
        data: {
            where: {
                AND: [
                    { organization: { id: client.organization.id } },
                    { createdAt_gte: dateStart.toISOString() },
                    { createdAt_lte: dateEnd.toISOString() },
                    { isEmergency: true },
                ],
            },
            groupBy: [ 'status', 'day' ],
        },
    })
    const ticketCountMap = Object.values(result).flatMap(dateGroup => Object.values(dateGroup))
    expect(result).toBeDefined()
    expect(ticketCountMap.some(count => count === 1)).toBe(true)
    expect(ticketCountMap.every(count => (count <= 1))).toBe(true)
})

test('Groupped counts [property, status]', async () => {
    const client = await makeClientWithProperty()
    await createTestTicket(client, client.organization, client.property)
    const dateStart = moment().startOf('week')
    const dateEnd = moment().endOf('week')
    const { data: { result: { result } } } = await client.query(TICKET_ANALYTICS_REPORT_MUTATION, {
        dv: 1,
        sender: { dv: 1, fingerprint: 'tests' },
        data: {
            where: {
                AND: [
                    { organization: { id: client.organization.id } },
                    { createdAt_gte: dateStart.toISOString() },
                    { createdAt_lte: dateEnd.toISOString() },
                    { isEmergency: false },
                    { isPaid: false },
                    { property: { id_in: [client.property.id] } },
                ],
            },
            groupBy: [ 'property', 'status' ],
        },
    })
    const ticketCountMap = Object.values(result[client.property.address])
    expect(result).toBeDefined()
    expect(ticketCountMap.some(count => count === 1)).toBe(true)
})
