/**
 * Generated by `createservice ticket.TicketAnalyticsReportService`
 */

const { TICKET_ANALYTICS_REPORT_QUERY, EXPORT_TICKET_ANALYTICS_TO_EXCEL } = require(('@condo/domains/ticket/gql'))
const dayjs = require('dayjs')
const { makeClientWithProperty } = require('@condo/domains/property/utils/testSchema')
const { createTestUser, makeLoggedInClient } = require('@condo/domains/user/utils/testSchema')
const { createTestTicket, makeClientWithTicket, createTestTicketCategoryClassifier } = require('@condo/domains/ticket/utils/testSchema')
const { makeClient, makeLoggedInAdminClient } = require('@core/keystone/test.utils')
const isObsConfigured = require('@condo/domains/common/utils/testSchema/isObsConfigured')

const NULL_REPLACES = {
    categoryClassifier: 'categoryClassifier not set',
    executor: 'executor not set',
    assignee: 'assignee not set',
}

describe('TicketAnalyticsReportService', () => {
    describe('User', () => {
        it('can read TicketAnalyticsReportService grouped counts [day, status]', async () => {
            const client = await makeClientWithTicket()
            await createTestTicket(client, client.organization, client.property)
            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')
            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: [ 'day', 'status' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.some(group => group.count === 2)).toBeTruthy()
        })

        it('can read TicketAnalyticsReportService grouped counts [status, day]', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property)
            await createTestTicket(client, client.organization, client.property, { isPaid: true })
            await createTestTicket(client, client.organization, client.property, { isEmergency: true })
            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')
            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                            { isEmergency: true },
                        ],
                    },
                    groupBy: [ 'status', 'day' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.some(group => group.count === 1)).toBeTruthy()
        })

        it('can read TicketAnalyticsReportService groupped with property filter', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property)
            await createTestTicket(client, client.organization, client.property, { isPaid: true })
            await createTestTicket(client, client.organization, client.property, { isEmergency: true })

            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')
            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                            { property: { id_in: [ client.property.id ] } },
                            { isPaid: false },
                            { isEmergency: false },
                        ],
                    },
                    groupBy: [ 'property', 'status' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups[0].count).toEqual(1)
            expect(groups[0].property).toEqual(client.property.address)
        })

        it('can read TicketAnalyticsReportService with property and categoryClassifier filter', async () => {
            const admin = await makeLoggedInAdminClient()
            const client = await makeClientWithProperty()
            const [categoryClassifier] = await createTestTicketCategoryClassifier(admin)

            await createTestTicket(client, client.organization, client.property)
            await createTestTicket(client, client.organization, client.property, { isPaid: true })
            await createTestTicket(client, client.organization, client.property, { isEmergency: true })

            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')

            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                            { property: { id_in: [ client.property.id ] } },
                            { categoryClassifier: { id_in: [ categoryClassifier.id ] } },
                            { isPaid: false },
                            { isEmergency: false },
                        ],
                    },
                    groupBy: [ 'categoryClassifier', 'status' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.every(group => group.categoryClassifier === categoryClassifier.name)).toBeTruthy()
        })

        it('can read TicketAnalyticsReportService grouped counts [status, executor]', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property, {
                executor: { connect: { id: client.user.id } },
            })

            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')

            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: [ 'status', 'executor' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.filter(group => group.count === 1)).toHaveLength(1)
        })

        it('can read TicketAnalyticsReportService with null assignee', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property)

            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')

            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: [ 'status', 'assignee' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.filter(group => group.count === 1)).toHaveLength(1)
            expect(groups.every(group => group.assignee !== null)).toBeTruthy()
            expect(groups.filter(group => group.count === 1)[0].assignee).toStrictEqual(NULL_REPLACES['assignee'])
        })

        it('can read TicketAnalyticsReportService with null categoryClassifier', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property)

            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')

            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: [ 'status', 'categoryClassifier' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.filter(group => group.count === 1)).toHaveLength(1)
            expect(groups.every(group => group.categoryClassifier !== null)).toBeTruthy()
            expect(groups.filter(group => group.count === 1)[0].categoryClassifier)
                .toStrictEqual(NULL_REPLACES['categoryClassifier'])
        })

        it('can read TicketAnalyticsReportService with null executor', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property)

            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')

            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: [ 'status', 'executor' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.filter(group => group.count === 1)).toHaveLength(1)
            expect(groups.every(group => group.executor !== null)).toBeTruthy()
            expect(groups.filter(group => group.count === 1)[0].executor)
                .toStrictEqual(NULL_REPLACES['executor'])
        })

        it('can read TicketAnalyticsReportService [status, executor] with id_in filter', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property, {
                executor: { connect: { id: client.user.id } },
            })

            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')

            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                            { executor: { id_in: [client.user.id] } },
                        ],
                    },
                    groupBy: [ 'status', 'executor' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.filter(group => group.count === 1)).toHaveLength(1)
        })

        it('can read TicketAnalyticsReportService grouped counts [status, assignee]', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property, {
                assignee: { connect: { id: client.user.id } },
            })

            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')

            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: [ 'status', 'assignee' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.filter(group => group.count === 1)).toHaveLength(1)
        })

        it('can read TicketAnalyticsReportService [status, assignee] with id_in filter', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property, {
                assignee: { connect: { id: client.user.id } },
            })

            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')

            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                            { assignee: { id_in: [client.user.id] } },
                        ],
                    },
                    groupBy: [ 'status', 'assignee' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.filter(group => group.count === 1)).toHaveLength(1)
        })

        it('can not read TicketAnalyticsReportService from another organization', async () => {
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property)
            const wrongClient = await makeClientWithProperty()
            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')
            const { data: { result: { groups: emptyGroups } } } = await wrongClient.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv:1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: wrongClient.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: [ 'day', 'status' ],
                    nullReplaces: NULL_REPLACES,
                },
            })

            const { data: { result: { groups } } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1,
                sender: { dv:1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: [ 'day', 'status' ],
                    nullReplaces: NULL_REPLACES,
                },
            })

            expect(emptyGroups).toMatchObject({})
            expect(groups).toBeDefined()
            expect(groups.length).toBeGreaterThanOrEqual(1)
            expect(groups.some(group => group.count === 1)).toBeTruthy()
        })

        it('can read exportTicketAnalyticsToExcel with selected organization', async () => {
            if (isObsConfigured()) {
                const client = await makeClientWithProperty()
                await createTestTicket(client, client.organization, client.property)
                const dateStart = dayjs().startOf('week')
                const dateEnd = dayjs().endOf('week')
                const { data: { result: { link } } }  = await client.query(EXPORT_TICKET_ANALYTICS_TO_EXCEL, {
                    dv: 1,
                    sender: { dv: 1, fingerprint: 'tests' },
                    data: {
                        where: {
                            organization: { id: client.organization.id },
                            AND: [
                                { createdAt_gte: dateStart.toISOString() },
                                { createdAt_lte: dateEnd.toISOString() },
                            ],
                        },
                        groupBy: ['status', 'day'],
                        translates: {
                            property: client.property.address,
                        },
                        nullReplaces: NULL_REPLACES,
                    },
                })
                expect(link).not.toHaveLength(0)
            }
        })

        it('can not read exportTicketAnalyticsToExcel from another organization', async () => {
            const admin = await makeLoggedInAdminClient()
            const [, userAttrs] = await createTestUser(admin)
            const restrictedClient = await makeLoggedInClient(userAttrs)
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property)
            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')
            const { data: { result }, errors } = await restrictedClient.query(EXPORT_TICKET_ANALYTICS_TO_EXCEL, {
                dv: 1,
                sender: { dv:1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: ['day', 'status'],
                    translates: {
                        property: client.property.address,
                    },
                    nullReplaces: NULL_REPLACES,
                },
            })

            expect(result).toBeNull()
            expect(errors).toHaveLength(1)
            expect(errors[0].name).toEqual('AccessDeniedError')
        })
    })

    describe('Anonymous', () => {
        it('can not read TicketAnalyticsReportService', async () => {
            const client = await makeClient()
            const clientWithProperty = await makeClientWithProperty()
            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')
            const { errors, data: { result } } = await client.query(TICKET_ANALYTICS_REPORT_QUERY, {
                dv: 1, sender: { dv: 1, fingerprint: 'tests' },
                data: {
                    where: {
                        organization: { id: clientWithProperty.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: [ 'day', 'status' ],
                    nullReplaces: NULL_REPLACES,
                },
            })
            expect(result).toBeNull()
            expect(errors).toHaveLength(1)
            expect(errors[0].name).toEqual('AuthenticationError')
        })

        it('can not get ticket analytics export', async () => {
            const anonymousClient = await makeClient()
            const client = await makeClientWithProperty()
            await createTestTicket(client, client.organization, client.property)
            const dateStart = dayjs().startOf('week')
            const dateEnd = dayjs().endOf('week')
            const { data: { result }, errors } = await anonymousClient.query(EXPORT_TICKET_ANALYTICS_TO_EXCEL, {
                data: {
                    where: {
                        organization: { id: client.organization.id },
                        AND: [
                            { createdAt_gte: dateStart.toISOString() },
                            { createdAt_lte: dateEnd.toISOString() },
                        ],
                    },
                    groupBy: ['day', 'status'],
                    translates: {
                        property: client.property.address,
                    },
                    nullReplaces: NULL_REPLACES,
                },
            })

            expect(result).toBeNull()
            expect(errors).toHaveLength(1)
            expect(errors[0].name).toEqual('AuthenticationError')
        })
    })
})
