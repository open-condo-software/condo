/**
 * Generated by `createschema ticket.TicketFile 'organization:Text;file?:File;ticket?:Relationship:Ticket:SET_NULL;'`
 */

const { makeClient, UUID_RE, DATETIME_RE } = require('@core/keystone/test.utils')
const { 
    TicketFile, 
    createTestTicketFile, 
    updateTestTicketFile,
    makeClientWithTicket,
} = require('@condo/domains/ticket/utils/testSchema')

const { makeClientWithProperty } = require('@condo/domains/property/utils/testSchema')

describe('TicketFile', () => {
    describe('User', () => {
        it('can create temporary TicketFile [no ticket relation]', async () => {
            const client = await makeClientWithProperty()
            const [ticketFile, attrs] = await createTestTicketFile(client, client.organization)  
            expect(ticketFile.id).toMatch(UUID_RE)
            expect(ticketFile.dv).toEqual(1)
            expect(ticketFile.sender).toEqual(attrs.sender)
            expect(ticketFile.v).toEqual(1)
            expect(ticketFile.newId).toEqual(null)
            expect(ticketFile.deletedAt).toEqual(null)
            expect(ticketFile.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(ticketFile.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(ticketFile.createdAt).toMatch(DATETIME_RE)
            expect(ticketFile.updatedAt).toMatch(DATETIME_RE)
            expect(ticketFile.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
        })
        it('can create TicketFile', async () => {
            const client = await makeClientWithTicket()
            const [ticketFile, attrs] = await createTestTicketFile(client, client.organization, client.ticket)  
            expect(ticketFile.id).toMatch(UUID_RE)
            expect(ticketFile.dv).toEqual(1)
            expect(ticketFile.sender).toEqual(attrs.sender)
            expect(ticketFile.v).toEqual(1)
            expect(ticketFile.newId).toEqual(null)
            expect(ticketFile.deletedAt).toEqual(null)
            expect(ticketFile.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(ticketFile.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(ticketFile.createdAt).toMatch(DATETIME_RE)
            expect(ticketFile.updatedAt).toMatch(DATETIME_RE)
            expect(ticketFile.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(ticketFile.ticket).toEqual(expect.objectContaining({ id: client.ticket.id }))
        })
        it('can read TicketFile', async () => {
            const client = await makeClientWithTicket()
            const [ticketFile, attrs] = await createTestTicketFile(client, client.organization, client.ticket)  
            const objs = await TicketFile.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
            expect(objs).toHaveLength(1)
            expect(objs[0].id).toMatch(ticketFile.id)
            expect(objs[0].dv).toEqual(1)
            expect(objs[0].sender).toEqual(attrs.sender)
            expect(objs[0].v).toEqual(1)
            expect(objs[0].newId).toEqual(null)
            expect(objs[0].deletedAt).toEqual(null)
            expect(objs[0].createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objs[0].updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            expect(objs[0].createdAt).toMatch(ticketFile.createdAt)
            expect(objs[0].updatedAt).toMatch(ticketFile.updatedAt)
        })
        it('cannot read TicketFile from another organization', async () => {
            const client = await makeClientWithTicket()
            await createTestTicketFile(client, client.organization, client.ticket)  
            const anotherClient = await makeClientWithTicket()
            const objs = await TicketFile.getAll(anotherClient, {}, { sortBy: ['updatedAt_DESC'] })
            expect(objs).toHaveLength(0)
        })
        it('can update temporary TicketFile', async () => {
            const client = await makeClientWithTicket()
            const [ticketFileCreated] = await createTestTicketFile(client, client.organization)  
            const [ticketFileUpdated, attrsUpdate] = await updateTestTicketFile(client, ticketFileCreated.id, { ticket: { connect: { id: client.ticket.id } } })
            expect(ticketFileUpdated.id).toEqual(ticketFileUpdated.id)
            expect(ticketFileUpdated.dv).toEqual(1)
            expect(ticketFileUpdated.sender).toEqual(attrsUpdate.sender)
            expect(ticketFileUpdated.v).toEqual(2)
            expect(ticketFileUpdated.organization).toEqual(expect.objectContaining({ id: client.organization.id }))
            expect(ticketFileUpdated.ticket).toEqual(expect.objectContaining({ id: client.ticket.id }))
        })
        it('cannot delete TicketFile', async () => {
            const userClient = await makeClientWithTicket()
            const [ticketFileCreated] = await createTestTicketFile(userClient, userClient.organization, userClient.ticket)  
            try {
                // TODO(codegen): check 'user: delete TicketFile' test!
                await TicketFile.delete(userClient, ticketFileCreated.id)
            } catch (e) {
                expect(e.errors[0]).toMatchObject({
                    'message': 'You do not have access to this resource',
                    'name': 'AccessDeniedError',
                    'path': ['obj'],
                })
                expect(e.data).toEqual({ 'obj': null })
            }
        })
    })

    describe('Anonymous', () => {
        it('cannot create TicketFile', async () => {
            const client = await makeClient()
            const clientWithOrganization = await makeClientWithProperty()
            try {
                await createTestTicketFile(client, clientWithOrganization.organization) 
            } catch (e) {
                expect(e.errors[0]).toMatchObject({
                    'message': 'You do not have access to this resource',
                    'name': 'AccessDeniedError',
                    'path': ['obj'],
                })
                expect(e.data).toEqual({ 'obj': null })
            }
        })
        it('cannot read TicketFile', async () => {
            const client = await makeClient()
            try {
                await TicketFile.getAll(client)
            } catch (e) {
                expect(e.errors[0]).toMatchObject({
                    'message': 'You do not have access to this resource',
                    'name': 'AccessDeniedError',
                    'path': ['objs'],
                })
                expect(e.data).toEqual({ 'objs': null })
            }
        })
        it('cannot update TicketFile', async () => {
            const userClient = await makeClientWithTicket()
            const [ticketFileCreated] = await createTestTicketFile(userClient, userClient.organization, userClient.ticket)  
            const client = await makeClient()
            const payload = { ticket: { connect: { id: userClient.ticket.id } } }
            try {
                await updateTestTicketFile(client, ticketFileCreated.id, payload)
            } catch (e) {
                expect(e.errors[0]).toMatchObject({
                    'message': 'You do not have access to this resource',
                    'name': 'AccessDeniedError',
                    'path': ['obj'],
                })
                expect(e.data).toEqual({ 'obj': null })
            }
        })
        it('cannot delete TicketFile', async () => {
            const userClient = await makeClientWithTicket()
            const [ticketFileCreated] = await createTestTicketFile(userClient, userClient.organization, userClient.ticket)  
            const client = await makeClient()
            try {
                // TODO(codegen): check 'anonymous: delete TicketFile' test!
                await TicketFile.delete(client, ticketFileCreated.id)
            } catch (e) {
                expect(e.errors[0]).toMatchObject({
                    'message': 'You do not have access to this resource',
                    'name': 'AccessDeniedError',
                    'path': ['obj'],
                })
                expect(e.data).toEqual({ 'obj': null })
            }
        })
    })
})
