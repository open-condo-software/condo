/**
 * Generated by `createschema ticket.IncidentExportTask 'status:Select:processing,completed,error; format:Select:excel; exportedRecordsCount:Integer; totalRecordsCount:Integer; file?:File; meta?:Json; where:Json; sortBy:Json; locale:Text; timeZone:Text; user:Relationship:User:CASCADE;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const conf = require('@open-condo/config')
const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, waitFor,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')
const { i18n } = require('@open-condo/locales/loader')

const { CANCELLED } = require('@condo/domains/common/constants/export')
const { COMPLETED, EXPORT_PROCESSING_BATCH_SIZE } = require('@condo/domains/common/constants/export')
const { getTmpFile, downloadFile, readXlsx, expectDataFormat } = require('@condo/domains/common/utils/testSchema/file')
const {
    createTestOrganization,
    createTestOrganizationEmployee,
    makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee, createTestOrganizationEmployeeRole,
} = require('@condo/domains/organization/utils/testSchema')
const { INCIDENT_WORK_TYPE_SCHEDULED, INCIDENT_WORK_TYPE_EMERGENCY, INCIDENT_STATUS_ACTUAL } = require('@condo/domains/ticket/constants/incident')
const { ERRORS } = require('@condo/domains/ticket/schema/IncidentExportTask')
const { IncidentExportTask, createTestIncidentExportTask, updateTestIncidentExportTask, createTestIncident } = require('@condo/domains/ticket/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')



const EMPTY_VALUE = '—'
const DATE_FORMAT = 'DD.MM.YYYY'

const formatDate = (date, timeZone, format = DATE_FORMAT) => {
    return dayjs(date).tz(timeZone).format(format)
}

describe('IncidentExportTask', () => {
    let admin, support, anonymous

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
    })

    describe('Accesses', () => {
        describe('Admin', () => {
            let task, taskAttrs, organization, employeeClient

            beforeAll(async () => {
                const { organization: createdOrg, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                    canManageIncidents: true,
                })
                employeeClient = userClient
                organization = createdOrg

                const [createdAdminTask, adminAttrs] = await createTestIncidentExportTask(admin, employeeClient.user, {
                    where: {
                        organization: {
                            id: organization.id,
                        },
                    },
                })
                task = createdAdminTask
                taskAttrs = adminAttrs
            })

            test('can create for any user', async () => {
                expect(task.id).toMatch(UUID_RE)
                expect(task.v).toEqual(1)
                expect(task.deletedAt).toEqual(null)
                expect(task.createdBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(task.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(task.createdAt).toMatch(DATETIME_RE)
                expect(task.updatedAt).toMatch(DATETIME_RE)
                expect(task.where).toEqual(taskAttrs.where)
                expect(task.user.id).toEqual(employeeClient.user.id)
            })

            test('can read any tasks', async () => {
                const tasks = await IncidentExportTask.getAll(admin, {
                    id_in: [task.id],
                })

                expect(tasks).toHaveLength(1)
                expect(tasks.map(item => item.id)).toEqual((expect.arrayContaining([task.id])))
            })

            test('can update any tasks', async () => {
                const [createdAdminTask] = await createTestIncidentExportTask(admin, admin.user, {
                    where: {
                        organization: {
                            id: organization.id,
                        },
                    },
                })
                const [updatedAdminTask, adminAttrs] = await updateTestIncidentExportTask(admin, createdAdminTask.id, {
                    status: CANCELLED,
                })
                expect(updatedAdminTask.id).toEqual(createdAdminTask.id)
                expect(updatedAdminTask.status).toEqual(adminAttrs.status)
            })

            test('cannot delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await IncidentExportTask.delete(admin, task.id)
                })
            })

            test('can soft-delete any tasks', async () => {
                const [deletedAdminTask] = await IncidentExportTask.softDelete(admin, task.id)
                expect(deletedAdminTask.id).toEqual(task.id)
                expect(deletedAdminTask.deletedAt).not.toBeNull()
                expect(deletedAdminTask.deletedAt).toMatch(DATETIME_RE)
            })
        })

        describe('Support', () => {
            let adminTask, organization, employeeClient

            beforeAll(async () => {
                const { organization: createdOrg, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                    canManageIncidents: true,
                })
                employeeClient = userClient
                organization = createdOrg

                const [createdAdminTask] = await createTestIncidentExportTask(admin, employeeClient.user, {
                    where: {
                        organization: {
                            id: organization.id,
                        },
                    },
                })
                adminTask = createdAdminTask
            })

            test('cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestIncidentExportTask(support, employeeClient.user, {
                        where: {
                            organization: {
                                id: organization.id,
                            },
                        },
                    })
                })
            })

            test('cannot read', async () => {
                const tasks = await IncidentExportTask.getAll(support, {
                    id: adminTask.id,
                })
                expect(tasks).toHaveLength(0)
            })

            test('cannot update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestIncidentExportTask(support, adminTask.id, {
                        status: CANCELLED,
                    })
                })
            })

            test('cannot delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await IncidentExportTask.delete(support, adminTask.id)
                })
            })

            test('cannot soft-delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await IncidentExportTask.softDelete(support, adminTask.id)
                })
            })
        })

        describe('User', () => {
            let task, taskAttrs, employeeClient1, employeeClient2, organization1, organization2

            beforeAll(async () => {
                const { userClient: employee1, organization, role } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                    canReadIncidents: true,
                })
                employeeClient1 = employee1
                organization1 = organization

                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)
                employeeClient2 = userClient

                const [otherOrganization] = await createTestOrganization(admin)
                organization2 = otherOrganization

                const [createdTask, attrs] = await createTestIncidentExportTask(employeeClient1, employeeClient1.user, {
                    where: {
                        organization: {
                            id: organization1.id,
                        },
                    },
                })
                task = createdTask
                taskAttrs = attrs
            })

            test('can create for self', async () => {
                expect(task.id).toMatch(UUID_RE)
                expect(task.v).toEqual(1)
                expect(task.deletedAt).toEqual(null)
                expect(task.createdBy).toEqual(expect.objectContaining({ id: employeeClient1.user.id }))
                expect(task.updatedBy).toEqual(expect.objectContaining({ id: employeeClient1.user.id }))
                expect(task.createdAt).toMatch(DATETIME_RE)
                expect(task.updatedAt).toMatch(DATETIME_RE)
                expect(task.where).toEqual(taskAttrs.where)
                expect(task.user.id).toEqual(employeeClient1.user.id)
            })

            test('cannot create for other user', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestIncidentExportTask(employeeClient1, employeeClient2.user, {
                        where: {
                            organization: {
                                id: organization1.id,
                            },
                        },
                    })
                })
            })

            test('cannot create with filter by other organizations', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestIncidentExportTask(employeeClient1, employeeClient1.user, {
                        where: {
                            organization: {
                                id: organization2.id,
                            },
                        },
                    })
                })
            })

            test('cannot create if employee has canReadIncidents: false', async () => {
                const employeeClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(admin, organization1, {
                    canReadIncidents: false,
                })
                await createTestOrganizationEmployee(admin, organization1, employeeClient.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestIncidentExportTask(employeeClient, employeeClient.user, {
                        where: {
                            organization: {
                                id: organization1.id,
                            },
                        },
                    })
                })
            })

            test('can read its task', async () => {
                const [obj] = await IncidentExportTask.getAll(employeeClient1, {
                    id: task.id,
                })
                expect(obj.id).toEqual(task.id)
            })

            test('cannot read other user\'s task', async () => {
                const [createdTask] = await createTestIncidentExportTask(employeeClient2, employeeClient2.user, {
                    where: {
                        organization: {
                            id: organization1.id,
                        },
                    },
                })

                const result = await IncidentExportTask.getAll(employeeClient1, {
                    id: createdTask.id,
                })
                expect(result).toHaveLength(0)
            })

            test('can update its task', async () => {
                const [createdTask] = await createTestIncidentExportTask(employeeClient1, employeeClient1.user, {
                    where: {
                        organization: {
                            id: organization1.id,
                        },
                    },
                })

                const [updatedTask, attrs] = await updateTestIncidentExportTask(employeeClient1, createdTask.id, {
                    status: CANCELLED,
                })

                expect(updatedTask.status).toEqual(attrs.status)
            })

            test('cannot update other user\'s task', async () => {
                const [createdTask] = await createTestIncidentExportTask(employeeClient2, employeeClient2.user, {
                    where: {
                        organization: {
                            id: organization1.id,
                        },
                    },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestIncidentExportTask(employeeClient1, createdTask.id)
                })
            })

            test('cannot delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await IncidentExportTask.delete(employeeClient1, task.id)
                })
            })

            test('cannot soft-delete its task', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await IncidentExportTask.softDelete(employeeClient1, task.id)
                })
            })
        })

        describe('Anonymous', () => {
            let adminTask, employeeClient

            beforeAll(async () => {
                const { organization, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                    canManageIncidents: true,
                })
                employeeClient = userClient

                const [createdAdminTask] = await createTestIncidentExportTask(admin, employeeClient.user, {
                    where: {
                        organization: {
                            id: organization.id,
                        },
                    },
                })
                adminTask = createdAdminTask
            })
            test('cannot create', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestIncidentExportTask(anonymous, employeeClient.user)
                })
            })

            test('cannot read', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await IncidentExportTask.getAll(anonymous, {
                        id: adminTask.id,
                    })
                })
            })

            test('cannot update', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestIncidentExportTask(anonymous, adminTask.id)
                })
            })

            test('cannot delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await IncidentExportTask.delete(anonymous, adminTask.id)
                })
            })

            test('cannot soft-delete', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await IncidentExportTask.softDelete(anonymous, adminTask.id)
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('should throw validation error if you trying to change status of already completed task', async () => {
            const { organization, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                canManageIncidents: true,
            })
            const [task] = await createTestIncidentExportTask(userClient, userClient.user, {
                where: {
                    organization: {
                        id: organization.id,
                    },
                },
            })

            await waitFor(async () => {
                const updatedTask = await IncidentExportTask.getOne(userClient, {
                    id: task.id,
                })
                expect(updatedTask.status).toEqual(COMPLETED)
            })

            await expectToThrowGQLError(async () => {
                await updateTestIncidentExportTask(userClient, task.id, { status: CANCELLED })
            }, ERRORS.STATUS_IS_ALREADY_COMPLETED)
        })
    })
})

describe('exportIncidents', () => {
    it('should create `IncidentExportTask` and create xlsx file', async () => {
        const { organization, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
            canManageIncidents: true,
        })

        const incidentsCountFor2Chunks = Math.floor(EXPORT_PROCESSING_BATCH_SIZE * 1.5)
        const incidents = []
        for (let i = incidentsCountFor2Chunks; i > 0; i--) {
            const [incident] = await createTestIncident(userClient, organization, {
                hasAllProperties: true,
                details: faker.lorem.sentence(),
                workStart: faker.date.soon(),
            })
            incidents.push(incident)
        }

        const [task] = await createTestIncidentExportTask(userClient, userClient.user, {
            where: {
                organization: {
                    id: organization.id,
                },
            },
            sortBy: 'createdAt_ASC',
            locale: 'ru',
            timeZone: 'Europe/Moscow',
        })

        const { locale, timeZone } = task

        await waitFor(async () => {
            const updatedTask = await IncidentExportTask.getOne(userClient, { id: task.id })

            expect(updatedTask.file).toBeDefined()
            expect(updatedTask.file.publicUrl.length).toBeGreaterThan(1)
            expect(updatedTask).toHaveProperty('exportedRecordsCount', incidentsCountFor2Chunks)
            expect(updatedTask).toHaveProperty('totalRecordsCount', incidentsCountFor2Chunks)
            expect(updatedTask.exportedRecordsCount).toEqual(incidents.length)
            expect(updatedTask).toHaveProperty('v', 3)
            expect(updatedTask).toHaveProperty('status', COMPLETED)
        })

        const updatedTask = await IncidentExportTask.getOne(userClient, { id: task.id })
        const url = updatedTask.file.publicUrl.replace(conf.SERVER_URL, userClient.serverUrl)
        const filename = getTmpFile('xlsx')
        await downloadFile(url, filename)
        const data = await readXlsx(filename)

        const translations = {
            AllProperties: i18n('incident.fields.properties.allSelected', { locale }),
            Actual: i18n('incident.status.actual', { locale }),
            NotActual: i18n('incident.status.notActual', { locale }),
            WorkTypes: {
                [INCIDENT_WORK_TYPE_SCHEDULED]: i18n('incident.workType.scheduled', { locale }),
                [INCIDENT_WORK_TYPE_EMERGENCY]: i18n('incident.workType.emergency', { locale }),
            },
        }

        expectDataFormat(data,  [
            ['Выгрузка отключений за все время', '', '', '', '', '', '', '', '', '', '', ''],
            [
                'Номер отключения',
                'Организация',
                'Адреса',
                'Описание',
                'Что сказать жителю',
                'Тип работ',
                'Классификатор',
                'Дата создания',
                'Начало работ',
                'Конец работ',
                'Статус',
                'Автор',
            ],
            ...(incidents.map(incident => [
                String(incident.number),
                incident.organization.name,
                translations.AllProperties,
                incident.details,
                incident.textForResident || EMPTY_VALUE,
                incident.workType ? translations.WorkTypes[incident.workType] : EMPTY_VALUE,
                EMPTY_VALUE,
                incident.createdAt ? formatDate(incident.createdAt, timeZone) : EMPTY_VALUE,
                incident.workStart ? formatDate(incident.workStart, timeZone) : EMPTY_VALUE,
                incident.workFinish ? formatDate(incident.workFinish, timeZone) : EMPTY_VALUE,
                incident.status === INCIDENT_STATUS_ACTUAL ? translations.Actual : translations.NotActual,
                incident.createdBy.name,
            ])),
        ])
    })
})
