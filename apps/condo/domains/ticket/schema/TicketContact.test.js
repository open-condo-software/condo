/**
 * Generated by `createschema ticket.TicketContact 'property:Relationship:Property:PROTECT; unitName:Text; email:Text; phone:Text; name:Text;' --force`
 */
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestOrganizationEmployeeRole } = require('@condo/domains/organization/utils/testSchema')
const { createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects } = require('@condo/domains/common/utils/testSchema')
const { makeClientWithProperty } = require('@condo/domains/property/utils/testSchema')
const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE } = require('@core/keystone/test.utils')

const { TicketContact, createTestTicketContact, updateTestTicketContact } = require('@condo/domains/ticket/utils/testSchema')

describe('TicketContact', () => {
    test('required fields', async () => {
        const userClient = await makeClientWithProperty()
        const adminClient = await makeLoggedInAdminClient()
        const emptyFields = {
            email: null,
            unitName: null,
        }
        const [obj, attrs] = await createTestTicketContact(adminClient, userClient.property, emptyFields)
        expect(obj.id).toMatch(UUID_RE)
        expect(obj.dv).toEqual(1)
        expect(obj.sender).toEqual(attrs.sender)
        expect(obj.name).toMatch(attrs.name)
        expect(obj.phone).toMatch(attrs.phone)
        expect(obj.property.id).toMatch(userClient.property.id)
        expect(obj.v).toEqual(1)
        expect(obj.newId).toEqual(null)
        expect(obj.deletedAt).toEqual(null)
        expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
        expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
        expect(obj.createdAt).toMatch(DATETIME_RE)
        expect(obj.updatedAt).toMatch(DATETIME_RE)
        expect(obj.email).toEqual(emptyFields.email)
        expect(obj.unitName).toEqual(emptyFields.unitName)
    })

    describe('normalization', async () => {
        it('converts phone to E.164 format without spaces', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const fields = {
                phone: '+7 999 111-22-33',
            }
            const [obj] = await createTestTicketContact(adminClient, userClient.property, fields)
            expect(obj.phone).toEqual('+79991112233')
        })
    })

    describe('Create', () => {
        it('can be created by admin', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj, attrs] = await createTestTicketContact(adminClient, userClient.property)

            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.unitName).toMatch(attrs.unitName)
            expect(obj.name).toMatch(attrs.name)
            expect(obj.phone).toMatch(attrs.phone)
            expect(obj.email).toMatch(attrs.email)
            expect(obj.property.id).toMatch(userClient.property.id)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
        })

        it('can be created by user, who is employed in organization, which manages associated property and has "canManageTicketContacts" ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, organization)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTicketContacts: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

            const [obj, attrs] = await createTestTicketContact(userClient, property)

            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.unitName).toMatch(attrs.unitName)
            expect(obj.name).toMatch(attrs.name)
            expect(obj.phone).toMatch(attrs.phone)
            expect(obj.email).toMatch(attrs.email)
            expect(obj.property.id).toMatch(property.id)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
        })

        it('cannot be created by user, who is employed in organization, which manages associated property and does not have "canManageTicketContacts" ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, organization)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTicketContacts: false,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketContact(userClient, property)
            })
        })

        it('cannot be created by user, who is not employed in organization, which manages associated property', async () => {
            const user = await makeClientWithProperty()
            const anotherUser = await makeClientWithProperty()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketContact(anotherUser, user.property)
            })
        })

        it('cannot be created by anonymous', async () => {
            const userClient = await makeClientWithProperty()
            const anonymous = await makeClient()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestTicketContact(anonymous, userClient.property)
            })
        })
    })

    describe('Read', async () => {
        it('can be read by admin', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestTicketContact(adminClient, userClient.property)
            const objs = await TicketContact.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })
            expect(objs.length >= 1).toBeTruthy()
            expect(objs[0].id).toMatch(obj.id)
        })

        it('can be read by user, who is employed in organization, which manages associated property', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestTicketContact(adminClient, userClient.property)
            const objs = await TicketContact.getAll(userClient, {}, { sortBy: ['updatedAt_DESC'] })
            expect(objs.length).toEqual(1)
            expect(objs[0].id).toMatch(obj.id)
        })

        it('cannot be read by user, who is not employed in organization, which manages associated property', async () => {
            const userClient = await makeClientWithProperty()
            const anotherUserClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestTicketContact(adminClient, userClient.property)
            await createTestTicketContact(adminClient, anotherUserClient.property)
            const objs = await TicketContact.getAll(userClient, {}, { sortBy: ['updatedAt_DESC'] })
            expect(objs.length).toEqual(1)
            expect(objs[0].id).toMatch(obj.id)
        })

        it('cannot be read by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anonymousClient = await makeClient()
            await createTestTicketContact(adminClient, userClient.property)
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await TicketContact.getAll(anonymousClient)
            })
        })
    })

    describe('Update', () => {
        it('can be updated by admin', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()
            const [obj] = await createTestTicketContact(adminClient, userClient.property)

            const [objUpdated, attrs] = await updateTestTicketContact(adminClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.name).toEqual(attrs.name)
            expect(objUpdated.email).toEqual(attrs.email)
            expect(objUpdated.phone).toEqual(attrs.phone)
        })

        it('can be updated by user, who is employed in organization, which manages associated property and does have "canManageTicketContacts" ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, organization)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTicketContacts: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

            const [obj] = await createTestTicketContact(adminClient, property)

            const [objUpdated, attrs] = await updateTestTicketContact(userClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.name).toEqual(attrs.name)
            expect(objUpdated.email).toEqual(attrs.email)
            expect(objUpdated.phone).toEqual(attrs.phone)
        })

        it('cannot be updated by user, who is employed in organization, which manages associated property and does not have "canManageTicketContacts" ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, organization)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTicketContacts: false,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

            const [obj] = await createTestTicketContact(adminClient, property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicketContact(userClient, obj.id)
            })
        })

        it('cannot be updated by user, who is not employed in organization, which manages associated property', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, organization)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageTicketContacts: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)

            const anotherUserClient = await makeClientWithProperty()

            const [obj] = await createTestTicketContact(adminClient, property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicketContact(anotherUserClient, obj.id)
            })
        })

        it('cannot be updated by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anonymousClient = await makeClient()

            const [obj] = await createTestTicketContact(adminClient, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestTicketContact(anonymousClient, obj.id)
            })
        })
    })

    describe('Delete', () => {
        it('cannot be deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()

            const [obj] = await createTestTicketContact(adminClient, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketContact.delete(adminClient, obj.id)
            })
        })

        it('cannot be deleted by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()

            const [obj] = await createTestTicketContact(adminClient, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketContact.delete(userClient, obj.id)
            })
        })

        it('cannot be deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithProperty()
            const anonymousClient = await makeClient()

            const [obj] = await createTestTicketContact(adminClient, userClient.property)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await TicketContact.delete(anonymousClient, obj.id)
            })
        })
    })
})
