/**
 * Generated by `createschema ticket.CallRecordFragment 'ticket:Relationship:Ticket:CASCADE;callRecord:Relationship:CallRecordFragment:CASCADE;'`
 */
const {
    makeLoggedInAdminClient, makeClient, UUID_RE,
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { createTestOrganization, createTestOrganizationEmployeeRole, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { CALL_RECORD_FRAGMENT_ERRORS } = require('@condo/domains/ticket/constants/errors')
const { CallRecordFragment, createTestCallRecordFragment, updateTestCallRecordFragment, createTestTicket, createTestCallRecord } = require('@condo/domains/ticket/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')


describe('CallRecordFragment', () => {
    let admin, support, employeeUser, notEmployeeUser, anonymous, organization, property, callRecordByAdmin, callRecordFragmentByAdmin

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        employeeUser = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()

        const [testOrganization] = await createTestOrganization(admin)
        organization = testOrganization
        const [testProperty] = await createTestProperty(admin, organization)
        property = testProperty

        const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageCallRecords: true,
            canManageTickets: true,
        })
        await createTestOrganizationEmployee(admin, organization, employeeUser.user, role)

        notEmployeeUser = await makeClientWithNewRegisteredAndLoggedInUser()
        const [secondTestOrganization] = await createTestOrganization(admin)
        const [secondRole] = await createTestOrganizationEmployeeRole(admin, secondTestOrganization, { canManageCallRecords: true })
        await createTestOrganizationEmployee(admin, secondTestOrganization, notEmployeeUser.user, secondRole)
    })
    beforeEach(async () => {
        const [testCallRecord] = await createTestCallRecord(admin, organization)
        const [testTicket] = await createTestTicket(admin, organization, property)
        const [testCallRecordFragment] = await createTestCallRecordFragment(admin, testTicket, testCallRecord)

        callRecordByAdmin = testCallRecord
        callRecordFragmentByAdmin = testCallRecordFragment
    })
    describe('Accesses', () => {
        describe('Admin', () => {
            test('can create', async () => {
                expect(callRecordFragmentByAdmin).toBeDefined()
                expect(callRecordFragmentByAdmin).toHaveProperty('organization.id', organization.id)
                expect(callRecordFragmentByAdmin.ticket.id).toMatch(UUID_RE)
                expect(callRecordFragmentByAdmin.callRecord.id).toMatch(UUID_RE)
            })
            test('can read', async () => {
                const callRecord = await CallRecordFragment.getOne(admin, { id: callRecordFragmentByAdmin.id }, { sortBy: ['updatedAt_DESC'] })
                expect(callRecord).toBeDefined()
                expect(callRecord).toHaveProperty('id', callRecordFragmentByAdmin.id)
            })
            test('can update', async () => {
                const [callRecord] = await updateTestCallRecordFragment(admin, callRecordFragmentByAdmin.id, { deletedAt: 'true' })
                expect(callRecord).toBeDefined()
                expect(callRecord.deletedAt).toBeTruthy()
            })
            test('can\'t delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await CallRecordFragment.delete(admin, callRecordFragmentByAdmin.id)
                })
            })
        })

        describe('Support', () => {
            test('can\'t create', async () => {
                const [testTicket] = await createTestTicket(admin, organization, property)

                await expectToThrowAccessDeniedErrorToObj(
                    async () => await createTestCallRecordFragment(support, testTicket, callRecordByAdmin)
                )
            })
            test('can\'t read', async () => {
                const callRecord = await CallRecordFragment.getOne(support, { id: callRecordFragmentByAdmin.id }, { sortBy: ['updatedAt_DESC'] })
                expect(callRecord).toBeUndefined()
            })
            test('can\'t update', async () => {
                await expectToThrowAccessDeniedErrorToObj(
                    async () => await updateTestCallRecordFragment(support, callRecordFragmentByAdmin.id, { deletedAt: 'true' })
                )
            })
            test('can\'t delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await CallRecordFragment.delete(support, callRecordFragmentByAdmin.id)
                })
            })
        })

        describe('Employee', () => {
            test('can create', async () => {
                const [testCallRecord] = await createTestCallRecord(employeeUser, organization)
                const [testTicket] = await createTestTicket(employeeUser, organization, property)
                const [callRecordFragment] = await createTestCallRecordFragment(employeeUser, testTicket, testCallRecord)

                expect(callRecordFragment).toBeDefined()
                expect(callRecordFragment).toHaveProperty('organization.id', organization.id)
                expect(callRecordFragment.ticket.id).toMatch(UUID_RE)
                expect(callRecordFragment.callRecord.id).toMatch(UUID_RE)
            })
            test('can read', async () => {
                const callRecord = await CallRecordFragment.getOne(employeeUser, { id: callRecordFragmentByAdmin.id }, { sortBy: ['updatedAt_DESC'] })
                expect(callRecord).toBeDefined()
                expect(callRecord).toHaveProperty('id', callRecordFragmentByAdmin.id)
            })
            test('can update', async () => {
                const [callRecord] = await updateTestCallRecordFragment(employeeUser, callRecordFragmentByAdmin.id, { deletedAt: 'true' })
                expect(callRecord).toBeDefined()
                expect(callRecord.deletedAt).toBeTruthy()
            })
            test('can\'t delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await CallRecordFragment.delete(employeeUser, callRecordFragmentByAdmin.id)
                })
            })
        })

        describe('Not employee', () => {
            test('can\'t create', async () => {
                const [testCallRecord] = await createTestCallRecord(employeeUser, organization)
                const [testTicket] = await createTestTicket(employeeUser, organization, property)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestCallRecordFragment(notEmployeeUser, testTicket, testCallRecord)
                })
            })
            test('can\'t read', async () => {
                const callRecords = await CallRecordFragment.getAll(notEmployeeUser, { id: callRecordFragmentByAdmin.id }, { sortBy: ['updatedAt_DESC'], first: 10 })
                expect(callRecords).toHaveLength(0)
            })
            test('can\'t update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestCallRecordFragment(notEmployeeUser, callRecordFragmentByAdmin.id)
                })
            })
            test('can\'t delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await CallRecordFragment.delete(notEmployeeUser, callRecordFragmentByAdmin.id)
                })
            })
        })

        describe('Anonymous', () => {
            test('can\'t create', async () => {
                const [testCallRecord] = await createTestCallRecord(employeeUser, organization)
                const [testTicket] = await createTestTicket(employeeUser, organization, property)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestCallRecordFragment(anonymous, testTicket, testCallRecord)
                })
            })
            test('can\'t read', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await CallRecordFragment.getOne(anonymous, { id: callRecordFragmentByAdmin.id }, { sortBy: ['updatedAt_DESC'] })
                })
            })
            test('can\'t update', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestCallRecordFragment(anonymous, callRecordFragmentByAdmin.id)
                })
            })
            test('can\'t delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await CallRecordFragment.delete(anonymous, callRecordFragmentByAdmin.id)
                })
            })
        })
    })
    describe('Validations',  () => {
        it('Ticket organization must be the same as callRecord organization', async () => {
            const [organization1] = await createTestOrganization(admin)
            const [testCallRecord] = await createTestCallRecord(admin, organization1)

            const [testTicket] = await createTestTicket(admin, organization, property)

            await expectToThrowGQLError(
                async () => await createTestCallRecordFragment(admin, testTicket, testCallRecord),
                CALL_RECORD_FRAGMENT_ERRORS.INVALID_TICKET_ORGANIZATION
            )
        })
    })
})
