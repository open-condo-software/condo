/**
 * Generated by `createschema property.Property 'organization:Text; name:Text; address:Text; addressMeta:Json; type:Select:building,village; map?:Json'`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { cloneDeep } = require('lodash')

const {
    catchErrorFrom,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects, expectToThrowAccessDeniedErrorToObjects,
} = require('@open-condo/keystone/test.utils')
const { makeClient, UUID_RE, DATETIME_RE, makeLoggedInAdminClient } = require('@open-condo/keystone/test.utils')

const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const {
    createTestOrganizationWithAccessToAnotherOrganization,
    makeClientWithRegisteredOrganization,
    makeEmployeeUserClientWithAbilities,
    registerNewOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { buildingMapJson } = require('@condo/domains/property/constants/property')
const { Property, createTestProperty, createTestProperties, updateTestProperty, makeClientWithProperty, updateTestProperties } = require('@condo/domains/property/utils/testSchema')
const { buildFakeAddressAndMeta } = require('@condo/domains/property/utils/testSchema/factories')
const { registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const { createTestTicket, updateTestTicket, ticketStatusByType } = require('@condo/domains/ticket/utils/testSchema')
const {
    makeClientWithResidentUser,
    makeClientWithSupportUser,
    makeClientWithNewRegisteredAndLoggedInUser,
} = require('@condo/domains/user/utils/testSchema')
const { makeClientWithServiceUser, createTestUserRightsSet } = require('@condo/domains/user/utils/testSchema')


const emptyParkingValueCases = [null, undefined]

describe('Property', () => {
    let admin
    let support
    let anonymous
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
    })
    describe('CRUD', () => {
        describe('Employee', () => {
            let canManageEmployee
            let cannotManageEmployee
            beforeAll(async () => {
                canManageEmployee = await makeEmployeeUserClientWithAbilities({
                    canManageProperties: true,
                    canReadProperties: true,
                })
                cannotManageEmployee = await makeEmployeeUserClientWithAbilities({
                    canManageProperties: false,
                    canReadProperties: true,
                })
            })
            test('Cannot manage properties if has no "canManageProperties" in role', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestProperty(cannotManageEmployee, cannotManageEmployee.property.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestProperty(cannotManageEmployee, cannotManageEmployee.organization)
                })
            })
            test('Can manage properties if has "canManageProperties" in role', async () => {
                const [obj, attrs] = await createTestProperty(canManageEmployee, canManageEmployee.organization)
                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toStrictEqual(attrs.sender)
                expect(obj.organization).toEqual(expect.objectContaining({ id: canManageEmployee.organization.id }))
                expect(obj.type).toEqual('building')
                expect(obj.name).toEqual(attrs.name)
                expect(obj.address).toEqual(attrs.address)
                expect(obj.map).toEqual(null)
                expect(obj.v).toEqual(1)
                expect(obj.newId).toEqual(null)
                expect(obj.deletedAt).toEqual(null)
                expect(obj.createdBy).toEqual(expect.objectContaining({ id: canManageEmployee.user.id }))
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: canManageEmployee.user.id }))
                expect(obj.createdAt).toMatch(DATETIME_RE)
                expect(obj.updatedAt).toMatch(DATETIME_RE)
                expect(obj.unitsCount).toEqual(0)
                expect(obj.uninhabitedUnitsCount).toEqual(0)

                const [updated] = await updateTestProperty(canManageEmployee, obj.id, {
                    deletedAt: dayjs().toISOString(),
                })
                expect(updated).toHaveProperty('deletedAt')
                expect(updated.deletedAt).not.toBeNull()
            })
            test('Can read properties in his organization despite of role', async () => {
                const property = await Property.getOne(cannotManageEmployee, { id: cannotManageEmployee.property.id })
                expect(property).toHaveProperty('id', cannotManageEmployee.property.id)
            })
            test('Cannot read properties with canReadProperties: false', async () => {
                const cannotReadEmployee = await makeEmployeeUserClientWithAbilities({
                    canReadProperties: false,
                })
                const property = await Property.getOne(cannotManageEmployee, { id: cannotReadEmployee.property.id })

                expect(property).toBeUndefined()
            })
            test('Cannot approve property despite of role, but can drop isApproved property', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestProperty(canManageEmployee, canManageEmployee.organization, {
                        isApproved: true,
                    })
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestProperty(canManageEmployee, canManageEmployee.property.id, {
                        isApproved: true,
                    })
                })
                const [property] = await createTestProperty(support, canManageEmployee.organization, {
                    isApproved: true,
                })
                expect(property).toHaveProperty('isApproved', true)
                const [updated] = await updateTestProperty(canManageEmployee, property.id, {
                    isApproved: false,
                })
                expect(updated).toHaveProperty('isApproved', false)
            })
            test('Cannot read and manage property of other organization', async () => {
                const properties = await Property.getOne(canManageEmployee, { id: cannotManageEmployee.property.id })
                expect(properties).toBeUndefined()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestProperty(canManageEmployee, cannotManageEmployee.organization)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestProperty(canManageEmployee, cannotManageEmployee.property.id)
                })
            })
        })
        describe('Resident', () => {
            test('Can read properties from all organizations at the address where he resides', async () => {
                const { property } = await makeClientWithProperty()
                const anotherClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [serviceProvider] = await registerNewOrganization(anotherClient, {
                    type: SERVICE_PROVIDER_TYPE,
                })
                const [providerProperty] = await createTestProperty(anotherClient, serviceProvider, {
                    address: property.address,
                    addressMeta: property.addressMeta,
                })

                expect(providerProperty).toHaveProperty('addressKey', property.addressKey)

                const residentClient = await makeClientWithResidentUser()
                await registerResidentByTestClient(residentClient, {
                    address: property.address,
                    unitName: '1',
                })

                const { property: anotherProperty } = await makeClientWithProperty()

                const objs = await Property.getAll(residentClient, {
                    id_in: [
                        property.id,
                        providerProperty.id,
                        anotherProperty.id,
                    ],
                })

                expect(objs).toHaveLength(2)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: property.id }),
                    expect.objectContaining({ id: providerProperty.id }),
                ]))
            })
        })
        describe('Support', () => {
            test('Can read and manage any property', async () => {
                const client = await makeClientWithProperty()
                const property = await Property.getOne(support, { id: client.property.id })
                expect(property).toHaveProperty('id', client.property.id)
                expect(property).toHaveProperty('isApproved', false)
                const [updated] = await updateTestProperty(support, property.id, {
                    isApproved: true,
                })
                expect(updated).toHaveProperty('isApproved', true)
                const [newProperty] = await createTestProperty(support, client.organization, {
                    isApproved: true,
                })
                expect(newProperty).toHaveProperty('isApproved', true)
            })
        })
        describe('Service user', () => {
            test('Can read and manage any property if has user access rights', async () => {
                const client = await makeClientWithProperty()

                const [rightsSet] = await createTestUserRightsSet(admin, {
                    canReadProperties: true,
                    canManageProperties: true,
                    canReadOrganizations: true,
                })

                const serviceUserClient = await makeClientWithServiceUser({ rightsSet: { connect: { id: rightsSet.id } } })

                const randomPropertyName = faker.random.alphaNumeric(10)

                const property = await Property.getOne(serviceUserClient, { id: client.property.id })
                expect(property).toHaveProperty('id', client.property.id)
                expect(property).toHaveProperty('name')
                const [updated] = await updateTestProperty(serviceUserClient, property.id, {
                    name: randomPropertyName,
                })
                expect(updated).toHaveProperty('name', randomPropertyName)
                const [newProperty] = await createTestProperty(serviceUserClient, client.organization, { name: randomPropertyName })
                expect(newProperty).toHaveProperty('name', randomPropertyName)
            })
        })
        describe('Admin', () => {
            test('Can read and manage any property', async () => {
                const client = await makeClientWithProperty()
                const property = await Property.getOne(admin, { id: client.property.id })
                expect(property).toHaveProperty('id', client.property.id)
                expect(property).toHaveProperty('isApproved', false)
                const [updated] = await updateTestProperty(admin, property.id, {
                    isApproved: true,
                })
                expect(updated).toHaveProperty('isApproved', true)
                const [newProperty] = await createTestProperty(admin, client.organization, {
                    isApproved: true,
                })
                expect(newProperty).toHaveProperty('isApproved', true)
            })
        })
        describe('Anonymous', () => {
            test('Cannot read and manage properties', async () => {
                const client = await makeClientWithProperty()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Property.getOne(anonymous, { id: client.property.id })
                })
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestProperty(anonymous, client.organization)
                })
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestProperty(anonymous, client.property.id)
                })
            })
        })
        describe('Employee from linked organization', () => {
            test('Employee of parent ("from") organization can see properties of child ("to") organization, but cannot manage it', async () => {
                const { clientFrom, propertyTo } = await createTestOrganizationWithAccessToAnotherOrganization()

                const property = await Property.getOne(clientFrom, { id: propertyTo.id })
                expect(property).toHaveProperty('id', propertyTo.id)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestProperty(clientFrom, property.id, { deletedAt: dayjs().toISOString() })
                })
            })
            test('Employee of a child ("to") organization can neither read nor manage the property of parent ("from") organization', async () => {
                const { propertyFrom, clientTo } = await createTestOrganizationWithAccessToAnotherOrganization()

                const property = await Property.getOne(clientTo, { id: propertyFrom.id })
                expect(property).toBeUndefined()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestProperty(clientTo, propertyFrom.id, { deletedAt: dayjs().toISOString() })
                })
            })
        })
    })
    describe('Bulk requests', () => {
        let organization,
            employeeUser,
            employeeInOtherOrganizationUser

        beforeAll(async () => {
            employeeUser = await makeClientWithNewRegisteredAndLoggedInUser()
            const [testOrganization] = await registerNewOrganization(employeeUser)
            organization = testOrganization

            employeeInOtherOrganizationUser = await makeClientWithNewRegisteredAndLoggedInUser()
            const [otherTestOrganization] = await registerNewOrganization(employeeInOtherOrganizationUser)
        })

        test('Can create for organization where user is employee', async () => {
            const fakeAddressData1 = buildFakeAddressAndMeta()
            const fakeAddressData2 = buildFakeAddressAndMeta()

            const properties = await createTestProperties(employeeUser, [
                {
                    organization: { connect: { id: organization.id } },
                    ...fakeAddressData1,
                },
                {
                    organization: { connect: { id: organization.id } },
                    ...fakeAddressData2,
                },
            ])

            expect(properties).toHaveLength(2)
            expect(properties).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    address: fakeAddressData1.address,
                    organization: expect.objectContaining({ id: organization.id }),
                }),
                expect.objectContaining({
                    address: fakeAddressData2.address,
                    organization: expect.objectContaining({ id: organization.id }),
                }),
            ]))
        })

        test('Can not create for organization where user is not employee', async () => {
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await createTestProperties(employeeInOtherOrganizationUser, [
                    {
                        organization: { connect: { id: organization.id } },
                    },
                ])
            })
        })

        test('Can update for organization where user is employee', async () => {
            const properties = await createTestProperties(employeeUser, [
                {
                    organization: { connect: { id: organization.id } },
                },
                {
                    organization: { connect: { id: organization.id } },
                },
            ])
            expect(properties).toHaveLength(2)

            const fakeAddressData1 = buildFakeAddressAndMeta()
            const fakeAddressData2 = buildFakeAddressAndMeta()
            const updatedProperties = await updateTestProperties(employeeUser, [
                {
                    id: properties[0].id,
                    data: {
                        ...fakeAddressData1,
                    },
                },
                {
                    id: properties[1].id,
                    data: {
                        ...fakeAddressData2,
                    },
                },
            ])

            expect(updatedProperties).toHaveLength(2)
            expect(updatedProperties).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    organization: expect.objectContaining({ id: organization.id }),
                    address: fakeAddressData1.address,
                }),
                expect.objectContaining({
                    organization: expect.objectContaining({ id: organization.id }),
                    address: fakeAddressData2.address,
                }),
            ]))
        })

        test('Can not update for organization where user is not employee', async () => {
            const properties = await createTestProperties(employeeUser, [
                {
                    organization: { connect: { id: organization.id } },
                },
                {
                    organization: { connect: { id: organization.id } },
                },
            ])
            expect(properties).toHaveLength(2)

            const fakeAddressData1 = buildFakeAddressAndMeta()
            const fakeAddressData2 = buildFakeAddressAndMeta()
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await updateTestProperties(employeeInOtherOrganizationUser, [
                    {
                        id: properties[0].id,
                        data: {
                            ...fakeAddressData1,
                        },
                    },
                    {
                        id: properties[1].id,
                        data: {
                            ...fakeAddressData2,
                        },
                    },
                ])
            })
        })
    })
    describe('isApproved', () => {
        test('Should drop on address change', async () => {
            const client = await makeClientWithProperty()
            const [approved] = await updateTestProperty(support, client.property.id, {
                isApproved: true,
            })
            expect(approved).toHaveProperty('isApproved', true)
            const [changed] = await updateTestProperty(client, client.property.id, {
                address: faker.address.streetAddress(true),
            })
            expect(changed).toHaveProperty('isApproved', false)
        })
    })
    describe('Map', () => {
        test('Updates unitsCount and uninhabitedUnitsCount on map change', async () => {
            const user = await makeClientWithRegisteredOrganization()
            const [property] = await createTestProperty(user, user.organization, { map: buildingMapJson })
            expect(property).toHaveProperty('map')
            expect(property.map).toMatchObject(buildingMapJson)
            expect(property).toHaveProperty('unitsCount', 28)
            expect(property).toHaveProperty('uninhabitedUnitsCount', 8)

            const [noMap] = await updateTestProperty(user, property.id, { map: null })
            expect(noMap).toHaveProperty('map', null)
            expect(noMap).toHaveProperty('unitsCount', 0)
            expect(noMap).toHaveProperty('uninhabitedUnitsCount', 0)

            const buildingMap = cloneDeep(buildingMapJson)
            buildingMap['sections'][0]['floors'][0]['units'][0].unitType = 'commercial'
            buildingMap['sections'][0]['floors'][1]['units'][0].unitType = 'warehouse'
            buildingMap['sections'][0]['floors'][2]['units'][0].unitType = 'apartment'

            const [updated] = await updateTestProperty(user, property.id, { map: buildingMap })
            expect(updated).toHaveProperty('unitsCount', 25)
            expect(updated).toHaveProperty('uninhabitedUnitsCount', 11)
        })
        test('Should not update if map is not updated', async () => {
            const user = await makeClientWithRegisteredOrganization()
            const [property] = await createTestProperty(user, user.organization, { map: buildingMapJson })
            expect(property).toHaveProperty('map')
            expect(property.map).toMatchObject(buildingMapJson)
            expect(property).toHaveProperty('unitsCount', 28)
            expect(property).toHaveProperty('uninhabitedUnitsCount', 8)

            const [updatedProperty] = await updateTestProperty(user, property.id, { name: faker.random.word() })
            expect(updatedProperty).toHaveProperty('map')
            expect(updatedProperty.map).toMatchObject(buildingMapJson)
            expect(updatedProperty).toHaveProperty('unitsCount', 28)
            expect(updatedProperty).toHaveProperty('uninhabitedUnitsCount', 8)
        })
        test('Can be created with `null` in `map.sections[].floors[].units[]`', async () => {
            const map = {
                'dv': 1,
                'type': 'building',
                'sections': [
                    {
                        'id': '5',
                        'type': 'section',
                        'index': 1,
                        'name': '1',
                        'preview': null,
                        'floors': [
                            {
                                'id': '7',
                                'type': 'floor',
                                'index': 1,
                                'name': '1',
                                'units': [
                                    {
                                        'id': '6',
                                        'type': 'unit',
                                        'name': null,
                                        'label': '1',
                                        'preview': null,
                                    },
                                ],
                            },
                        ],
                    },
                ],
                'parking': [],
            }
            const client = await makeClientWithRegisteredOrganization()
            const payload = {
                map,
            }
            const [obj] = await createTestProperty(client, client.organization, payload)
            expect(obj).toBeDefined()
        })
        test.each(emptyParkingValueCases)('Can be created with `%p` value in `map.parking`', async (parking) => {
            const map = {
                'dv': 1,
                'type': 'building',
                'sections': [
                    {
                        'id': '5',
                        'type': 'section',
                        'index': 1,
                        'name': '1',
                        'preview': null,
                        'floors': [
                            {
                                'id': '7',
                                'type': 'floor',
                                'index': 1,
                                'name': '1',
                                'units': [
                                    {
                                        'id': '6',
                                        'type': 'unit',
                                        'name': null,
                                        'label': '1',
                                        'preview': null,
                                    },
                                ],
                            },
                        ],
                    },
                ],
                'parking': parking,
            }
            const client = await makeClientWithRegisteredOrganization()
            const payload = {
                map,
            }
            const [obj] = await createTestProperty(client, client.organization, payload)
            expect(obj.id).toMatch(UUID_RE)
        })
    })
    describe('Constraints', () => {
        // TODO(AleX83Xpert): Migrate this constraint to addressKey
        test('Address of all non-deleted properties in organization should be unique', async () => {
            const user  = await makeEmployeeUserClientWithAbilities({
                canManageProperties: true,
            })

            // Create
            await catchErrorFrom(async () => {
                await createTestProperty(user, user.organization, { address: user.property.address })
            }, ({ errors, data }) => {
                expect(errors).toHaveLength(1)
                expect(errors[0].message).toMatch(`Property with the same address (id=${user.property.id}) already exists in current organization`)
                expect(data).toEqual({ 'obj': null })
            })

            // Update
            const [anotherProperty] = await createTestProperty(user, user.organization)
            expect(anotherProperty).toBeDefined()
            // TODO(pahaz): DOMA-10368 use expectToThrow??
            await catchErrorFrom(async () => {
                await updateTestProperty(user, anotherProperty.id, { address: user.property.address })
            }, ({ errors, data }) => {
                expect(errors).toHaveLength(1)
                expect(errors[0].message).toMatch(`Property with the same address (id=${user.property.id}) already exists in current organization`)
                expect(data).toEqual({ 'obj': null })
            })

            // Success on soft-delete
            const [deleted] = await updateTestProperty(user, user.property.id, { deletedAt: dayjs().toISOString() })
            expect(deleted).not.toHaveProperty('deletedAt', null)

            // Create
            const [recreated] = await createTestProperty(user, user.organization, { address: user.property.address })
            expect(recreated).toHaveProperty('address', user.property.address)
            expect(recreated.id).not.toBe(user.property.id)

            const [deletedAgain] = await updateTestProperty(user, recreated.id, { deletedAt: dayjs().toISOString() })
            expect(deletedAgain).not.toHaveProperty('deletedAt', null)

            // Update
            const [updated] = await updateTestProperty(user, anotherProperty.id, { address: user.property.address })
            expect(updated).toHaveProperty('address', user.property.address)

            // Another organization
            const anotherUser = await makeClientWithProperty()
            const [anotherOrgProperty] = await createTestProperty(anotherUser, anotherUser.organization, { address: user.property.address })
            expect(anotherOrgProperty).toHaveProperty('address', user.property.address)
        })
    })
    describe('Ticket-related stats', () => {
        test('Should be updated correctly', async () => {
            const client = await makeClientWithProperty()
            const [ticket] = await createTestTicket(client, client.organization, client.property)
            const [obj] = await Property.getAll(client, { id_in: [client.property.id] })
            expect(obj.ticketsInWork).toEqual('0')
            expect(obj.ticketsDeferred).toEqual('0')
            expect(obj.ticketsClosed).toEqual('0')

            const statuses = await ticketStatusByType(client)

            // Move ticket to processing status
            await updateTestTicket(client, ticket.id, { status: { connect:{ id: statuses.processing } } })
            const [afterTicketProcessing] = await Property.getAll(client, { id_in: [client.property.id] })
            expect(afterTicketProcessing.ticketsInWork).toEqual('1')
            expect(afterTicketProcessing.ticketsDeferred).toEqual('0')
            expect(afterTicketProcessing.ticketsClosed).toEqual('0')

            // Defer ticket
            await updateTestTicket(client, ticket.id, {
                status: { connect: { id: statuses.deferred } },
                deferredUntil: faker.date.soon(30, dayjs().add(1, 'day')),
            })
            const [afterTicketDeferred] = await Property.getAll(client, { id_in: [client.property.id] })
            expect(afterTicketDeferred.ticketsInWork).toEqual('0')
            expect(afterTicketDeferred.ticketsDeferred).toEqual('1')
            expect(afterTicketDeferred.ticketsClosed).toEqual('0')

            // Close ticket
            await updateTestTicket(client, ticket.id, { status: { connect: { id: statuses.closed } } })
            const [afterTicketClosed] = await Property.getAll(client, { id_in: [client.property.id] })
            expect(afterTicketClosed.ticketsInWork).toEqual('0')
            expect(afterTicketClosed.ticketsDeferred).toEqual('0')
            expect(afterTicketClosed.ticketsClosed).toEqual('1')
        })
    })
})
