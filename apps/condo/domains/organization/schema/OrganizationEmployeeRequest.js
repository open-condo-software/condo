/**
 * Generated by `createschema organization.OrganizationEmployeeRequest 'organization:Relationship:Organization:CASCADE;user:Relationship:User:CASCADE;isAccepted:Checkbox;isRejected:Checkbox'`
 */

const dayjs = require('dayjs')
const get = require('lodash/get')

const { canOnlyServerSideWithoutUserRequest } = require('@open-condo/keystone/access')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getByCondition } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/organization/access/OrganizationEmployeeRequest')
const { MAX_ORGANIZATION_EMPLOYEE_REQUEST_RETRIES, MIN_ORGANIZATION_EMPLOYEE_REQUEST_RETRIES } = require('@condo/domains/organization/constants/common')
const { ORGANIZATION_OWNED_FIELD } = require('@condo/domains/organization/schema/fields')


const ERRORS = {
    INVALID_RETRIES: {
        variable: ['data', 'retries'],
        code: BAD_USER_INPUT,
        type: 'INVALID_RETRIES',
        message: 'Invalid retries. The value must be from {min} to {max}',
        messageInterpolation: {
            min: MIN_ORGANIZATION_EMPLOYEE_REQUEST_RETRIES,
            max: MAX_ORGANIZATION_EMPLOYEE_REQUEST_RETRIES - 1,
        },
    },
    ACCEPT_OR_REJECT_ONLY: {
        variable: ['data'],
        code: BAD_USER_INPUT,
        type: 'ACCEPT_OR_REJECT_ONLY',
        message: '"isAccepted" and "isRejected" cannot be marked at the same time',
    },
    EMPLOYEE_NOT_FOUND: {
        variable: ['data', 'employee'],
        code: BAD_USER_INPUT,
        type: 'EMPLOYEE_NOT_FOUND',
        message: 'Employee was not found',
    },
    EMPLOYEE_FROM_ANOTHER_ORGANIZATION: {
        variable: ['data', 'employee'],
        code: BAD_USER_INPUT,
        type: 'EMPLOYEE_FROM_ANOTHER_ORGANIZATION',
        message: 'An employee from another organization cannot be connected',
    },
    EMPLOYEE_WITH_ANOTHER_USER: {
        variable: ['data', 'employee'],
        code: BAD_USER_INPUT,
        type: 'EMPLOYEE_WITH_ANOTHER_USER',
        message: 'An employee with another user cannot be connected',
    },
}

const OrganizationEmployeeRequest = new GQLListSchema('OrganizationEmployeeRequest', {
    schemaDoc: 'User request to join the organization',
    fields: {

        organization: {
            ...ORGANIZATION_OWNED_FIELD,
            access: {
                read: true,
                create: true,
                update: false,
            },
        },

        organizationId: {
            schemaDoc: 'Organization id (For the user who sent the request because he does not have access to the organization)',
            type: 'Uuid',
            isRequired: true,
            access: {
                read: true,
                create: false,
                update: false,
            },
        },

        organizationName: {
            schemaDoc: 'Organization name (For the user who sent the request because he does not have access to the organization)',
            type: 'Text',
            isRequired: true,
            access: {
                read: true,
                create: false,
                update: false,
            },
        },

        organizationTin: {
            schemaDoc: 'Organization tin (For the user who sent the request because he does not have access to the organization)',
            type: 'Text',
            isRequired: true,
            access: {
                read: true,
                create: false,
                update: false,
            },
        },

        user: {
            schemaDoc: 'User who sent the request',
            type: 'Relationship',
            ref: 'User',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: {
                read: true,
                create: true,
                update: false,
            },
        },

        isAccepted: {
            schemaDoc: 'Means that the request has been accepted',
            type: 'Checkbox',
            defaultValue: false,
            access: {
                read: true,
                create: false,
                update: true,
            },
        },

        isRejected: {
            schemaDoc: 'Means that the request has been rejected',
            type: 'Checkbox',
            defaultValue: false,
            access: {
                read: true,
                create: false,
                update: true,
            },
        },

        processedBy: {
            schemaDoc: 'User who processed the request',
            type: 'Relationship',
            ref: 'User',
            isRequired: false,
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
            access: {
                read: true,
                create: false,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        processedAt: {
            schemaDoc: 'Date when the request was processed',
            type: 'DateTimeUtc',
            access: {
                read: true,
                create: false,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        retries: {
            schemaDoc: 'Number of retries',
            type: 'Integer',
            defaultValue: 0,
            access: {
                read: true,
                create: false,
                update: true,
            },
            hooks: {
                validateInput: async ({ context, resolvedData, fieldPath }) => {
                    const value = resolvedData[fieldPath]
                    if (value < MIN_ORGANIZATION_EMPLOYEE_REQUEST_RETRIES || value > MAX_ORGANIZATION_EMPLOYEE_REQUEST_RETRIES - 1) {
                        throw new GQLError(ERRORS.INVALID_RETRIES, context)
                    }
                },
            },
        },

        createdEmployee: {
            schemaDoc: 'An employee who was created in the organization after the request was accepted',
            type: 'Relationship',
            ref: 'OrganizationEmployee',
            isRequired: false,
            kmigratorOptions: { null: true, on_delete: 'models.CASCADE' },
            access: {
                read: true,
                create: false,
                update: true,
            },
            hooks: {
                validateInput: async ({ context, resolvedData, existingItem, fieldPath }) => {
                    const newItem = { ...existingItem, ...resolvedData }
                    const employeeId = get(resolvedData, fieldPath)
                    const userId = get(newItem, 'user')
                    const organizationId = get(newItem, 'organization')

                    if (employeeId) {
                        const employee = await getByCondition('OrganizationEmployee', {
                            id: employeeId,
                            deletedAt: null,
                        })
                        if (!employee) throw new GQLError(ERRORS.EMPLOYEE_NOT_FOUND, context)
                        const employeeUserId = get(employee, 'user')
                        const employeeOrganizationId = get(employee, 'organization')
                        if (!employeeUserId || userId !== employeeUserId) {
                            throw new GQLError(ERRORS.EMPLOYEE_WITH_ANOTHER_USER, context)
                        }
                        if (!employeeOrganizationId || organizationId !== employeeOrganizationId) {
                            throw new GQLError(ERRORS.EMPLOYEE_FROM_ANOTHER_ORGANIZATION, context)
                        }
                    }
                },
            },
        },

    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['organization', 'user'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'OrganizationEmployeeRequest_unique_organization_and_user',
            },
        ],
    },
    hooks: {
        resolveInput: async ({ context, resolvedData, existingItem }) => {
            const isAcceptanceOperation = !get(existingItem, 'isAccepted') && get(resolvedData, 'isAccepted')
            const isRejectionOperation = !get(existingItem, 'isRejected') && get(resolvedData, 'isRejected')
            
            if (isAcceptanceOperation || isRejectionOperation) {
                resolvedData['processedBy'] = get(context, 'authedItem.id', null)
                resolvedData['processedAt'] = dayjs().toISOString()
            }

            const organizationId = get(resolvedData, 'organization')
            if (organizationId) {
                const organization = await getByCondition('Organization', {
                    id: organizationId,
                    deletedAt: null,
                })
                if (organization) {
                    resolvedData['organizationId'] = organization.id
                    resolvedData['organizationName'] = organization.name
                    resolvedData['organizationTin'] = organization.tin
                }
            }

            return resolvedData
        },
        validateInput: async ({ resolvedData, existingItem, context }) => {
            const newItem = { ...existingItem, ...resolvedData }
            if (get(newItem, 'isAccepted') && get(newItem, 'isRejected')) {
                throw new GQLError(ERRORS.ACCEPT_OR_REJECT_ONLY, context)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadOrganizationEmployeeRequests,
        create: access.canManageOrganizationEmployeeRequests,
        update: access.canManageOrganizationEmployeeRequests,
        delete: false,
        auth: true,
    },
})

module.exports = {
    OrganizationEmployeeRequest,
    ERRORS,
}
