/**
 * Generated by `createservice organization.AcceptOrRejectOrganizationEmployeeRequestService --type mutations`
 */

const { faker } = require('@faker-js/faker')

const {
    makeLoggedInAdminClient,
    makeClient,
    DATETIME_RE,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowGQLError,
    catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const {
    acceptOrRejectOrganizationEmployeeRequestByTestClient,
    makeEmployeeUserClientWithAbilities,
    createTestOrganizationEmployee,
    OrganizationEmployee,
    createTestOrganizationEmployeeRequest,
    createTestOrganizationEmployeeRole,
} = require('@condo/domains/organization/utils/testSchema')
const {
    createTestUser,
    User,
    makeClientWithStaffUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser, makeClientWithSupportUser,
} = require('@condo/domains/user/utils/testSchema')


describe('AcceptOrRejectOrganizationEmployeeRequestService', () => {
    let admin, support, resident, service, anonymous,
        employeeWithPermissions,
        organization, user, userAttrs,
        request

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        resident = await makeClientWithResidentUser()
        service = await makeClientWithServiceUser()
        anonymous = await makeClient()

        employeeWithPermissions = await makeEmployeeUserClientWithAbilities({
            canManageOrganizationEmployeeRequests: true,
        })
        organization = employeeWithPermissions.organization
    })

    beforeEach(async () => {
        [user, userAttrs] = await createTestUser(admin);
        [request] = await createTestOrganizationEmployeeRequest(admin, organization, user)
    })

    describe('Accesses', () => {
        describe('Admin', () => {
            test('can execute', async () => {
                const [rejectedRequest] = await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                    employeeRequest: { id: request.id },
                    isRejected: true,
                })
                expect(rejectedRequest.isRejected).toBeTruthy()
            })
        })

        describe('Support', () => {
            test('cannot execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(support, {
                        employeeRequest: { id: request.id },
                        isRejected: true,
                    })
                })
            })
        })

        describe('Staff', () => {
            test('can execute if he is an employee of an organization with the permission to "canManageOrganizationEmployeeRequests"', async () => {
                const [rejectedRequest] = await acceptOrRejectOrganizationEmployeeRequestByTestClient(employeeWithPermissions, {
                    employeeRequest: { id: request.id },
                    isRejected: true,
                })
                expect(rejectedRequest.id).toBe(request.id)
                expect(rejectedRequest.isAccepted).toBeFalsy()
                expect(rejectedRequest.isRejected).toBeTruthy()
                expect(rejectedRequest.decidedBy.id).toBe(employeeWithPermissions.user.id)
                expect(rejectedRequest.decidedAt).toMatch(DATETIME_RE)
                expect(rejectedRequest.employee).toBeNull()
            })

            test('cannot execute if he is an employee of an organization without the permission to "canManageOrganizationEmployeeRequests"', async () => {
                const [roleWithoutPermissions] = await createTestOrganizationEmployeeRole(admin, organization, {
                    canManageOrganizationEmployeeRequests: false,
                })
                const employeeWithoutPermissions = await makeClientWithStaffUser()
                await createTestOrganizationEmployee(admin, organization, employeeWithoutPermissions.user, roleWithoutPermissions)
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(employeeWithoutPermissions, {
                        employeeRequest: { id: request.id },
                        isRejected: true,
                    })
                })
            })

            test('cannot execute if not an employee of the organization', async () => {
                const employeeFromAnotherO10n = await makeEmployeeUserClientWithAbilities({
                    canManageOrganizationEmployeeRequests: true,
                })
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(employeeFromAnotherO10n, {
                        employeeRequest: { id: request.id },
                        isRejected: true,
                    })
                })
            })
        })

        describe('Resident', () => {
            test('cannot execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(resident, {
                        employeeRequest: { id: request.id },
                        isRejected: true,
                    })
                })
            })
        })

        describe('Service', () => {
            test('cannot execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(service, {
                        employeeRequest: { id: request.id },
                        isRejected: true,
                    })
                })
            })
        })

        describe('Anonymous', () => {
            test('cannot execute', async () => {
                await expectToThrowAuthenticationErrorToResult(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(anonymous, {
                        employeeRequest: { id: request.id },
                        isRejected: true,
                    })
                })
            })
        })
    })

    describe('Basic logic', () => {
        test('should throw error if dv and sender not valid', async () => {
            await expectToThrowGQLError(async () => {
                await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                    employeeRequest: { id: request.id },
                    isRejected: true,
                    dv: 123,
                })
            }, {
                mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                variable: ['data', 'dv'],
                code: 'BAD_USER_INPUT',
                type: 'DV_VERSION_MISMATCH',
                message: 'Wrong value for data version number',
            }, 'result')

            await expectToThrowGQLError(async () => {
                await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                    employeeRequest: { id: request.id },
                    isRejected: true,
                    sender: { dv: 1, fingerprint: '-' },
                })
            }, {
                mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                variable: ['data', 'sender'],
                code: 'BAD_USER_INPUT',
                type: 'WRONG_FORMAT',
                message: 'Invalid format of "sender" field value',
                correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
            }, 'result')
        })

        test('should throw error if a request is both accepted and rejected', async () => {
            await expectToThrowGQLError(async () => {
                await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                    employeeRequest: { id: request.id },
                    isRejected: true,
                    isAccepted: true,
                })
            }, {
                mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                variable: ['data'],
                code: 'BAD_USER_INPUT',
                type: 'REQUEST_NEEDS_ACCEPT_OR_REJECT',
                message: 'The request must be accepted or rejected',
            }, 'result')
        })

        test('should throw error if a request is both no accepted and no rejected', async () => {
            await expectToThrowGQLError(async () => {
                await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                    employeeRequest: { id: request.id },
                    isRejected: false,
                    isAccepted: false,
                })
            }, {
                mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                variable: ['data'],
                code: 'BAD_USER_INPUT',
                type: 'REQUEST_NEEDS_ACCEPT_OR_REJECT',
                message: 'The request must be accepted or rejected',
            }, 'result')

            await expectToThrowGQLError(async () => {
                await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                    employeeRequest: { id: request.id },
                })
            }, {
                mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                variable: ['data'],
                code: 'BAD_USER_INPUT',
                type: 'REQUEST_NEEDS_ACCEPT_OR_REJECT',
                message: 'The request must be accepted or rejected',
            }, 'result')
        })

        test('should throw error if a request not exist', async () => {
            await expectToThrowGQLError(async () => {
                await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                    employeeRequest: { id: faker.datatype.uuid() },
                    isRejected: true,
                })
            }, {
                mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                variable: ['data', 'employeeRequest'],
                code: 'BAD_USER_INPUT',
                type: 'REQUEST_NOT_FOUND',
                message: 'The request not found',
            }, 'result')
        })

        test('should throw error if a request already decided', async () => {
            await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                employeeRequest: { id: request.id },
                isRejected: true,
            })
            await expectToThrowGQLError(async () => {
                await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                    employeeRequest: { id: request.id },
                    isRejected: true,
                })
            }, {
                mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                variable: ['data', 'employeeRequest'],
                code: 'BAD_USER_INPUT',
                type: 'REQUEST_ALREADY_DECIDED',
                message: 'The request has already been decided',
            }, 'result')
        })

        describe('if pass flag "isRejected: false"', () => {
            test('should reject request and not update existing employee', async () => {
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {})
                const [createdEmployee] = await createTestOrganizationEmployee(admin, organization, user, role, {
                    isAccepted: false,
                })
                const [rejectedRequest] = await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                    employeeRequest: { id: request.id },
                    isRejected: true,
                })
                const employee = await OrganizationEmployee.getOne(admin, { id: createdEmployee.id })
                expect(employee.isAccepted).toBeFalsy()
                expect(employee.v).toBe(createdEmployee.v)
                expect(rejectedRequest.id).toBe(request.id)
                expect(rejectedRequest.isAccepted).toBeFalsy()
                expect(rejectedRequest.isRejected).toBeTruthy()
                expect(rejectedRequest.decidedBy.id).toBe(admin.user.id)
                expect(rejectedRequest.decidedAt).toMatch(DATETIME_RE)
                expect(rejectedRequest.employee).toBeNull()
            })
        })

        describe('if pass flag "isAccepted: true"', () => {
            test('should throw error if not pass employee role', async () => {
                await expectToThrowGQLError(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                        employeeRequest: { id: request.id },
                        isAccepted: true,
                    })
                }, {
                    mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                    variable: ['data', 'employeeData', 'role'],
                    code: 'BAD_USER_INPUT',
                    type: 'EMPLOYEE_ROLE_REQUIRED',
                    message: 'Employee role required',
                }, 'result')
            })

            test('should throw error if user not found from request', async () => {
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {})
                await User.softDelete(admin, user.id)
                await expectToThrowGQLError(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                        employeeData: { role: { id: role.id } },
                        employeeRequest: { id: request.id },
                        isAccepted: true,
                    })
                }, {
                    mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                    variable: ['data', 'employeeRequest'],
                    code: 'BAD_USER_INPUT',
                    type: 'USER_NOT_FOUND',
                    message: 'No user found to join the organization',
                }, 'result')
            })

            test('should throw error if user who sent the request does not have a phone', async () => {
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {})
                await User.update(admin, user.id, { phone: null })
                await expectToThrowGQLError(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                        employeeData: { role: { id: role.id } },
                        employeeRequest: { id: request.id },
                        isAccepted: true,
                    })
                }, {
                    mutation: 'acceptOrRejectOrganizationEmployeeRequest',
                    variable: ['data', 'employeeRequest'],
                    code: 'BAD_USER_INPUT',
                    type: 'USER_DOES_NOT_HAVE_PHONE',
                    message: 'The user does not have a phone',
                }, 'result')
            })

            describe('if the employee exists', () => {
                test('should accept request and accept employee if he is not accepted and update role of employee', async () => {
                    const [role] = await createTestOrganizationEmployeeRole(admin, organization, {})
                    const [role2] = await createTestOrganizationEmployeeRole(admin, organization, {})
                    const [createdEmployee] = await createTestOrganizationEmployee(admin, organization, user, role, {
                        isAccepted: false,
                    })
                    const [acceptedRequest] = await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                        employeeData: { role: { id: role2.id } },
                        employeeRequest: { id: request.id },
                        isAccepted: true,
                    })
                    const employee = await OrganizationEmployee.getOne(admin, { id: createdEmployee.id })
                    expect(employee.isAccepted).toBeTruthy()
                    expect(employee.isRejected).toBeFalsy()
                    expect(employee.role.id).toBe(role2.id)
                    expect(employee.name).toBe(userAttrs.name)
                    expect(employee.phone).toBe(userAttrs.phone)
                    expect(employee.email).toBe(userAttrs.email)
                    expect(acceptedRequest.id).toBe(request.id)
                    expect(acceptedRequest.isAccepted).toBeTruthy()
                    expect(acceptedRequest.isRejected).toBeFalsy()
                    expect(acceptedRequest.decidedBy.id).toBe(admin.user.id)
                    expect(acceptedRequest.decidedAt).toMatch(DATETIME_RE)
                    expect(acceptedRequest.employee.id).toBe(createdEmployee.id)
                })
            })

            describe('if the employee not exists', () => {
                test('should accept request and create new employee', async () => {
                    const [role] = await createTestOrganizationEmployeeRole(admin, organization, {})
                    const [acceptedRequest] = await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                        employeeData: { role: { id: role.id } },
                        employeeRequest: { id: request.id },
                        isAccepted: true,
                    })
                    const employee = await OrganizationEmployee.getOne(admin, { id: acceptedRequest.employee.id })
                    expect(employee.isAccepted).toBeTruthy()
                    expect(employee.isRejected).toBeFalsy()
                    expect(employee.role.id).toBe(role.id)
                    expect(employee.name).toBe(userAttrs.name)
                    expect(employee.phone).toBe(userAttrs.phone)
                    expect(employee.email).toBe(userAttrs.email)
                    expect(employee.dv).toBe(acceptedRequest.dv)
                    expect(employee.sender).toEqual(acceptedRequest.sender)
                    expect(acceptedRequest.id).toBe(request.id)
                    expect(acceptedRequest.isAccepted).toBeTruthy()
                    expect(acceptedRequest.isRejected).toBeFalsy()
                    expect(acceptedRequest.decidedBy.id).toBe(admin.user.id)
                    expect(acceptedRequest.decidedAt).toMatch(DATETIME_RE)
                    expect(acceptedRequest.employee.id).not.toBeNull()
                })
            })

            test('should throw error if employee role not exists', async () => {
                await catchErrorFrom(async () => {
                    await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                        employeeData: { role: { id: faker.datatype.uuid() } },
                        employeeRequest: { id: request.id },
                        isAccepted: true,
                    })
                }, ({ errors }) => {
                    expect(errors[0].originalError.errors).toMatchObject([{
                        message: 'Unable to connect a OrganizationEmployee.role<OrganizationEmployeeRole>',
                        name: 'GraphQLError',
                    }])
                })
            })
        })
    })
})
