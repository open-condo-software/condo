/**
 * Generated by `createservice organization.SendNewBillingReceiptFilesNotificationsService '--type=mutations'`
 */
const dayjs = require('dayjs')
const locale_ru = require('dayjs/locale/ru')
const { isNil, isEmpty, get } = require('lodash')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { BILLING_RECEIPT_FILE_FOLDER_NAME } = require('@condo/domains/billing/constants/constants')
const {
    BillingReceiptFile,
    BillingReceiptAdmin,
    BillingProperty,
} = require('@condo/domains/billing/utils/serverSchema')
const { isValidDateValue } = require('@condo/domains/billing/utils/validation.utils')
const { NOT_FOUND, WRONG_VALUE } = require('@condo/domains/common/constants/errors')
const { DATE_FORMAT } = require('@condo/domains/common/utils/date')
const FileAdapter = require('@condo/domains/common/utils/fileAdapter')
const { loadListByChunks } = require('@condo/domains/common/utils/serverSchema')
const { Contact } = require('@condo/domains/contact/utils/serverSchema')
const {
    BILLING_RECEIPT_FILE_ADDED_TYPE,
} = require('@condo/domains/notification/constants/constants')
const { sendMessage } = require('@condo/domains/notification/utils/serverSchema')
const access = require('@condo/domains/organization/access/SendNewBillingReceiptFilesNotificationsService')
const { Organization } = require('@condo/domains/organization/utils/serverSchema')

const fileAdapter = new FileAdapter(BILLING_RECEIPT_FILE_FOLDER_NAME)

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    ORGANIZATION_NOT_FOUND: {
        mutation: 'sendNewBillingReceiptFilesNotifications',
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Could not find Organization by specified search criteria',
    },
    CREATED_AFTER_DATE_ILLEGAL_VALUE: {
        mutation: 'sendNewBillingReceiptFilesNotifications',
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: 'Wrong value for createdAfter field. Required non null date string, less than current time',
    },
    INVALID_PERIOD_PROVIDED: {
        mutation: 'sendNewBillingReceiptFilesNotifications',
        variable: ['data', 'period'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: `Please provide proper period not before start of previous and not later than start of current month, valid format is ${DATE_FORMAT}`,
    },
}

function getWatermark (value) {
    if (isEmpty(value)) {
        return null
    }

    return dayjs(value)
}

async function prepareAttachments (files) {
    return files.filter(file => !isEmpty(get(file, ['sensitiveDataFile', 'publicUrl'])))
        .map(file => {
            const {
                sensitiveDataFile: {
                    filename,
                    publicUrl,
                    mimetype,
                    originalFilename,
                },
            } = file


            const attachment = {
                mimetype,
                originalFilename,
                publicUrl,
            }

            if (fileAdapter.acl && fileAdapter.acl.generateUrl) {
                attachment.publicUrl = fileAdapter.acl.generateUrl({
                    filename: `${fileAdapter.folder}/${filename}`,
                    originalFilename,
                })
            }

            return attachment
        })
}

const SendNewBillingReceiptFilesNotificationsService = new GQLCustomSchema('SendNewBillingReceiptFilesNotificationsService', {
    types: [
        {
            access: true,
            type: 'input SendNewBillingReceiptFilesNotificationsInput { dv: Int!, sender: JSON!, organization: OrganizationWhereUniqueInput!, createdAfter: String!, period: String! }',
        },
        {
            access: true,
            type: 'type SendNewBillingReceiptFilesNotificationsOutput { notificationsSent: Int! }',
        },
    ],

    mutations: [
        {
            access: access.canSendNewBillingReceiptFilesNotifications,
            schema: 'sendNewBillingReceiptFilesNotifications(data: SendNewBillingReceiptFilesNotificationsInput!): SendNewBillingReceiptFilesNotificationsOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { organization: { id: organizationId }, createdAfter, sender, period } } = args
                const watermark = getWatermark(createdAfter)

                // period is valid
                if (!isValidDateValue(period)) throw new GQLError(ERRORS.INVALID_PERIOD_PROVIDED, context)
                const periodDate = dayjs(period)
                const year = periodDate.year()
                const month = periodDate.format('MMMM') // TODO localize it

                // watermark not null
                if (isNil(watermark)) {
                    throw new GQLError(ERRORS.CREATED_AFTER_DATE_ILLEGAL_VALUE, context)
                }

                // watermark not bigger than current time
                if (dayjs().unix() <= watermark.unix()) {
                    throw new GQLError(ERRORS.CREATED_AFTER_DATE_ILLEGAL_VALUE, context)
                }

                // check organization
                const organization = await Organization.getOne(context, {
                    id: organizationId,
                    deletedAt: null,
                })
                if (isNil(organization)) {
                    throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)
                }

                // load new billing receipt files
                const billingReceiptFiles = await loadListByChunks({
                    context,
                    list: BillingReceiptFile,
                    where: {
                        context: { organization: { id: organizationId } },
                        createdAt_gte: watermark.toISOString(),
                        deletedAt: null,
                    }, sortBy: 'createdAt_ASC',
                })

                /**
                 * Proceeding billing receipt files steps:
                 * 1. Get related billing receipt
                 * 2. Get related organization contact (receipt.account.unitName, receipt.account.unitType, receipt.property.property)
                 * 3. Build a dictionary with contact as key and files as a value
                 */
                const sendMessagesCache = {}
                for (let billingReceiptFile of billingReceiptFiles) {
                    const receipt = await BillingReceiptAdmin.getOne(context, {
                        file: { id: billingReceiptFile.id },
                        period,
                        deletedAt: null,
                    })

                    // no receipt for billing receipt file
                    if (isNil(receipt)) {
                        continue
                    }

                    // destructuring receipt to build contact search conditions 
                    const {
                        account: { unitName, unitType },
                        property: { id: billingPropertyId },
                    } = receipt
                    const billingProperty = await BillingProperty.getOne(context, { id: billingPropertyId })

                    // check if no matching property exists
                    if (isNil(get(billingProperty, ['property', 'id']))) {
                        continue
                    }

                    // get contacts
                    const contacts = await Contact.getAll(context, {
                        property: { id: billingProperty.property.id },
                        email_not: null,
                        unitName,
                        unitType,
                        isVerified: true,
                        deletedAt: null,
                    })

                    // set contacts
                    contacts.forEach(contact => {
                        if (isNil(sendMessagesCache[contact.email])) {
                            sendMessagesCache[contact.email] = {
                                contactId: contact.id,
                                files: [],
                            }
                        }

                        sendMessagesCache[contact.email].files.push(receipt.file)
                    })
                }

                // and finally send messages by build cache
                let notificationsSent = 0
                for (let email of Object.keys(sendMessagesCache)) {
                    const attachments = await prepareAttachments(sendMessagesCache[email].files)

                    // no attachments case
                    if (attachments.length === 0) {
                        continue
                    }

                    // send message
                    await sendMessage(context, {
                        to: { email },
                        type: BILLING_RECEIPT_FILE_ADDED_TYPE,
                        meta: {
                            dv: 1,
                            data: {
                                year,
                                month,
                            },
                            attachments,
                        },
                        sender,
                    })
                    notificationsSent++
                }

                return { notificationsSent }
            },
        },
    ],
})

module.exports = {
    SendNewBillingReceiptFilesNotificationsService,
}
