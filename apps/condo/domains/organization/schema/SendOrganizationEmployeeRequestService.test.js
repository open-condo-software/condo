/**
 * Generated by `createservice organization.SendOrganizationEmployeeRequestService --type mutations`
 */

const { faker } = require('@faker-js/faker')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const {
    sendOrganizationEmployeeRequestByTestClient,
    createTestOrganization,
    updateTestOrganizationEmployeeRequest,
    makeEmployeeUserClientWithAbilities,
    updateTestOrganizationEmployee,
    acceptOrRejectOrganizationEmployeeRequestByTestClient,
    OrganizationEmployee,
    createTestOrganizationEmployeeRole,
} = require('@condo/domains/organization/utils/testSchema')
const {
    makeClientWithStaffUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')


describe('SendOrganizationEmployeeRequestService', () => {
    let admin, staff, resident, service, anonymous,
        organization

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        staff = await makeClientWithStaffUser()
        resident = await makeClientWithResidentUser()
        service = await makeClientWithServiceUser()
        anonymous = await makeClient()
    })

    beforeEach(async () => {
        [organization] = await createTestOrganization(admin)
    })

    describe('Accesses', () => {
        describe('Staff', () => {
            test('can execute', async () => {
                const [request] = await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id },
                })
                expect(request.organization).toBeNull()
                expect(request.organizationId).toBe(organization.id)
                expect(request.organizationName).toBe(organization.name)
                expect(request.organizationTin).toBe(organization.tin)
                expect(request.user.id).toBe(staff.user.id)
                expect(request.isAccepted).toBeFalsy()
                expect(request.isRejected).toBeFalsy()
                expect(request.processedBy).toBeNull()
                expect(request.processedAt).toBeNull()
                expect(request.retries).toBe(0)
                expect(request.createdEmployee).toBeNull()
            })
        })

        describe('Resident', () => {
            test('cannot execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendOrganizationEmployeeRequestByTestClient(resident, {
                        organization: { id: organization.id },
                    })
                })
            })
        })

        describe('Service', () => {
            test('cannot execute', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendOrganizationEmployeeRequestByTestClient(service, {
                        organization: { id: organization.id },
                    })
                })
            })
        })

        describe('Anonymous', () => {
            test('cannot execute', async () => {
                await expectToThrowAuthenticationErrorToResult(async () => {
                    await sendOrganizationEmployeeRequestByTestClient(anonymous, {
                        organization: { id: organization.id },
                    })
                })
            })
        })
    })

    describe('Basic logic', () => {
        test('should create request if it and the employee do not already exist', async () => {
            const [request] = await sendOrganizationEmployeeRequestByTestClient(staff, {
                organization: { id: organization.id },
            })
            expect(request.organizationId).toBe(organization.id)
            expect(request.user.id).toBe(staff.user.id)
        })

        test('should create request if rejected employee already exist for specified organization and authed user', async () => {
            const employeeClient = await makeEmployeeUserClientWithAbilities({}, false)
            await updateTestOrganizationEmployee(admin, employeeClient.employee.id, { isRejected: true })
            const [request] = await sendOrganizationEmployeeRequestByTestClient(employeeClient, {
                organization: { id: employeeClient.organization.id },
            })
            expect(request.organizationId).toBe(employeeClient.organization.id)
            expect(request.user.id).toBe(employeeClient.user.id)
        })

        test('should re-create with increased retries request if it was rejected', async () => {
            const [request] = await sendOrganizationEmployeeRequestByTestClient(staff, {
                organization: { id: organization.id },
            })
            expect(request.retries).toBe(0)
            await updateTestOrganizationEmployeeRequest(admin, request.id, { isRejected: true })

            const [request2] = await sendOrganizationEmployeeRequestByTestClient(staff, {
                organization: { id: organization.id },
            })
            expect(request2.id).toBe(request.id)
            expect(request2.retries).toBe(1)
        })

        test('should resend request if the employee that was created by the request was deleted', async () => {
            const [request] = await sendOrganizationEmployeeRequestByTestClient(staff, {
                organization: { id: organization.id },
            })
            expect(request.retries).toBe(0)

            const [role] = await createTestOrganizationEmployeeRole(admin, organization, {})
            const [acceptedRequest] = await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                employeeData: { role: { id: role.id } },
                employeeRequest: { id: request.id },
                isAccepted: true,
            })
            expect(acceptedRequest.createdEmployee.id).not.toBeNull()

            const [deletedEmployee] = await OrganizationEmployee.softDelete(admin, acceptedRequest.createdEmployee.id)
            expect(deletedEmployee.deletedAt).not.toBeNull()

            const [resendedRequest] = await sendOrganizationEmployeeRequestByTestClient(staff, {
                organization: { id: organization.id },
            })
            expect(resendedRequest.id).toBe(request.id)
            expect(resendedRequest.retries).toBe(1)
        })

        test('should throw error if request was accepted already', async () => {
            const [request] = await sendOrganizationEmployeeRequestByTestClient(staff, {
                organization: { id: organization.id },
            })
            const [role] = await createTestOrganizationEmployeeRole(admin, organization, {})
            const [acceptedRequest] = await acceptOrRejectOrganizationEmployeeRequestByTestClient(admin, {
                employeeData: { role: { id: role.id } },
                employeeRequest: { id: request.id },
                isAccepted: true,
            })
            expect(acceptedRequest.createdEmployee.id).not.toBeNull()

            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id },
                })
            }, {
                mutation: 'sendOrganizationEmployeeRequest',
                variable: ['data'],
                code: 'BAD_USER_INPUT',
                type: 'EMPLOYEE_ALREADY_ACCEPTED',
                message: 'An accepted employee already exist in this organization',
            }, 'result')
        })

        test('should throw error if dv and sender not valid', async () => {
            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id }, dv: 123,
                })
            }, {
                mutation: 'sendOrganizationEmployeeRequest',
                variable: ['data', 'dv'],
                code: 'BAD_USER_INPUT',
                type: 'DV_VERSION_MISMATCH',
                message: 'Wrong value for data version number',
            }, 'result')

            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id }, sender: { dv: 1, fingerprint: '-' },
                })
            }, {
                mutation: 'sendOrganizationEmployeeRequest',
                variable: ['data', 'sender'],
                code: 'BAD_USER_INPUT',
                type: 'WRONG_FORMAT',
                message: 'Invalid format of "sender" field value. {details}',
                correctExample: '{ "dv": 1, "fingerprint": "uniq-device-or-container-id" }',
                messageInterpolation: { details: 'Please, check the example for details' },
            }, 'result')
        })

        test('should throw error if organization is not exist', async () => {
            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: faker.datatype.uuid() },
                })
            }, {
                mutation: 'sendOrganizationEmployeeRequest',
                variable: ['data', 'organization'],
                code: 'BAD_USER_INPUT',
                type: 'ORGANIZATION_NOT_FOUND',
                message: 'Organization not found',
            }, 'result')
        })

        test('should throw error if accepted employee already exist for specified organization and authed user', async () => {
            const employee = await makeEmployeeUserClientWithAbilities()
            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(employee, {
                    organization: { id: employee.organization.id },
                })
            }, {
                mutation: 'sendOrganizationEmployeeRequest',
                variable: ['data'],
                code: 'BAD_USER_INPUT',
                type: 'EMPLOYEE_ALREADY_ACCEPTED',
                message: 'An accepted employee already exist in this organization',
            }, 'result')
        })

        test('should throw error if employee who did not respond to an invitation by specified organization', async () => {
            const employee = await makeEmployeeUserClientWithAbilities({}, false)
            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(employee, {
                    organization: { id: employee.organization.id },
                })
            }, {
                mutation: 'sendOrganizationEmployeeRequest',
                variable: ['data'],
                code: 'BAD_USER_INPUT',
                type: 'EMPLOYEE_INVITATION_ALREADY_SENT',
                message: 'The invitation has already been sent to the employee.',
            }, 'result')
        })

        test('should throw error if the request to one organization has already been sent 5 times', async () => {
            for (let i = 0; i < 5; i++) {
                const [request] = await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id },
                })
                await updateTestOrganizationEmployeeRequest(admin, request.id, { isRejected: true })
            }
            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id },
                })
            }, {
                mutation: 'sendOrganizationEmployeeRequest',
                variable: ['data'],
                code: 'BAD_USER_INPUT',
                type: 'REQUEST_TO_ORGANIZATION_LIMIT_REACHED',
                message: 'A request to the organization limit reached',
            }, 'result')
        })

        test('should throw error if the request has not yet been processed', async () => {
            await sendOrganizationEmployeeRequestByTestClient(staff, {
                organization: { id: organization.id },
            })
            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id },
                })
            }, {
                mutation: 'sendOrganizationEmployeeRequest',
                variable: ['data'],
                code: 'BAD_USER_INPUT',
                type: 'REQUEST_NOT_PROCESSED',
                message: 'A request not processed yet. Please wait for a decide on the request from the organization',
            }, 'result')
        })

        test('should throw error if authed user has not phone', async () => {
            const staff = await makeClientWithStaffUser({ phone: null })

            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id },
                })
            }, {
                mutation: 'sendOrganizationEmployeeRequest',
                variable: ['data'],
                code: 'BAD_USER_INPUT',
                type: 'USER_DOES_NOT_HAVE_PHONE',
                message: 'The user does not have a phone',
            }, 'result')
        })

        test('should throw error if user send many requests (more then 100)', async () => {
            const staff = await makeClientWithStaffUser()

            for (let i = 0; i < 100; i++) {
                const [organization] = await createTestOrganization(admin)
                await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id },
                })
            }
            const [organization] = await createTestOrganization(admin)
            await expectToThrowGQLError(async () => {
                await sendOrganizationEmployeeRequestByTestClient(staff, {
                    organization: { id: organization.id },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOTAL_REQUEST_LIMIT_FOR_USER_REACHED',
                message: 'Too many requests from this user. Try again later',
            }, 'result')
        })
    })
})
