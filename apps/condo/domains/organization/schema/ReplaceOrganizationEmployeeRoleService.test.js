/**
 * Generated by `createservice organization.ReplaceOrganizationEmployeeRoleService --type mutations`
 */

const { faker } = require('@faker-js/faker')
const omit = require('lodash/omit')

const { makeLoggedInAdminClient, makeClient, expectToThrowGQLError, expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { createTestB2BApp, createTestB2BAppContext, createTestB2BAppRole, B2BAppRole } = require('@condo/domains/miniapp/utils/testSchema')
const { replaceOrganizationEmployeeRoleByTestClient } = require('@condo/domains/organization/utils/testSchema')
const {
    makeEmployeeUserClientWithAbilities,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    updateTestOrganizationEmployee,
    OrganizationEmployee,
    OrganizationEmployeeRole, registerNewOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithSupportUser, makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')

const { ERRORS } = require('./ReplaceOrganizationEmployeeRoleService')

 
describe('ReplaceOrganizationEmployeeRoleService', () => {
    let admin, support, employeeUser, notEmployeeUser, anonymous

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        employeeUser = await makeEmployeeUserClientWithAbilities({ canManageRoles: true, canManageEmployees: true })
        notEmployeeUser = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()
    })

    describe('Accesses', () => {
        let oldRole, newRole, employee

        beforeAll(async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser();
            [employee] = await createTestOrganizationEmployee(admin, employeeUser.organization, client.user, employeeUser.role, { isAccepted: true })
        })

        beforeEach(async () => {
            [oldRole] = await createTestOrganizationEmployeeRole(admin, employeeUser.organization);
            [newRole] = await createTestOrganizationEmployeeRole(admin, employeeUser.organization)
            await updateTestOrganizationEmployee(admin, employee.id, {
                role: { connect: { id: oldRole.id } },
            })
        })

        test('Admin can execute', async () => {
            const [result] = await replaceOrganizationEmployeeRoleByTestClient(admin, employeeUser.organization, oldRole, newRole)
            expect(result).toHaveProperty('status', 'ok')
            const updatedEmployee = await OrganizationEmployee.getOne(admin, { id: employee.id })
            expect(updatedEmployee.role.id).toBe(newRole.id)
        })

        test('Support can execute', async () => {
            const [result] = await replaceOrganizationEmployeeRoleByTestClient(support, employeeUser.organization, oldRole, newRole)
            expect(result).toHaveProperty('status', 'ok')
            const updatedEmployee = await OrganizationEmployee.getOne(admin, { id: employee.id })
            expect(updatedEmployee.role.id).toBe(newRole.id)
        })

        test('Employee with permissions "canManageRoles" and "canManageEmployees" can execute', async () => {
            const [result] = await replaceOrganizationEmployeeRoleByTestClient(employeeUser, employeeUser.organization, oldRole, newRole)
            expect(result).toHaveProperty('status', 'ok')
            const updatedEmployee = await OrganizationEmployee.getOne(admin, { id: employee.id })
            expect(updatedEmployee.role.id).toBe(newRole.id)
        })

        describe('Employee without permissions "canManageRoles" and "canManageEmployees" can not execute', () => {
            const cases = [
                { canManageRoles: false, canManageEmployees: false },
                { canManageRoles: true, canManageEmployees: false },
                { canManageRoles: false, canManageEmployees: true },
            ]

            test.each(cases)('%p', async (permissions) => {
                const [roleWithoutPermissions] = await createTestOrganizationEmployeeRole(admin, employeeUser.organization, permissions)
                const employeeUserWithoutPermissions = await makeClientWithNewRegisteredAndLoggedInUser()
                await createTestOrganizationEmployee(admin, employeeUser.organization, employeeUserWithoutPermissions.user, roleWithoutPermissions, { isAccepted: true })
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await replaceOrganizationEmployeeRoleByTestClient(employeeUserWithoutPermissions, employeeUser.organization, oldRole, newRole)
                })
            })
        })

        test('Not employee', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(notEmployeeUser, employeeUser.organization, oldRole, newRole)
            })
        })

        test('Anonymous', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(anonymous, employeeUser.organization, oldRole, newRole)
            })
        })
    })

    describe('Validations', () => {
        let oldRole, newRole, employee

        beforeAll(async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser();
            [employee] = await createTestOrganizationEmployee(admin, employeeUser.organization, client.user, employeeUser.role, { isAccepted: true })
        })

        beforeEach(async () => {
            [oldRole] = await createTestOrganizationEmployeeRole(admin, employeeUser.organization);
            [newRole] = await createTestOrganizationEmployeeRole(admin, employeeUser.organization)
            await updateTestOrganizationEmployee(admin, employee.id, {
                role: { connect: { id: oldRole.id } },
            })
        })

        test('should throw error if organization is not exist', async () => {
            await expectToThrowGQLError(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(admin, { id: faker.datatype.uuid() }, oldRole, newRole)
            }, ERRORS.ORGANIZATION_NOT_FOUND, 'result')
        })

        test('should throw error if old role is not exist', async () => {
            await expectToThrowGQLError(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(admin, employeeUser.organization, { id: faker.datatype.uuid() }, newRole)
            }, ERRORS.OLD_ROLE_NOT_FOUND, 'result')
        })

        test('should throw error if new role is not exist', async () => {
            await expectToThrowGQLError(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(admin, employeeUser.organization, oldRole, { id: faker.datatype.uuid() })
            }, ERRORS.NEW_ROLE_NOT_FOUND, 'result')
        })

        test('should throw error if dv and sender not valid', async () => {
            await expectToThrowGQLError(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(admin, employeeUser.organization, oldRole, newRole, false, {
                    dv: 123,
                })
            }, ERRORS.DV_VERSION_MISMATCH, 'result')
            await expectToThrowGQLError(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(admin, employeeUser.organization, oldRole, newRole, false, {
                    sender: { dv: 1, fingerprint: '-' },
                })
            }, ERRORS.WRONG_SENDER_FORMAT, 'result')
        })

        test('should throw error if the new and old role are the same', async () => {
            await expectToThrowGQLError(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(admin, employeeUser.organization, oldRole, oldRole)
            }, ERRORS.ROLES_MUST_BE_DIFFERENT, 'result')
        })

        test('should throw error if old role or new role from other organization', async () => {
            const employeeUserFromOtherO10n = await makeEmployeeUserClientWithAbilities({ canManageRoles: true, canManageEmployees: true })
            const [oldRoleFromOtherO10n] = await createTestOrganizationEmployeeRole(admin, employeeUserFromOtherO10n.organization)
            const [newRoleFromOtherO10n] = await createTestOrganizationEmployeeRole(admin, employeeUserFromOtherO10n.organization)

            await expectToThrowGQLError(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(admin, employeeUser.organization, oldRoleFromOtherO10n, newRole)
            }, ERRORS.OLD_ROLE_NOT_FOUND, 'result')

            await expectToThrowGQLError(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(admin, employeeUser.organization, oldRole, newRoleFromOtherO10n)
            }, ERRORS.NEW_ROLE_NOT_FOUND, 'result')
        })
    })

    describe('Basic logic', () => {
        let employeeWithOldRole, employeeWithNewRole, employeeWithDefaultRole,
            oldRole, newRole, otherRole,
            b2bApp, oldB2bAppRole, newB2bAppRole, otherB2bAppRole,
            employeeFromOtherO10n, b2bAppRoleFromOtherO10n,
            o10n

        beforeEach(async () => {
            [o10n] = await registerNewOrganization(employeeUser);
            [oldRole] = await createTestOrganizationEmployeeRole(admin, o10n);
            [newRole] = await createTestOrganizationEmployeeRole(admin, o10n);
            [otherRole] = await createTestOrganizationEmployeeRole(admin, o10n)
            const client1 = await makeClientWithNewRegisteredAndLoggedInUser()
            const client2 = await makeClientWithNewRegisteredAndLoggedInUser()
            const client3 = await makeClientWithNewRegisteredAndLoggedInUser();
            [employeeWithOldRole] = await createTestOrganizationEmployee(admin, o10n, client1.user, oldRole, { isAccepted: true });
            [employeeWithNewRole] = await createTestOrganizationEmployee(admin, o10n, client2.user, newRole, { isAccepted: true });
            [employeeWithDefaultRole] = await createTestOrganizationEmployee(admin, o10n, client3.user, otherRole, { isAccepted: true });

            [b2bApp] = await createTestB2BApp(admin, { contextDefaultStatus: CONTEXT_FINISHED_STATUS })
            await createTestB2BAppContext(admin, b2bApp, o10n);
            [oldB2bAppRole] = await createTestB2BAppRole(admin, b2bApp, oldRole);
            [newB2bAppRole] = await createTestB2BAppRole(admin, b2bApp, newRole);
            [otherB2bAppRole] = await createTestB2BAppRole(admin, b2bApp, otherRole)

            employeeFromOtherO10n = await makeEmployeeUserClientWithAbilities({ canManageRoles: true, canManageEmployees: true })
            await createTestB2BAppContext(admin, b2bApp, employeeFromOtherO10n.organization);
            [b2bAppRoleFromOtherO10n] = await createTestB2BAppRole(admin, b2bApp, employeeFromOtherO10n.role)
        })

        test('Should replace old role with new role only for all employees with old role, and retain old role and B2B-roles if flag "withDeletionOldRole" is false', async () => {
            await replaceOrganizationEmployeeRoleByTestClient(employeeUser, o10n, oldRole, newRole)

            const updatedEmployee1 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithOldRole.id })
            const updatedEmployee2 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithNewRole.id })
            const updatedEmployee3 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithDefaultRole.id })
            const oldRoleAfterChanges = await OrganizationEmployeeRole.getOne(employeeUser, { id: oldRole.id })
            const newRoleAfterChanges = await OrganizationEmployeeRole.getOne(employeeUser, { id: newRole.id })
            const otherRoleAfterChanges = await OrganizationEmployeeRole.getOne(employeeUser, { id: otherRole.id })
            const oldB2bAppRoleAfterChanges = await B2BAppRole.getOne(employeeUser, { id: oldB2bAppRole.id })
            const newB2bAppRoleAfterChanges = await B2BAppRole.getOne(employeeUser, { id: newB2bAppRole.id })
            const otherB2bAppRoleAfterChanges = await B2BAppRole.getOne(employeeUser, { id: otherB2bAppRole.id })
            const b2bAppRoleFromOtherO10nAfterChanges = await B2BAppRole.getOne(employeeFromOtherO10n, { id: b2bAppRoleFromOtherO10n.id })

            expect(updatedEmployee1.role.id).toBe(newRole.id)
            expect(updatedEmployee2.role.id).toBe(newRole.id)
            expect(updatedEmployee3.role.id).toBe(otherRole.id)
            expect(oldRoleAfterChanges).toBeDefined()
            expect(newRoleAfterChanges).toBeDefined()
            expect(otherRoleAfterChanges).toBeDefined()
            expect(oldB2bAppRoleAfterChanges).toBeDefined()
            expect(newB2bAppRoleAfterChanges).toBeDefined()
            expect(otherB2bAppRoleAfterChanges).toBeDefined()
            expect(b2bAppRoleFromOtherO10nAfterChanges).toBeDefined()
        })

        test('Should replace old role with new role only for all employees with old role, and delete old role and B2B-roles if flag "withDeletionOldRole" is true', async () => {
            await replaceOrganizationEmployeeRoleByTestClient(employeeUser, o10n, oldRole, newRole, true)

            const updatedEmployee1 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithOldRole.id })
            const updatedEmployee2 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithNewRole.id })
            const updatedEmployee3 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithDefaultRole.id })
            const oldRoleAfterChanges = await OrganizationEmployeeRole.getOne(employeeUser, { id: oldRole.id })
            const newRoleAfterChanges = await OrganizationEmployeeRole.getOne(employeeUser, { id: newRole.id })
            const otherRoleAfterChanges = await OrganizationEmployeeRole.getOne(employeeUser, { id: otherRole.id })
            const oldB2bAppRoleAfterChanges = await B2BAppRole.getOne(employeeUser, { id: oldB2bAppRole.id })
            const newB2bAppRoleAfterChanges = await B2BAppRole.getOne(employeeUser, { id: newB2bAppRole.id })
            const otherB2bAppRoleAfterChanges = await B2BAppRole.getOne(employeeUser, { id: otherB2bAppRole.id })
            const b2bAppRoleFromOtherO10nAfterChanges = await B2BAppRole.getOne(employeeFromOtherO10n, { id: b2bAppRoleFromOtherO10n.id })

            expect(updatedEmployee1.role.id).toBe(newRole.id)
            expect(updatedEmployee2.role.id).toBe(newRole.id)
            expect(updatedEmployee3.role.id).toBe(otherRole.id)
            expect(oldRoleAfterChanges).toBeUndefined()
            expect(newRoleAfterChanges).toBeDefined()
            expect(otherRoleAfterChanges).toBeDefined()
            expect(oldB2bAppRoleAfterChanges).toBeUndefined()
            expect(newB2bAppRoleAfterChanges).toBeDefined()
            expect(otherB2bAppRoleAfterChanges).toBeDefined()
            expect(b2bAppRoleFromOtherO10nAfterChanges).toBeDefined()
        })

        test('Should not remove role with "isDefault" flag', async () => {
            const [defaultRole] = await OrganizationEmployeeRole.getAll(admin, {
                organization: { id: o10n.id },
                isDefault: true,
                // NOTE: If we get the administrator role,
                // we will not be able to perform the following operation (createTestB2BAppRole)
                canManageRoles: false,
            })
            const [defaultB2bAppRole] = await createTestB2BAppRole(admin, b2bApp, defaultRole)
            await updateTestOrganizationEmployee(admin, employeeWithOldRole.id, {
                role: { connect: { id: defaultRole.id } },
            })

            await expectToThrowGQLError(async () => {
                await replaceOrganizationEmployeeRoleByTestClient(employeeUser, o10n, defaultRole, newRole, true)
            }, ERRORS.DEFAULT_ROLE_CANNOT_BE_DELETED, 'result')

            const updatedEmployee1 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithOldRole.id })
            const updatedEmployee2 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithNewRole.id })
            const defaultRoleAfterChanges = await OrganizationEmployeeRole.getOne(employeeUser, { id: defaultRole.id })
            const defaultB2bAppRoleAfterChanges = await B2BAppRole.getOne(employeeUser, { id: defaultB2bAppRole.id })

            expect(updatedEmployee1.role.id).toBe(defaultRole.id)
            expect(updatedEmployee2.role.id).toBe(newRole.id)
            expect(defaultRoleAfterChanges).toBeDefined()
            expect(defaultB2bAppRoleAfterChanges).toBeDefined()
        })

        test('Should change role with "isDefault" flag', async () => {
            const [defaultRole] = await OrganizationEmployeeRole.getAll(admin, {
                organization: { id: o10n.id },
                isDefault: true,
                // NOTE: If we get the administrator role,
                // we will not be able to perform the following operation (createTestB2BAppRole)
                canManageRoles: false,
            })
            const [defaultB2bAppRole] = await createTestB2BAppRole(admin, b2bApp, defaultRole)
            await updateTestOrganizationEmployee(admin, employeeWithOldRole.id, {
                role: { connect: { id: defaultRole.id } },
            })

            await replaceOrganizationEmployeeRoleByTestClient(employeeUser, o10n, defaultRole, newRole, false)

            const updatedEmployee1 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithOldRole.id })
            const updatedEmployee2 = await OrganizationEmployee.getOne(employeeUser, { id: employeeWithNewRole.id })
            const defaultRoleAfterChanges = await OrganizationEmployeeRole.getOne(employeeUser, { id: defaultRole.id })
            const defaultB2bAppRoleAfterChanges = await B2BAppRole.getOne(employeeUser, { id: defaultB2bAppRole.id })

            expect(updatedEmployee1.role.id).toBe(newRole.id)
            expect(updatedEmployee2.role.id).toBe(newRole.id)
            expect(defaultRoleAfterChanges).toBeDefined()
            expect(defaultB2bAppRoleAfterChanges).toBeDefined()
        })

        test('If send two identical requests at the same time, then one should succeed, and the second should return an error', async () => {
            const result = await Promise.allSettled([
                replaceOrganizationEmployeeRoleByTestClient(employeeUser, o10n, oldRole, newRole, true),
                replaceOrganizationEmployeeRoleByTestClient(employeeUser, o10n, oldRole, newRole, false),
            ])

            expect(result).toHaveLength(2)
            expect(result).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    status: 'fulfilled',
                    value: expect.arrayContaining([
                        { status: 'ok' },
                    ]),
                }),
                expect.objectContaining({
                    status: 'rejected',
                    reason: expect.objectContaining({
                        name: 'TestClientResponseError',
                        data: expect.objectContaining({
                            result: null,
                        }),
                        errors: [
                            expect.objectContaining({
                                name: 'GQLError',
                                path: ['result'],
                                message: ERRORS.ROLES_ARE_BEING_PROCESSED.message,
                                // TODO(pahaz): you should refactor it somehow! it's a bad example!
                                extensions: expect.objectContaining(omit(ERRORS.ROLES_ARE_BEING_PROCESSED, 'messageForUser')),
                            }),
                        ],
                    }),
                }),
            ]))
        })
    })
})
