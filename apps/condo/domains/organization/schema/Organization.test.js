/**
 * Generated by `createschema organization.Organization 'country:Select:ru,en; name:Text; description?:Text; avatar?:File; meta:Json; employees:Relationship:OrganizationEmployee:CASCADE; statusTransitions:Json; defaultEmployeeRoleStatusTransitions:Json'`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, makeLoggedInClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowGQLError,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
} = require('@open-condo/keystone/test.utils')
const { setFeatureFlag } = require('@open-condo/keystone/test.utils')

const { createTestAcquiringIntegration, createTestAcquiringIntegrationAccessRight, createTestAcquiringIntegrationContext, updateTestAcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBillingIntegrationOrganizationContext, makeClientWithIntegrationAccess, updateTestBillingIntegrationOrganizationContext } = require('@condo/domains/billing/utils/testSchema')
const { DEFAULT_ENGLISH_COUNTRY, RUSSIA_COUNTRY } = require('@condo/domains/common/constants/countries')
const { COMMON_ERRORS } = require('@condo/domains/common/constants/errors')
const { SUBSCRIPTIONS } = require('@condo/domains/common/constants/featureflags')
const { createTestB2BApp, createTestB2CApp } = require('@condo/domains/miniapp/utils/testSchema')
const { MANAGING_COMPANY_TYPE, SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const { SERVICE_PROVIDER_PROFILE_FEATURE } = require('@condo/domains/organization/constants/features')
const { generateTin, registerNewOrganization, createTestOrganizationWithAccessToAnotherOrganization, OrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const {
    Organization,
    createTestOrganization,
    updateTestOrganization,
    updateTestOrganizationEmployee,
    makeEmployeeUserClientWithAbilities,
    makeClientWithRegisteredOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const {
    VALID_RU_TIN_10,
    VALID_RU_TIN_12,
    INVALID_RU_TIN_10,
    INVALID_RU_TIN_12,
    SOME_RANDOM_LETTERS,
} = require('@condo/domains/organization/utils/tin.utils.spec')
const { createTestSubscriptionPlan, createTestSubscriptionContext, SubscriptionPlan } = require('@condo/domains/subscription/utils/testSchema')
const { DEFAULT_STATUS_TRANSITIONS } = require('@condo/domains/ticket/constants/statusTransitions')
const {
    makeClientWithNewRegisteredAndLoggedInUser, makeClientWithServiceUser, makeClientWithSupportUser, createTestUser,
    createTestUserRightsSet, updateTestUser,
} = require('@condo/domains/user/utils/testSchema')

const { ERRORS } = require('./Organization')

describe('Organization', () => {
    let admin
    let support
    let user
    let anonymous
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()
    })
    describe('Basic CRUD', () => {
        describe('Create', () => {
            // Despite just registered user can create Organization from UI, calling `Organization.create`
            // should be forbidden for it. User can create organization using UI, because it executes
            // `registerNewOrganization` GraphQL mutation, that creates all the stuff without
            // access check, using `execGqlWithoutAccess` under the hood.
            // So, organization creation tests should be located in `registerNewOrganization` test suit
            test('User cannot create organization directly', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestOrganization(user)
                })
            })
            test('User with custom rights cannot create organization directly', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [userRightsSet] = await createTestUserRightsSet(support, { canReadOrganizations: true, canManageOrganizations: true })
                await updateTestUser(admin, userClient.user.id, { rightsSet: { connect: { id: userRightsSet.id } } })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestOrganization(userClient)
                })
            })
            test('Support can not create organization directly', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestOrganization(support)
                })
            })
            test('Admin can create organization directly', async () => {
                const [obj, attrs] = await createTestOrganization(admin)

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(1)
                expect(obj.newId).toEqual(null)
                expect(obj.deletedAt).toEqual(null)
                expect(obj.createdBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(obj.createdAt).toMatch(DATETIME_RE)
                expect(obj.updatedAt).toMatch(DATETIME_RE)
                expect(obj.isApproved).toBeTruthy()
            })
        })
        describe('Read', () => {
            test('Support can read all organizations', async () => {
                const userClient = await makeClientWithRegisteredOrganization()
                const userOrg = await Organization.getOne(support, { id: userClient.organization.id })
                expect(userOrg).toHaveProperty('id', userClient.organization.id)
            })
            test('User can read organizations in which he is an employed', async () => {
                const userClient = await makeClientWithRegisteredOrganization()
                await createTestOrganization(admin)

                const organizations = await Organization.getAll(userClient, {})
                expect(organizations).toHaveLength(1)
                expect(organizations).toEqual([expect.objectContaining({
                    id: userClient.organization.id,
                    name: userClient.organization.name,
                    description: userClient.organization.description,
                })])
            })
            test('User can read all organizations if custom access is provided', async () => {
                const [organization] = await createTestOrganization(admin)
                const customAccess = {
                    accessRules: [{
                        list: 'Organization',
                        read: true,
                    }],
                }
                const [, userAttrs] = await createTestUser(admin, { customAccess })
                const userClient = await makeLoggedInClient({ password: userAttrs.password, email: userAttrs.email })
                const org = await Organization.getOne(userClient, { id: organization.id })
                expect(org).toHaveProperty('id', organization.id)
            })
            test('User cannot read organization if he is unemployed (OrganizationEmployee was deleted)', async () => {
                const userClient = await makeEmployeeUserClientWithAbilities({
                    canManageEmployees: true,
                    canManageOrganization: true,
                })
                await updateTestOrganizationEmployee(support, userClient.employee.id, { deletedAt: 'true' })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestOrganization(userClient, userClient.organization.id, { name: 'name3' })
                })
            })
            test('Anonymous cannot read any organization', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Organization.getAll(anonymous, {})
                })
            })
        })
        describe('Update', () => {
            let userOrganization
            beforeAll(async () => {
                [userOrganization] = await registerNewOrganization(user)
            })
            test('User from another organization cannot update organization regardless of granted "canManageOrganization"', async () => {
                const anotherUser = await makeEmployeeUserClientWithAbilities({
                    canManageOrganization: true,
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestOrganization(anotherUser, userOrganization.id, {})
                })
            })
            test('Organization employee with "canManageOrganization" can', async () => {
                const anotherUser = await makeEmployeeUserClientWithAbilities({
                    canManageOrganization: true,
                })
                const newName = faker.company.name()
                const [updatedOrg] = await updateTestOrganization(anotherUser, anotherUser.organization.id, {
                    name: newName,
                })
                expect(updatedOrg).toEqual(expect.objectContaining({
                    id: anotherUser.organization.id,
                    name: newName,
                }))
            })
            test('Organization employee without "canManageOrganization" cannot', async () => {
                const anotherUser = await makeEmployeeUserClientWithAbilities({
                    canManageOrganization: false,
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestOrganization(anotherUser, anotherUser.organization.id, {})
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestOrganization(anonymous, userOrganization.id)
                })
            })
            test('Support can', async () => {
                const [updatedOrg, attrs] = await updateTestOrganization(support, userOrganization.id)
                expect(attrs).toHaveProperty('meta')
                expect(attrs).toHaveProperty('name')
                expect(attrs).toHaveProperty('description')
                expect(attrs).toHaveProperty('country')
                expect(updatedOrg).toEqual(expect.objectContaining({
                    meta: attrs.meta,
                    name: attrs.name,
                    description: attrs.description,
                    country: attrs.country,
                }))
            })

        })
        describe('Update TIN and importId Field', () => {
            let userOrganization
            beforeAll(async () => {
                [userOrganization] = await registerNewOrganization(user, { country: DEFAULT_ENGLISH_COUNTRY })
            })
            test('Owner cannot change TIN and importId fields', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestOrganization(user, userOrganization.id, { tin: generateTin(DEFAULT_ENGLISH_COUNTRY) })
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestOrganization(user, userOrganization.id, { importId: faker.datatype.uuid() })
                })
            })
            test('Support cannot change TIN and importId fields', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestOrganization(support, userOrganization.id, { tin: generateTin(DEFAULT_ENGLISH_COUNTRY) })
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestOrganization(support, userOrganization.id, { importId: faker.datatype.uuid() })
                })
            })

            test('Admin can change TIN and importId', async () => {
                const newTin = generateTin(DEFAULT_ENGLISH_COUNTRY)
                const [updatedOrg] = await updateTestOrganization(admin, userOrganization.id, { tin: newTin })
                expect(updatedOrg.tin).toEqual(newTin)
                const importId = faker.datatype.uuid()
                const [updatedImportIdOrg] = await updateTestOrganization(admin, userOrganization.id, { importId })
                expect(updatedImportIdOrg.importId).toEqual(importId)
            })
        })
        describe('Delete', () => {
            test('Nobody cannot', async () => {
                const [org] = await createTestOrganization(admin)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Organization.delete(admin, org.id)
                })
            })
        })
    })
    describe('Organization types', () => {
        test(`Organization should have "${MANAGING_COMPANY_TYPE}" type by default`, async () => {
            const [org] = await createTestOrganization(admin)
            expect(org).toHaveProperty('type', MANAGING_COMPANY_TYPE)
        })
        test('Support can change organization type', async () => {
            const [org] = await createTestOrganization(admin)
            const [updatedOrg] = await updateTestOrganization(support, org.id, {
                type: SERVICE_PROVIDER_TYPE,
            })
            expect(updatedOrg).toHaveProperty('type', SERVICE_PROVIDER_TYPE)
        })
        test('Employee cannot change organization type', async () => {
            const userClient = await makeEmployeeUserClientWithAbilities({
                canManageOrganization: true,
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestOrganization(userClient, userClient.organization.id, {
                    type: SERVICE_PROVIDER_TYPE,
                })
            })
        })
    })
    describe('Organization status transitions', () => {
        test('Default status transitions must be created automatically', async () => {
            const { organization } = await makeClientWithRegisteredOrganization()
            expect(organization.statusTransitions).toBeDefined()
            expect(organization.defaultEmployeeRoleStatusTransitions).toMatchObject(DEFAULT_STATUS_TRANSITIONS)
        })
    })
    describe('Organization TIN', () => {
        describe('Valid cases', () => {
            const VALID_CASES = [
                [VALID_RU_TIN_10, RUSSIA_COUNTRY],
                [VALID_RU_TIN_12, RUSSIA_COUNTRY],
            ]
            test.each(VALID_CASES)('TIN: %p, Country: %p', async (tin, country) => {
                const [org] = await registerNewOrganization(user, {
                    tin,
                    country,
                })
                expect(org).toHaveProperty('tin', tin)
                expect(org).toHaveProperty('country', country)
            })
            test('Trim tin value', async () => {
                const [org] = await registerNewOrganization(user, {
                    tin: `   ${VALID_RU_TIN_10}  `,
                    country: RUSSIA_COUNTRY,
                })
                expect(org).toHaveProperty('tin', VALID_RU_TIN_10)
                expect(org).toHaveProperty('country', RUSSIA_COUNTRY)
            })
        })
        describe('Invalid cases', () => {
            const INVALID_CASES = [
                [INVALID_RU_TIN_10, RUSSIA_COUNTRY],
                [INVALID_RU_TIN_12, RUSSIA_COUNTRY],
                [SOME_RANDOM_LETTERS, RUSSIA_COUNTRY],
            ]
            test.each(INVALID_CASES)('TIN: %p, Country: %p', async (tin, country) => {
                await expectToThrowGQLError(async () => {
                    await registerNewOrganization(user, {
                        tin,
                        country,
                    })
                }, {
                    'code': 'INTERNAL_ERROR',
                    'type': 'SUB_GQL_ERROR',
                    'message': 'Tin field has not a valid values supplied',
                })
            })
        })
    })
    describe('Organization features', () => {
        test('Organization is created with no features be default', async () => {
            const [org] = await registerNewOrganization(user)
            expect(org).toHaveProperty('features', [])
        })
        test('Organization can be created with known features', async () => {
            const [obj] = await createTestOrganization(admin, { features: [SERVICE_PROVIDER_PROFILE_FEATURE] })
            expect(obj).toHaveProperty('features', [SERVICE_PROVIDER_PROFILE_FEATURE])
        })
        test('Existing organization can be enhanced with features by support', async () => {
            const client = await makeClientWithRegisteredOrganization()
            expect(client).toHaveProperty(['organization', 'id'])
            expect(client).toHaveProperty(['organization', 'features'], [])

            const [orgWithFeatures] = await updateTestOrganization(support, client.organization.id, {
                features: [SERVICE_PROVIDER_PROFILE_FEATURE],
            })
            expect(orgWithFeatures).toHaveProperty('features', [SERVICE_PROVIDER_PROFILE_FEATURE])

            const [orgWithDisabledFeature] = await updateTestOrganization(support, client.organization.id, {
                features: [],
            })
            expect(orgWithDisabledFeature).toHaveProperty('features', [])
        })
        test('Organization employee cannot set features himself', async () => {
            const orgManager = await makeClientWithRegisteredOrganization()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestOrganization(orgManager, orgManager.organization.id, { features: [SERVICE_PROVIDER_PROFILE_FEATURE] })
            })
        })
    })
    describe('Service user access', () => {
        describe('Billing integration', () => {
            test('Can access to organization with existing billing integration context', async () => {
                const serviceUserClient = await makeClientWithIntegrationAccess(support)
                const [organization] = await registerNewOrganization(user)
                const noCtxOrg = await Organization.getOne(serviceUserClient, { id: organization.id })
                expect(noCtxOrg).toBeUndefined()

                const [ctx] = await createTestBillingIntegrationOrganizationContext(user, organization, serviceUserClient.integration)
                const org = await Organization.getOne(serviceUserClient, { id: organization.id })
                expect(org).toHaveProperty('id', organization.id)

                await updateTestBillingIntegrationOrganizationContext(support, ctx.id, { deletedAt: dayjs().toISOString() })
                const noOrg = await Organization.getOne(serviceUserClient, { id: organization.id })
                expect(noOrg).toBeUndefined()
            })
        })
        describe('Acquiring integration', () => {
            test('Can access to organization with existing billing acquiring context', async () => {
                const [organization] = await registerNewOrganization(user)
                const serviceUserClient = await makeClientWithServiceUser()
                const [acquiringIntegration] = await createTestAcquiringIntegration(admin)
                await createTestAcquiringIntegrationAccessRight(admin, acquiringIntegration, serviceUserClient.user)

                const noCtxOrg = await Organization.getOne(serviceUserClient, { id: organization.id })
                expect(noCtxOrg).toBeUndefined()

                const [ctx] = await createTestAcquiringIntegrationContext(user, organization, acquiringIntegration)
                const org = await Organization.getOne(serviceUserClient, { id: organization.id })
                expect(org).toHaveProperty('id', organization.id)

                await updateTestAcquiringIntegrationContext(support, ctx.id, { deletedAt: dayjs().toISOString() })
                const noOrg = await Organization.getOne(serviceUserClient, { id: organization.id })
                expect(noOrg).toBeUndefined()
            })
        })
    })
    describe('Related organizations', () => {
        test('Employee from "from" related organization: can read organization from "to" organization', async () => {
            const { clientFrom, organizationTo } = await createTestOrganizationWithAccessToAnotherOrganization()
            const organizations = await Organization.getAll(clientFrom, { id: organizationTo.id })

            expect(organizations).toHaveLength(1)
        })
        test('employee from "to" related organization: cannot read organization from "from"', async () => {
            const { organizationFrom, clientTo } = await createTestOrganizationWithAccessToAnotherOrganization()
            const organizations = await Organization.getAll(clientTo, { id: organizationFrom.id })

            expect(organizations).toHaveLength(0)
        })
        test('blocked employee from related organization cannot read', async () => {
            const { clientFrom, employeeFrom, organizationTo } = await createTestOrganizationWithAccessToAnotherOrganization()
            await updateTestOrganizationEmployee(admin, employeeFrom.id, { isBlocked: true })
            const organizations = await Organization.getAll(clientFrom, { id: organizationTo.id })

            expect(organizations).toHaveLength(0)
        })
        test('deleted employee from related organization cannot read', async () => {
            const { clientFrom, employeeFrom, organizationTo } = await createTestOrganizationWithAccessToAnotherOrganization()
            await OrganizationEmployee.softDelete(admin, employeeFrom.id)
            const organizations = await Organization.getAll(clientFrom, { id: organizationTo.id })

            expect(organizations).toHaveLength(0)
        })
    })
    describe('Fields', () => {
        describe('isApproved', () => {
            test('Admin: can create, read and update field "isApproved"', async () => {
                const [createdO10n] = await createTestOrganization(admin, { isApproved: false })
                expect(createdO10n.isApproved).toBeFalsy()

                const o10n = await Organization.getOne(admin, { id: createdO10n.id })
                expect(o10n.isApproved).toBeFalsy()

                const [updatedO18n] = await updateTestOrganization(admin, createdO10n.id, { isApproved: true })
                expect(updatedO18n.isApproved).toBeTruthy()
            })

            test('Support: can read and update field "isApproved"', async () => {
                const [createdO10n] = await createTestOrganization(admin, { isApproved: false })
                expect(createdO10n.isApproved).toBeFalsy()

                const o10n = await Organization.getOne(support, { id: createdO10n.id })
                expect(o10n.isApproved).toBeFalsy()

                const [updatedO18n] = await updateTestOrganization(support, createdO10n.id, { isApproved: true })
                expect(updatedO18n.isApproved).toBeTruthy()
            })

            test('Employee: can read and cannot update field "isApproved" for their organization', async () => {
                const userClient = await makeEmployeeUserClientWithAbilities({
                    canManageOrganization: true,
                })

                const { organization } = userClient

                const o10n = await Organization.getOne(userClient, { id: organization.id })
                expect(o10n.isApproved).toBeTruthy()

                const [updatedO18n, attrs] = await updateTestOrganization(support, organization.id, { name: faker.company.name() })
                expect(updatedO18n.name).toEqual(attrs.name)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Organization.update(userClient, organization.id, {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.datatype.uuid() },
                        isApproved: false,
                    })
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await Organization.update(userClient, organization.id, {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.datatype.uuid() },
                        isApproved: false,
                        name: faker.company.name(),
                    })
                })
            })
        })
    })
    describe('Validations', () => {
        describe('phone', () => {
            it('throw error when phone has invalid format', async () => {
                const admin = await makeLoggedInAdminClient()

                await expectToThrowGQLError(
                    async () => await createTestOrganization(admin, { phone: '42' }),
                    { ...COMMON_ERRORS.WRONG_PHONE_FORMAT, variable: ['data', 'phone'] },
                )
            })
        })
        describe('name', () => {
            test('cannot be empty', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestOrganization(admin, { name: '' })
                }, ERRORS.NAME_IS_EMPTY)

                const [org] = await createTestOrganization(admin)
                await expectToThrowGQLError(async () => {
                    await updateTestOrganization(admin, org.id, { name: '' })
                }, ERRORS.NAME_IS_EMPTY)
            })
            test('cannot be includes emails or url', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestOrganization(admin, { name: `${faker.lorem.sentence(5)}. ${faker.internet.url()}` })
                }, ERRORS.NAME_IS_INVALID)
                await expectToThrowGQLError(async () => {
                    await createTestOrganization(admin, { name: `${faker.lorem.sentence(5)}. ${faker.internet.email()}` })
                }, ERRORS.NAME_IS_INVALID)

                const [org] = await createTestOrganization(admin)
                await expectToThrowGQLError(async () => {
                    await updateTestOrganization(admin, org.id, { name: `${faker.lorem.sentence(5)}. ${faker.internet.url()}` })
                }, ERRORS.NAME_IS_INVALID)
                await expectToThrowGQLError(async () => {
                    await updateTestOrganization(admin, org.id, { name: `${faker.lorem.sentence(5)}. ${faker.internet.email()}` })
                }, ERRORS.NAME_IS_INVALID)
            })
            test('cannot be includes emails or url - repeated requests', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestOrganization(admin, { name: `${faker.lorem.sentence(5)}. ${faker.internet.url()}` })
                }, ERRORS.NAME_IS_INVALID)
                await expectToThrowGQLError(async () => {
                    await createTestOrganization(admin, { name: `${faker.lorem.sentence(5)}. ${faker.internet.url()}` })
                }, ERRORS.NAME_IS_INVALID)

                await expectToThrowGQLError(async () => {
                    await createTestOrganization(admin, { name: `${faker.lorem.sentence(5)}. ${faker.internet.email()}` })
                }, ERRORS.NAME_IS_INVALID)
                await expectToThrowGQLError(async () => {
                    await createTestOrganization(admin, { name: `${faker.lorem.sentence(5)}. ${faker.internet.email()}` })
                }, ERRORS.NAME_IS_INVALID)
            })
            test('cannot be includes cyrillic url', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestOrganization(admin, { name: 'http://КАКОЙ-ТО-САЙТ.РФ' })
                }, ERRORS.NAME_IS_INVALID)
                await expectToThrowGQLError(async () => {
                    await createTestOrganization(admin, { name: 'https://кликни-на-меня.рф' })
                }, ERRORS.NAME_IS_INVALID)
            })
            test('can be simple name', async () => {
                const [org, attrs1] = await createTestOrganization(admin, { name: '     ' + faker.company.name() + '     ' })
                expect(org.name).toBe(attrs1.name.trim())
                const [updatedOrg, attrs2] = await updateTestOrganization(admin, org.id, { name: '     ' + faker.company.name() + '     ' })
                expect(updatedOrg.name).toBe(attrs2.name.trim())
            })
        })
    })

    describe('subscription field', () => {
        beforeAll(() => {
            setFeatureFlag(SUBSCRIPTIONS, true)
        })

        afterAll(() => {
            setFeatureFlag(SUBSCRIPTIONS, false)
        })

        beforeEach(async () => {
            const plans = await SubscriptionPlan.getAll(admin)
            for (const plan of plans) {
                await SubscriptionPlan.softDelete(admin, plan.id)
            }
        })

        describe('when no plans exist', () => {
            test('returns far-future dates for all features', async () => {
                const [organization] = await createTestOrganization(admin, {
                    type: SERVICE_PROVIDER_TYPE,
                })

                const org = await Organization.getOne(admin, { id: organization.id })

                expect(org.subscription).not.toBeNull()
                const farFutureYear = dayjs().add(100, 'years').year()
                expect(org.subscription.paymentsEndAt).toContain(String(farFutureYear))
                expect(org.subscription.metersEndAt).toContain(String(farFutureYear))
                expect(org.subscription.ticketsEndAt).toContain(String(farFutureYear))
                expect(org.subscription.newsEndAt).toContain(String(farFutureYear))
                expect(org.subscription.marketplaceEndAt).toContain(String(farFutureYear))
                expect(org.subscription.supportEndAt).toContain(String(farFutureYear))
                expect(org.subscription.aiEndAt).toContain(String(farFutureYear))
                expect(org.subscription.customizationEndAt).toContain(String(farFutureYear))
                expect(org.subscription.propertiesEndAt).toContain(String(farFutureYear))
                expect(org.subscription.analyticsEndAt).toContain(String(farFutureYear))
            })

            test('computes far-future dates dynamically on each call', async () => {
                const [organization] = await createTestOrganization(admin, {
                    type: SERVICE_PROVIDER_TYPE,
                })

                const org1 = await Organization.getOne(admin, { id: organization.id })
                const date1 = org1.subscription.paymentsEndAt

                const org2 = await Organization.getOne(admin, { id: organization.id })
                const date2 = org2.subscription.paymentsEndAt

                expect(date1).toBe(date2)
                const expectedDate = dayjs().add(100, 'years').format('YYYY-MM-DD')
                expect(date1).toBe(expectedDate)
                expect(date2).toBe(expectedDate)
            })
        })

        test('returns null features when no contexts exist', async () => {
            const [organization] = await createTestOrganization(admin)
            await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription).not.toBeNull()
            expect(org.subscription.paymentsEndAt).toBeNull()
            expect(org.subscription.activeSubscriptionContextId).toBeNull()
        })

        test('returns feature dates from active context', async () => {
            const [organization] = await createTestOrganization(admin)
            const [b2bApp1] = await createTestB2BApp(admin)
            const [b2bApp2] = await createTestB2BApp(admin)
            const [b2cApp] = await createTestB2CApp(admin)
            const enabledB2BApps = [b2bApp1.id, b2bApp2.id]
            const enabledB2CApps = [b2cApp.id]
            const endAt = dayjs().add(30, 'days').format('YYYY-MM-DD')
            const [subscriptionPlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                isHidden: false,
                payments: true,
                meters: true,
                tickets: true,
                news: true,
                marketplace: true,
                support: false,
                ai: true,
                enabledB2BApps,
                enabledB2CApps,
            })
            await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().subtract(1, 'day').format('YYYY-MM-DD'),
                endAt,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription.paymentsEndAt).toBe(endAt)
            expect(org.subscription.metersEndAt).toBe(endAt)
            expect(org.subscription.ticketsEndAt).toBe(endAt)
            expect(org.subscription.newsEndAt).toBe(endAt)
            expect(org.subscription.marketplaceEndAt).toBe(endAt)
            expect(org.subscription.supportEndAt).toBeNull()
            expect(org.subscription.aiEndAt).toBe(endAt)
            expect(org.subscription.b2bApps).toEqual(expect.arrayContaining([
                { id: b2bApp1.id, endAt },
                { id: b2bApp2.id, endAt },
            ]))
            expect(org.subscription.b2cApps).toEqual(expect.arrayContaining([
                { id: b2cApp.id, endAt },
            ]))
            expect(org.subscription.activeSubscriptionContextId).toBeDefined()
        })

        test('returns latest date when multiple contexts active', async () => {
            const [organization] = await createTestOrganization(admin, {
                type: SERVICE_PROVIDER_TYPE,
            })
            const endAt1 = dayjs().add(30, 'days').format('YYYY-MM-DD')
            const endAt2 = dayjs().add(60, 'days').format('YYYY-MM-DD')
            const [lowPriorityPlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: SERVICE_PROVIDER_TYPE,
                priority: 1,
                news: true,
                marketplace: false,
            })
            const [highPriorityPlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: SERVICE_PROVIDER_TYPE,
                priority: 100,
                news: false,
                marketplace: true,
            })

            await createTestSubscriptionContext(admin, organization, lowPriorityPlan, {
                startAt: dayjs().subtract(1, 'day').format('YYYY-MM-DD'),
                endAt: endAt2,
                isTrial: false,
            })
            await createTestSubscriptionContext(admin, organization, highPriorityPlan, {
                startAt: dayjs().subtract(2, 'days').format('YYYY-MM-DD'),
                endAt: endAt1,
                isTrial: false,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription).not.toBeNull()
            expect(org.subscription.newsEndAt).toBe(endAt2)
            expect(org.subscription.marketplaceEndAt).toBe(endAt1)
        })

        test('includes future contexts without gaps', async () => {
            const [organization] = await createTestOrganization(admin)
            const endAt1 = dayjs().add(30, 'days').format('YYYY-MM-DD')
            const endAt2 = dayjs().add(60, 'days').format('YYYY-MM-DD')
            const [plan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                payments: true,
            })

            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: dayjs().subtract(1, 'day').format('YYYY-MM-DD'),
                endAt: endAt1,
                isTrial: false,
            })
            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: endAt1,
                endAt: endAt2,
                isTrial: false,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription).not.toBeNull()
            expect(org.subscription.paymentsEndAt).toBe(endAt2)
        })

        test('stops at gap between contexts', async () => {
            const [organization] = await createTestOrganization(admin)
            const endAt1 = dayjs().add(30, 'days').format('YYYY-MM-DD')
            const startAt2 = dayjs().add(32, 'days').format('YYYY-MM-DD')
            const endAt2 = dayjs().add(60, 'days').format('YYYY-MM-DD')
            const [plan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                payments: true,
            })

            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: dayjs().subtract(1, 'day').format('YYYY-MM-DD'),
                endAt: endAt1,
                isTrial: false,
            })
            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: startAt2,
                endAt: endAt2,
                isTrial: false,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription).not.toBeNull()
            expect(org.subscription.paymentsEndAt).toBe(endAt1)
        })

        test('ignores future contexts after gap', async () => {
            const [organization] = await createTestOrganization(admin)
            const endAt1 = dayjs().add(30, 'days').format('YYYY-MM-DD')
            const startAt2 = dayjs().add(32, 'days').format('YYYY-MM-DD')
            const endAt2 = dayjs().add(60, 'days').format('YYYY-MM-DD')
            
            const [plan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                payments: true,
                tickets: true,
            })

            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: dayjs().subtract(1, 'day').format('YYYY-MM-DD'),
                endAt: endAt1,
                isTrial: false,
            })
            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: startAt2,
                endAt: endAt2,
                isTrial: false,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription).not.toBeNull()
            expect(org.subscription.paymentsEndAt).toBe(endAt1)
            expect(org.subscription.ticketsEndAt).toBe(endAt1)
        })

        test('returns expiration date for expired context', async () => {
            const [organization] = await createTestOrganization(admin)
            const [subscriptionPlan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                payments: true,
            })
            const endAt = dayjs().subtract(1, 'day').format('YYYY-MM-DD')
            await createTestSubscriptionContext(admin, organization, subscriptionPlan, {
                startAt: dayjs().subtract(30, 'days').format('YYYY-MM-DD'),
                endAt,
                isTrial: true,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription).not.toBeNull()
            expect(org.subscription.paymentsEndAt).toBe(endAt)
            expect(org.subscription.activeSubscriptionContextId).toBeNull()
        })

        test('ignores historical gap and uses current active subscription', async () => {
            const [organization] = await createTestOrganization(admin)
            const [plan] = await createTestSubscriptionPlan(admin, {
                organizationType: MANAGING_COMPANY_TYPE,
                payments: true,
                tickets: true,
            })

            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: dayjs().subtract(12, 'months').format('YYYY-MM-DD'),
                endAt: dayjs().subtract(6, 'months').format('YYYY-MM-DD'),
                isTrial: false,
            })

            const currentEndAt = dayjs().add(11, 'months').format('YYYY-MM-DD')
            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: dayjs().subtract(1, 'month').format('YYYY-MM-DD'),
                endAt: currentEndAt,
                isTrial: false,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription).not.toBeNull()
            expect(org.subscription.paymentsEndAt).toBe(currentEndAt)
            expect(org.subscription.ticketsEndAt).toBe(currentEndAt)
        })

        test('returns activeSubscriptionEndAt for active subscription', async () => {
            const [organization] = await createTestOrganization(admin)
            const endAt = dayjs().add(30, 'days').format('YYYY-MM-DD')
            const [plan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                payments: true,
            })

            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: dayjs().subtract(1, 'day').format('YYYY-MM-DD'),
                endAt,
                isTrial: false,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription).not.toBeNull()
            expect(org.subscription.activeSubscriptionEndAt).toBe(endAt)
            expect(org.subscription.activeSubscriptionContextId).toBeDefined()
        })

        test('returns null activeSubscriptionEndAt when no active subscription', async () => {
            const [organization] = await createTestOrganization(admin)
            const [plan] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                payments: true,
            })

            await createTestSubscriptionContext(admin, organization, plan, {
                startAt: dayjs().subtract(60, 'days').format('YYYY-MM-DD'),
                endAt: dayjs().subtract(30, 'days').format('YYYY-MM-DD'),
                isTrial: false,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription).not.toBeNull()
            expect(org.subscription.activeSubscriptionEndAt).toBeNull()
            expect(org.subscription.activeSubscriptionContextId).toBeNull()
        })

        test('returns far future end date for apps from plans of different organization type', async () => {
            const [organization] = await createTestOrganization(admin, {
                type: MANAGING_COMPANY_TYPE,
            })
            const [b2bAppForMC] = await createTestB2BApp(admin)
            const [b2bAppForSP] = await createTestB2BApp(admin)
            const [b2cAppForSP] = await createTestB2CApp(admin)
            
            const endAt = dayjs().add(30, 'days').format('YYYY-MM-DD')
            const futureDate = dayjs().add(100, 'years').format('YYYY-MM-DD')
            
            const [planForMC] = await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: MANAGING_COMPANY_TYPE,
                isHidden: false,
                enabledB2BApps: [b2bAppForMC.id],
            })
            
            await createTestSubscriptionPlan(admin, {
                name: faker.commerce.productName(),
                organizationType: SERVICE_PROVIDER_TYPE,
                isHidden: false,
                enabledB2BApps: [b2bAppForSP.id],
                enabledB2CApps: [b2cAppForSP.id],
            })
            
            await createTestSubscriptionContext(admin, organization, planForMC, {
                startAt: dayjs().subtract(1, 'day').format('YYYY-MM-DD'),
                endAt,
            })

            const org = await Organization.getOne(admin, { id: organization.id })

            expect(org.subscription.b2bApps).toHaveLength(2)
            expect(org.subscription.b2cApps).toHaveLength(1)
            
            const b2bAppForMCResult = org.subscription.b2bApps.find(app => app.id === b2bAppForMC.id)
            const b2bAppForSPResult = org.subscription.b2bApps.find(app => app.id === b2bAppForSP.id)
            const b2cAppForSPResult = org.subscription.b2cApps.find(app => app.id === b2cAppForSP.id)
            
            expect(b2bAppForMCResult.endAt).toBe(endAt)
            expect(b2bAppForSPResult.endAt).toBe(futureDate)
            expect(b2cAppForSPResult.endAt).toBe(futureDate)
        })
    })
})
