/**
 * Generated by `createschema organization.OrganizationEmployeeRole 'organization:Relationship:Organization:CASCADE; name:Text; statusTransitions:Json; canManageOrganization:Checkbox; canManageEmployees:Checkbox; canManageRoles:Checkbox; canManageIntegrations:Checkbox; canManageProperties:Checkbox; canManageTickets:Checkbox;' --force`
 */

const { DEFAULT_STATUS_TRANSITIONS } = require('@condo/domains/ticket/constants/statusTransitions')
const { createTestOrganizationEmployee } = require('../utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')
const { createTestOrganization } = require('../utils/testSchema')
const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE } = require('@open-condo/keystone/test.utils')

const { OrganizationEmployeeRole, createTestOrganizationEmployeeRole, updateTestOrganizationEmployeeRole } = require('@condo/domains/organization/utils/testSchema')
const { expectToThrowAuthenticationErrorToObjects, expectToThrowAccessDeniedErrorToObj, expectToThrowAuthenticationErrorToObj } = require('@open-condo/keystone/test.utils')
const { getTranslations, getAvailableLocales } = require('@open-condo/locales/loader')
const { DEFAULT_ROLES } = require('../constants/common')
const { makeClientWithRegisteredOrganization } = require('../utils/testSchema/Organization')
const { ORGANIZATION_TICKET_VISIBILITY, PROPERTY_TICKET_VISIBILITY, ASSIGNED_TICKET_VISIBILITY, PROPERTY_AND_SPECIALIZATION_VISIBILITY } = require('@condo/domains/scope/constants')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { createTestTicket, Ticket, createTestTicketClassifier } = require('@condo/domains/ticket/utils/testSchema')
const { createTestPropertyScope, createTestPropertyScopeProperty, createTestPropertyScopeOrganizationEmployee, createTestSpecializationScope } = require('@condo/domains/scope/utils/testSchema')

describe('OrganizationEmployeeRole', () => {
    describe('defaults', () => {
        it('has default values for ability attributes, according to schema defaults', async () => {
            const admin = await makeLoggedInAdminClient()
            const [organization] = await createTestOrganization(admin)
            const [obj] = await createTestOrganizationEmployeeRole(admin, organization)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.canManageOrganization).toBeFalsy()
            expect(obj.canManageEmployees).toBeFalsy()
            expect(obj.canManageRoles).toBeFalsy()
            expect(obj.canManageIntegrations).toBeFalsy()
            expect(obj.canManageProperties).toBeFalsy()
            expect(obj.canManageTickets).toBeFalsy()
            expect(obj.canManageContacts).toBeFalsy()
            expect(obj.canManageContactRoles).toBeFalsy()
            expect(obj.canManageTicketComments).toBeTruthy()
            expect(obj.canManageDivisions).toBeFalsy()
            expect(obj.canShareTickets).toBeTruthy()
            expect(obj.canBeAssignedAsResponsible).toBeTruthy()
            expect(obj.canBeAssignedAsExecutor).toBeTruthy()
            expect(obj.canReadPayments).toBeFalsy()
            expect(obj.canReadBillingReceipts).toBeFalsy()
            expect(obj.nameNonLocalized).toEqual(obj.name)
            expect(obj.descriptionNonLocalized).toEqual(obj.description)
            expect(obj.ticketVisibilityType).toEqual(ORGANIZATION_TICKET_VISIBILITY)
        })
    })
    describe('user: create OrganizationEmployeeRole', () => {

        it('can with granted "canManageRoles" permission', async () => {
            const admin = await makeLoggedInAdminClient()
            const [organization] = await createTestOrganization(admin)
            const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                canManageRoles: true,
            })
            const managerUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
            await createTestOrganizationEmployee(admin, organization, managerUserClient.user, role)

            const [obj, attrs] = await createTestOrganizationEmployeeRole(managerUserClient, organization)

            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.name).toEqual(attrs.name)
            expect(obj.statusTransitions).toMatchObject(DEFAULT_STATUS_TRANSITIONS)
            expect(obj.organization).toEqual(expect.objectContaining({ id: organization.id }))
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: managerUserClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: managerUserClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
        })

        it('cannot without granted "canManageRoles" permission', async () => {
            const admin = await makeLoggedInAdminClient()
            const [organization] = await createTestOrganization(admin)
            const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                canManageRoles: false,
            })
            const notManagerUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
            await createTestOrganizationEmployee(admin, organization, notManagerUserClient.user, role)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestOrganizationEmployeeRole(notManagerUserClient, organization)
            })
        })

    })

    test('anonymous: create OrganizationEmployeeRole', async () => {
        const admin = await makeLoggedInAdminClient()
        const [organization] = await createTestOrganization(admin)
        const anonymous = await makeClient()
        await expectToThrowAuthenticationErrorToObj(async () => {
            await createTestOrganizationEmployeeRole(anonymous, organization)
        })
    })

    describe('user: read OrganizationEmployeeRole', () => {

        it('can only for organization it employed in', async () => {
            const admin = await makeLoggedInAdminClient()
            const [organization] = await createTestOrganization(admin)
            const [role, attrs] = await createTestOrganizationEmployeeRole(admin, organization)
            const employeeUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
            await createTestOrganizationEmployee(admin, organization, employeeUserClient.user, role)

            const [anotherOrganization] = await createTestOrganization(admin)
            await createTestOrganizationEmployeeRole(admin, anotherOrganization)

            const objs = await OrganizationEmployeeRole.getAll(employeeUserClient, {}, { sortBy: ['updatedAt_DESC'] })

            expect(objs).toHaveLength(1)
            expect(objs[0].id).toMatch(role.id)
            expect(objs[0].dv).toEqual(1)
            expect(objs[0].sender).toEqual(attrs.sender)
            expect(objs[0].v).toEqual(1)
            expect(objs[0].createdBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            expect(objs[0].updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            expect(objs[0].createdAt).toMatch(role.createdAt)
            expect(objs[0].updatedAt).toMatch(role.updatedAt)
        })

    })

    test('anonymous: read OrganizationEmployeeRole', async () => {
        const admin = await makeLoggedInAdminClient()
        const [organization] = await createTestOrganization(admin)
        await createTestOrganizationEmployeeRole(admin, organization)

        const anonymous = await makeClient()
        await expectToThrowAuthenticationErrorToObjects(async () => {
            await OrganizationEmployeeRole.getAll(anonymous)
        })
    })

    describe('user: update OrganizationEmployeeRole', () => {

        it('can with granted "canManageRoles" permission', async () => {
            const admin = await makeLoggedInAdminClient()
            const [organization] = await createTestOrganization(admin)
            const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                canManageRoles: true,
            })
            const managerUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
            await createTestOrganizationEmployee(admin, organization, managerUserClient.user, role)

            const [objUpdated, attrs] = await updateTestOrganizationEmployeeRole(managerUserClient, role.id)

            expect(objUpdated.id).toEqual(role.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.name).toEqual(attrs.name)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: managerUserClient.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('cannot without granted "canManageRoles" permission', async () => {
            const admin = await makeLoggedInAdminClient()
            const [organization] = await createTestOrganization(admin)
            const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                canManageRoles: false,
            })
            const managerUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
            await createTestOrganizationEmployee(admin, organization, managerUserClient.user, role)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestOrganizationEmployeeRole(managerUserClient, role.id)
            })
        })

    })

    test('anonymous: update OrganizationEmployeeRole', async () => {
        const admin = await makeLoggedInAdminClient()
        const [organization] = await createTestOrganization(admin)
        const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageRoles: false,
        })
        const managerUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
        await createTestOrganizationEmployee(admin, organization, managerUserClient.user, role)

        const client = await makeClient()

        await expectToThrowAuthenticationErrorToObj(async () => {
            await updateTestOrganizationEmployeeRole(client, role.id)
        })
    })

    test('user: delete OrganizationEmployeeRole', async () => {
        const admin = await makeLoggedInAdminClient()
        const [organization] = await createTestOrganization(admin)
        const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageRoles: true,
        })
        const managerUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
        await createTestOrganizationEmployee(admin, organization, managerUserClient.user, role)

        let thrownError
        try {
            await OrganizationEmployeeRole.delete(managerUserClient, role.id)
        } catch (e) {
            thrownError = e
        }
        expect(thrownError).toBeDefined()
        // Method `toMatchObject` is not suitable here, because error message contains suggestions, generated by Keystone:
        // > Cannot query field "deleteOrganizationEmployeeRole" on type "Mutation". Did you mean "createOrganizationEmployeeRole", "deleteOrganizationEmployee", "deleteOrganizationEmployees", "updateOrganizationEmployeeRole", or "createOrganizationEmployeeRoles"?
        // We don't know this suggestions list in advance.
        expect(thrownError.errors[0].message).toMatch('Cannot query field "deleteOrganizationEmployeeRole" on type "Mutation"')
        expect(thrownError.errors[0].name).toMatch('ValidationError')
    })

    test('anonymous: delete OrganizationEmployeeRole', async () => {
        const admin = await makeLoggedInAdminClient()
        const [organization] = await createTestOrganization(admin)
        const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageRoles: true,
        })

        const anonymous = await makeClient()
        let thrownError
        try {
            await OrganizationEmployeeRole.delete(anonymous, role.id)
        } catch (e) {
            thrownError = e
        }
        expect(thrownError).toBeDefined()
        // Method `toMatchObject` is not suitable here, because error message contains suggestions, generated by Keystone:
        // > Cannot query field "deleteOrganizationEmployeeRole" on type "Mutation". Did you mean "createOrganizationEmployeeRole", "deleteOrganizationEmployee", "deleteOrganizationEmployees", "updateOrganizationEmployeeRole", or "createOrganizationEmployeeRoles"?
        // We don't know this suggestions list in advance.
        expect(thrownError.errors[0].message).toMatch('Cannot query field "deleteOrganizationEmployeeRole" on type "Mutation"')
        expect(thrownError.errors[0].name).toMatch('ValidationError')
    })

    describe('ticket visibility type', () => {
        describe('organization', () => {
            it('can read tickets in organization where user is employee', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: ORGANIZATION_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property)

                const readTicket = await Ticket.getOne(userClient, { id: ticket.id })

                expect(readTicket.id).toMatch(ticket.id)
            })

            it('cannot read tickets in organization where user is not employee', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [organization1] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: ORGANIZATION_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization1)
                const [ticket] = await createTestTicket(admin, organization1, property)

                const readTicket = await Ticket.getOne(userClient, { id: ticket.id })

                expect(readTicket).toBeUndefined()
            })
        })

        describe('property', () => {
            it('can read tickets organization ticket if employee in PropertyScope with hasAllProperties flag', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization, {
                    hasAllProperties: true,
                })
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)

                const [ticket1] = await createTestTicket(admin, organization, property)
                const [ticket2] = await createTestTicket(admin, organization, property2)

                const tickets = await Ticket.getAll(userClient, {
                    id_in: [ticket1.id, ticket2.id],
                }, { sortBy: 'createdAt_ASC' })

                expect(tickets).toHaveLength(2)
                expect(tickets[0].id).toEqual(ticket1.id)
                expect(tickets[1].id).toEqual(ticket2.id)
            })

            it('can read tickets in properties from PropertyScope where this employee is', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)
                const [property3] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)
                await createTestPropertyScopeProperty(admin, propertyScope, property2)
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)

                const [ticket1] = await createTestTicket(admin, organization, property)
                const [ticket2] = await createTestTicket(admin, organization, property2)
                const [ticket3] = await createTestTicket(admin, organization, property3)

                const tickets = await Ticket.getAll(userClient, {
                    id_in: [ticket1.id, ticket2.id, ticket3.id],
                }, { sortBy: 'createdAt_ASC' })

                expect(tickets).toHaveLength(2)
                expect(tickets[0].id).toEqual(ticket1.id)
                expect(tickets[1].id).toEqual(ticket2.id)
            })

            it('can read tickets where employee is executor or assignee', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property, {
                    assignee: { connect: { id: userClient.user.id } },
                })
                const [ticket1] = await createTestTicket(admin, organization, property, {
                    executor: { connect: { id: userClient.user.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property)

                const readTickets = await Ticket.getAll(userClient, { id_in: [ticket.id, ticket1.id, ticket2.id] },
                    { sortBy: 'createdAt_ASC' })

                expect(readTickets).toHaveLength(2)
                expect(readTickets[0].id).toEqual(ticket.id)
                expect(readTickets[1].id).toEqual(ticket1.id)
            })

            it('cannot read tickets if there no PropertyScope in which employee is', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property)

                const readTicket = await Ticket.getOne(userClient, { id: ticket.id })

                expect(readTicket).toBeUndefined()
            })

            it('cannot read tickets with properties which are in the PropertyScope where employee is not', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)

                const [ticket1] = await createTestTicket(admin, organization, property)

                const readTicketsByClient = await Ticket.getOne(userClient, {
                    id: ticket1.id,
                })

                expect(readTicketsByClient).toBeUndefined()
            })
        })

        describe('property and specialization', () => {
            it('can read tickets with TicketCategoryClassifier matches to employee SpecializationScope ' +
                'and property from PropertyScope where this employee is', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                const [classifier1] = await createTestTicketClassifier(admin)
                const [classifier2] = await createTestTicketClassifier(admin)
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)

                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)
                await createTestSpecializationScope(admin, employee, classifier1.category)

                const [ticket1] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier1.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier2.id } },
                })
                const [ticket3] = await createTestTicket(admin, organization, property2, {
                    classifier: { connect: { id: classifier2.id } },
                })

                const tickets = await Ticket.getAll(userClient, {
                    id_in: [ticket1.id, ticket2.id, ticket3.id],
                }, { sortBy: 'createdAt_ASC' })

                expect(tickets).toHaveLength(1)
                expect(tickets[0].id).toEqual(ticket1.id)
            })

            it('can read tickets where employee is executor or assignee', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property, {
                    assignee: { connect: { id: userClient.user.id } },
                })
                const [ticket1] = await createTestTicket(admin, organization, property, {
                    executor: { connect: { id: userClient.user.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property)

                const readTickets = await Ticket.getAll(userClient, { id_in: [ticket.id, ticket1.id, ticket2.id] },
                    { sortBy: 'createdAt_ASC' })

                expect(readTickets).toHaveLength(2)
                expect(readTickets[0].id).toEqual(ticket.id)
                expect(readTickets[1].id).toEqual(ticket1.id)
            })

            it('cannot read tickets with TicketCategoryClassifier matches to employee SpecializationScope ' +
                'and there no property from PropertyScope where this employee is', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                const [classifier1] = await createTestTicketClassifier(admin)
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)

                await createTestSpecializationScope(admin, employee, classifier1.category)

                const [ticket1] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier1.id } },
                })

                const readTicket = await Ticket.getOne(userClient, {
                    id: ticket1.id,
                })

                expect(readTicket).toBeUndefined()
            })

            it('cannot read tickets with property from PropertyScope where this employee is ' +
                'and TicketCategoryClassifier not matches to employee SpecializationScope', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: PROPERTY_AND_SPECIALIZATION_VISIBILITY,
                })
                const [classifier] = await createTestTicketClassifier(admin)
                const [employee] = await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [propertyScope] = await createTestPropertyScope(admin, organization)
                await createTestPropertyScopeProperty(admin, propertyScope, property)
                await createTestPropertyScopeOrganizationEmployee(admin, propertyScope, employee)

                const [ticket] = await createTestTicket(admin, organization, property, {
                    classifier: { connect: { id: classifier.id } },
                })

                const readTicket = await Ticket.getOne(userClient, {
                    id: ticket.id,
                })

                expect(readTicket).toBeUndefined()
            })
        })

        describe('assigned', () => {
            it('can read only tickets where employee is executor or assignee', async () => {
                const admin = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                    ticketVisibilityType: ASSIGNED_TICKET_VISIBILITY,
                })
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)

                const [property] = await createTestProperty(admin, organization)
                const [ticket] = await createTestTicket(admin, organization, property, {
                    assignee: { connect: { id: userClient.user.id } },
                })
                const [ticket1] = await createTestTicket(admin, organization, property, {
                    executor: { connect: { id: userClient.user.id } },
                })
                const [ticket2] = await createTestTicket(admin, organization, property)

                const readTickets = await Ticket.getAll(userClient, { id_in: [ticket.id, ticket1.id, ticket2.id] },
                    { sortBy: 'createdAt_ASC' })

                expect(readTickets).toHaveLength(2)
                expect(readTickets[0].id).toEqual(ticket.id)
                expect(readTickets[1].id).toEqual(ticket1.id)
            })
        })
    })

    test.each(getAvailableLocales())('localization [%s]: static roles has translations', async (locale) => {

        const translations = getTranslations(locale)

        const client = await makeClientWithRegisteredOrganization()
        client.setHeaders({
            'Accept-Language': locale,
        })

        const defaultRolesInstances = await OrganizationEmployeeRole.getAll(client, {
            organization: { id: client.organization.id },
        })
        Object.values(DEFAULT_ROLES).forEach(staticRole => {
            const nameTranslation = translations[staticRole.name]
            const descriptionTranslation = translations[staticRole.description]
            const defaultRoleInstance = Object.values(defaultRolesInstances).find(x => x.name === nameTranslation && x.description === descriptionTranslation)
            expect(defaultRoleInstance).toBeDefined()
        })
    })
})
