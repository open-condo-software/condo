/**
 * Generated by `createschema organization.OrganizationEmployee 'organization:Relationship:Organization:CASCADE; user:Relationship:User:SET_NULL; inviteCode:Text; name:Text; email:Text; phone:Text; role:Relationship:OrganizationEmployeeRole:SET_NULL; isAccepted:Checkbox; isRejected:Checkbox' --force`
 */
const { getByCondition } = require('@core/keystone/schema')
const { getById } = require('@core/keystone/schema')
const { throwAuthenticationError } = require('@condo/domains/common/utils/apolloErrorFormatter')
const { queryOrganizationEmployeeFor, queryOrganizationEmployeeFromRelatedOrganizationFor } = require('../utils/accessSchema')
const { USER_SCHEMA_NAME } = require('@condo/domains/common/constants/utils')

async function canReadOrganizationEmployees ({ authentication: { item, listKey } }) {
    if (!listKey || !item) return throwAuthenticationError()
    if (item.deletedAt) return false

    if (listKey === USER_SCHEMA_NAME) {
        if (item.isSupport || item.isAdmin) return {}
        const userId = item.id

        return {
            OR: [
                { user: { id: userId } },
                {
                    organization: {
                        OR: [
                            queryOrganizationEmployeeFor(userId),
                            queryOrganizationEmployeeFromRelatedOrganizationFor(userId),
                        ],
                    },
                },
            ],
        }
    }

    return false
}

async function canManageOrganizationEmployees ({ authentication: { item, listKey }, originalInput, operation, itemId }) {
    if (!listKey || !item) return throwAuthenticationError()
    if (item.deletedAt) return false

    if (listKey === USER_SCHEMA_NAME) {
        if (item.isAdmin) return true

        if (operation === 'create') {
            const employeeForUser = await getByCondition('OrganizationEmployee', {
                organization: { id: originalInput.organization.connect.id },
                user: { id: item.id },
                deletedAt: null,
                isBlocked: false,
            })

            if (!employeeForUser) {
                return false
            }

            const employeeRole = await getByCondition('OrganizationEmployeeRole', {
                id: employeeForUser.role,
                organization: { id: employeeForUser.organization },
            })

            return !!(employeeRole && employeeRole.canManageEmployees)
        }

        if (operation === 'update' && itemId) {
            const employeeToEdit = await getById('OrganizationEmployee', itemId)

            if (!employeeToEdit || !employeeToEdit.organization) return false

            const employeeForUser = await getByCondition('OrganizationEmployee', {
                organization: { id: employeeToEdit.organization },
                user: { id: item.id },
                deletedAt: null,
                isBlocked: false,
            })

            if (!employeeForUser || !employeeForUser.role) {
                return false
            }

            const employeeRole = await getByCondition('OrganizationEmployeeRole', {
                id: employeeForUser.role,
                organization: { id: employeeToEdit.organization },
            })
            if (!employeeRole) return false

            return employeeRole.canManageEmployees
        }
    }

    return false
}

/*
  Rules are logical functions that used for list access, and may return a boolean (meaning
  all or no items are available) or a set of filters that limit the available items.
*/
module.exports = {
    canReadOrganizationEmployees,
    canManageOrganizationEmployees,
}
