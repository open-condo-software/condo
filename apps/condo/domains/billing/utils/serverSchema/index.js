/**
 * Generated by `createschema billing.BillingIntegration name:Text;`
 * In most cases you should not change it by hands
 * Please, don't remove `AUTOGENERATE MARKER`s
 */

const Big = require('big.js')

const { generateServerUtils } = require('@open-condo/codegen/generate.server.utils')
const { execGqlWithoutAccess } = require('@open-condo/codegen/generate.server.utils')
const { find, getById } = require('@open-condo/keystone/schema')

const { PAYMENT_DONE_STATUS, PAYMENT_WITHDRAWN_STATUS } = require('@condo/domains/acquiring/constants/payment')
const { REGISTER_BILLING_RECEIPTS_MUTATION } = require('@condo/domains/billing/gql')
const { VALIDATE_QRCODE_MUTATION } = require('@condo/domains/billing/gql')
const { SEND_NEW_BILLING_RECEIPT_FILES_NOTIFICATIONS_MUTATION } = require('@condo/domains/billing/gql')
const { REGISTER_BILLING_RECEIPT_FILE_MUTATION } = require('@condo/domains/billing/gql')
const { SUM_BILLING_RECEIPTS_QUERY } = require('@condo/domains/billing/gql')
const { SEND_RESIDENT_MESSAGE_MUTATION } = require('@condo/domains/resident/gql')
/* AUTOGENERATE MARKER <IMPORT> */

const BillingIntegration = generateServerUtils('BillingIntegration')
const BillingIntegrationAccessRight = generateServerUtils('BillingIntegrationAccessRight')
const BillingIntegrationOrganizationContext = generateServerUtils('BillingIntegrationOrganizationContext')
const BillingIntegrationProblem = generateServerUtils('BillingIntegrationProblem')
const BillingProperty = generateServerUtils('BillingProperty')
const BillingAccount = generateServerUtils('BillingAccount')
const BillingReceipt = generateServerUtils('BillingReceipt')
const BillingRecipient = generateServerUtils('BillingRecipient')
const BillingCategory = generateServerUtils('BillingCategory')
const BillingReceiptFile = generateServerUtils('BillingReceiptFile')

async function registerBillingReceipts (context, data) {
    if (!context) throw new Error('no context')
    if (!data) throw new Error('no data')
    if (!data.sender) throw new Error('no data.sender')

    return await execGqlWithoutAccess(context, {
        query: REGISTER_BILLING_RECEIPTS_MUTATION,
        variables: { data: { dv: 1, ...data } },
        errorMessage: '[error] Unable to registerBillingReceipts',
        dataPath: 'result',
    })
}

/**
 * Sums up all DONE or WITHDRAWN payments for billingReceipt, connected by receiptId
 * @param receiptId {string}
 * @return {Promise<*>}
 */
const getPaymentsSum = async (receiptId) => {
    const payments = await find('Payment', {
        AND: [
            { status_in: [PAYMENT_DONE_STATUS, PAYMENT_WITHDRAWN_STATUS] },
            { deletedAt: null },
            { receipt: { id: receiptId } },
        ],
    })
    return payments.reduce((total, current) => (Big(total).plus(current.amount)), 0).toFixed(8).toString()
}

/**
 * Sums up all new Payments for receipt
 * The payment is new - if the BillingReceipt has not been updated since the payment was transferred to the organization or was not transferred yet
 * @param receiptId {string}
 * @return {Promise<*>}
 */
const getNewPaymentsSum = async (receiptId) => {
    const receipt = await getById('BillingReceipt', receiptId)
    const defaultConditions = [
        { status_in: [PAYMENT_DONE_STATUS, PAYMENT_WITHDRAWN_STATUS] },
        { deletedAt: null },
    ]
    // NOTE(YEgorLu): this is hack to know, that BillingReceipt.toPay was reduced by Managing Company during update
    // When Company uploads receipt, we know it is same receipt with different "toPay", we set "balanceUpdatedAt"
    // In that case all payments with "transferDate" <= "balanceUpdatedAt" should already be calculated in "toPay" by Managing Company
    if (receipt.balanceUpdatedAt) {
        defaultConditions.push({
            OR: [
                { transferDate: null },
                { transferDate_gte: new Date(receipt.balanceUpdatedAt).toISOString() },
            ],
        })
    }
    const conditionsByReceipt = [
        { receipt: { id: receiptId } },
        ...defaultConditions,
    ]
    let payments = await find('Payment', {
        AND: conditionsByReceipt,
    })
    const billingContext = await getById('BillingIntegrationOrganizationContext', receipt.context)
    const account = await getById('BillingAccount', receipt.account)
    if (billingContext && account) {
        const conditionsWithNoReceipt = [
            { receipt_is_null: true },
            { invoice_is_null: true },
            { organization: { id: billingContext.organization } },
            { period: receipt.period },
            { accountNumber: account.number },
            ...defaultConditions,
        ]
        const qrPayments = await find('Payment', {
            AND: conditionsWithNoReceipt,
        })
        payments = payments.concat(qrPayments)
    }
    return payments.reduce((total, current) => (Big(total).plus(current.amount)), 0).toFixed(8).toString()
}

/**
 *
 * @param context
 * @param data
 * @returns {Promise<*>}
 */
async function sendNewReceiptMessagesToResidentScopes (context, data) {
    if (!context) throw new Error('no context')
    if (!data) throw new Error('no data')
    if (!data.sender) throw new Error('no data.sender')

    return await execGqlWithoutAccess(context, {
        query: SEND_RESIDENT_MESSAGE_MUTATION,
        variables: { data: { dv: 1, ...data } },
        errorMessage: '[error] Unable to sendNewReceiptMessagesToResidentScopes',
        dataPath: 'result',
    })
}

async function validateQRCode (context, data) {
    if (!context) throw new Error('no context')
    if (!data) throw new Error('no data')
    if (!data.sender) throw new Error('no data.sender')

    return await execGqlWithoutAccess(context, {
        query: VALIDATE_QRCODE_MUTATION,
        variables: { data: { dv: 1, ...data } },
        errorMessage: '[error] Unable to validateQRCode',
        dataPath: 'result',
    })
}

async function sendNewBillingReceiptFilesNotifications (context, data) {
    if (!context) throw new Error('no context')
    if (!data) throw new Error('no data')
    if (!data.sender) throw new Error('no data.sender')

    return await execGqlWithoutAccess(context, {
        query: SEND_NEW_BILLING_RECEIPT_FILES_NOTIFICATIONS_MUTATION,
        variables: { data: { dv: 1, ...data } },
        errorMessage: '[error] Unable to sendNewBillingReceiptFilesNotifications',
        dataPath: 'result',
    })
}

async function registerBillingReceiptFile (context, data) {
    if (!context) throw new Error('no context')
    if (!data) throw new Error('no data')
    if (!data.sender) throw new Error('no data.sender')
    return await execGqlWithoutAccess(context, {
        query: REGISTER_BILLING_RECEIPT_FILE_MUTATION,
        variables: { data: { dv: 1, ...data } },
        errorMessage: '[error] Unable to registerBillingReceiptFile',
        dataPath: 'obj',
    })
}

async function sumBillingReceipts (context, data) {
    if (!context) throw new Error('no context')
    if (!data) throw new Error('no data')
    if (!data.sender) throw new Error('no data.sender')

    return await execGqlWithoutAccess(context, {
        query: SUM_BILLING_RECEIPTS_QUERY,
        variables: { data: { dv: 1, ...data } },
        errorMessage: '[error] Unable to sumBillingReceipts',
        dataPath: 'obj',
    })
}

/* AUTOGENERATE MARKER <CONST> */

module.exports = {
    BillingIntegration,
    BillingIntegrationAccessRight,
    BillingIntegrationOrganizationContext,
    BillingIntegrationProblem,
    BillingProperty,
    BillingAccount,
    BillingReceipt,
    BillingRecipient,
    BillingCategory,
    registerBillingReceipts,
    getPaymentsSum,
    getNewPaymentsSum,
    sendNewReceiptMessagesToResidentScopes,
    BillingReceiptFile,
    validateQRCode,
    sendNewBillingReceiptFilesNotifications,
    sumBillingReceipts,
    registerBillingReceiptFile,
/* AUTOGENERATE MARKER <EXPORTS> */
}
