/**
 * Generated by `createservice resident.SendNewReceiptMessagesToResidentScopesService --type mutations`
 */
const dayjs = require('dayjs')
const { isEmpty, get, uniq, compact } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/billing/access/SendNewReceiptMessagesToResidentScopesService')
const { BillingCategory, BillingIntegrationOrganizationContext } = require('@condo/domains/billing/utils/serverSchema')
const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { DATE_FORMAT } = require('@condo/domains/common/utils/date')
const { getStartDates } = require('@condo/domains/common/utils/date')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE } = require('@condo/domains/notification/constants/constants')
const { Property } = require('@condo/domains/property/utils/serverSchema')
const { sendMessageToResidentScopes } = require('@condo/domains/resident/utils/serverSchema')

const { isValidDateValue } = require('../utils/validation.utils')

const UNIQ_KEY_TEMPLATE = ['{categoryId}', '{period}', '{residentId}'].join(':')
const MUTATION_NAME = 'sendNewReceiptMessagesToResidentScopes'

const ERRORS = {
    INVALID_PERIOD_PROVIDED: {
        mutation: MUTATION_NAME,
        variable: ['data', 'context'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: `Please provide proper period not before start of previous and not later than start of current month, valid format is ${DATE_FORMAT}`,
        messageForUser: `api.billing.${MUTATION_NAME}.INVALID_PERIOD_PROVIDED`,
    },
    INVALID_BILLING_CONTEXT_PROVIDED: {
        mutation: MUTATION_NAME,
        variable: ['data', 'billingIntegrationContext'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Please provide existing non-deleted billing integration organization context id',
        messageForUser: `api.billing.${MUTATION_NAME}.INVALID_BILLING_CONTEXT_PROVIDED`,
    },
    INVALID_BILLING_CATEGORY_PROVIDED: {
        mutation: MUTATION_NAME,
        variable: ['data', 'context'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Please provide existing non-deleted billing category id',
        messageForUser: `api.billing.${MUTATION_NAME}.INVALID_BILLING_CATEGORY_PROVIDED`,
    },
    SCOPES_IS_EMPTY: {
        mutation: MUTATION_NAME,
        variable: ['data', 'scopes'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Scopes could not be empty',
        messageForUser: `api.billing.${MUTATION_NAME}.SCOPES_IS_EMPTY`,
    },
    INVALID_PROPERTY_PROVIDED: {
        mutation: MUTATION_NAME,
        variable: ['data', 'scopes'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'All provided properties in scopes should be non-deleted & connected to organization of the billing context',
        messageForUser: `api.billing.${MUTATION_NAME}.INVALID_PROPERTY_PROVIDED`,
    },
}

/**
 * Validate data for SendNewReceiptMessagesToResidentScopesService.
 * Throws typed errors on invalid values.
 * Prepares data for sendNewReceiptMessagesToResidentScopesTask
 * @param context
 * @param data
 * @returns {Promise<{categoryData: (*), period: 'YYYY-MM-01'}>}
 */
const validateAndNormalizeData = async (context, data) => {
    const { context: billingIntegrationContext, scopes, category, period: periodRaw } = data

    /** Validate period */
    if (!isValidDateValue(periodRaw)) throw new GQLError(ERRORS.INVALID_PERIOD_PROVIDED, context)

    const periodDt = dayjs(periodRaw)
    const { prevMonthStart, currMonthStart  } = getStartDates()

    if (!periodRaw || !periodDt.isValid()) throw new GQLError(ERRORS.INVALID_PERIOD_PROVIDED, context)

    const period = dayjs(periodDt).startOf('month')

    if (period.isAfter(currMonthStart) || period.isBefore(prevMonthStart)) throw new GQLError(ERRORS.INVALID_PERIOD_PROVIDED, context)

    /** Validate scopes */
    if (isEmpty(scopes)) throw new GQLError(ERRORS.SCOPES_IS_EMPTY, context)

    /** validate category id */
    const categoryData = await BillingCategory.getOne(context, { id: category.id, deletedAt: null })

    if (isEmpty(categoryData)) throw new GQLError(ERRORS.INVALID_BILLING_CATEGORY_PROVIDED, context)

    /** validate billing context id */
    const contextData = await BillingIntegrationOrganizationContext.getOne(context, { id: billingIntegrationContext.id, deletedAt: null, status: CONTEXT_FINISHED_STATUS })
    const organizationId = get(contextData, 'organization.id')

    /** Validate organization id */
    if (isEmpty(organizationId)) throw new GQLError(ERRORS.INVALID_BILLING_CONTEXT_PROVIDED, context)

    /** check if all properties in scopes are connected to proper organization */
    const propertyIds = scopes.map(scope => scope.property.id)
    const uniqPropertyIds = uniq(compact(propertyIds))
    const propertiesCount = await Property.count(context, { id_in: uniqPropertyIds, organization: { id: organizationId }, deletedAt: null })

    if (propertiesCount !== uniqPropertyIds.length) throw new GQLError(ERRORS.INVALID_PROPERTY_PROVIDED, context)

    return { categoryData, period: period.format(DATE_FORMAT) }
}

const SendNewReceiptMessagesToResidentScopesService = new GQLCustomSchema('SendNewReceiptMessagesToResidentScopesService', {
    types: [
        {
            access: true,
            type: 'input PropertyUnitInput { unitType: String!, unitName: String! }',
        },
        {
            access: true,
            type: 'input PropertyScopesInput { property: PropertyWhereUniqueInput!, units: [PropertyUnitInput], accountNumbers: [String] }',
        },
        {
            access: true,
            type:   'input SendNewReceiptMessagesToResidentScopesInput { ' +
                        'dv: Int!, ' +
                        'sender: JSON!, ' +
                        'context: BillingIntegrationOrganizationContextWhereUniqueInput!, ' +
                        'category: BillingCategoryWhereUniqueInput!, ' +
                        'period: String!, ' +
                        'lang: SendMessageLang, ' +
                        'scopes: [PropertyScopesInput]!, ' +
                        'meta: JSON' +
                    '}',
        },
        {
            access: true,
            type: 'type SendNewReceiptMessagesToResidentScopesOutput { status: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canSendNewReceiptMessagesToResidentScopes,
            schema: 'sendNewReceiptMessagesToResidentScopes(data: SendNewReceiptMessagesToResidentScopesInput!): SendNewReceiptMessagesToResidentScopesOutput',
            doc: {
                summary:    'Sends notification of BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE type to all residents of provided scopes. ' +
                            'Requires service user with access rights to billing domain. ' +
                            'All properties in scopes should be connected to provided context. ',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { sender, lang, scopes, category, meta } = data

                const { categoryData, period } = await validateAndNormalizeData(context, data)
                const categoryName = `${categoryData.nameNonLocalized}.declined`

                const payload = {
                    sender,
                    type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
                    lang,
                    uniqKeyTemplate: UNIQ_KEY_TEMPLATE,
                    scopes,
                    meta: { ...meta, categoryName, data: { ...meta.data, period, categoryId: category.id } },
                }

                return await sendMessageToResidentScopes(context, payload)
            },
        },
    ],
    
})

module.exports = {
    SendNewReceiptMessagesToResidentScopesService,
    ERRORS,
}
