/**
 * Generated by `createservice resident.SendNewReceiptMessagesToResidentScopesService --type mutations`
 */
const dayjs = require('dayjs')
const { isEmpty, get, uniq, compact, omit } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/billing/access/SendNewReceiptMessagesToResidentScopesService')
const { BillingCategory, BillingProperty, BillingIntegrationOrganizationContext } = require('@condo/domains/billing/utils/serverSchema')
const { FAILURE_STATUS } = require('@condo/domains/common/constants')
const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { getStartDates, DATE_FORMAT } = require('@condo/domains/common/utils/date')
const { loadListByChunks } = require('@condo/domains/common/utils/serverSchema')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE } = require('@condo/domains/notification/constants/constants')
const { PAYMENT_CATEGORIES_META } = require('@condo/domains/resident/constants')
const { Resident, sendMessageToResidentScopes } = require('@condo/domains/resident/utils/serverSchema')

const { isValidDateValue } = require('../utils/validation.utils')

const UNIQ_KEY_TEMPLATE = ['{categoryId}', '{period}', '{residentId}'].join(':')
const MUTATION_NAME = 'sendNewReceiptMessagesToResidentScopes'

const ERRORS = {
    INVALID_PERIOD_PROVIDED: {
        mutation: MUTATION_NAME,
        variable: ['data', 'context'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: `Please provide proper period not before start of previous and not later than start of current month, valid format is ${DATE_FORMAT}`,
        messageForUser: `api.billing.${MUTATION_NAME}.INVALID_PERIOD_PROVIDED`,
    },
    INVALID_BILLING_CONTEXT_PROVIDED: {
        mutation: MUTATION_NAME,
        variable: ['data', 'context'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Please provide existing non-deleted billing integration organization context id',
        messageForUser: `api.billing.${MUTATION_NAME}.INVALID_BILLING_CONTEXT_PROVIDED`,
    },
    INVALID_BILLING_CATEGORY_PROVIDED: {
        mutation: MUTATION_NAME,
        variable: ['data', 'category'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Please provide existing non-deleted billing category id',
        messageForUser: `api.billing.${MUTATION_NAME}.INVALID_BILLING_CATEGORY_PROVIDED`,
    },
    SCOPES_IS_EMPTY: {
        mutation: MUTATION_NAME,
        variable: ['data', 'scopes'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Scopes could not be empty',
        messageForUser: `api.billing.${MUTATION_NAME}.SCOPES_IS_EMPTY`,
    },
    INVALID_BILLING_PROPERTY_PROVIDED: {
        mutation: MUTATION_NAME,
        variable: ['data', 'scopes'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'All provided billing properties in scopes should be non-deleted & connected to organization of the billing context',
        messageForUser: `api.billing.${MUTATION_NAME}.INVALID_BILLING_PROPERTY_PROVIDED`,
    },
}

/**
 * Validate data for SendNewReceiptMessagesToResidentScopesService.
 * Throws typed errors on invalid values.
 * Prepares data for sendNewReceiptMessagesToResidentScopesTask
 * @param context
 * @param data
 * @returns {Promise<{categoryData: (*), period: 'YYYY-MM-01'}>}
 */
const validateAndNormalizeData = async (context, data) => {
    const { context: billingIntegrationContext, scopes, category, period: periodRaw } = data

    /** Validate period */
    if (!isValidDateValue(periodRaw)) throw new GQLError(ERRORS.INVALID_PERIOD_PROVIDED, context)

    const periodDt = dayjs(periodRaw)
    const { prevMonthStart, currMonthStart  } = getStartDates()

    if (!periodRaw || !periodDt.isValid()) throw new GQLError(ERRORS.INVALID_PERIOD_PROVIDED, context)

    const period = dayjs(periodDt).startOf('month')

    if (period.isAfter(currMonthStart) || period.isBefore(prevMonthStart)) throw new GQLError(ERRORS.INVALID_PERIOD_PROVIDED, context)

    /** Validate scopes */
    if (isEmpty(scopes)) throw new GQLError(ERRORS.SCOPES_IS_EMPTY, context)

    /** Validate category id */
    const categoryData = await BillingCategory.getOne(context, { id: category.id, deletedAt: null })

    if (isEmpty(categoryData)) throw new GQLError(ERRORS.INVALID_BILLING_CATEGORY_PROVIDED, context)

    /** Validate billing context id */
    const contextData = await BillingIntegrationOrganizationContext.getOne(context, { id: billingIntegrationContext.id, deletedAt: null, status: CONTEXT_FINISHED_STATUS })
    const organizationId = get(contextData, 'organization.id')

    /** Validate organization id */
    if (isEmpty(organizationId)) throw new GQLError(ERRORS.INVALID_BILLING_CONTEXT_PROVIDED, context)

    /** Request all billing properties data */
    const billingPropertyIds = scopes.map(scope => scope.billingProperty.id)
    const uniqBillingPropertyIds = uniq(compact(billingPropertyIds))
    const billingPropertiesWhere = { context: { id: billingIntegrationContext.id }, id_in: uniqBillingPropertyIds, deletedAt: null }
    const billingProperties = await loadListByChunks({ context, list: BillingProperty, where: billingPropertiesWhere })
    const loadedBillingPropertyIds = billingProperties.map(billingProperty => billingProperty.id)
    const loadedBillingPropertyUniqIds = uniq(compact(loadedBillingPropertyIds))
    const propertiesMapping = {}

    /** Make sure all billing property items contain property with id */
    if (loadedBillingPropertyUniqIds.length !== uniqBillingPropertyIds.length) throw new GQLError(ERRORS.INVALID_BILLING_PROPERTY_PROVIDED, context)

    /**
     * Map billing property ids to property ids by finding first non-deleted resident within non-deleted property with same address.
     * This should work because all residents are always connected to actual properties in actual organizations.
     * */
    for (const billingProperty of billingProperties) {
        const residentWhere = {
            deletedAt: null,
            property: {
                deletedAt: null,
                OR: [
                    { address_i: billingProperty.address.toLowerCase() },
                    { addressKey: billingProperty.addressKey },
                ],
            },
        }
        const [resident] = await Resident.getAll(context, residentWhere, { sortBy: ['createdAt_ASC'], first: 1 })

        if (!isEmpty(get(resident, 'residentProperty'))) propertiesMapping[billingProperty.id] = resident.residentProperty.id
    }

    /** replace billing properties with corresponding properties in scopes */
    const scopesData = scopes.map(scope => {
        /**
         * If billingProperty to property mapping is missing, we should skip whole scope, because there were no residents found for the address
         * */
        if (!propertiesMapping[scope.billingProperty.id]) return undefined

        const scopeItem = {
            ...omit(scope, ['billingProperty', 'skipAccountNumbers']),
            property: { id: propertiesMapping[scope.billingProperty.id] },
        }

        if (!isEmpty(scope.skipAccountNumbers)) scopeItem.skipBillingAccountNumbers = scope.skipAccountNumbers

        return scopeItem
    })

    return { categoryData, period: period.format(DATE_FORMAT), scopesData: compact(scopesData) }
}

const SendNewReceiptMessagesToResidentScopesService = new GQLCustomSchema('SendNewReceiptMessagesToResidentScopesService', {
    types: [
        {
            access: true,
            type: 'input PropertyUnitInput { unitType: String!, unitName: String! }',
        },
        {
            access: true,
            type: 'input PropertyScopesInput { billingProperty: BillingPropertyWhereUniqueInput!, units: [PropertyUnitInput], accountNumbers: [ID], skipUnits: [PropertyUnitInput], skipAccountNumbers: [ID] }',
        },
        {
            access: true,
            type:   'input SendNewReceiptMessagesToResidentScopesInput { ' +
                        'dv: Int!, ' +
                        'sender: JSON!, ' +
                        'context: BillingIntegrationOrganizationContextWhereUniqueInput!, ' +
                        'category: BillingCategoryWhereUniqueInput!, ' +
                        'period: String!, ' +
                        'lang: SendMessageLang, ' +
                        'scopes: [PropertyScopesInput]!, ' +
                        'meta: JSON' +
                    '}',
        },
        {
            access: true,
            type: 'type SendNewReceiptMessagesToResidentScopesOutput { status: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canSendNewReceiptMessagesToResidentScopes,
            schema: 'sendNewReceiptMessagesToResidentScopes(data: SendNewReceiptMessagesToResidentScopesInput!): SendNewReceiptMessagesToResidentScopesOutput',
            doc: {
                summary:    'Sends notification of BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE type to all residents of provided scopes. ' +
                            'Requires service user with access rights to billing domain. ' +
                            'All properties in scopes should be connected to provided context. ',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { sender, lang, category, meta } = data

                const { categoryData, period, scopesData } = await validateAndNormalizeData(context, data)
                const categoryName = `${categoryData.nameNonLocalized}.declined`
                /**
                 * TODO(DOMA-5729):
                 * To get rid of PAYMENT_CATEGORIES_META please remove 2 rows of code below & also replace
                 * paymentCategoryId by categoryId in urlTemplate declaration in
                 * apps/eps/domains/eps/tasks/helpers/triggerNewReceiptsNotifications.js
                 */
                const paymentCategoryData = PAYMENT_CATEGORIES_META.find(item => item.uuid === category.id)
                const paymentCategoryId = get(paymentCategoryData, 'id', null)

                /**
                 * if scopesData is empty at this point, it means that either
                 * - there was no matching Property item found for corresponding BillingProperty item of the scope item
                 * - or there was no Resident items found for that matched Property item,
                 * for every scope item
                 * */
                if (isEmpty(scopesData)) return { status: FAILURE_STATUS }

                const payload = {
                    sender,
                    type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
                    lang,
                    uniqKeyTemplate: UNIQ_KEY_TEMPLATE,
                    scopes: scopesData,
                    meta: { ...meta, categoryName, data: { ...meta.data, period, categoryId: category.id, paymentCategoryId /** TODO(DOMA-5729): remove this too to get rid of PAYMENT_CATEGORIES_META */ } },
                }

                return await sendMessageToResidentScopes(context, payload)
            },
        },
    ],
    
})

module.exports = {
    SendNewReceiptMessagesToResidentScopesService,
    ERRORS,
}
