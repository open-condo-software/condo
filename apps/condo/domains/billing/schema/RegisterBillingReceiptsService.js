/**
 * Generated by `createservice billing.RegisterBillingReceiptsService --type mutations`
 */

const _ = require('lodash')

const { BillingAccount, BillingProperty, BillingReceipt } = require('@condo/domains/billing/utils/serverSchema')

const access = require('@condo/domains/billing/access/RegisterBillingReceiptsService')
const { find, getById, GQLCustomSchema } = require('@core/keystone/schema')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@core/keystone/errors')
const { NOT_FOUND, WRONG_FORMAT, WRONG_VALUE } = require('@condo/domains/common/constants/errors')

const RECEIPTS_LIMIT = 100

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const errors = {
    BILLING_CONTEXT_NOT_FOUND: {
        mutation: 'registerBillingReceipts',
        variable: ['data', 'context'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Provided BillingIntegrationOrganizationContext is not found',
    },
    BILLING_CATEGORY_NOT_FOUND: {
        mutation: 'registerBillingReceipts',
        variable: ['data', 'receipts', '[]', 'category'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Provided BillingCategory is not found for some receipts',
    },
    PERIOD_WRONG_FORMAT: {
        mutation: 'registerBillingReceipts',
        variable: ['data', 'receipts', '[]', 'period'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'field Period is in wrong format for some receipts. Period should be in format: {YEAR}-{MONTH}-01. Example: 2022-03-01 - March of 2022',
    },
    ADDRESS_WRONG_VALUE: {
        mutation: 'registerBillingReceipts',
        variable: ['data', 'receipts', '[]', 'address'],
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: 'field Address has wrong value for some receipts',
    },
    RECEIPTS_LIMIT_HIT: {
        mutation: 'registerBillingReceipts',
        variable: ['data', 'receipts'],
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: `Too many receipts in one query! We support up to ${RECEIPTS_LIMIT} receipts`,
    },
}

const syncEntity = async (existingObjs, objs, shouldCreateHook, shouldUpdateHook) => {

    return {
        create: [],
        update: [],
        delete: [],
    }
}


const getBillingPropertyKey = ({ address }) => address
const getBillingAccountKey = ({ unitName, unitType, number, property }) => [unitName, unitType, number, getBillingPropertyKey(property)].join('_')
const getBillingReceiptKey = ({ category: { id: categoryId }, period, property, account, recipient: { tin, bankAccount, iec, bic } }) => [categoryId, period, getBillingPropertyKey(property), getBillingAccountKey(account), tin, bankAccount, iec, bic].join('_')

const syncBillingProperties = async (context, properties, { billingContextId }) => {
    const propertiesQuery = { address_in: Object.values(properties).map(p => p.address) }
    const existingProperties = await find('BillingProperty', {
        ...propertiesQuery,
        context: { id: billingContextId },
    })
    const propertiesIndex = Object.fromEntries(existingProperties.map((property) => ([getBillingPropertyKey(property), property.id])))

    const propertiesToAdd = Object.values(properties).filter((({ globalId }) => !Reflect.has(propertiesIndex, globalId)))

    const newProperties = []
    for (const p of propertiesToAdd) {
        const newProperty = await BillingProperty.create(context, p)
        newProperties.push(newProperty)
    }

    return [ ...newProperties, ...existingProperties ]
}

const syncBillingAccounts = async (context, accounts, { properties, billingContextId }) => {

    const accountsWithData = Object.values(accounts).map(account => ({
        ..._.omit(account, 'propertyKey'),
        property: _.find(properties, p => account.propertyKey === getBillingPropertyKey(p)),
    }))

    const existingAccountQuery = {
        OR: accountsWithData.map(a => ({
            number: a.number,
            unitName: a.unitName,
            unitType: a.unitType,
            property: { id: _.get(a, ['property', 'id']) },
        })),
    }
    const existingAccounts = await find('BillingAccount', {
        ...existingAccountQuery,
        context: { id: billingContextId },
    })
    const existingAccountsWithData = existingAccounts.map(account => ({ ...account, ...{ property: _.find(properties, p => p.id === account.property ) } } ))
    const accountsIndex = Object.fromEntries(existingAccountsWithData.map((account) => ([getBillingAccountKey(account), account.id])))

    const accountsToAdd = accountsWithData.filter((({ globalId }) => !Reflect.has(accountsIndex, globalId)))

    const newAccounts = []
    for (const a of accountsToAdd) {

        // TODO @toplenboren (DOMA-3445) refactor this!
        a.property = { connect: { id: _.get(a, ['property', 'id']) } }

        const newAccount = await BillingAccount.create(context, a)
        newAccounts.push(newAccount)
    }

    const newAccountsWithData = newAccounts.map(item => ({
        ...item,
        property: _.find(properties, p => p.id === _.get(item, ['property', 'id'])),
    }))

    return [ ...newAccountsWithData, ...existingAccountsWithData ]
}

const syncBillingReceipts = async (context, receipts, { accounts, properties, billingContextId } ) => {
    const receiptsWithData = Object.values(receipts).map(receipt => ({
        ..._.omit(receipt, ['propertyKey', 'accountKey']),
        property: _.find(properties, p => receipt.propertyKey === getBillingPropertyKey(p)),
        account: _.find(accounts, a => receipt.accountKey === getBillingAccountKey(a)),
    }))

    const existingReceiptsQuery = {
        OR: receiptsWithData.map(item => ({
            // TODO @toplenboren (DOMA-3445) refactor this! Also add PAYMENT INFO!
            period: item.period,
            category: { id: _.get(item, ['category', 'connect', 'id']) },
            property: { id: _.get(item, ['property', 'id']) },
            account: { id: _.get(item, ['account', 'id']) },
        })),
    }
    const existingReceipts = await find('BillingReceipt', {
        ...existingReceiptsQuery,
        context: { id: billingContextId },
    })
    const existingReceiptsWithData = existingReceipts.map(receipt => ({ ...receipt, ...{ property: _.find(properties, p => p.id === receipt.property ) } } ))
    const receiptsIndex = Object.fromEntries(existingReceiptsWithData.map((receipt) => ([getBillingReceiptKey(receipt), receipt.id])))

    const receiptsToAdd = receiptsWithData.filter((({ globalId }) => !Reflect.has(receiptsIndex, globalId)))

    const newReceipts = []
    for (const item of receiptsToAdd) {

        // TODO @toplenboren (DOMA-3445) refactor this!
        item.property = { connect: { id: _.get(item, ['property', 'id']) } }
        item.account = { connect: { id: _.get(item, ['account', 'id']) } }

        item.recipient = {
            tin: item.tin,
            iec: item.iec,
            bankAccount: item.bankAccount,
            bic: item.bic,
        }

        const cleanItem = _.omit(item, ['tin', 'iec', 'bic', 'bankAccount'])

        const newReceipt = await BillingReceipt.create(context, cleanItem)
        newReceipts.push(newReceipt)
    }

    return { createdReceipts: newReceipts,  notChangedReceipts: existingReceipts }
}

const RegisterBillingReceiptsService = new GQLCustomSchema('RegisterBillingReceiptsService', {
    types: [
        {
            access: true,
            type: 'input RegisterBillingReceiptInput ' +
                '{ ' +
                    'importId: String! ' +

                    'address: String! ' +

                    'accountNumber: String! ' +
                    'unitName: String! ' + // Should delete this!
                    'unitType: String! ' + // Should delete this!
                    'fullName: String ' +

                    'toPay: String! ' +
                    'toPayDetails: BillingReceiptServiceToPayDetailsFieldInput ' +
                    'services: BillingReceiptServiceFieldInput ' +
                    'period: String! ' +

                    'category: BillingCategoryWhereUniqueInput! ' +

                    'tin: String! ' +
                    'iec: String! ' + // Should delete this!
                    'bic: String! ' +
                    'bankAccount: String! ' +

                    'raw: JSON ' +
                '}',
        },
        {
            access: true,
            type: 'input RegisterBillingReceiptsInput { dv: Int!, sender: SenderFieldInput!, context: BillingIntegrationOrganizationContextWhereUniqueInput, receipts: [RegisterBillingReceiptInput!]! }',
        },
    ],
    
    mutations: [
        {
            access: access.canRegisterBillingReceipts,
            schema: 'registerBillingReceipts(data: RegisterBillingReceiptsInput!): [BillingReceipt]',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { context: billingContextInput, receipts: receiptsInput, dv, sender } } = args

                // Step 0:
                // Perform basic validations:
                if (receiptsInput.length > RECEIPTS_LIMIT) {
                    throw new GQLError(errors.RECEIPTS_LIMIT_HIT, context)
                }

                const { id: billingContextId } = billingContextInput
                const billingContext = await getById('BillingIntegrationOrganizationContext', billingContextId)
                if (!billingContextId || !billingContext) {
                    throw new GQLError(errors.BILLING_CONTEXT_NOT_FOUND, context)
                }

                // Step 1:
                // Parse properties, accounts and receipts from input
                const { properties, accounts, receipts } = receiptsInput.reduce((index, receiptInput) => {
                    const {
                        importId,
                        address,
                        accountNumber,
                        unitName,
                        unitType,
                        category,
                        period,
                        services,
                        toPay,
                        toPayDetails,
                        tin,
                        iec,
                        bic,
                        bankAccount,
                        raw,
                    } = receiptInput

                    const propertyFromInput = { address }
                    const accountFromInput = { unitName, unitType, number: accountNumber, property: propertyFromInput }
                    const receiptFromInput = { category, period, property: propertyFromInput, account: accountFromInput, services, recipient: { tin, iec, bic, bankAccount } }

                    const propertyKey = getBillingPropertyKey( propertyFromInput )
                    const accountKey = getBillingAccountKey( accountFromInput )
                    const receiptKey = getBillingReceiptKey(receiptFromInput)

                    if (!index.properties[propertyKey]) {
                        index.properties[propertyKey] = {
                            dv: dv,
                            sender: sender,
                            globalId: propertyKey,
                            address: address,
                            raw: { dv: 1 },
                            importId: propertyKey,
                            context: { connect: { id: billingContext.id } },
                            meta: { dv: 1 },
                        }
                    }
                    if (!index.accounts[accountKey]) {
                        index.accounts[accountKey] = {
                            dv: dv,
                            sender: sender,
                            context: { connect: { id: billingContext.id } },
                            number: accountNumber,
                            importId: accountKey,
                            globalId: accountKey,
                            unitName,
                            unitType,
                            propertyKey,
                            raw: { dv: 1 },
                            meta: { dv: 1 },
                        }
                    }
                    if (!index.receipts[receiptKey]) {
                        index.receipts[receiptKey] = {
                            dv: dv,
                            sender: sender,
                            context: { connect: { id: billingContext.id } },
                            accountKey,
                            propertyKey,
                            period: period,
                            importId: importId,
                            category: { connect: { id: category.id } },
                            toPay: toPay,
                            services: services,
                            toPayDetails: toPayDetails,
                            tin,
                            iec,
                            bic,
                            bankAccount,
                            raw: { ...{ dv: 1 }, ...raw },
                        }
                    }
                    return index
                }, { properties: {}, accounts: {}, receipts: {} })

                // Step 2:
                // Sync billing properties
                const syncedProperties = await syncBillingProperties(context, properties, { properties, billingContextId })

                // Step 3:
                // Sync Billing Accounts
                const syncedAccounts = await syncBillingAccounts(context, accounts, { accounts, properties: syncedProperties, billingContextId })

                // Step 4:
                // Sync billing receipts
                const { createdReceipts, notChangedReceipts } = await syncBillingReceipts(context, receipts, { accounts: syncedAccounts, properties: syncedProperties, billingContextId })

                // TODO: throw errors in a following way
                // throw new GQLError(errors.NAME_OF_ERROR_FOR_USAGE_INSIDE_THIS_MODULE_ONLY)
                return createdReceipts
            },
        },
    ],
    
})

module.exports = {
    RegisterBillingReceiptsService,
}
