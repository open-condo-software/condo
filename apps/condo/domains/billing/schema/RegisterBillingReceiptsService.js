/**
 * Generated by `createservice billing.RegisterBillingReceiptsService --type mutations`
 */

const Big = require('big.js')
const dayjs = require('dayjs')
const { get, omit, isEqual, isString } = require('lodash')

const { GQLError } = require('@open-condo/keystone/errors')
const { getLogger } = require('@open-condo/keystone/logging')
const { find, getById, GQLCustomSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/billing/access/RegisterBillingReceiptsService')
const {
    RECEIPTS_LIMIT,
    ERRORS,
} = require('@condo/domains/billing/constants/registerBillingReceiptService')
const { CategoryResolver: OldCategoryResolver } = require('@condo/domains/billing/schema/helpers/categoryResolver')
const {
    CategoryResolver,
    RecipientResolver,
    PropertyResolver,
    AccountResolver,
    PeriodResolver,
    ReceiptResolver,
} = require('@condo/domains/billing/schema/resolvers')
const { BillingAccount, BillingProperty, BillingReceipt } = require('@condo/domains/billing/utils/serverSchema')
const { BillingIntegrationOrganizationContext: BillingContextApi } = require('@condo/domains/billing/utils/serverSchema')
const { getAddressSuggestions } = require('@condo/domains/common/utils/serverSideAddressApi')

const { findPropertyByOrganizationAndAddress } = require('./helpers/propertyFinder')

const appLogger = getLogger('condo')
const registerReceiptLogger = appLogger.child({ module: 'register-billing-receipts' })

const OLD_RECEIPTS_LIMIT = 50

// This is a percent of matched tokens while searching through the organization's properties
const PROPERTY_SCORE_TO_PASS = 95

const getBillingPropertyKey = ({ address }) => address
const getBillingAccountKey = ({ unitName, unitType, number, property }) => [unitName, unitType, number, getBillingPropertyKey(property)].join('_')
const getBillingReceiptKey = ({ category: { id: categoryId }, period, property, account }) => [categoryId, period, getBillingPropertyKey(property), getBillingAccountKey(account) ].join('_')

const syncBillingProperties = async (context, properties, { billingContextId }) => {
    const propertiesQuery = { address_in: properties.map(p => p.address), context: { id: billingContextId }, deletedAt: null }

    const existingProperties = await find('BillingProperty', propertiesQuery)
    const existingPropertiesIndex = Object.fromEntries(existingProperties.map((property) => ([getBillingPropertyKey(property), property.id])))

    const propertiesToAdd = properties.filter(((property) => !Reflect.has(existingPropertiesIndex, getBillingPropertyKey(property))))

    const createdProperties = []
    for (const property of propertiesToAdd) {

        const propertyToCreate = {
            ...property,
            context: { connect: { id: get(property, ['context', 'id']) } },
        }

        const newProperty = await BillingProperty.create(context, propertyToCreate)
        createdProperties.push(newProperty)
    }

    return [...createdProperties, ...existingProperties]
}

const syncBillingAccounts = async (context, accounts, { properties, billingContextId }) => {

    const propertiesIndex = Object.fromEntries(properties.map((item) => ([getBillingPropertyKey(item), item])))
    const propertiesIndexById = Object.fromEntries(properties.map((item) => ([item.id, item])))

    const existingAccountQuery = {
        OR: accounts.map(item => (
            {
                AND: [
                    { number: item.number },
                    { unitName: item.unitName },
                    { unitType: item.unitType },
                    { property: { id: get(propertiesIndex[getBillingPropertyKey(item.property)], 'id') } },
                    { deletedAt: null },
                ],
            }
        )),
    }
    const existingAccounts = await find('BillingAccount', {
        ...existingAccountQuery,
        context: { id: billingContextId },
    })
    const existingAccountsWithData = existingAccounts.map(account => ({ ...account, ...{ property: get(propertiesIndexById, account.property ) } } ))
    const accountsIndex = Object.fromEntries(existingAccountsWithData.map((account) => ([getBillingAccountKey(account), account])))

    const accountsToAdd = accounts.filter(((item) => !Reflect.has(accountsIndex, getBillingAccountKey(item))))

    const newAccounts = []
    for (const account of accountsToAdd) {

        const accountGQLInput = {
            ...account,
            context: { connect: { id: get(account, ['context', 'id']) } },
            property: { connect: { id: get(propertiesIndex[getBillingPropertyKey(account.property)], 'id' ) } },
        }

        const newAccount = await BillingAccount.create(context, accountGQLInput)
        newAccounts.push(newAccount)
    }

    const newAccountsWithData = newAccounts.map(item => ({
        ...item,
        property: get(propertiesIndexById, get(item, ['property', 'id'])),
    }))

    return [ ...newAccountsWithData, ...existingAccountsWithData ]
}

const convertBillingReceiptToGQLInput = (item, propertiesIndex, accountsIndex, receiverId) => {
    item.category = { connect: { id: get(item, ['category', 'id']) } }
    item.context = { connect: { id: get(item, ['context', 'id']) } }

    item.property = { connect: { id: get(propertiesIndex[getBillingPropertyKey(item.property)], 'id') } }
    item.account = { connect: { id: get(accountsIndex[getBillingAccountKey(item.account)], 'id') } }
    item.receiver = { connect: { id: item.receiverId } }

    return omit(item, ['receiverId'])
}

const syncBillingReceipts = async (context, receipts, { accounts, properties, billingContextId } ) => {

    const propertiesIndex = Object.fromEntries(properties.map((item) => ([getBillingPropertyKey(item), item])))
    const propertiesIndexById = Object.fromEntries(properties.map((item) => ([item.id, item])))

    const accountsIndex = Object.fromEntries(accounts.map((item) => ([getBillingAccountKey(item), item])))
    const accountsIndexById = Object.fromEntries(accounts.map((item) => ([item.id, item])))

    const existingReceiptsQuery = {
        OR: receipts.map(item => (
            {
                AND: [
                    { period: item.period },
                    { category: { id: get(item, ['category', 'id']) } },
                    { property: { id: get(propertiesIndex[getBillingPropertyKey(item.property)], 'id') } },
                    { account: { id: get(accountsIndex[getBillingAccountKey(item.account)], 'id') } },
                    { deletedAt: null },
                ],
            }
        )),
    }
    const existingReceipts = await find('BillingReceipt', {
        ...existingReceiptsQuery,
        context: { id: billingContextId },
    })
    const existingReceiptsWithData = existingReceipts.map(receipt => ({
        ...receipt,
        ...{
            property: get(propertiesIndexById, get(receipt, ['property'] )),
            account: get(accountsIndexById, get(receipt, ['account'])),
            category: { id: get(receipt, ['category']) },
        },
    }))
    const receiptsIndex = Object.fromEntries(existingReceiptsWithData.map((receipt) => ([getBillingReceiptKey(receipt), receipt])))

    const receiptsToUpdate = []
    const receiptsToAdd = []
    const notChangedReceipts = []

    receipts.forEach((item) => {
        const receiptKey = getBillingReceiptKey(
            {
                ...item,
                ...{ recipient: item.recipient } },
        )

        const receiptExists = Reflect.has(receiptsIndex, receiptKey)
        if (!receiptExists) {
            receiptsToAdd.push(item)
        } else {
            const existingReceiptByKey = receiptsIndex[receiptKey]

            const existingToPay = new Big(existingReceiptByKey.toPay)
            const newToPay = new Big(item.toPay)
            const toPayIsEqual = existingToPay.eq(newToPay)

            const existingServices = existingReceiptByKey.services
            // if not specified, then it is null
            const newServices = item.services ? item.services : null
            const servicesIsEqual = isEqual(existingServices, newServices)

            const existingToPayDetails = existingReceiptByKey.toPayDetails
            // if not specified, then it is null
            const newToPayDetails = item.toPayDetails ? item.toPayDetails : null
            const toPayDetailsIsEqual = isEqual(existingToPayDetails, newToPayDetails)

            const existingReceiver = existingReceiptByKey.receiver
            const recipientIsEqual = isEqual(existingReceiver, item.receiverId)

            const shouldUpdateReceipt = !toPayIsEqual || !servicesIsEqual || !toPayDetailsIsEqual || !recipientIsEqual

            if (shouldUpdateReceipt) {
                item.id = existingReceiptByKey.id
                receiptsToUpdate.push(item)
            } else {
                notChangedReceipts.push(item)
            }
        }
    })

    const newReceipts = []
    for (const item of receiptsToAdd) {
        const billingReceiptGQLInput = convertBillingReceiptToGQLInput(item, propertiesIndex, accountsIndex)
        const newReceipt = await BillingReceipt.create(context, billingReceiptGQLInput)
        newReceipts.push(newReceipt)
    }

    const updatedReceipts = []
    for (const item of receiptsToUpdate) {
        const itemId = item.id
        const billingReceiptGQLInput = convertBillingReceiptToGQLInput(item, propertiesIndex, accountsIndex)
        const updatableItem = omit(billingReceiptGQLInput, ['context', 'id'])
        const updatedReceipt = await BillingReceipt.update(context, itemId, updatableItem)
        updatedReceipts.push(updatedReceipt)
    }

    return { createdReceipts: newReceipts, updatedReceipts: updatedReceipts, notChangedReceipts: notChangedReceipts }
}

const RegisterBillingReceiptsService = new GQLCustomSchema('RegisterBillingReceiptsService', {
    types: [
        {
            access: true,
            type: `input RegisterBillingReceiptAddressMetaInput {
                globalId: String
                importId: String
                unitName: String
                unitType: String
            }`,
        },
        {
            access: true,
            type: `input RegisterBillingReceiptAccountMetaInput {
                globalId: String 
                importId: String
                fullName: String
                isClosed: Boolean
                ownerType: BillingAccountOwnerTypeType
            }`,
        },
        {
            access: true,
            type: 'input RegisterBillingReceiptInput ' +
                '{ ' +
                    'importId: String ' +

                    'address: String! ' +
                    'addressMeta: RegisterBillingReceiptAddressMetaInput ' +

                    'accountNumber: String! ' +
                    'accountMeta: RegisterBillingReceiptAccountMetaInput ' +

                    'toPay: String! ' +
                    'toPayDetails: BillingReceiptServiceToPayDetailsFieldInput ' +
                    'services: [BillingReceiptServiceFieldInput] ' +

                    'category: BillingCategoryWhereUniqueInput ' +

                    'month: Int! ' +
                    'year: Int! ' +

                    'tin: String! ' +
                    'routingNumber: String! ' +
                    'bankAccount: String! ' +

                    'raw: JSON ' +

                    // [DEPRECATED] Not used fields will be removed
                    'unitName: String ' +
                    'unitType: String ' +
                    'normalizedAddress: String ' +
                    'fullName: String ' +
                    'tinMeta: JSON ' +
                    'routingNumberMeta: JSON' +
                '}',
        },
        {
            access: true,
            type: 'input RegisterBillingReceiptsInput { dv: Int!, sender: SenderFieldInput!, context: BillingIntegrationOrganizationContextWhereUniqueInput, receipts: [RegisterBillingReceiptInput!]! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterBillingReceipts,
            schema: 'registerBillingReceipts(data: RegisterBillingReceiptsInput!): [BillingReceipt]',
            resolver: async (parent, args, context = {}) => {
                const { data: { context: billingContextInput, receipts: receiptsInput, dv, sender } } = args
                // New flow description:
                // 1. Normalize addresses
                // 2. Collect data for BillingProblems
                // 3. Create BillingRecipients
                // 4. Auto-detect BillingCategory
                const isNewFlow = !receiptsInput.find(({ normalizedAddress }) => normalizedAddress)

                if (isNewFlow) {
                    if (receiptsInput.length > RECEIPTS_LIMIT) {
                        throw new GQLError(ERRORS.RECEIPTS_LIMIT_HIT, context)
                    }
                    const { id: billingContextId } = billingContextInput
                    const billingContext = await BillingContextApi.getOne(context, { id: billingContextId })
                    if (!billingContextId || !billingContext) {
                        throw new GQLError(ERRORS.BILLING_CONTEXT_NOT_FOUND, context)
                    }
                    // preserve order for response
                    // errors are critical and receipt will be skipped, problems can be fixed later
                    let receiptIndex = Object.fromEntries(receiptsInput.map((receiptInput, index) =>
                        ([index, { ...receiptInput, error: null, problems: [] }])
                    ))
                    let errorsIndex = {}
                    const debug = []
                    const chain = [PeriodResolver, RecipientResolver, PropertyResolver, AccountResolver, CategoryResolver, ReceiptResolver]
                    for (const Worker of chain) {
                        try {
                            const worker = new Worker({ context, billingContext })
                            await worker.init()
                            const { errorReceipts, receipts } = await worker.processReceipts(receiptIndex)
                            debug.push(...worker.debugMessages)
                            errorsIndex = { ...errorsIndex, ...errorReceipts }
                            receiptIndex = receipts
                        } catch (error) {
                            registerReceiptLogger.error({ msg: 'Resolver fail', payload: { error } })
                        }
                    }
                    registerReceiptLogger.info({ msg: 'register-receipts-profiler', debug, context: billingContextInput, receiptsCount: receiptsInput.length })
                    const receiptIds = Object.values(receiptIndex).map(({ id }) => id)

                    const receipts = receiptIds.length ? await find('BillingReceipt', { id_in: receiptIds }) : []
                    const receiptsIndex = Object.fromEntries(receipts.map(receipt => ([receipt.id, receipt])))
                    return Object.values({ ...receiptIndex, ...errorsIndex }).map(idOrError => {
                        const id = get(idOrError, 'id')
                        if (id) {
                            return Promise.resolve(receiptsIndex[id])
                        } else {
                            return Promise.reject(idOrError)
                        }
                    })
                }




                // Old way - will be removed
                const partialErrors = []

                // Step 0:
                // Perform basic validations:
                if (receiptsInput.length > OLD_RECEIPTS_LIMIT) {
                    throw new GQLError(ERRORS.RECEIPTS_LIMIT_HIT, context)
                }

                const { id: billingContextId } = billingContextInput
                const billingContext = await getById('BillingIntegrationOrganizationContext', billingContextId)
                if (!billingContextId || !billingContext) {
                    throw new GQLError(ERRORS.BILLING_CONTEXT_NOT_FOUND, context)
                }

                // Step 1:
                // Parse properties, accounts and receipts from input
                const categoryResolver = new OldCategoryResolver()
                await categoryResolver.loadCategories(context)

                const propertyIndex = {}
                const accountIndex = {}
                const receiptIndex = {}

                const billingContextWithOrganization = await BillingContextApi.getOne(context, { id: billingContextId })

                const recipientResolver = new RecipientResolver({ context, billingContext: billingContextWithOrganization })
                await recipientResolver.init()
                for (let i = 0; i < receiptsInput.length; ++i) {

                    const { importId, address, accountNumber, unitName, unitType, month, year, services, toPay, toPayDetails, raw } = receiptsInput[i]
                    const { tin, routingNumber, bankAccount } = receiptsInput[i]

                    // Todo: (DOMA-2225) migrate it to address service
                    let { normalizedAddress } = receiptsInput[i]

                    // Todo: (DOMA-3252) migrate it to new recipients
                    const { result: { id: receiverId, recipient: normalizedRecipient } } = await recipientResolver.getReceiver({ tin, routingNumber, bankAccount })
                    // Validate period field
                    if (!(0 <= month && month <= 12 )) {
                        partialErrors.push(new GQLError({ ...ERRORS.WRONG_MONTH, inputIndex: i }, context))
                        continue
                    }
                    if (year < 0) {
                        partialErrors.push(new GQLError({ ...ERRORS.WRONG_YEAR, inputIndex: i }, context))
                        continue
                    }

                    const period = dayjs().year(year).month(month - 1).format('YYYY-MM-01')

                    // Validate address field
                    if (address === '') {
                        partialErrors.push(new GQLError({ ...ERRORS.ADDRESS_EMPTY_VALUE, inputIndex: i }, context))
                        continue
                    }

                    if (!normalizedAddress) {
                        const [findedOrganizationProperties, score] = await findPropertyByOrganizationAndAddress(context, billingContext.organization.id, address)

                        if (score > PROPERTY_SCORE_TO_PASS && findedOrganizationProperties.length === 1) {
                            normalizedAddress = findedOrganizationProperties[0].address
                        }
                    }

                    if (!normalizedAddress) {
                        const normalizedAddressFromSuggestions = get(await getAddressSuggestions(address, 1), ['0', 'value'])
                        if (!normalizedAddressFromSuggestions) {
                            partialErrors.push(new GQLError({ ...ERRORS.ADDRESS_NOT_RECOGNIZED_VALUE, inputIndex: i }, context))
                            continue
                        }
                        normalizedAddress = normalizedAddressFromSuggestions
                    }

                    // TODO (DOMA-4077) When address service is here -> use normalized address to compare properties
                    const property = { address }
                    const propertyKey = getBillingPropertyKey(property)
                    if (!propertyIndex[propertyKey]) {
                        propertyIndex[propertyKey] = {
                            dv: dv,
                            sender: sender,
                            globalId: propertyKey,
                            address,
                            normalizedAddress,
                            raw: { dv: 1 },
                            importId: propertyKey,
                            context: { id: billingContext.id },
                            meta: { dv: 1 },
                        }
                    }

                    const account = { unitName, unitType, number: accountNumber, property }
                    const accountKey = getBillingAccountKey(account)
                    if (!accountIndex[accountKey]) {
                        accountIndex[accountKey] = {
                            dv: dv,
                            sender: sender,
                            context: { id: billingContext.id },
                            number: accountNumber,
                            importId: accountKey,
                            globalId: accountKey,
                            unitName,
                            unitType,
                            property: propertyIndex[propertyKey],
                            raw: { dv: 1 },
                            meta: { dv: 1 },
                        }
                    }

                    // detect billing category by input
                    const {
                        error: detectCategoryErrorKey,
                        categoryId,
                    } = categoryResolver.detectCategory(receiptsInput[i])
                    const category = { id: categoryId }

                    // validate category detection
                    if (isString(detectCategoryErrorKey)) {
                        partialErrors.push(new GQLError({ ...ERRORS[detectCategoryErrorKey], inputIndex: i }, context))
                        continue
                    }

                    const receipt = { category, period, property, account, services, recipient: normalizedRecipient }
                    const receiptKey = getBillingReceiptKey(receipt)
                    if (!receiptIndex[receiptKey]) {
                        receiptIndex[receiptKey] = {
                            dv: dv,
                            sender: sender,
                            context: { id: billingContextId },
                            account: accountIndex[accountKey],
                            property: propertyIndex[propertyKey],
                            period: period,
                            importId: importId,
                            category: { id: category.id },
                            toPay: toPay,
                            services: services,
                            toPayDetails: toPayDetails,
                            receiverId: receiverId,
                            recipient: normalizedRecipient,
                            raw: { ...{ dv: 1 }, ...raw },
                        }
                    }
                }

                // Step 2:
                // Sync billing properties and billing accounts
                const syncedProperties = await syncBillingProperties(context, Object.values(propertyIndex), { billingContextId })
                const syncedAccounts = await syncBillingAccounts(context, Object.values(accountIndex), { properties: syncedProperties, billingContextId })

                // Step 3:
                // Sync billing receipts
                const { createdReceipts, updatedReceipts } = await syncBillingReceipts(context, Object.values(receiptIndex), { accounts: syncedAccounts, properties: syncedProperties, billingContextId })

                // Step 4:
                // Forming result
                // To form a result with partial success a list of promises needs to be returned from function
                // NOTE: getById is a hack that help to resolve complex fields
                const resultData = [...createdReceipts, ...updatedReceipts].map(item => getById('BillingReceipt', item.id))
                const resultErrors = partialErrors.map(err => (new Promise(() => { throw err })))

                return [...resultData, ...resultErrors]
            },
        },
    ],
})

module.exports = {
    RegisterBillingReceiptsService,
    errors: ERRORS,
}
