/**
 * Generated by `createschema billing.BillingAccount 'context:Relationship:BillingIntegrationOrganizationContext:CASCADE; importId?:Text; property:Relationship:BillingProperty:CASCADE; bindingId:Text; number:Text; unit:Text; raw:Json; meta:Json'`
 */

const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/billing/access/BillingAccount')
const { BILLING_ACCOUNT_OWNER_TYPES, BILLING_ACCOUNT_OWNER_TYPE_PERSON } = require('@condo/domains/billing/constants/constants')
const {
    JSON_EXPECT_OBJECT_ERROR,
    UNEQUAL_CONTEXT_ERROR,
} = require('@condo/domains/common/constants/errors')
const { IMPORT_ID_FIELD, UNIT_TYPE_FIELD } = require('@condo/domains/common/schema/fields')
const { hasValidJsonStructure } = require('@condo/domains/common/utils/validation.utils')

const { RAW_DATA_FIELD } = require('./fields/common')
const { INTEGRATION_CONTEXT_FIELD, BILLING_PROPERTY_FIELD } = require('./fields/relations')

const BillingAccount = new GQLListSchema('BillingAccount', {
    schemaDoc: 'All `account` objects from `billing data source`. In close account cases, these objects should be soft deleted',
    fields: {

        context: INTEGRATION_CONTEXT_FIELD,

        importId: IMPORT_ID_FIELD,

        raw: RAW_DATA_FIELD,

        property: BILLING_PROPERTY_FIELD,

        globalId: {
            schemaDoc: 'A well-known universal identifier that allows you to identify the same objects in different systems. It may differ in different countries. ' +
                'Example: for Russia, the dom.gosuslugi.ru account number is used',
            type: 'Text',
            isRequired: false,
            kmigratorOptions: {
                null: true,
            },
        },

        number: {
            schemaDoc: 'Account number',
            type: 'Text',
            isRequired: true,
        },

        // TODO(pahaz): make a link to property domain fields
        unitName: {
            schemaDoc: 'Flat number / door number of an apartment building (property)',
            type: 'Text',
            isRequired: true,
        },

        unitType: {
            ...UNIT_TYPE_FIELD,
            isRequired: true,
        },

        fullName: {
            schemaDoc: 'Full name of the account holder',
            type: 'Text',
            sensitive: true,
            isRequired: false,
        },

        isClosed: {
            schemaDoc: 'Shows whether the billing account closed or not. When one resident leaves unit and another one went in we need to close hte old billing account.',
            type: 'Checkbox',
            defaultValue: false,
            kmigratorOptions: { default: false },
        },

        ownerType: {
            schemaDoc: 'The account owner\'s type',
            type: 'Select',
            options: BILLING_ACCOUNT_OWNER_TYPES,
            defaultValue: BILLING_ACCOUNT_OWNER_TYPE_PERSON,
            kmigratorOptions: { default: `'${BILLING_ACCOUNT_OWNER_TYPE_PERSON}'` },
        },

        meta: {
            schemaDoc: 'Structured metadata obtained from the `billing data source`. Some of this data is required for use in the `receipt template`. ' +
                'Examples of data keys: `property unit number`, `floor`, `entrance`, `is parking`',
            type: 'Json',
            sensitive: true,
            isRequired: false,
            hooks: {
                validateInput: (args) => {
                    const { resolvedData, fieldPath, addFieldValidationError } = args
                    if (!resolvedData.hasOwnProperty(fieldPath)) return // skip if on value
                    const value = resolvedData[fieldPath]
                    if (value === null) return // null is OK
                    if (!hasValidJsonStructure(args, true, 1, {}))
                        return addFieldValidationError(`${JSON_EXPECT_OBJECT_ERROR}${fieldPath}] ${fieldPath} field type error. We expect JSON Object`)
                },
            },
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), analytical()],
    access: {
        read: access.canReadBillingAccounts,
        create: access.canManageBillingAccounts,
        update: access.canManageBillingAccounts,
        delete: false,
        auth: true,
    },
    kmigratorOptions: {
        indexes: [
            // used in allResidentBillingReceipts getting BillingReceipts
            {
                type: 'BTreeIndex',
                fields: ['number', 'deletedAt'],
                name: 'billingAccount_number_deletedAt',
            },
        ],
    },
    hooks: {
        validateInput: async ({ resolvedData, addValidationError, existingItem }) => {
            const newItem = { ...existingItem, ...resolvedData }
            const { context: accountContextId, property: propertyId } = newItem

            const property = await getById('BillingProperty', propertyId)
            const { context: propertyContextId } = property
            if (accountContextId !== propertyContextId) {
                return addValidationError(`${UNEQUAL_CONTEXT_ERROR}:property:context] Context is not equal to property.context`)
            }
        },
    },
    /*
    // TODO(dkovyazin): DOMA-7760 Turn on after clearing of duplicates
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['context', 'property', 'number'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'billingAccount_unique_address_number',
            },
        ],
    },

    */
})

module.exports = {
    BillingAccount,
}
