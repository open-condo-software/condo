/**
 * Generated by `createservice billing.RegisterBillingReceiptFileService --type mutations`
 */
const { Readable } = require('stream')

const { get, isEmpty } = require('lodash')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT  } } = require('@open-condo/keystone/errors')
const { DEFAULT_FILE_ADAPTER } = require('@open-condo/keystone/fileAdapter/constants')
const { GQLCustomSchema, find, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/billing/access/RegisterBillingReceiptFileService')
const {
    REGISTER_BILLING_RECEIPT_FILE_CREATED_STATUS,
    REGISTER_BILLING_RECEIPT_FILE_UPDATED_STATUS,
    REGISTER_BILLING_RECEIPT_FILE_SKIPPED_STATUS,
    REGISTER_BILLING_RECEIPT_FILE_STATUSES,
} = require('@condo/domains/billing/constants')
const { BillingReceiptFileIdOnly } = require('@condo/domains/billing/utils/serverSchema')
const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { md5 } = require('@condo/domains/common/utils/crypto')
const { buildUploadInputFrom } = require('@condo/domains/common/utils/serverSchema/export')

const isLocalFileAdapterConfigured = (conf.FILE_FIELD_ADAPTER || DEFAULT_FILE_ADAPTER) === 'local'

const ERRORS = {
    MULTIPLE_BILLING_RECEIPTS_FOUND: {
        mutation: 'registerBillingReceiptFile',
        variable: ['data', 'receipt'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'More then one receipt found for receipt file',
        messageForUser: 'api.billing.registerBillingReceiptFile.MULTIPLE_BILLING_RECEIPTS_FOUND',
    },
    NO_RECEIPTS_FOUND: {
        mutation: 'registerBillingReceiptFile',
        variable: ['data', 'receipt'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'There are no receipts to connect to this receipt file',
        messageForUser: 'api.billing.registerBillingReceiptFile.NO_RECEIPTS_FOUND',
    },
}

const RegisterBillingReceiptFileService = new GQLCustomSchema('RegisterBillingReceiptFileService', {
    types: [
        {
            access: true,
            type: `enum RegisterBillingReceiptFileResultStatus { ${REGISTER_BILLING_RECEIPT_FILE_STATUSES.join(' ')} }`,
        },
        {
            access: true,
            type: 'input RegisterBillingReceiptFileInput { dv: Int!, sender: SenderFieldInput!, context: BillingIntegrationOrganizationContextWhereUniqueInput!, receipt: BillingReceiptWhereInput!, base64EncodedPDF: String! }',
        },
        {
            access: true,
            type: 'type RegisterBillingReceiptFileOutput { id: ID!, status: RegisterBillingReceiptFileResultStatus! }',
        },
    ],
    
    mutations: [
        {
            access: access.canRegisterBillingReceiptFile,
            schema: 'registerBillingReceiptFile(data: RegisterBillingReceiptFileInput!): RegisterBillingReceiptFileOutput',
            resolver: async (parent, args, context) => {
                const { dv, sender, context: billingContextWhereUniqueInput, receipt: receiptWhereInput, base64EncodedPDF } = get(args, 'data') || {}
                const receipts = await find('BillingReceipt', {
                    context: billingContextWhereUniqueInput,
                    ...receiptWhereInput,
                    deletedAt: null,
                })
                if (receipts.length > 1) {
                    throw new GQLError(ERRORS.MULTIPLE_BILLING_RECEIPTS_FOUND, context)
                }
                const [receipt] = receipts
                if (!receipt) {
                    throw new GQLError(ERRORS.NO_RECEIPTS_FOUND, context)
                }
                const account = await getById('BillingAccount', receipt.account)
                const [receiptFile] = await find('BillingReceiptFile', { receipt: { id: receipt.id }, deletedAt: null })

                // for cases when we have a pdf receipt file bound to receipt
                // that means we can skip processing such request
                if (!isEmpty(get(receiptFile, 'receipt'))) {
                    return { id: receiptFile.id, status: REGISTER_BILLING_RECEIPT_FILE_SKIPPED_STATUS }
                }

                // since control sum for local file adapter not going to be resolved exactly as for s3 one
                // let's calculate it in order to keep compatibility for tests purposes
                const controlSumInput = isLocalFileAdapterConfigured ? { controlSum: md5(base64EncodedPDF) } : {}
                const sensitiveDataFile = buildUploadInputFrom({
                    stream: Readable.from(Buffer.from(base64EncodedPDF, 'base64')),
                    filename: [
                        account.number.replace(/[^a-zA-Z0-9]/g, ''),
                        receipt.period.replace(/-/g, '_'),
                        'private',
                    ].join('_') + '.pdf',
                    mimetype: 'application/pdf',
                    encoding: 'UTF-8',
                    meta: {},
                })

                if (!receiptFile) {
                    const { id } = await BillingReceiptFileIdOnly.create(context, {
                        dv, sender,
                        sensitiveDataFile,
                        ...controlSumInput,
                        receipt: { connect: { id: receipt.id } },
                        context: { connect: billingContextWhereUniqueInput },
                    })

                    return { id, status: REGISTER_BILLING_RECEIPT_FILE_CREATED_STATUS }
                } else {
                    await BillingReceiptFileIdOnly.update(context, receiptFile.id, {
                        dv, sender,
                        sensitiveDataFile,
                        ...controlSumInput,
                        publicDataFile: null,
                    })

                    return { id: receiptFile.id, status: REGISTER_BILLING_RECEIPT_FILE_UPDATED_STATUS }
                }
            },
        },
    ],
    
})

module.exports = {
    RegisterBillingReceiptFileService,
}
