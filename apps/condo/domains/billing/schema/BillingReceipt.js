/**
 * Generated by `createschema billing.BillingReceipt 'context:Relationship:BillingIntegrationOrganizationContext:CASCADE; importId?:Text; property:Relationship:BillingProperty:CASCADE; account:Relationship:BillingAccount:CASCADE; period:CalendarDay; raw:Json; toPay:Text; services:Json; meta:Json'`
 */

const { Big } = require('big.js')
const dayjs = require('dayjs')
const get = require('lodash/get')
const isEmpty = require('lodash/isEmpty')

const { readOnlyFieldAccess } = require('@open-condo/keystone/access')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById, find, getByCondition } = require('@open-condo/keystone/schema')

const {
    PAYMENT_STATUS_CHANGE_WEBHOOK_URL_FIELD,
    PAYMENT_STATUS_CHANGE_WEBHOOK_SECRET_FIELD,
    applyWebhookSecretGeneration,
    isWebhookUrlInWhitelist,
    returnPlainTextWebhookSecretOnCreation,
} = require('@condo/domains/acquiring/schema/fields/paymentChangeWebhook')
const access = require('@condo/domains/billing/access/BillingReceipt')
const { DEFAULT_BILLING_CATEGORY_ID, CONTEXT_FINISHED_STATUS } = require('@condo/domains/billing/constants/constants')
const { BillingRecipient } = require('@condo/domains/billing/utils/serverSchema')
const { WRONG_TEXT_FORMAT, UNEQUAL_CONTEXT_ERROR } = require('@condo/domains/common/constants/errors')
const { MONEY_AMOUNT_FIELD } = require('@condo/domains/common/schema/fields')

const { AMOUNT_DISTRIBUTION_FIELD } = require('./fields/AmountDistribution')
const { RECIPIENT_FIELD } = require('./fields/BillingReceipt/Recipient')
const { SERVICES_FIELD } = require('./fields/BillingReceipt/Services')
const { TO_PAY_DETAILS_FIELD } = require('./fields/BillingReceipt/ToPayDetailsField')
const { RAW_DATA_FIELD, PERIOD_FIELD } = require('./fields/common')
const { INTEGRATION_CONTEXT_FIELD, BILLING_PROPERTY_FIELD, BILLING_ACCOUNT_FIELD } = require('./fields/relations')

const ERRORS = {
    WEBHOOK_URL_NOT_IN_WHITELIST: {
        code: BAD_USER_INPUT,
        type: 'WEBHOOK_URL_NOT_IN_WHITELIST',
        message: 'The webhook URL must be registered in PaymentStatusChangeWebhookUrl',
        messageForUser: 'api.billing.billingReceipt.WEBHOOK_URL_NOT_IN_WHITELIST',
    },
}

const findAcquiringContext = async (item) => {
    const billingContext = await getById('BillingIntegrationOrganizationContext', item.context)
    const acquiringContexts = await find('AcquiringIntegrationContext', { organization: { id: billingContext.organization }, status: CONTEXT_FINISHED_STATUS, deletedAt: null })
    return acquiringContexts[0]
}

const BillingReceipt = new GQLListSchema('BillingReceipt', {
    schemaDoc: 'Account monthly invoice document',
    fields: {
        context: {
            ...INTEGRATION_CONTEXT_FIELD,
            access: { ...INTEGRATION_CONTEXT_FIELD.access, read: access.canReadSensitiveBillingReceiptData },
        },
        property: {
            ...BILLING_PROPERTY_FIELD,
            access: { read: access.canReadSensitiveBillingReceiptData },
        },
        account: {
            ...BILLING_ACCOUNT_FIELD,
            access: { read: access.canReadSensitiveBillingReceiptData },
        },

        period: PERIOD_FIELD,

        // Refs migration: 20210823172647-0047_auto_20210823_1226.js
        importId: {
            schemaDoc: '`billing receipt` local object ID. Unique up to billing context. It is unique up to the context. ' +
                'The constrain is a combination of contextId and importId.',
            type: 'Text',
            isRequired: true,
            kmigratorOptions: { unique: true, null: false },
            hooks: {
                validateInput: async ({ resolvedData, addFieldValidationError }) => {
                    const resolvedImportId = get(resolvedData, ['importId'])

                    if (!resolvedImportId || typeof resolvedImportId !== 'string' || resolvedImportId.length === 0) {
                        addFieldValidationError(
                            `${WRONG_TEXT_FORMAT}importId] Cannot mutate billing receipt with empty or null importId, found ${resolvedImportId}`)
                    }
                },
            },
            access: { read: access.canReadSensitiveBillingReceiptData },
        },

        category: {
            schemaDoc: 'A category to print on display on the payment document.',
            type: 'Relationship',
            ref: 'BillingCategory',
            isRequired: true,
            knexOptions: { isNotNullable: true },
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
            defaultValue: { connect: { id: DEFAULT_BILLING_CATEGORY_ID } },
        },

        printableNumber: {
            schemaDoc: 'A number to print on the payment document.',
            type: 'Text',
            isRequired: false,
        },

        raw: {
            ...RAW_DATA_FIELD,
            access: { read: access.canReadSensitiveBillingReceiptData },
        },

        toPay: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'Total sum to pay. Usually counts as the sum of all services.',
            isRequired: true,
        },

        formula: {
            schemaDoc: 'Calculation formula. Example: balance + charge + recalculation + privilege + penalty',
            type: 'Text',
            // TODO(DOMA-6519): change read-only access to { create: true, read: true, update: true } after toPayDetails field removal
            access: readOnlyFieldAccess,
        },

        charge: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'Amount of money charged by paid period. Example: "50.00", "-50.00"',
            // TODO(DOMA-6519): change read-only access to { create: true, read: true, update: true } after toPayDetails field removal
            access: readOnlyFieldAccess,
        },

        balance: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'Recipient balance on the receipt creation moment. Example: "50.00", "-50.00"',
            // TODO(DOMA-6519): change read-only access to { create: true, read: true, update: true } after toPayDetails field removal
            access: readOnlyFieldAccess,
        },

        recalculation: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'Recipient balance recalculation in case of overpaid or etc. Example: "50.00", "-50.00"',
            // TODO(DOMA-6519): change read-only access to { create: true, read: true, update: true } after toPayDetails field removal
            access: readOnlyFieldAccess,
        },

        privilege: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'Special privileges for recipient. Example: "50.00", "-50.00"',
            // TODO(DOMA-6519): change read-only access to { create: true, read: true, update: true } after toPayDetails field removal
            access: readOnlyFieldAccess,
        },

        penalty: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'Amount of money that recipient doesn\'t pay for previous receipt. Example: "50.00", "-50.00"',
            // TODO(DOMA-6519): change read-only access to { create: true, read: true, update: true } after toPayDetails field removal
            access: readOnlyFieldAccess,
        },

        balanceUpdatedAt: {
            schemaDoc: 'Last date time when the balance was updated',
            type: 'DateTimeUtc',
            isRequired: false,
        },

        paid: {
            ...MONEY_AMOUNT_FIELD,
            schemaDoc: 'Amount of money that recipient already paid by current receipt. Example: "50.00", "-50.00"',
            // TODO(DOMA-6519): change read-only access to { create: true, read: true, update: true } after toPayDetails field removal
            access: readOnlyFieldAccess,
        },

        // TODO(DOMA-6519): remove field and provide backward compatibility options for API
        toPayDetails: TO_PAY_DETAILS_FIELD,

        services: SERVICES_FIELD,

        // TODO(abshnko): DOMA-7656 remove this field! we already have `receiver` field! And we can save this date in raw/meta field
        recipient: {
            ...RECIPIENT_FIELD,
            isRequired: false,
        },

        // TODO @toplenboren (Doma-2241) make this not null!
        receiver: {
            schemaDoc: 'Relation to the BillingRecipient. Going to override recipient field, has the same meaning',
            type: 'Relationship',
            ref: 'BillingRecipient',
            isRequired: true,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.CASCADE' },
        },

        invalidServicesError:  {
            schemaDoc: 'Indicates if services are valid and add up to total sum toPay.',
            type: 'Virtual',
            isRequired: false,
            resolver: async (receipt) => {
                const toPayAmount = Big(get(receipt, 'toPay') || 0)
                const paidAmount = Big(get(receipt, 'paid') || 0)
                const services = get(receipt, 'services', [])

                const servicesTotal = services
                    ? services.reduce((total, { toPay = 0 }) => Big(total).add(Big(toPay)), Big(0))
                    : Big(0)

                const servicesAreValid = servicesTotal.cmp(toPayAmount.add(paidAmount)) === 0

                if (services && services.length > 0 && !servicesAreValid) return `Services sum (${servicesTotal}) does not add up to the toPay (${toPayAmount}) amount correctly`

                return null
            },
        },

        file: {
            schemaDoc: 'A BillingReceiptFile that related to this billing receipt (filled up by integration)',
            type: 'Relationship',
            ref: 'BillingReceiptFile',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.SET_NULL' },
        },

        isPayable: {
            schemaDoc: 'Indicator that this invoice document is latest for its account and receiver/category',
            type: 'Virtual',
            isRequired: false,
            graphQLReturnType: 'Boolean',
            resolver: async (receipt) => {
                const category = await getByCondition('BillingCategory', {
                    id: get(receipt, 'category'),
                    deletedAt: null,
                })

                if (!category) return false

                const billingContext = await getByCondition('BillingIntegrationOrganizationContext', {
                    id: get(receipt, 'context'),
                    deletedAt: null,
                })
                if (!billingContext) return false

                const activeAcquiringContexts = await find('AcquiringIntegrationContext', {
                    organization: { id: get(billingContext, 'organization') },
                    status: CONTEXT_FINISHED_STATUS,
                    deletedAt: null,
                })
                if (!activeAcquiringContexts || activeAcquiringContexts.length !== 1) return false

                const validityMonths = get(category, 'receiptValidityMonths')
                if (validityMonths) {
                    const periodDate = dayjs(get(receipt, 'period'))
                    const lastValidDate = periodDate.add(validityMonths - 1, 'month').endOf('month')

                    if (dayjs().isAfter(lastValidDate)) return false
                }

                const receipts = await find('BillingReceipt', {
                    account: { id: get(receipt, 'account'), deletedAt: null },
                    OR: [
                        { receiver: { AND: [{ id: get(receipt, 'receiver') }, { deletedAt: null } ] } },
                        { category: { AND: [{ id: get(receipt, 'category') }, { deletedAt: null } ] } },
                    ],
                    period_gt: get(receipt, 'period'),
                    deletedAt: null,
                })

                return !(receipts && receipts.length)
            },
        },

        acquiringIntegrationId: {
            schemaDoc: 'Integration ID through which this receipt can be paid',
            type: 'Virtual',
            graphQLReturnType: 'ID',
            resolver: async (item, args, context) => {
                const acquiringContext = await findAcquiringContext(item)
                if (!isEmpty(acquiringContext)) {
                    const acquiringIntegration = await getById('AcquiringIntegration', get(acquiringContext, 'integration', null))
                    return get(acquiringIntegration, 'id', null)
                }
                return null
            },
            access: { create: false, read: true, update: false },
        },

        acquiringHostUrl: {
            schemaDoc: 'Url to acquiring integration service. Mobile devices will use it communicate with external acquiring. List of endpoints is the same for all of them.',
            type: 'Virtual',
            graphQLReturnType: 'String',
            resolver: async (item, args, context) => {
                const acquiringContext = await findAcquiringContext(item)
                if (!isEmpty(acquiringContext)) {
                    const acquiringIntegration = await getById('AcquiringIntegration', get(acquiringContext, 'integration', null))
                    return get(acquiringIntegration, 'hostUrl', null)
                }
                return null
            },
            access: { create: false, read: true, update: false },
        },

        canGroupReceipts: {
            schemaDoc: 'Can multiple receipts be united through this acquiring',
            type: 'Virtual',
            graphQLReturnType: 'Boolean',
            resolver: async (item, args, context) => {
                const acquiringContext = await findAcquiringContext(item)
                if (!isEmpty(acquiringContext)) {
                    const acquiringIntegration = await getById('AcquiringIntegration', get(acquiringContext, 'integration', null))
                    return get(acquiringIntegration, 'canGroupReceipts', null)
                }
                return null
            },
            access: { create: false, read: true, update: false },
        },

        currencyCode: {
            schemaDoc: 'Code of currency in ISO-4217 format',
            type: 'Virtual',
            graphQLReturnType: 'String',
            resolver: async (item, args, context) => {
                const billingContext = await getById('BillingIntegrationOrganizationContext', item.context)
                const billingIntegration = await getById('BillingIntegration', billingContext.integration)
                return get(billingIntegration, 'currencyCode', null)
            },
            access: { create: false, read: true, update: false },
        },

        amountDistribution: AMOUNT_DISTRIBUTION_FIELD({
            organizationIdResolver: async (context, validateInputAttrs) => {
                const { existingItem, resolvedData } = validateInputAttrs
                const nextData = { ...existingItem, ...resolvedData }
                const billingContext = await getById('BillingIntegrationOrganizationContext', nextData.context)

                return billingContext.organization
            },
        }),

        paymentStatusChangeWebhookUrl: PAYMENT_STATUS_CHANGE_WEBHOOK_URL_FIELD,

        paymentStatusChangeWebhookSecret: PAYMENT_STATUS_CHANGE_WEBHOOK_SECRET_FIELD,
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), analytical()],
    access: {
        read: access.canReadBillingReceipts,
        create: access.canManageBillingReceipts,
        update: access.canManageBillingReceipts,
        delete: false,
        auth: true,
    },
    kmigratorOptions: {
        indexes: [
            {
                type: 'BTreeIndex',
                fields: ['period', 'context'],
                name: 'billingReceipt_period_context',
                // This should add conditional index like in constraints, but is not yet implemented in kmigrator.
                // Instead you can add conditional index manually â€“ check 20240814005507-0417_billingreceipt_billingreceipt_period_context.js for reference
                // Don't forget to add CONCURRENTLY if running manually on large tables
                condition: 'Q(deletedAt__isnull=True)',
            },
        ],
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['context', 'importId'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'billingReceipt_unique_context_and_importId',
            },
        ],
    },
    hooks: {
        validateInput: async ({ resolvedData, addValidationError, existingItem, context }) => {
            const newItem = { ...existingItem, ...resolvedData }
            const { context: contextId, property: propertyId, account: accountId } = newItem

            const account = await getById('BillingAccount', accountId)
            const { context: accountContextId } = account
            const property = await getById('BillingProperty', propertyId)
            const { context: propertyContextId } = property
            if (contextId !== accountContextId) {
                return addValidationError(`${UNEQUAL_CONTEXT_ERROR}:account:context] Context is not equal to account.context`)
            }
            if (contextId !== propertyContextId) {
                return addValidationError(`${UNEQUAL_CONTEXT_ERROR}:property:context] Context is not equal to property.context`)
            }

            // Validate callback URL is in whitelist
            // Normalize empty string to null
            let callbackUrl = get(resolvedData, 'paymentStatusChangeWebhookUrl')
            if (!callbackUrl) {
                callbackUrl = null
                resolvedData['paymentStatusChangeWebhookUrl'] = null
            }
            if (callbackUrl && !await isWebhookUrlInWhitelist(callbackUrl)) {
                throw new GQLError(ERRORS.WEBHOOK_URL_NOT_IN_WHITELIST, context)
            }
        },
        resolveInput: ({ resolvedData, existingItem, context }) => {
            // TODO(DOMA-6519): remove hook after toPayDetails field removal
            // Update toPayDetails explicit fields directly from passed value
            if ('toPayDetails' in resolvedData) {
                resolvedData = { ...resolvedData, ...resolvedData.toPayDetails }
            }

            // Auto-generate webhook secret when callback URL is set
            applyWebhookSecretGeneration(resolvedData, existingItem, context)

            return resolvedData
        },
        beforeChange: async ({ existingItem, resolvedData, context }) => {
            const { sender: { fingerprint } } = resolvedData

            // Handle cases when we do not need to search for BillingRecipient
            // receiver is explicitly set
            if ('receiver' in resolvedData) {
                return
            }
            // receiver is in existing item and not being updated
            if (existingItem && 'receiver' in existingItem && !('receiver' in resolvedData) && !('recipient' in resolvedData)) {
                return
            }

            const newItem = { ...existingItem, ...resolvedData }
            const contextId = get(newItem, 'context')
            const recipient = get(newItem, 'recipient')

            let receiverId
            const sameRecipient = await getByCondition('BillingRecipient', {
                context: { id: contextId },
                tin: get(recipient, 'tin'),
                bic: get(recipient, 'bic'),
                bankAccount: get(recipient, 'bankAccount'),
                deletedAt: null,
            })
            const { bankName = '', territoryCode = '', offsettingAccount = '' } = recipient
            if (sameRecipient) {
                receiverId = sameRecipient.id
            } else {
                const createdRecipient = await BillingRecipient.create(context, {
                    dv: 1,
                    sender: { dv: 1, fingerprint: fingerprint },
                    context: { connect: { id: contextId } },
                    name: get(recipient, 'name', null),
                    tin: get(recipient, 'tin'),
                    iec: get(recipient, 'iec'),
                    bic: get(recipient, 'bic'),
                    bankAccount: get(recipient, 'bankAccount'),
                    bankName, territoryCode, offsettingAccount,
                })
                receiverId = createdRecipient.id
            }
            resolvedData.receiver = receiverId
        },
        afterChange: async (args) => {
            // Return plain text webhook secret on creation
            returnPlainTextWebhookSecretOnCreation(args)
        },
    },
})

module.exports = {
    BillingReceipt,
}
