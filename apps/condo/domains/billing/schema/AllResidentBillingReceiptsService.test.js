/**
 * Generated by `createservice billing.BillingReceiptsService --type queries`
 */

const Big = require('Big.js')

const { makeLoggedInAdminClient } = require('@open-condo/keystone/test.utils')

const {
    CONTEXT_FINISHED_STATUS: ACQUIRING_CONTEXT_FINISHED_STATUS,
    CONTEXT_IN_PROGRESS_STATUS: ACQUIRING_CONTEXT_IN_PROGRESS_STATUS,
} = require('@condo/domains/acquiring/constants/context')
const {
    completeTestPayment,
    createTestAcquiringIntegrationContext,
    updateTestAcquiringIntegrationContext,
    createTestAcquiringIntegration,
} = require('@condo/domains/acquiring/utils/testSchema')
const { createTestRecipient } = require('@condo/domains/billing/utils/testSchema')
const {
    createTestBillingAccount,
    createTestBillingProperty,
    createTestBillingIntegrationOrganizationContext,
    updateTestBillingIntegrationOrganizationContext,
    createTestBillingIntegrationAccessRight,
} = require('@condo/domains/billing/utils/testSchema')
const {
    CONTEXT_FINISHED_STATUS: BILLING_CONTEXT_FINISHED_STATUS,
    CONTEXT_IN_PROGRESS_STATUS: BILLING_CONTEXT_IN_PROGRESS_STATUS,
} = require('@condo/domains/miniapp/constants')
const { makeClientWithProperty, createTestProperty, updateTestProperty } = require('@condo/domains/property/utils/testSchema')
const { registerServiceConsumerByTestClient, updateTestServiceConsumer, registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const { makeClientWithResidentUser, makeClientWithSupportUser, makeClientWithServiceUser } = require('@condo/domains/user/utils/testSchema')

const { createTestBillingIntegration, createTestBillingReceipt, updateTestBillingReceipt, ResidentBillingReceipt } = require('../utils/testSchema')

const HOUSING_CATEGORY = '928c97ef-5289-4daa-b80e-4b9fed50c629'
const OVERHAUL_CATEGORY = 'c0b9db6a-c351-4bf4-aa35-8e5a500d0195'

async function makeClientWithResidentAndServiceConsumer (property, billingAccount, organization = null) {
    const residentUser = await makeClientWithResidentUser()
    const [resident] = await registerResidentByTestClient(residentUser, {
        address: property.address,
        addressMeta: property.addressMeta,
        unitName: billingAccount.unitName,
    })
    residentUser.resident = resident
    const [serviceConsumer] = await registerServiceConsumerByTestClient(residentUser, {
        residentId: resident.id,
        accountNumber: billingAccount.number,
        organizationId: organization.id,
    })
    residentUser.serviceConsumer = serviceConsumer
    return residentUser
}

describe('AllResidentBillingReceiptsService', () => {
    const data = {
        admin: null,
        userClient: null,
        supportClient: null,
        integrationClient: null,
        organization: null,
        property: null,
        billingContext: null,
        acquiringContext: null,
    }
    beforeAll(async () => {
        data.admin = await makeLoggedInAdminClient()
        const { organization, property, ...userClient } =  await makeClientWithProperty()
        data.userClient = userClient
        data.organization = organization
        data.property = property
        data.supportClient = await makeClientWithSupportUser()
        const [integration] = await createTestBillingIntegration(data.supportClient, { isTrustedBankAccountSource: true })
        const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, organization, integration, {
            status: BILLING_CONTEXT_FINISHED_STATUS,
        })
        data.billingContext = billingContext
        const [acquiringIntegration] = await createTestAcquiringIntegration(data.supportClient, {
            canGroupReceipts: true,
        })
        const [acquiringContext] = await createTestAcquiringIntegrationContext(userClient, organization, acquiringIntegration, {
            status: ACQUIRING_CONTEXT_FINISHED_STATUS,
        })
        data.acquiringContext = acquiringContext
        data.integrationClient = await makeClientWithServiceUser()
        await createTestBillingIntegrationAccessRight(data.supportClient, integration, data.integrationClient.user)
    })

    describe('Resident access and filters', () => {

        it('should contain fields for resident', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const { serviceConsumer, ...residentUser } = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)
            const residentBillingReceipts = await ResidentBillingReceipt.getAll(residentUser)
            expect(residentBillingReceipts).toBeDefined()
            expect(residentBillingReceipts).not.toHaveLength(0)
            residentBillingReceipts.forEach(receipt => {
                expect(receipt).toHaveProperty('id')
                expect(receipt).toHaveProperty('toPay')
                expect(receipt).toHaveProperty('paid')
                expect(receipt).toHaveProperty('period')
                expect(receipt).toHaveProperty('recipient')
                expect(receipt.serviceConsumer.id).toEqual(serviceConsumer.id)
                expect(receipt).toHaveProperty('currencyCode')
                expect(receipt).toHaveProperty('category')
                expect(receipt).toHaveProperty('services')
            })
        })

        it('should have the same receipt for different residents with the same unit', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)

            const residentWifeClient = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const residentHusbandClient = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const husbandReceipts = await ResidentBillingReceipt.getAll(residentHusbandClient, {
                serviceConsumer: { resident: { id: residentHusbandClient.resident.id } },
            })
            const wifeReceipts = await ResidentBillingReceipt.getAll(residentWifeClient, {
                serviceConsumer: { resident: { id: residentWifeClient.resident.id } },
            })
            expect(husbandReceipts.some(({ id }) => id === receipt.id)).toBe(true)
            expect(wifeReceipts.some(({ id }) => id === receipt.id)).toBe(true)
        })

        it('can filter residentBillingReceipts by serviceConsumer', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const [anotherProperty] = await createTestProperty(userClient, organization)
            const [anotherBillingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: anotherProperty.address,
            })
            const [anotherBillingAccount] = await createTestBillingAccount(integrationClient, billingContext, anotherBillingProperty)
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)
            const [anotherReceipt] = await createTestBillingReceipt(integrationClient, billingContext, anotherBillingProperty, anotherBillingAccount)

            const residentUser = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const propertyReceipts = await ResidentBillingReceipt.getAll(residentUser, {
                serviceConsumer: { resident: { id: residentUser.resident.id } },
            })
            const [anotherResident] = await registerResidentByTestClient(residentUser, {
                address: anotherProperty.address,
                addressMeta: anotherProperty.addressMeta,
                unitName: anotherBillingAccount.unitName,
            })
            await registerServiceConsumerByTestClient(residentUser, {
                residentId: anotherResident.id,
                accountNumber: anotherBillingAccount.number,
                organizationId: organization.id,
            })
            const anotherPropertyReceipts = await ResidentBillingReceipt.getAll(residentUser, {
                serviceConsumer: { resident: { id: anotherResident.id } },
            })
            expect(propertyReceipts.some(({ id }) => id === receipt.id)).toBe(true)
            expect(propertyReceipts.some(({ id }) => id === anotherReceipt.id)).toBe(false)

            expect(anotherPropertyReceipts.some(({ id }) => id === receipt.id)).toBe(false)
            expect(anotherPropertyReceipts.some(({ id }) => id === anotherReceipt.id)).toBe(true)
        })

        it('should return the same receipt, after serviceConsumer was recreated', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)

            const { serviceConsumer, ...residentClient } = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const ordinaryReceipts = await ResidentBillingReceipt.getAll(residentClient, {})
            await updateTestServiceConsumer(residentClient, serviceConsumer.id, { deletedAt: new Date().toISOString() })
            const receiptsAfterDeletingConsumer = await ResidentBillingReceipt.getAll(residentClient, {})
            await registerServiceConsumerByTestClient(residentClient, {
                residentId: residentClient.resident.id,
                accountNumber: billingAccount.number,
                organizationId: organization.id,
            })
            const restoredConsumersReceipts = await ResidentBillingReceipt.getAll(residentClient, {})
            expect(ordinaryReceipts.some(({ id }) => id === receipt.id)).toBeTruthy()
            expect(receiptsAfterDeletingConsumer.some(({ id }) => id === receipt.id)).toBeFalsy()
            expect(restoredConsumersReceipts.some(({ id }) => id === receipt.id)).toBeTruthy()
        })

        it('should return all receipts for the consumer', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const [overhaulReceipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                category: { connect: { id: OVERHAUL_CATEGORY } },
            })
            const [housingReceipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                category: { connect: { id: HOUSING_CATEGORY } },
            })
            const residentClient = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const receipts = await ResidentBillingReceipt.getAll(residentClient, {
                serviceConsumer: { resident: { id: residentClient.resident.id } },
            })
            expect(receipts.some(({ id }) => id === overhaulReceipt.id)).toBeTruthy()
            expect(receipts.some(({ id }) => id === housingReceipt.id)).toBeTruthy()
        })

        // Housing from organization and overhaul from eps bug fix
        it('should correctly set serviceConsumer to output result for several organizations on the same address', async () => {
            const [dataProperty] = await createTestProperty(data.userClient, data.organization)
            const [dataBillingProperty] = await createTestBillingProperty(data.integrationClient, data.billingContext, {
                address: dataProperty.address,
            })
            const [dataBillingAccount] = await createTestBillingAccount(data.integrationClient, data.billingContext, dataBillingProperty)
            const [overhaulReceipt] = await createTestBillingReceipt(data.integrationClient, data.billingContext, dataBillingProperty, dataBillingAccount, {
                category: { connect: { id: OVERHAUL_CATEGORY } },
            })
            const { organization, ...userClient } =  await makeClientWithProperty()
            const [integration] = await createTestBillingIntegration(data.supportClient, { isTrustedBankAccountSource: true })
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, organization, integration, {
                status: BILLING_CONTEXT_FINISHED_STATUS,
            })
            const [acquiringIntegration] = await createTestAcquiringIntegration(data.supportClient, {
                canGroupReceipts: true,
            })
            await createTestAcquiringIntegrationContext(userClient, organization, acquiringIntegration, {
                status: ACQUIRING_CONTEXT_FINISHED_STATUS,
            })
            await createTestBillingIntegrationAccessRight(data.supportClient, integration, data.integrationClient.user)
            const [property] = await createTestProperty(userClient, organization, {
                address: dataProperty.address,
            })
            const [billingProperty] = await createTestBillingProperty(data.integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(data.integrationClient, billingContext, billingProperty, {
                number: dataBillingAccount.number,
                unitName: dataBillingAccount.unitName,
                unitType: dataBillingAccount.unitType,
            })
            const [housingReceipt] = await createTestBillingReceipt(data.integrationClient, billingContext, billingProperty, billingAccount, {
                category: { connect: { id: HOUSING_CATEGORY } },
            })
            const { serviceConsumer: serviceConsumer1, ...residentClient } = await makeClientWithResidentAndServiceConsumer(dataProperty, dataBillingAccount, data.organization)
            const [anotherResident] = await registerResidentByTestClient(residentClient, {
                address: property.address,
                addressMeta: property.addressMeta,
                unitName: billingAccount.unitName,
            })
            const [serviceConsumer2] = await registerServiceConsumerByTestClient(residentClient, {
                residentId: anotherResident.id,
                accountNumber: billingAccount.number,
                organizationId: organization.id,
            })
            const receipts = await ResidentBillingReceipt.getAll(residentClient)
            expect(receipts.some(({ id, serviceConsumer }) => id === overhaulReceipt.id && serviceConsumer.id === serviceConsumer1.id )).toBeTruthy()
            expect(receipts.some(({ id, serviceConsumer }) => id === housingReceipt.id && serviceConsumer.id === serviceConsumer2.id)).toBeTruthy()
        })
    })

    describe('Payable receipts', () => {

        it('should select only one latest receipt from each category + accountNumber by period and mark it as payable', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const MARCH_PERIOD = '2022-03-01'
            const APRIL_PERIOD = '2022-04-01'
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const [oldOverhaulReceipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                category: { connect: { id: OVERHAUL_CATEGORY } },
                period: MARCH_PERIOD,
            })
            const [newOverhaulReceipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                category: { connect: { id: OVERHAUL_CATEGORY } },
                period: APRIL_PERIOD,
            })
            const [oldHousingReceipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                category: { connect: { id: HOUSING_CATEGORY } },
                period: MARCH_PERIOD,
            })
            const residentClient = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const receipts = await ResidentBillingReceipt.getAll(residentClient, {
                serviceConsumer: { resident: { id: residentClient.resident.id } },
            }, { sortBy: 'period_DESC' })
            expect(receipts.some(({ id, isPayable }) => id === oldOverhaulReceipt.id && isPayable === false)).toBeTruthy()
            expect(receipts.some(({ id, isPayable }) => id === newOverhaulReceipt.id && isPayable === true)).toBeTruthy()
            expect(receipts.some(({ id, isPayable }) => id === oldHousingReceipt.id && isPayable === true)).toBeTruthy()
        })
        // change requisites bug fix
        it('should not mark 2 receipts as payable with a same category on organization bankAccount change', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const MARCH_PERIOD = '2022-03-01'
            const APRIL_PERIOD = '2022-04-01'
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const oldRequisites = createTestRecipient({ name: 'Old bank requisites' })
            const newRequisites = createTestRecipient({ name: 'New bank requisites' })
            expect(oldRequisites.bankAccount).not.toEqual(newRequisites.bankAccount)
            const [oldOverhaulReceipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                category: { connect: { id: OVERHAUL_CATEGORY } },
                period: MARCH_PERIOD,
                recipient: oldRequisites,
            })
            const [newOverhaulReceipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                category: { connect: { id: OVERHAUL_CATEGORY } },
                period: APRIL_PERIOD,
                recipient: newRequisites,
            })
            const residentClient = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const receipts = await ResidentBillingReceipt.getAll(residentClient, {
                serviceConsumer: { resident: { id: residentClient.resident.id } },
            }, { sortBy: 'period_DESC' })
            expect(receipts.some(({ id, isPayable }) => id === oldOverhaulReceipt.id && isPayable === false)).toBeTruthy()
            expect(receipts.some(({ id, isPayable }) => id === newOverhaulReceipt.id && isPayable === true)).toBeTruthy()
        })
    })

    describe('Paid field', () => {

        it('should return correct paid amount after receipt was paid', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const { serviceConsumer, ...residentClient } = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const INITIAL_AMOUNT = '10000.00'
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                toPay: INITIAL_AMOUNT,
            })
            const beforePaymentReceipt = (await ResidentBillingReceipt.getAll(residentClient)).find(({ id }) => id === receipt.id)
            expect(Big(beforePaymentReceipt.toPay).toFixed(2)).toEqual(INITIAL_AMOUNT)
            expect(Big(beforePaymentReceipt.paid).toFixed(2)).toEqual('0.00')
            await completeTestPayment(residentClient, data.admin, serviceConsumer.id, receipt.id )
            const afterPaymentReceipt = (await ResidentBillingReceipt.getAll(residentClient)).find(({ id }) => id === receipt.id)
            expect(Big(afterPaymentReceipt.paid).toFixed(2)).toEqual(INITIAL_AMOUNT)
        })

        it('should return correct paid after receipt was paid, and then recreated', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const { serviceConsumer, ...residentClient } = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const INITIAL_AMOUNT = '10000.00'
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                toPay: INITIAL_AMOUNT,
            })
            const beforePaymentReceipt = (await ResidentBillingReceipt.getAll(residentClient)).find(({ id }) => id === receipt.id)
            expect(Big(beforePaymentReceipt.toPay).toFixed(2)).toEqual(INITIAL_AMOUNT)
            expect(Big(beforePaymentReceipt.paid).toFixed(2)).toEqual('0.00')
            await completeTestPayment(residentClient, data.admin, serviceConsumer.id, receipt.id )
            await updateTestBillingReceipt(data.integrationClient, receipt.id, { deletedAt: new Date().toISOString() })
            const [newReceipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                toPay: INITIAL_AMOUNT,
                recipient: receipt.recipient,
            })
            const afterPaymentReceipt = (await ResidentBillingReceipt.getAll(residentClient)).find(({ id }) => id === newReceipt.id)
            expect(Big(afterPaymentReceipt.paid).toFixed(2)).toEqual(INITIAL_AMOUNT)
        })

        it('should subtract amount if receipt was paid, by another person', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const INITIAL_AMOUNT = '10000.00'
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount, {
                toPay: INITIAL_AMOUNT,
            })
            const residentWifeClient = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const { serviceConsumer, ...residentHusbandClient } = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const husbandReceiptsBeforePay = await ResidentBillingReceipt.getAll(residentHusbandClient, {
                serviceConsumer: { resident: { id: residentHusbandClient.resident.id } },
            })
            const wifeReceiptsBeforePay = await ResidentBillingReceipt.getAll(residentWifeClient, {
                serviceConsumer: { resident: { id: residentWifeClient.resident.id } },
            })
            expect(husbandReceiptsBeforePay.some(({ id, paid }) => id === receipt.id && Big(paid).toFixed(2) === '0.00')).toBe(true)
            expect(wifeReceiptsBeforePay.some(({ id, paid }) => id === receipt.id && Big(paid).toFixed(2) === '0.00')).toBe(true)
            await completeTestPayment(residentHusbandClient, data.admin, serviceConsumer.id, receipt.id )
            const husbandReceiptsAfterPay = await ResidentBillingReceipt.getAll(residentHusbandClient, {
                serviceConsumer: { resident: { id: residentHusbandClient.resident.id } },
            })
            const wifeReceiptsAfterPay = await ResidentBillingReceipt.getAll(residentWifeClient, {
                serviceConsumer: { resident: { id: residentWifeClient.resident.id } },
            })
            expect(husbandReceiptsAfterPay.some(({ id, paid }) => id === receipt.id && Big(paid).toFixed(2) === INITIAL_AMOUNT)).toBe(true)
            expect(wifeReceiptsAfterPay.some(({ id, paid }) => id === receipt.id && Big(paid).toFixed(2) === INITIAL_AMOUNT)).toBe(true)
        })

    })

    describe('Restrictions for Resident', () => {

        it('should not get receipt for deleted property', async () => {
            const { integrationClient, billingContext, organization, userClient } = data
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)
            const residentUser = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)
            const receiptsBeforePropertyIsDeleted = await ResidentBillingReceipt.getAll(residentUser)
            expect(receiptsBeforePropertyIsDeleted.some(({ id }) => id === receipt.id)).toBeTruthy()
            await updateTestProperty(userClient, property.id, { deletedAt: new Date().toISOString() })
            const receiptsAfterPropertyIsDeleted = await ResidentBillingReceipt.getAll(residentUser)
            expect(receiptsAfterPropertyIsDeleted.some(({ id }) => id === receipt.id)).toBeFalsy()
        })

        it('should not get receipt when billing context is disabled', async () => {
            const { organization, ...userClient } =  await makeClientWithProperty()
            const [integration] = await createTestBillingIntegration(data.supportClient, { isTrustedBankAccountSource: true })
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, organization, integration, {
                status: BILLING_CONTEXT_FINISHED_STATUS,
            })
            const [acquiringIntegration] = await createTestAcquiringIntegration(data.supportClient, {
                canGroupReceipts: true,
            })
            await createTestAcquiringIntegrationContext(userClient, organization, acquiringIntegration, {
                status: ACQUIRING_CONTEXT_FINISHED_STATUS,
            })
            await createTestBillingIntegrationAccessRight(data.supportClient, integration, data.integrationClient.user)
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(data.integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(data.integrationClient, billingContext, billingProperty)
            const residentUser = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const [receipt] = await createTestBillingReceipt(data.integrationClient, billingContext, billingProperty, billingAccount)
            const receiptsBeforeBillingContextDisable = await ResidentBillingReceipt.getAll(residentUser)
            expect(receiptsBeforeBillingContextDisable.some(({ id }) => id === receipt.id)).toBeTruthy()
            await updateTestBillingIntegrationOrganizationContext(data.supportClient, billingContext.id, { status: BILLING_CONTEXT_IN_PROGRESS_STATUS })
            const receiptsAfterBillingContextDisable = await ResidentBillingReceipt.getAll(residentUser)
            expect(receiptsAfterBillingContextDisable.some(({ id }) => id === receipt.id)).toBeFalsy()
        })

        it('should not get receipt when acquiring context is disabled', async () => {
            const { organization, ...userClient } =  await makeClientWithProperty()
            const [integration] = await createTestBillingIntegration(data.supportClient, { isTrustedBankAccountSource: true })
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, organization, integration, {
                status: BILLING_CONTEXT_FINISHED_STATUS,
            })
            const [acquiringIntegration] = await createTestAcquiringIntegration(data.supportClient, {
                canGroupReceipts: true,
            })
            const [acquiringContext] = await createTestAcquiringIntegrationContext(userClient, organization, acquiringIntegration, {
                status: ACQUIRING_CONTEXT_FINISHED_STATUS,
            })
            await createTestBillingIntegrationAccessRight(data.supportClient, integration, data.integrationClient.user)
            const [property] = await createTestProperty(userClient, organization)
            const [billingProperty] = await createTestBillingProperty(data.integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(data.integrationClient, billingContext, billingProperty)
            const residentUser = await makeClientWithResidentAndServiceConsumer(property, billingAccount, organization)
            const [receipt] = await createTestBillingReceipt(data.integrationClient, billingContext, billingProperty, billingAccount)
            const receiptsBeforeAcquiringContextDisable = await ResidentBillingReceipt.getAll(residentUser)
            expect(receiptsBeforeAcquiringContextDisable.some(({ id }) => id === receipt.id)).toBeTruthy()
            await updateTestAcquiringIntegrationContext(data.supportClient, acquiringContext.id, { status: ACQUIRING_CONTEXT_IN_PROGRESS_STATUS })
            const receiptsAfterAcquiringContextDisable = await ResidentBillingReceipt.getAll(residentUser)
            expect(receiptsAfterAcquiringContextDisable.some(({ id }) => id === receipt.id)).toBeFalsy()
        })

    })

})
