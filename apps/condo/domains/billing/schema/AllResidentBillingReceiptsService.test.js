/**
 * Generated by `createservice billing.BillingReceiptsService --type queries`
 */

const path = require('path')

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { catchErrorFrom } = require('@open-condo/keystone/test.utils')
const { makeLoggedInAdminClient } = require('@open-condo/keystone/test.utils')

const {
    CONTEXT_FINISHED_STATUS: ACQUIRING_CONTEXT_FINISHED_STATUS,
} = require('@condo/domains/acquiring/constants/context')
const {
    completeTestPayment,
    createTestAcquiringIntegrationContext,
    createTestAcquiringIntegration,
} = require('@condo/domains/acquiring/utils/testSchema')
const { makeClientWithPropertyAndBilling, createTestBillingRecipient } = require('@condo/domains/billing/utils/testSchema')
const { createTestBillingAccount, createTestBillingProperty, createTestBillingIntegrationOrganizationContext, createTestBillingIntegrationAccessRight, makeClientWithResidentAndServiceConsumer } = require('@condo/domains/billing/utils/testSchema')
const {
    createTestContact,
    updateTestContact,
} = require('@condo/domains/contact/utils/testSchema')
const {
    CONTEXT_FINISHED_STATUS: BILLING_CONTEXT_FINISHED_STATUS,
} = require('@condo/domains/miniapp/constants')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithProperty, createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { registerServiceConsumerByTestClient, updateTestServiceConsumer, registerResidentByTestClient, createTestResident, ServiceConsumer } = require('@condo/domains/resident/utils/testSchema')
const { addResidentAccess, makeClientWithResidentUser, makeClientWithSupportUser, makeClientWithServiceUser } = require('@condo/domains/user/utils/testSchema')

const { createTestBillingIntegration, createTestBillingReceipt, updateTestBillingReceipt, ResidentBillingReceipt,
    generateServicesData, createTestBillingReceiptFile, updateTestBillingReceiptFile, PUBLIC_FILE, PRIVATE_FILE,
} = require('../utils/testSchema')

const HOUSING_CATEGORY = '928c97ef-5289-4daa-b80e-4b9fed50c629'
const OVERHAUL_CATEGORY = 'c0b9db6a-c351-4bf4-aa35-8e5a500d0195'
const ELECTRICITY_CATEGORY = '9c29b499-6594-4479-a2a7-b6553587d6e2'
const WATER_CATEGORY = 'b84acc8b-ee9d-401c-bde6-75a284d84789'

// TODO(zuch): After hotfix rewrite tests using beforeAll with this function
async function init () {
    const data = {
        admin: null,
        userClient: null,
        supportClient: null,
        integrationClient: null,
        organization: null,
        property: null,
        billingContext: null,
        acquiringContext: null,
    }
    data.admin = await makeLoggedInAdminClient()
    const { organization, property, ...userClient } =  await makeClientWithProperty()
    data.userClient = userClient
    data.organization = organization
    data.property = property
    data.supportClient = await makeClientWithSupportUser()
    const [integration] = await createTestBillingIntegration(data.supportClient, { isTrustedBankAccountSource: true })
    const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, organization, integration, {
        status: BILLING_CONTEXT_FINISHED_STATUS,
    })
    data.billingContext = billingContext
    const [acquiringIntegration] = await createTestAcquiringIntegration(data.supportClient, {
        canGroupReceipts: true,
    })
    const [acquiringContext] = await createTestAcquiringIntegrationContext(userClient, organization, acquiringIntegration, {
        status: ACQUIRING_CONTEXT_FINISHED_STATUS,
    })
    data.acquiringContext = acquiringContext
    data.integrationClient = await makeClientWithServiceUser()
    await createTestBillingIntegrationAccessRight(data.supportClient, integration, data.integrationClient.user)
    return data
}

describe('AllResidentBillingReceiptsService', () => {

    describe('fields for resident',  () => {
        it('returns all required fields', async () => {
            const userClient = await makeClientWithProperty()
            const support = await makeClientWithSupportUser()

            const [integration] = await createTestBillingIntegration(support)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, userClient.organization, integration)

            const integrationClient = await makeClientWithServiceUser()
            await createTestBillingIntegrationAccessRight(support, integration, integrationClient.user)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: userClient.property.address,
            })
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)

            const residentUser = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(residentUser, {
                address: userClient.property.address,
                addressMeta: userClient.property.addressMeta,
                unitName: billingAccountAttrs.unitName,
            })
            await registerServiceConsumerByTestClient(residentUser, {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            })
            await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)
            const residentBillingReceipts = await ResidentBillingReceipt.getAll(residentUser)

            expect(residentBillingReceipts).toBeDefined()
            expect(residentBillingReceipts).not.toHaveLength(0)
            residentBillingReceipts.forEach(receipt => {
                expect(receipt).toHaveProperty('id')
                expect(receipt.id).not.toBeNull()

                expect(receipt).toHaveProperty('toPay')
                expect(receipt.toPay).not.toBeNull()

                expect(receipt).toHaveProperty('paid')
                expect(receipt.paid).not.toBeNull()

                expect(receipt).toHaveProperty('period')
                expect(receipt.period).not.toBeNull()

                expect(receipt).toHaveProperty('recipient')
                expect(receipt.recipient).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer')
                expect(receipt.serviceConsumer).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer.id')
                expect(receipt.serviceConsumer.id).not.toBeNull()

                expect(receipt).toHaveProperty('currencyCode')
                expect(receipt.currencyCode).not.toBeNull()

                expect(receipt).toHaveProperty('category')
                expect(receipt.category).not.toBeNull()

                expect(receipt).toHaveProperty('services')
                expect(receipt.services).not.toBeNull()
            })
        })

        it('should correctly set serviceConsumer to output result for several organizations on the same address with equal account number', async () => {
            const data = await init()
            const [dataProperty] = await createTestProperty(data.userClient, data.organization)
            const [dataBillingProperty] = await createTestBillingProperty(data.integrationClient, data.billingContext, {
                address: dataProperty.address,
            })
            const [dataBillingAccount] = await createTestBillingAccount(data.integrationClient, data.billingContext, dataBillingProperty)
            const [overhaulReceipt] = await createTestBillingReceipt(data.integrationClient, data.billingContext, dataBillingProperty, dataBillingAccount, {
                category: { connect: { id: OVERHAUL_CATEGORY } },
            })
            const { organization, ...userClient } =  await makeClientWithProperty()
            const [integration] = await createTestBillingIntegration(data.supportClient, { isTrustedBankAccountSource: true })
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, organization, integration, {
                status: BILLING_CONTEXT_FINISHED_STATUS,
            })
            const [acquiringIntegration] = await createTestAcquiringIntegration(data.supportClient, {
                canGroupReceipts: true,
            })
            await createTestAcquiringIntegrationContext(userClient, organization, acquiringIntegration, {
                status: ACQUIRING_CONTEXT_FINISHED_STATUS,
            })
            await createTestBillingIntegrationAccessRight(data.supportClient, integration, data.integrationClient.user)
            const [property] = await createTestProperty(userClient, organization, {
                address: dataProperty.address,
            })
            const [billingProperty] = await createTestBillingProperty(data.integrationClient, billingContext, {
                address: property.address,
            })
            const [billingAccount] = await createTestBillingAccount(data.integrationClient, billingContext, billingProperty, {
                number: dataBillingAccount.number,
                unitName: dataBillingAccount.unitName,
                unitType: dataBillingAccount.unitType,
            })
            const [housingReceipt] = await createTestBillingReceipt(data.integrationClient, billingContext, billingProperty, billingAccount, {
                category: { connect: { id: HOUSING_CATEGORY } },
            })
            const { serviceConsumer: serviceConsumer1, ...residentClient } = await makeClientWithResidentAndServiceConsumer(dataProperty, dataBillingAccount, data.organization)
            const [anotherResident] = await registerResidentByTestClient(residentClient, {
                address: property.address,
                addressMeta: property.addressMeta,
                unitName: billingAccount.unitName,
            })
            const [serviceConsumer2] = await registerServiceConsumerByTestClient(residentClient, {
                residentId: anotherResident.id,
                accountNumber: billingAccount.number,
                organizationId: organization.id,
            })
            const receipts = await ResidentBillingReceipt.getAll(residentClient)
            expect(receipts.some(({ id, serviceConsumer }) => id === overhaulReceipt.id && serviceConsumer.id === serviceConsumer1.id )).toBeTruthy()
            expect(receipts.some(({ id, serviceConsumer }) => id === housingReceipt.id && serviceConsumer.id === serviceConsumer2.id)).toBeTruthy()
        })

        it('returns public file', async () => {
            const userClient = await makeClientWithProperty()
            const support = await makeClientWithSupportUser()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(support)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, userClient.organization, integration)

            const integrationClient = await makeClientWithServiceUser()
            await createTestBillingIntegrationAccessRight(support, integration, integrationClient.user)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: userClient.property.address,
            })
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)

            const residentUser = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(residentUser, {
                address: userClient.property.address,
                addressMeta: userClient.property.addressMeta,
                unitName: billingAccountAttrs.unitName,
            })
            await registerServiceConsumerByTestClient(residentUser, {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            })
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)

            // create BillingReceiptFile
            const [receiptFile] = await createTestBillingReceiptFile(adminClient, receipt, billingContext)

            // set primary file
            await updateTestBillingReceipt(integrationClient, receipt.id, {
                file: { connect: { id: receiptFile.id } },
            })

            // getting the result
            const residentBillingReceipts = await ResidentBillingReceipt.getAll(residentUser)

            expect(residentBillingReceipts).toBeDefined()
            expect(residentBillingReceipts).not.toHaveLength(0)
            residentBillingReceipts.forEach(receipt => {
                expect(receipt).toHaveProperty('id')
                expect(receipt.id).not.toBeNull()

                expect(receipt).toHaveProperty('toPay')
                expect(receipt.toPay).not.toBeNull()

                expect(receipt).toHaveProperty('paid')
                expect(receipt.paid).not.toBeNull()

                expect(receipt).toHaveProperty('period')
                expect(receipt.period).not.toBeNull()

                expect(receipt).toHaveProperty('recipient')
                expect(receipt.recipient).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer')
                expect(receipt.serviceConsumer).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer.id')
                expect(receipt.serviceConsumer.id).not.toBeNull()

                expect(receipt).toHaveProperty('currencyCode')
                expect(receipt.currencyCode).not.toBeNull()

                expect(receipt).toHaveProperty('category')
                expect(receipt.category).not.toBeNull()

                expect(receipt).toHaveProperty('services')
                expect(receipt.services).not.toBeNull()

                expect(receipt).toHaveProperty('file')
                expect(receipt.file).not.toBeNull()

                expect(receipt.file).toHaveProperty('file')
                expect(receipt.file.file).not.toBeNull()
                expect(receipt.file.file.originalFilename).toEqual(path.basename(PUBLIC_FILE))
            })
        })

        it('returns sensetive file', async () => {
            const userClient = await makeClientWithProperty()
            const support = await makeClientWithSupportUser()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(support)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, userClient.organization, integration)

            const integrationClient = await makeClientWithServiceUser()
            await createTestBillingIntegrationAccessRight(support, integration, integrationClient.user)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: userClient.property.address,
            })
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)

            const residentUser = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(residentUser, {
                address: userClient.property.address,
                addressMeta: userClient.property.addressMeta,
                unitName: billingAccountAttrs.unitName,
            })
            await registerServiceConsumerByTestClient(residentUser, {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            })
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)

            // create BillingReceiptFile
            const [receiptFile] = await createTestBillingReceiptFile(adminClient, receipt, billingContext)

            // set primary file
            await updateTestBillingReceipt(integrationClient, receipt.id, {
                file: { connect: { id: receiptFile.id } },
            })

            // set contact
            await createTestContact(adminClient, userClient.organization, userClient.property, {
                phone: residentUser.userAttrs.phone,
                unitName: billingAccountAttrs.unitName,
                unitType: billingAccountAttrs.unitType,
                isVerified: true,
            })

            // getting the result
            const residentBillingReceipts = await ResidentBillingReceipt.getAll(residentUser)

            expect(residentBillingReceipts).toBeDefined()
            expect(residentBillingReceipts).not.toHaveLength(0)
            residentBillingReceipts.forEach(receipt => {
                expect(receipt).toHaveProperty('id')
                expect(receipt.id).not.toBeNull()

                expect(receipt).toHaveProperty('toPay')
                expect(receipt.toPay).not.toBeNull()

                expect(receipt).toHaveProperty('paid')
                expect(receipt.paid).not.toBeNull()

                expect(receipt).toHaveProperty('period')
                expect(receipt.period).not.toBeNull()

                expect(receipt).toHaveProperty('recipient')
                expect(receipt.recipient).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer')
                expect(receipt.serviceConsumer).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer.id')
                expect(receipt.serviceConsumer.id).not.toBeNull()

                expect(receipt).toHaveProperty('currencyCode')
                expect(receipt.currencyCode).not.toBeNull()

                expect(receipt).toHaveProperty('category')
                expect(receipt.category).not.toBeNull()

                expect(receipt).toHaveProperty('services')
                expect(receipt.services).not.toBeNull()

                expect(receipt).toHaveProperty('file')
                expect(receipt.file).not.toBeNull()

                expect(receipt.file).toHaveProperty('file')
                expect(receipt.file.file).not.toBeNull()
                expect(receipt.file.file.originalFilename).toEqual(path.basename(PRIVATE_FILE))
            })
        })

        it('returns public file for removed contact', async () => {
            const userClient = await makeClientWithProperty()
            const support = await makeClientWithSupportUser()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(support)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, userClient.organization, integration)

            const integrationClient = await makeClientWithServiceUser()
            await createTestBillingIntegrationAccessRight(support, integration, integrationClient.user)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: userClient.property.address,
            })
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)

            const residentUser = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(residentUser, {
                address: userClient.property.address,
                addressMeta: userClient.property.addressMeta,
                unitName: billingAccountAttrs.unitName,
            })
            await registerServiceConsumerByTestClient(residentUser, {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            })
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)

            // create BillingReceiptFile
            const [receiptFile] = await createTestBillingReceiptFile(adminClient, receipt, billingContext)

            // set primary file
            await updateTestBillingReceipt(integrationClient, receipt.id, {
                file: { connect: { id: receiptFile.id } },
            })

            // set contact
            const [contact] = await createTestContact(adminClient, userClient.organization, userClient.property, {
                phone: residentUser.userAttrs.phone,
                unitName: billingAccountAttrs.unitName,
                unitType: billingAccountAttrs.unitType,
                isVerified: true,
            })

            // soft delete contact
            await updateTestContact(adminClient, contact.id, {
                deletedAt: dayjs().toISOString(),
            })

            // getting the result
            const residentBillingReceipts = await ResidentBillingReceipt.getAll(residentUser)

            expect(residentBillingReceipts).toBeDefined()
            expect(residentBillingReceipts).not.toHaveLength(0)
            residentBillingReceipts.forEach(receipt => {
                expect(receipt).toHaveProperty('id')
                expect(receipt.id).not.toBeNull()

                expect(receipt).toHaveProperty('toPay')
                expect(receipt.toPay).not.toBeNull()

                expect(receipt).toHaveProperty('paid')
                expect(receipt.paid).not.toBeNull()

                expect(receipt).toHaveProperty('period')
                expect(receipt.period).not.toBeNull()

                expect(receipt).toHaveProperty('recipient')
                expect(receipt.recipient).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer')
                expect(receipt.serviceConsumer).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer.id')
                expect(receipt.serviceConsumer.id).not.toBeNull()

                expect(receipt).toHaveProperty('currencyCode')
                expect(receipt.currencyCode).not.toBeNull()

                expect(receipt).toHaveProperty('category')
                expect(receipt.category).not.toBeNull()

                expect(receipt).toHaveProperty('services')
                expect(receipt.services).not.toBeNull()

                expect(receipt).toHaveProperty('file')
                expect(receipt.file).not.toBeNull()

                expect(receipt.file).toHaveProperty('file')
                expect(receipt.file.file).not.toBeNull()
                expect(receipt.file.file.originalFilename).toEqual(path.basename(PUBLIC_FILE))
            })
        })

        it('returns empty file', async () => {
            const userClient = await makeClientWithProperty()
            const support = await makeClientWithSupportUser()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(support)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, userClient.organization, integration)

            const integrationClient = await makeClientWithServiceUser()
            await createTestBillingIntegrationAccessRight(support, integration, integrationClient.user)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: userClient.property.address,
            })
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)

            const residentUser = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(residentUser, {
                address: userClient.property.address,
                addressMeta: userClient.property.addressMeta,
                unitName: billingAccountAttrs.unitName,
            })
            await registerServiceConsumerByTestClient(residentUser, {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            })
            const [receipt] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)
            const [receipt1] = await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount)

            // create BillingReceiptFile
            const [receiptFile] = await createTestBillingReceiptFile(adminClient, receipt1, billingContext)

            // set primary file
            await updateTestBillingReceipt(integrationClient, receipt.id, {
                file: { connect: { id: receiptFile.id } },
            })

            // remove file
            await updateTestBillingReceiptFile(adminClient, receiptFile.id, {
                publicDataFile: null,
            })

            // getting the result
            const residentBillingReceipts = await ResidentBillingReceipt.getAll(residentUser)

            expect(residentBillingReceipts).toBeDefined()
            expect(residentBillingReceipts).not.toHaveLength(0)
            residentBillingReceipts.forEach(receipt => {
                expect(receipt).toHaveProperty('id')
                expect(receipt.id).not.toBeNull()

                expect(receipt).toHaveProperty('toPay')
                expect(receipt.toPay).not.toBeNull()

                expect(receipt).toHaveProperty('paid')
                expect(receipt.paid).not.toBeNull()

                expect(receipt).toHaveProperty('period')
                expect(receipt.period).not.toBeNull()

                expect(receipt).toHaveProperty('recipient')
                expect(receipt.recipient).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer')
                expect(receipt.serviceConsumer).not.toBeNull()

                expect(receipt).toHaveProperty('serviceConsumer.id')
                expect(receipt.serviceConsumer.id).not.toBeNull()

                expect(receipt).toHaveProperty('currencyCode')
                expect(receipt.currencyCode).not.toBeNull()

                expect(receipt).toHaveProperty('category')
                expect(receipt.category).not.toBeNull()

                expect(receipt).toHaveProperty('services')
                expect(receipt.services).not.toBeNull()

                expect(receipt.file).not.toBeTruthy()
            })
        })

        //TODO: @abshnko return services check to mobile
        it.skip('returns correct services field', async () => {
            const userClient = await makeClientWithProperty()
            const support = await makeClientWithSupportUser()

            const [integration] = await createTestBillingIntegration(support)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(userClient, userClient.organization, integration)

            const integrationClient = await makeClientWithServiceUser()
            await createTestBillingIntegrationAccessRight(support, integration, integrationClient.user)
            const [billingProperty] = await createTestBillingProperty(integrationClient, billingContext, {
                address: userClient.property.address,
            })
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(integrationClient, billingContext, billingProperty)

            const residentUser = await makeClientWithResidentUser()
            const [resident] = await registerResidentByTestClient(residentUser, {
                address: userClient.property.address,
                addressMeta: userClient.property.addressMeta,
                unitName: billingAccountAttrs.unitName,
            })
            await registerServiceConsumerByTestClient(residentUser, {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            })

            await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount,
                { services: generateServicesData(1, '1000'), toPay: '2000' })
            await createTestBillingReceipt(integrationClient, billingContext, billingProperty, billingAccount,
                { services: generateServicesData(2, '1000'), toPay: '2000' })
            const residentBillingReceipts = await ResidentBillingReceipt.getAll(residentUser)

            expect(residentBillingReceipts).toBeDefined()
            expect(residentBillingReceipts).not.toHaveLength(0)
            
            expect(residentBillingReceipts[0]).toBeDefined()
            expect(residentBillingReceipts[0]).toHaveProperty('services')
            expect(residentBillingReceipts[0].services).toBeNull()

            expect(residentBillingReceipts[1]).toBeDefined()
            expect(residentBillingReceipts[1]).toHaveProperty('services')
            expect(residentBillingReceipts[1].services).not.toBeNull()
        })
    })

    describe('user with valid serviceAccount', () => {
        it('can read BillingReceipt without raw data', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(adminClient)
            const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
            const [billingProperty] = await createTestBillingProperty(adminClient, context)
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)
            const [billingAccount2] = await createTestBillingAccount(adminClient, context, billingProperty)

            await addResidentAccess(userClient.user)

            const [resident] = await createTestResident(adminClient, userClient.user, userClient.property, { unitName: billingAccountAttrs.unitName })
            const payload = {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            }

            await registerServiceConsumerByTestClient(userClient, payload)
            const [receipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount)
            await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount2)

            const objs = await ResidentBillingReceipt.getAll(userClient)
            expect(objs).toHaveLength(1)
            expect(objs[0].raw).toEqual(undefined)
            expect(objs[0].id).toEqual(receipt.id)
        })

        it('can read BillingReceipt without raw data even if there are other Resident with this service consumer', async () => {
            /**
             * Story: Husband and Wife live in the same flat,
             *        They have the same accountNumber and unitName, but different Residents and serviceConsumers
             *        Both Wife and Husband should be able to read BillingReceipts
             */

            const adminClient = await makeLoggedInAdminClient()
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, organization)

            const husbandClient = await makeClientWithResidentUser()
            const wifeClient = await makeClientWithResidentUser()

            // Create billing integration and billing entities
            const [integration] = await createTestBillingIntegration(adminClient)
            const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, organization, integration)
            const [billingProperty] = await createTestBillingProperty(adminClient, context)
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)
            const [billingAccount2] = await createTestBillingAccount(adminClient, context, billingProperty)
            const [receipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount)
            await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount2)

            const [residentHusband] = await registerResidentByTestClient(husbandClient, {
                address: property.address,
                addressMeta: property.addressMeta,
                unitName: billingAccountAttrs.unitName,
            })
            const [serviceConsumerHusband] = await registerServiceConsumerByTestClient(husbandClient, {
                residentId: residentHusband.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: organization.id,
            })
            // you can't read billingAccount field as resident, so we should get true serviceConsumer here to further check
            const [serviceConsumerHusbandWithAccount] = await ServiceConsumer.getAll(adminClient, { id: serviceConsumerHusband.id })

            const [residentWife] = await registerResidentByTestClient(wifeClient, {
                address: property.address,
                addressMeta: property.addressMeta,
                unitName: billingAccountAttrs.unitName,
            })
            const [serviceConsumerWife] = await registerServiceConsumerByTestClient(wifeClient, {
                residentId: residentWife.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: organization.id,
            })
            // you can't read billingAccount field as resident, so we should get true serviceConsumer here to further check
            const [serviceConsumerWifeWithAccount] = await ServiceConsumer.getAll(adminClient, { id: serviceConsumerWife.id })

            expect(serviceConsumerHusbandWithAccount.billingAccount.id).toEqual(serviceConsumerWifeWithAccount.billingAccount.id)
            expect(serviceConsumerHusbandWithAccount.billingAccount.id).toEqual(billingAccount.id)

            const objsHusband = await ResidentBillingReceipt.getAll(husbandClient, { serviceConsumer: { resident: { id: residentHusband.id } } })
            expect(objsHusband).toHaveLength(1)
            expect(objsHusband[0].raw).toEqual(undefined)
            expect(objsHusband[0].id).toEqual(receipt.id)

            const objsWife = await ResidentBillingReceipt.getAll(wifeClient, { serviceConsumer: { resident: { id: residentWife.id } } })
            expect(objsWife).toHaveLength(1)
            expect(objsWife[0].raw).toEqual(undefined)
            expect(objsWife[0].id).toEqual(receipt.id)
        })

        it('can filter residentBillingReceipts by serviceConsumer', async () => {
            // User has flats in building A and building B
            // Each building has own BillingOrganizationIntegrationContext
            // User is able to get receipts for both of his buildings

            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            // User has two flats in building A:
            const [integrationA] = await createTestBillingIntegration(adminClient)
            const [contextA] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integrationA)
            const [billingPropertyA] = await createTestBillingProperty(adminClient, contextA)
            const [billingAccountA, billingAccountAttrsA] = await createTestBillingAccount(adminClient, contextA, billingPropertyA)
            const [billingAccountA2, billingAccountAttrsA2] = await createTestBillingAccount(adminClient, contextA, billingPropertyA)

            await addResidentAccess(userClient.user)
            const [residentA] = await createTestResident(adminClient, userClient.user, userClient.property, {
                unitName: billingAccountAttrsA.unitName,
            })

            const serviceConsumerPayloadA = {
                residentId: residentA.id,
                accountNumber: billingAccountAttrsA.number,
                organizationId: userClient.organization.id,
            }
            await registerServiceConsumerByTestClient(userClient, serviceConsumerPayloadA)

            const [residentA2] = await createTestResident(adminClient, userClient.user, userClient.property, {
                unitName: billingAccountAttrsA2.unitName,
            })

            const serviceConsumerPayloadA2 = {
                residentId: residentA2.id,
                accountNumber: billingAccountAttrsA2.number,
                organizationId: userClient.organization.id,
            }
            await registerServiceConsumerByTestClient(userClient, serviceConsumerPayloadA2)

            await createTestBillingReceipt(adminClient, contextA, billingPropertyA, billingAccountA)
            await createTestBillingReceipt(adminClient, contextA, billingPropertyA, billingAccountA2)

            // User has one flat in building B:
            const [organizationB] = await createTestOrganization(adminClient)
            const [propertyB] = await createTestProperty(adminClient, organizationB)
            const [integrationB] = await createTestBillingIntegration(adminClient)
            const [contextB] = await createTestBillingIntegrationOrganizationContext(adminClient, organizationB, integrationB)
            const [billingPropertyB] = await createTestBillingProperty(adminClient, contextB)
            const [billingAccountB, billingAccountAttrsB] = await createTestBillingAccount(adminClient, contextB, billingPropertyB)

            const [residentB] = await createTestResident(adminClient, userClient.user, propertyB, {
                unitName: billingAccountAttrsB.unitName,
            })

            const payloadForServiceConsumerB = {
                residentId: residentB.id,
                accountNumber: billingAccountAttrsB.number,
                organizationId: organizationB.id,
            }
            await registerServiceConsumerByTestClient(userClient, payloadForServiceConsumerB)

            await createTestBillingReceipt(adminClient, contextB, billingPropertyB, billingAccountB)

            // User get two receipts for his building A
            const objsA = await ResidentBillingReceipt.getAll(userClient, { serviceConsumer: { resident: { id: residentA.id } } })
            expect(objsA).toHaveLength(1)

            const objsA2 = await ResidentBillingReceipt.getAll(userClient, { serviceConsumer: { resident: { id: residentA2.id } } })
            expect(objsA2).toHaveLength(1)

            // User get one receipt for his building B
            const objsForResident2 = await ResidentBillingReceipt.getAll(userClient, { serviceConsumer: { resident: { id: residentB.id } } })
            expect(objsForResident2).toHaveLength(1)
        })

        describe('with deleted service account', () => {
            it('can read BillingReceipt without raw data', async () => {
                /**
                 * Story: Nikolay deleted the service consumer by accident and registered new
                 *        Nikolay should be able to get all receipts!
                 */

                const adminClient = await makeLoggedInAdminClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)

                const client = await makeClientWithResidentUser()

                // Create billing integration and billing entities
                const [integration] = await createTestBillingIntegration(adminClient)
                const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, organization, integration)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [billingAccount2] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [receipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount)
                await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount2)

                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName: billingAccountAttrs.unitName,
                })
                const [firstServiceConsumer] = await registerServiceConsumerByTestClient(client, {
                    residentId: resident.id,
                    accountNumber: billingAccountAttrs.number,
                    organizationId: organization.id,
                })
                const [updatedServiceConsumer] = await updateTestServiceConsumer(client, firstServiceConsumer.id, { deletedAt: 'true' })
                expect(updatedServiceConsumer.deletedAt).not.toBeNull()

                const objsFirst = await ResidentBillingReceipt.getAll(client, { serviceConsumer: { resident: { id: resident.id } } })
                expect(objsFirst).toHaveLength(0)

                await registerServiceConsumerByTestClient(client, {
                    residentId: resident.id,
                    accountNumber: billingAccountAttrs.number,
                    organizationId: organization.id,
                })

                const objsSecond = await ResidentBillingReceipt.getAll(client, { serviceConsumer: { resident: { id: resident.id } } })
                expect(objsSecond).toHaveLength(1)
                expect(objsSecond[0].raw).toEqual(undefined)
                expect(objsSecond[0].id).toEqual(receipt.id)
            })
        })

        describe('with multiple billlingAccounts with same number', () => {
            it('can filter residentBillingReceipts by serviceConsumer', async () => {
                // User has flat in building A
                // Billing company has two billing accounts with same unitName and accountNumber
                // User is able to get receipts for both billingAccounts

                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                // User has flat in building A:
                const [integrationA] = await createTestBillingIntegration(adminClient)
                const [contextA] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integrationA)
                const [billingPropertyA] = await createTestBillingProperty(adminClient, contextA)
                const [billingAccountA] = await createTestBillingAccount(adminClient, contextA, billingPropertyA)
                const [billingAccountA2] = await createTestBillingAccount(adminClient, contextA, billingPropertyA, {
                    unitName: billingAccountA.unitName,
                    number: billingAccountA.number,
                })

                await addResidentAccess(userClient.user)
                const [residentA] = await createTestResident(adminClient, userClient.user, userClient.property, {
                    unitName: billingAccountA.unitName,
                })

                const serviceConsumerPayloadA = {
                    residentId: residentA.id,
                    accountNumber: billingAccountA.number,
                    organizationId: userClient.organization.id,
                }
                await registerServiceConsumerByTestClient(userClient, serviceConsumerPayloadA)

                await createTestBillingReceipt(adminClient, contextA, billingPropertyA, billingAccountA)
                await createTestBillingReceipt(adminClient, contextA, billingPropertyA, billingAccountA2)

                // User get two receipts for his building A
                const objsA = await ResidentBillingReceipt.getAll(userClient, { serviceConsumer: { resident: { id: residentA.id } } })
                expect(objsA).toHaveLength(2)
            })
        })

        describe('with valid multiple serviceAccounts', () => {
            it('can read all his BillingReceipts without raw data', async () => {
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [integration] = await createTestBillingIntegration(adminClient)
                const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [billingAccount2, billingAccountAttrs2] = await createTestBillingAccount(adminClient, context, billingProperty)

                await addResidentAccess(userClient.user)

                const [resident] = await createTestResident(adminClient, userClient.user, userClient.property, {
                    unitName: billingAccountAttrs.unitName,
                })

                const payload = {
                    residentId: resident.id,
                    accountNumber: billingAccountAttrs.number,
                    organizationId: userClient.organization.id,
                }
                await registerServiceConsumerByTestClient(userClient, payload)

                const [resident2] = await createTestResident(adminClient, userClient.user, userClient.property, {
                    unitName: billingAccountAttrs2.unitName,
                })

                const payload2 = {
                    residentId: resident2.id,
                    accountNumber: billingAccountAttrs2.number,
                    organizationId: userClient.organization.id,
                }
                await registerServiceConsumerByTestClient(userClient, payload2)

                await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount)
                await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount2)

                const objs = await ResidentBillingReceipt.getAll(userClient)
                expect(objs).toHaveLength(2)
            })
        })

        it('can read BillingReceipt without raw data with where query', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(adminClient)
            const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
            const [billingProperty] = await createTestBillingProperty(adminClient, context)
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)

            await addResidentAccess(userClient.user)

            const [resident] = await createTestResident(adminClient, userClient.user, userClient.property, {
                unitName: billingAccountAttrs.unitName,
            })
            const payload = {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            }

            await registerServiceConsumerByTestClient(userClient, payload)
            await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount)
            const [receipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount)

            await updateTestBillingReceipt(adminClient, receipt.id, { toPay: '100.50' })

            const objs = await ResidentBillingReceipt.getAll(userClient, { toPay: '100.50' })
            expect(objs).toHaveLength(1)
            expect(objs[0].raw).toEqual(undefined)
            expect(objs[0].id).toEqual(receipt.id)
        })

        describe('in case of multiple billingRecipients', () => {
            it('gets result filtered by accountId and receiverId', async () => {
                /**
                 * Test that we select only one latest receipt from each receiver/category + accountNumber by period
                 *   Case:
                 *   1. John pays for cold water and electricity
                 *   2. John got the receipt for March for water
                 *   3. John got the receipt for March for electricity
                 *   4. John got the receipt for April for water
                 *   5. In result of AllResidentBillingReceipts John should get 2 receipts:
                 *     - April water receipt
                 *     - March electricity receipt
                 */
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [integration] = await createTestBillingIntegration(adminClient)
                const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)

                await addResidentAccess(userClient.user)

                const [resident] = await createTestResident(adminClient, userClient.user, userClient.property, {
                    unitName: billingAccountAttrs.unitName,
                })
                const payload = {
                    residentId: resident.id,
                    accountNumber: billingAccountAttrs.number,
                    organizationId: userClient.organization.id,
                }

                await registerServiceConsumerByTestClient(userClient, payload)

                const MARCH_PERIOD = '2022-03-01'
                const APRIL_PERIOD = '2022-04-01'

                const [waterRecipient] = await createTestBillingRecipient(adminClient, context)
                const [electricityRecipient] = await createTestBillingRecipient(adminClient, context)


                // March receipt for water
                const [marchWaterReceipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                    period: MARCH_PERIOD,
                    receiver: { connect: { id: waterRecipient.id } },
                    category: { connect: { id: WATER_CATEGORY } },
                })
                const [marchElectricityReceipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                    period: MARCH_PERIOD,
                    receiver: { connect: { id: electricityRecipient.id } },
                    category: { connect: { id: ELECTRICITY_CATEGORY } },
                })
                const [aprilWaterReceipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                    period: APRIL_PERIOD,
                    receiver: { connect: { id: waterRecipient.id } },
                    category: { connect: { id: WATER_CATEGORY } },
                })

                const objs = await ResidentBillingReceipt.getAll(userClient, {}, {
                    sortBy: 'period_DESC',
                })
                const payableReceipts = objs.filter(receipt => receipt.isPayable)
                const unPayableReceipts = objs.filter(receipt => !receipt.isPayable)

                expect(objs).toHaveLength(3)
                expect(payableReceipts).toHaveLength(2)
                expect(payableReceipts[0].id).toEqual(aprilWaterReceipt.id)
                expect(payableReceipts[1].id).toEqual(marchElectricityReceipt.id)
                expect(unPayableReceipts).toHaveLength(1)
                expect(unPayableReceipts[0].id).toEqual(marchWaterReceipt.id)
            })
        })

        describe('in case of singleRecipient', () => {
            it('gets result filtered by accountId and receiverId', async () => {
                /**
                 * Test that we select only one latest receipt from each receiver/category + accountId by period
                 *   Case:
                 *   1. John pays for cold water
                 *   2. John got the receipt for March for water
                 *   3. John got the receipt for April for water
                 *   4. John got the receipt for May for water
                 *   5. In result of AllResidentBillingReceipts John should get 1 receipt:
                 *     - May water receipt
                 */
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [integration] = await createTestBillingIntegration(adminClient)
                const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)

                await addResidentAccess(userClient.user)

                const [resident] = await createTestResident(adminClient, userClient.user, userClient.property, {
                    unitName: billingAccountAttrs.unitName,
                })
                const payload = {
                    residentId: resident.id,
                    accountNumber: billingAccountAttrs.number,
                    organizationId: userClient.organization.id,
                }
                await registerServiceConsumerByTestClient(userClient, payload)

                const MARCH_PERIOD = '2022-03-01'
                const APRIL_PERIOD = '2022-04-01'
                const MAY_PERIOD = '2022-05-01'

                const [waterRecipient] = await createTestBillingRecipient(adminClient, context)

                // March receipt for water
                const [marchWaterReceipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                    period: MARCH_PERIOD,
                    receiver: { connect: { id: waterRecipient.id } },
                    category: { connect: { id: WATER_CATEGORY } },
                })

                const [aprilWaterReceipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                    period: APRIL_PERIOD,
                    receiver: { connect: { id: waterRecipient.id } },
                    category: { connect: { id: WATER_CATEGORY } },
                })

                const [mayWaterReceipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                    period: MAY_PERIOD,
                    receiver: { connect: { id: waterRecipient.id } },
                    category: { connect: { id: WATER_CATEGORY } },
                })

                const objs = await ResidentBillingReceipt.getAll(userClient, {}, { sortBy: 'period_DESC' })

                expect(marchWaterReceipt.receiver.id).toEqual(aprilWaterReceipt.receiver.id)
                expect(aprilWaterReceipt.receiver.id).toEqual(mayWaterReceipt.receiver.id)
                expect(marchWaterReceipt.account.id).toEqual(aprilWaterReceipt.account.id)
                expect(aprilWaterReceipt.account.id).toEqual(mayWaterReceipt.account.id)
                expect(marchWaterReceipt.property.id).toEqual(aprilWaterReceipt.property.id)
                expect(aprilWaterReceipt.property.id).toEqual(mayWaterReceipt.property.id)

                expect(objs).toHaveLength(3)
                expect(objs[0].id).toEqual(mayWaterReceipt.id)
                expect(objs[0].isPayable).toBeTruthy()
                expect(objs[1].id).toEqual(aprilWaterReceipt.id)
                expect(objs[1].isPayable).toBeFalsy()
                expect(objs[2].id).toEqual(marchWaterReceipt.id)
                expect(objs[2].isPayable).toBeFalsy()

                // We add one more receipt!

                const JUNE_PERIOD = '2022-06-01'

                const [juneWaterReceipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                    period: JUNE_PERIOD,
                    receiver: { connect: { id: waterRecipient.id } },
                    category: { connect: { id: WATER_CATEGORY } },
                })
                const objsWithJune = await ResidentBillingReceipt.getAll(userClient, {}, { sortBy: 'period_DESC' })

                expect(objsWithJune).toHaveLength(4)
                expect(objsWithJune[0].id).toEqual(juneWaterReceipt.id)
                expect(objsWithJune[0].isPayable).toBeTruthy()
                expect(objsWithJune[1].id).toEqual(mayWaterReceipt.id)
                expect(objsWithJune[1].isPayable).toBeFalsy()
                expect(objsWithJune[2].id).toEqual(aprilWaterReceipt.id)
                expect(objsWithJune[2].isPayable).toBeFalsy()
                expect(objsWithJune[3].id).toEqual(marchWaterReceipt.id)
                expect(objsWithJune[3].isPayable).toBeFalsy()
            })
        })

        describe('in case of singleRecipient and different payment categories', () => {
            it('gets result filtered by accountId and receiverId', async () => {
                /**
                 * Test that we select only one latest receipt from each receiver/category + accountId by period
                 *   Case:
                 *   1. John pays for housing water and repairs to single recipient
                 *   2. John got the receipt for March for housing
                 *   3. John got the receipt for March for repairs
                 *   4. In result of AllResidentBillingReceipts John should get 2 receipts:
                 *     - March housing receipt
                 *     - March repairs receipt
                 */
                const userClient = await makeClientWithProperty()
                const adminClient = await makeLoggedInAdminClient()

                const [integration] = await createTestBillingIntegration(adminClient)
                const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)

                await addResidentAccess(userClient.user)

                const [resident] = await createTestResident(adminClient, userClient.user, userClient.property, {
                    unitName: billingAccountAttrs.unitName,
                })
                const payload = {
                    residentId: resident.id,
                    accountNumber: billingAccountAttrs.number,
                    organizationId: userClient.organization.id,
                }

                await registerServiceConsumerByTestClient(userClient, payload)

                const MARCH_PERIOD = '2022-03-01'

                const [singleRecipient] = await createTestBillingRecipient(adminClient, context)

                const [marchHousingReceipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                    period: MARCH_PERIOD,
                    receiver: { connect: { id: singleRecipient.id } },
                    category: { connect: { id: '928c97ef-5289-4daa-b80e-4b9fed50c629' } }, // HOUSING CATEGORY
                    toPay: '20.00000000',
                })
                const [marchRepairsReceipt] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                    period: MARCH_PERIOD,
                    receiver: { connect: { id: singleRecipient.id } },
                    category: { connect: { id: 'c0b9db6a-c351-4bf4-aa35-8e5a500d0195' } }, // REPAIRS CATEGORY
                    toPay: '30.00000000',
                })

                const objs = await ResidentBillingReceipt.getAll(userClient, {}, {
                    sortBy: ['period_DESC', 'toPay_ASC'],
                })
                const payableReceipts = objs.filter(receipt => receipt.isPayable)
                const unPayableReceipts = objs.filter(receipt => !receipt.isPayable)

                expect(objs).toHaveLength(2)
                expect(payableReceipts).toHaveLength(2)
                expect(payableReceipts[0].id).toEqual(marchHousingReceipt.id)
                expect(payableReceipts[1].id).toEqual(marchRepairsReceipt.id)
                expect(unPayableReceipts).toHaveLength(0)

                // Sorting does not matter on result 1

                const objs2 = await ResidentBillingReceipt.getAll(userClient, {}, {
                    sortBy: ['period_DESC', 'id_DESC'],
                })
                const payableReceipts2 = objs.filter(receipt => receipt.isPayable)
                const unPayableReceipts2 = objs.filter(receipt => !receipt.isPayable)

                expect(objs2).toHaveLength(2)
                expect(payableReceipts2).toHaveLength(2)
                expect(unPayableReceipts2).toHaveLength(0)

                // Sorting does not matter on result 2

                const objs3 = await ResidentBillingReceipt.getAll(userClient, {}, {
                    sortBy: ['period_DESC' ],
                })
                const payableReceipts3 = objs.filter(receipt => receipt.isPayable)
                const unPayableReceipts3 = objs.filter(receipt => !receipt.isPayable)

                expect(objs3).toHaveLength(2)
                expect(payableReceipts3).toHaveLength(2)
                expect(unPayableReceipts3).toHaveLength(0)
            })
        })
    })

    describe('user with stolen billing account id and hacky intentions', () => {
        it('cannot read BillingReceipt', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(adminClient)
            const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
            const [billingProperty] = await createTestBillingProperty(adminClient, context)
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)
            await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount)

            await addResidentAccess(userClient.user)
            const [resident] = await createTestResident(adminClient, userClient.user, userClient.property, {
                unitName: billingAccountAttrs.unitName,
            })
            const payload = {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            }
            await registerServiceConsumerByTestClient(userClient, payload)

            const hackerClient = await makeClientWithProperty()
            const [context2] = await createTestBillingIntegrationOrganizationContext(adminClient, hackerClient.organization, integration)
            const [billingProperty2] = await createTestBillingProperty(adminClient, context2)
            const [billingAccount2] = await createTestBillingAccount(adminClient, context2, billingProperty2)

            await addResidentAccess(hackerClient.user)
            const [hackerResident] = await createTestResident(adminClient, hackerClient.user, hackerClient.property, {
                unitName: billingAccount2.unitName,
            })
            const hackerPayload = {
                residentId: hackerResident.id,
                accountNumber: billingAccount2.number,
                organizationId: userClient.organization.id,
            }
            // Hacker is connected to billingAccount2 and tries to get receipts for billingAccount
            await catchErrorFrom(async () => {
                await registerServiceConsumerByTestClient(hackerClient, hackerPayload)
                await ResidentBillingReceipt.getAll(hackerClient, { account: { id: billingAccountAttrs.id } })
            }, (err) => {
                expect(err).toBeDefined()
            })
        })
    })

    describe('user without valid serviceAccount', () => {
        it('cannot read BillingReceipt', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(adminClient)
            const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
            const [billingProperty] = await createTestBillingProperty(adminClient, context)
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)
            await createTestResident(adminClient, userClient.user, userClient.property, {
                unitName: billingAccountAttrs.unitName,
            })
            await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount)
            await addResidentAccess(userClient.user)

            const objs = await ResidentBillingReceipt.getAll(userClient)
            expect(objs).toHaveLength(0)
        })
    })

    describe('user without valid resident', () => {
        it('cannot read BillingReceipt', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(adminClient)
            const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
            const [billingProperty] = await createTestBillingProperty(adminClient, context)
            const [billingAccount] = await createTestBillingAccount(adminClient, context, billingProperty)

            await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount)
            await addResidentAccess(userClient.user)

            const objs = await ResidentBillingReceipt.getAll(userClient)
            expect(objs).toHaveLength(0)
        })
    })

    describe('paid field', () => {
        /**
         * Checks:
         * Simple cases:
         * 1. Case when you have single receipt and single payment
         * 2. Case when you have single receipt and no payments
         *
         * Complex cases:
         * 1. Receipt is paid, then recreated.
         * 2. Receipt is duplicated in single period
         */

        test('simple cases', async () => {

            const UNIT_NAME = faker.random.alphaNumeric(8)

            const admin = await makeLoggedInAdminClient()
            const sortReceiptsByToPay = (a, b) => Number(a.toPay) - Number(b.toPay)

            // Prepare billing integration and receipts
            const { organizationClient, integrationClient } = await makeClientWithPropertyAndBilling({ billingAccountAttrs: { unitName: UNIT_NAME } })
            const [ receiptWithSinglePayment ] = await createTestBillingReceipt(
                integrationClient,
                organizationClient.billingIntegrationContext,
                organizationClient.billingProperty,
                organizationClient.billingAccount,
                { toPay: '2000.00' }
            )

            // We create a new billing account since there are currently only one billing receipt is possible for period
            const [ billingAccount2 ] = await createTestBillingAccount(
                integrationClient,
                organizationClient.billingIntegrationContext,
                organizationClient.billingProperty,
                {
                    unitName: UNIT_NAME,
                }
            )
            const [ receiptWithNoPayments ] = await createTestBillingReceipt(
                integrationClient,
                organizationClient.billingIntegrationContext,
                organizationClient.billingProperty,
                billingAccount2,
                { toPay: '25000.00' }
            )

            // Prepare acquiring integration
            const [acquiringIntegration] = await createTestAcquiringIntegration(admin, {
                canGroupReceipts: true,
            })
            await createTestAcquiringIntegrationContext(organizationClient, organizationClient.organization, acquiringIntegration)

            // Prepare resident entities
            const residentClient = await makeClientWithResidentUser()
            const [ resident ] = await registerResidentByTestClient(residentClient, {
                address: organizationClient.property.address,
                addressMeta: organizationClient.property.addressMeta,
                unitName: UNIT_NAME,
            })

            const [serviceConsumer] = await registerServiceConsumerByTestClient(residentClient, {
                residentId: resident.id,
                accountNumber: organizationClient.billingAccount.number,
                organizationId: organizationClient.organization.id,
            })
            await registerServiceConsumerByTestClient(residentClient, {
                residentId: resident.id,
                accountNumber: billingAccount2.number,
                organizationId: organizationClient.organization.id,
            })

            // Mobile app gets the list of all resident receipts
            const beforePaymentResult = await ResidentBillingReceipt.getAll(residentClient, { serviceConsumer: { resident: { id: resident.id } } },
                {
                    sortBy: ['toPay_ASC'],
                },
            )
            beforePaymentResult.sort(sortReceiptsByToPay)
            // TODO(zuch): DOMA-2004 = Find out why graphql sorting by custom decimal type gives unpredictable results
            expect(beforePaymentResult).toHaveLength(2)
            expect(Number(beforePaymentResult[0].toPay)).toEqual(2000)
            expect(Number(beforePaymentResult[1].toPay)).toEqual(25000)
            const [
                singlePaymentReceiptBeforePayment,
                noPaymentReceiptBeforePayment,
            ] = beforePaymentResult

            // Mobile app tries to pay for the first receipt in one payment
            await completeTestPayment(residentClient, admin, serviceConsumer.id, singlePaymentReceiptBeforePayment.id )

            // Resident gets own receipts and sees that first one is fully paid!
            const afterPaymentResult = await ResidentBillingReceipt.getAll(residentClient, { serviceConsumer: { resident: { id: resident.id } } },
                {
                    sortBy: ['toPay_ASC'],
                },
            )
            afterPaymentResult.sort(sortReceiptsByToPay)
            expect(afterPaymentResult).toHaveLength(2)
            expect(Number(afterPaymentResult[0].toPay)).toEqual(2000)
            expect(Number(afterPaymentResult[1].toPay)).toEqual(25000)
            const [
                singlePaymentReceiptAfterPayment,
                noPaymentReceiptAfterPayments,
            ] = afterPaymentResult

            // Assert with one payment for one receipt
            expect(singlePaymentReceiptAfterPayment.id).toEqual(receiptWithSinglePayment.id)
            expect(singlePaymentReceiptBeforePayment.id).toEqual(receiptWithSinglePayment.id)
            expect(singlePaymentReceiptBeforePayment.paid).toEqual('0.00000000')
            expect(singlePaymentReceiptAfterPayment.paid).toEqual('2000.00000000')
            expect(singlePaymentReceiptAfterPayment.paid).toEqual(singlePaymentReceiptAfterPayment.toPay)

            // Assert with no payments for one receipt
            expect(noPaymentReceiptAfterPayments.id).toEqual(receiptWithNoPayments.id)
            expect(noPaymentReceiptBeforePayment.id).toEqual(receiptWithNoPayments.id)
            expect(noPaymentReceiptBeforePayment.paid).toEqual('0.00000000')
            expect(noPaymentReceiptAfterPayments.paid).toEqual('0.00000000')
            expect(noPaymentReceiptAfterPayments.paid).not.toEqual(noPaymentReceiptAfterPayments.toPay)
        })

        test('receipt is paid and overwritten by billing integration.', async () => {

            const UNIT_NAME = '22'

            const admin = await makeLoggedInAdminClient()

            // Prepare billing integration and receipts
            const { organizationClient, integrationClient } = await makeClientWithPropertyAndBilling({ billingAccountAttrs: { unitName: UNIT_NAME } })
            const [ receiptWithSinglePayment ] = await createTestBillingReceipt(
                integrationClient,
                organizationClient.billingIntegrationContext,
                organizationClient.billingProperty,
                organizationClient.billingAccount,
                { toPay: '2000.00' }
            )

            // Prepare acquiring integration
            const [ acquiringIntegration ] = await createTestAcquiringIntegration(admin, {
                canGroupReceipts: true,
            })
            await createTestAcquiringIntegrationContext(organizationClient, organizationClient.organization, acquiringIntegration)

            // Prepare resident entities
            const residentClient = await makeClientWithResidentUser()
            const [ resident ] = await registerResidentByTestClient(residentClient, {
                address: organizationClient.property.address,
                addressMeta: organizationClient.property.addressMeta,
                unitName: UNIT_NAME,
            })

            const [serviceConsumer] = await registerServiceConsumerByTestClient(residentClient, {
                residentId: resident.id,
                accountNumber: organizationClient.billingAccount.number,
                organizationId: organizationClient.organization.id,
            })

            // Mobile app gets the list of all resident receipts
            const [ singlePaymentReceiptBeforePayment ] = await ResidentBillingReceipt.getAll(residentClient, { serviceConsumer: { resident: { id: resident.id } } }, { sortBy: ['toPay_ASC'] } )

            // Mobile app tries to pay for the first receipt in one payment
            await completeTestPayment(residentClient, admin, serviceConsumer.id, singlePaymentReceiptBeforePayment.id, {}, 'WITHDRAWN')

            // Billing Recreates the receipt
            const [ deletedReceiptWithSinglePayment ] = await updateTestBillingReceipt(
                integrationClient,
                receiptWithSinglePayment.id,
                {
                    deletedAt: 'true',
                }
            )
            const [ newReceiptWithSinglePayment ] = await createTestBillingReceipt(
                integrationClient,
                organizationClient.billingIntegrationContext,
                organizationClient.billingProperty,
                organizationClient.billingAccount,
                {
                    toPay: '2500.00',
                    recipient: receiptWithSinglePayment.recipient,
                }
            )

            // Resident gets own receipts and sees that first one is fully paid!
            const [ singlePaymentReceiptAfterPayment ] = await ResidentBillingReceipt.getAll(residentClient, { serviceConsumer: { resident: { id: resident.id } } }, { sortBy: ['toPay_ASC'] })

            // Assert with one payment for one receipt
            expect(singlePaymentReceiptBeforePayment.id).toEqual(receiptWithSinglePayment.id)
            expect(singlePaymentReceiptBeforePayment.toPay).toEqual('2000.00000000')
            expect(singlePaymentReceiptBeforePayment.paid).toEqual('0.00000000')

            expect(deletedReceiptWithSinglePayment.deletedAt).not.toBeNull()

            expect(singlePaymentReceiptAfterPayment.id).toEqual(newReceiptWithSinglePayment.id)
            expect(singlePaymentReceiptAfterPayment.toPay).toEqual('2500.00000000')
            expect(singlePaymentReceiptAfterPayment.paid).toEqual('2000.00000000') // Since we paid for the old receipt!
        })

        test('receipt is duplicated in single period in single organization. e.g Housing and Water goes to different recipients', async () => {

            const UNIT_NAME = '22'

            const admin = await makeLoggedInAdminClient()

            // Prepare billing integration and receipts
            const { organizationClient, integrationClient } = await makeClientWithPropertyAndBilling({ billingAccountAttrs: { unitName: UNIT_NAME } })

            const [ receiptForHousing ] = await createTestBillingReceipt(
                integrationClient,
                organizationClient.billingIntegrationContext,
                organizationClient.billingProperty,
                organizationClient.billingAccount,
                { toPay: '2000.00' }
            )
            const [ receiptForWater ] = await createTestBillingReceipt(
                integrationClient,
                organizationClient.billingIntegrationContext,
                organizationClient.billingProperty,
                organizationClient.billingAccount,
                { toPay: '2500.00' }
            )

            // Prepare acquiring integration
            const [ acquiringIntegration ] = await createTestAcquiringIntegration(admin, {
                canGroupReceipts: true,
            })
            await createTestAcquiringIntegrationContext(organizationClient, organizationClient.organization, acquiringIntegration)

            // Prepare resident entities
            const residentClient = await makeClientWithResidentUser()
            const [ resident ] = await registerResidentByTestClient(residentClient, {
                address: organizationClient.property.address,
                addressMeta: organizationClient.property.addressMeta,
                unitName: UNIT_NAME,
            })

            const [serviceConsumer] = await registerServiceConsumerByTestClient(residentClient, {
                residentId: resident.id,
                accountNumber: organizationClient.billingAccount.number,
                organizationId: organizationClient.organization.id,
            })

            // Mobile app gets the list of all resident receipts
            const [ receiptForHousingBeforePayment, receiptForWaterBeforePayment ] = await ResidentBillingReceipt.getAll(residentClient, { serviceConsumer: { resident: { id: resident.id } } }, { sortBy: ['toPay_ASC'] } )

            // Mobile app tries to pay for the first receipt in one payment
            await completeTestPayment(residentClient, admin, serviceConsumer.id, receiptForHousingBeforePayment.id)
            await completeTestPayment(residentClient, admin, serviceConsumer.id, receiptForWaterBeforePayment.id)

            // Resident gets own receipts and sees that first one is fully paid!
            const [ receiptForHousingAfterPayment, receiptForWaterAfterPayment ] = await ResidentBillingReceipt.getAll(residentClient, { serviceConsumer: { resident: { id: resident.id } } }, { sortBy: ['toPay_ASC'] })

            // Assert with one payment for one receipt
            expect(receiptForHousingAfterPayment.id).toEqual(receiptForHousing.id)
            expect(receiptForHousingAfterPayment.toPay).toEqual('2000.00000000')
            expect(receiptForHousingBeforePayment.paid).toEqual('0.00000000')
            expect(receiptForHousingAfterPayment.paid).toEqual('2000.00000000')

            expect(receiptForWaterAfterPayment.id).toEqual(receiptForWater.id)
            expect(receiptForWaterAfterPayment.toPay).toEqual('2500.00000000')
            expect(receiptForWaterBeforePayment.paid).toEqual('0.00000000')
            expect(receiptForWaterAfterPayment.paid).toEqual('2500.00000000') // Since we paid for the old receipt!

            expect(receiptForHousing.period).toEqual(receiptForWater.period)
            expect(receiptForHousing.account.id).toEqual(receiptForWater.account.id)
        })
    })

    describe('sortBy', () => {
        it('sortBy period field works for receipts with old receipts', async () => {
            const userClient = await makeClientWithProperty()
            const adminClient = await makeLoggedInAdminClient()

            const [integration] = await createTestBillingIntegration(adminClient)
            const [context] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, integration)
            const [billingProperty] = await createTestBillingProperty(adminClient, context)
            const [billingAccount, billingAccountAttrs] = await createTestBillingAccount(adminClient, context, billingProperty)
            const [billingAccount2, billingAccountAttrs2] = await createTestBillingAccount(adminClient, context, billingProperty)

            await addResidentAccess(userClient.user)

            const [resident] = await createTestResident(adminClient,
                userClient.user, userClient.property,
                { unitName: billingAccountAttrs.unitName })

            const payload = {
                residentId: resident.id,
                accountNumber: billingAccountAttrs.number,
                organizationId: userClient.organization.id,
            }
            await registerServiceConsumerByTestClient(userClient, payload)

            const payload2 = {
                residentId: resident.id,
                accountNumber: billingAccountAttrs2.number,
                organizationId: userClient.organization.id,
            }
            await registerServiceConsumerByTestClient(userClient, payload2)

            // Receipts for billing account 1

            const [receipt1] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                period: '2022-03-01',
            })

            const [receipt2] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount, {
                period: '2022-05-01',
            })

            // Receipts for billing account 2

            const [receipt3] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount2, {
                period: '2022-04-01',
            })

            const [receipt4] = await createTestBillingReceipt(adminClient, context, billingProperty, billingAccount2, {
                period: '2022-06-01',
            })

            const objs = await ResidentBillingReceipt.getAll(userClient, {}, { sortBy: 'period_ASC' })
            expect(objs).toHaveLength(4)
            expect(objs[0].raw).toEqual(undefined)
            expect(objs[0].id).toEqual(receipt1.id)
            expect(objs[1].raw).toEqual(undefined)
            expect(objs[1].id).toEqual(receipt3.id)
            expect(objs[2].raw).toEqual(undefined)
            expect(objs[2].id).toEqual(receipt2.id)
            expect(objs[3].raw).toEqual(undefined)
            expect(objs[3].id).toEqual(receipt4.id)
        })
    })
})