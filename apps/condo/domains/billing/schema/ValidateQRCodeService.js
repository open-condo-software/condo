/**
 * Generated by `createservice billing.ValidateQRCodeService --type mutations`
 */
const { isEmpty } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const { BankAccount } = require('@condo/domains/banking/utils/serverSchema')
const access = require('@condo/domains/billing/access/ValidateQRCodeService')
const { WRONG_FORMAT, NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { Organization } = require('@condo/domains/organization/utils/serverSchema')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    INVALID_QR_CODE: {
        mutation: 'validateQRCode',
        variable: ['data', 'qrCode'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Provided QR code doesn\'t have one of required fields: PersonalAcc, payerAddress, lastName, paymPeriod or Sum',
    },
    NO_ORGANIZATION: {
        mutation: 'validateQRCode',
        code: INTERNAL_ERROR,
        type: NOT_FOUND,
        message: 'Organization with provided TIN is not registered with Doma.ai',
    },
    NO_ACQUIRING_CONTEXT: {
        mutation: 'validateQRCode',
        code: INTERNAL_ERROR,
        type: NOT_FOUND,
        message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
    },
    NO_BANK_ACCOUNT: {
        mutation: 'validateQRCode',
        code: INTERNAL_ERROR,
        type: NOT_FOUND,
        message: 'Bank Account with provided personal account number wasn\'t found',
    },
}

const ValidateQRCodeService = new GQLCustomSchema('ValidateQRCodeService', {
    types: [
        {
            access: true,
            type: 'input ValidateQRCodeInput { dv: Int!, sender: SenderFieldInput!, qrCode: String! }',
        },
        {
            access: true,
            type: 'type ValidateQRCodeOutput { qrCodeFields: JSON! }',
        },
    ],
    
    mutations: [
        {
            access: access.canValidateQRCode,
            schema: 'validateQRCode(data: ValidateQRCodeInput!): ValidateQRCodeOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { qrCode } = data

                const qrCodeFields = Object.fromEntries(qrCode.split('|').map(part => part.split('=')))
                const { PersonalAcc, payerAddress, lastName, paymPeriod, Sum, PayeeINN } = qrCodeFields

                if (!PersonalAcc || !payerAddress || !lastName || !paymPeriod || !Sum) throw new GQLError(ERRORS.INVALID_QR_CODE)
                
                if (PayeeINN) {
                    const organizations = await Organization.getAll(context, {
                        tin: PayeeINN,
                        deletedAt: null,
                    })

                    if (isEmpty(organizations)) throw new GQLError(ERRORS.NO_ORGANIZATION)
                    
                    const acquiringContexts = await AcquiringIntegrationContext.getAll(context, {
                        organization: { id: organizations[0].id, deletedAt: null },
                        status: CONTEXT_FINISHED_STATUS,
                        deletedAt: null,
                    })

                    if (isEmpty(acquiringContexts)) throw new GQLError(ERRORS.NO_ACQUIRING_CONTEXT)

                } else {
                    const bankAccounts = await BankAccount.getAll(context, {
                        number: PersonalAcc,
                        deletedAt: null,
                    })

                    if (isEmpty(bankAccounts)) throw new GQLError(ERRORS.NO_BANK_ACCOUNT)

                }

                return { qrCodeFields }
            },
        },
    ],
    
})

module.exports = {
    ValidateQRCodeService,
}
