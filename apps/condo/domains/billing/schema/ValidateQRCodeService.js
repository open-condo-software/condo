/**
 * Generated by `createservice billing.ValidateQRCodeService --type mutations`
 */
const { get, isEmpty } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const access = require('@condo/domains/billing/access/ValidateQRCodeService')
const {
    BILLING_VALIDATE_QR_CODE_WINDOW,
    MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW,
} = require('@condo/domains/billing/constants')
const { WRONG_FORMAT, NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { Organization } = require('@condo/domains/organization/utils/serverSchema')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')

const redisGuard = new RedisGuard()

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    INVALID_QR_CODE: (missedFieldsArr) => ({
        mutation: 'validateQRCode',
        variable: ['data', 'qrCode'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: `Provided QR code doesn't have required fields: ${missedFieldsArr.join(', ')}`,
    }),
    NO_ORGANIZATION: {
        mutation: 'validateQRCode',
        code: INTERNAL_ERROR,
        type: NOT_FOUND,
        message: 'Organization with provided TIN is not registered with Doma.ai',
    },
    NO_ACQUIRING_CONTEXT: {
        mutation: 'validateQRCode',
        code: INTERNAL_ERROR,
        type: NOT_FOUND,
        message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
    },
}

/**
 * @typedef {object} ValidateQRCodeInput
 * @property {string} qrCode
 */

/**
 * @typedef {object} ValidateQRCodeInputArgs
 * @property {ValidateQRCodeInput} data
 */

const REQUIRED_QR_CODE_FIELDS = ['BIC', 'PayerAddress', 'PaymPeriod', 'Sum', 'PersAcc', 'PayeeINN', 'PersonalAcc']

const ValidateQRCodeService = new GQLCustomSchema('ValidateQRCodeService', {
    types: [
        {
            access: true,
            type: 'input ValidateQRCodeInput { dv: Int!, sender: SenderFieldInput!, qrCode: String! }',
        },
        {
            access: true,
            type: 'type ValidateQRCodeOutput { qrCodeFields: JSON! }',
        },
    ],

    mutations: [
        {
            access: access.canValidateQRCode,
            schema: 'validateQRCode(data: ValidateQRCodeInput!): ValidateQRCodeOutput',
            resolver: async (parent, /** @type {ValidateQRCodeInputArgs} */ args, context) => {
                const { data } = args
                const { qrCode } = data

                const checkLimits = async (ip) => {
                    await redisGuard.checkCustomLimitCounters(
                        `validate-QR-code-${ip}`,
                        BILLING_VALIDATE_QR_CODE_WINDOW,
                        MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW,
                    )
                }

                const ip = context.req.headers['x-forwarded-for'] || context.req.socket.remoteAddress
                await checkLimits(ip)

                const matches = /^ST(?<version>\d{4})(?<encodingTag>\d)\|(?<requisitesStr>.*)$/g.exec(qrCode)
                const requisitesStr = get(matches, ['groups', 'requisitesStr'], '')

                // TODO(AleX83Xpert): maybe decode requisitesStr
                // Need to test the result of scanning from mobile devices
                // https://encoding.spec.whatwg.org/#koi8-r
                // https://encoding.spec.whatwg.org/#windows-1251
                // const encodingTag = get(matches, ['groups', 'encodingTag'])
                // const encoding = get(['windows-1251', 'utf-8', 'koi8-r'], encodingTag, 'utf-8')

                const qrCodeFields = Object.fromEntries(requisitesStr.split('|').map(part => part.split('=', 2)))

                const missedFields = REQUIRED_QR_CODE_FIELDS.filter((requiredField) => !get(qrCodeFields, requiredField, null))

                if (missedFields.length > 0) {
                    throw new GQLError(ERRORS.INVALID_QR_CODE(missedFields), context)
                }

                const { PayeeINN } = qrCodeFields

                const organizations = await Organization.getAll(context, {
                    tin: PayeeINN,
                    deletedAt: null,
                })

                if (isEmpty(organizations)) throw new GQLError(ERRORS.NO_ORGANIZATION, context)

                const acquiringContexts = await AcquiringIntegrationContext.getAll(context, {
                    organization: { id_in: organizations.map((org) => org.id), deletedAt: null },
                    status: CONTEXT_FINISHED_STATUS,
                    deletedAt: null,
                })

                if (isEmpty(acquiringContexts)) throw new GQLError(ERRORS.NO_ACQUIRING_CONTEXT, context)

                return { qrCodeFields }
            },
        },
    ],

})

module.exports = {
    ValidateQRCodeService,
}
