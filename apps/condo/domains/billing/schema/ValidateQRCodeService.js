/**
 * Generated by `createservice billing.ValidateQRCodeService --type mutations`
 */
const Big = require('big.js')
const { get, pick } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, getById, find } = require('@open-condo/keystone/schema')

const { CONTEXT_FINISHED_STATUS: ACQUIRING_CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    compactDistributionSettings,
    FeeDistribution,
} = require('@condo/domains/acquiring/utils/serverSchema/feeDistribution')
const access = require('@condo/domains/billing/access/ValidateQRCodeService')
const {
    BILLING_VALIDATE_QR_CODE_WINDOW,
    MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW,
} = require('@condo/domains/billing/constants')
const { CONTEXT_FINISHED_STATUS: BILLING_CONTEXT_FINISHED_STATUS } = require('@condo/domains/billing/constants/constants')
const { getCountrySpecificQRCodeParser } = require('@condo/domains/billing/utils/countrySpecificQRCodeParsers')
const {
    getQRCodeMissedFields,
    compareQRCodeWithLastReceipt,
    isReceiptPaid,
    formatPeriodFromQRCode,
    getQRCodeFields,
    getQRCodeField,
    getQRCodePaymPeriod,
} = require('@condo/domains/billing/utils/receiptQRCodeUtils')
const { RUSSIA_COUNTRY } = require('@condo/domains/common/constants/countries')
const { WRONG_FORMAT, NOT_FOUND, ALREADY_EXISTS_ERROR, WRONG_VALUE } = require('@condo/domains/common/constants/errors')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')

const redisGuard = new RedisGuard()

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    INVALID_QR_CODE_FIELDS: (missedFieldsArr) => ({
        mutation: 'validateQRCode',
        variable: ['data', 'qrCode'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: `Provided QR code doesn't have required fields: ${missedFieldsArr.join(', ')}`,
    }),
    NO_ACQUIRING_CONTEXT: {
        mutation: 'validateQRCode',
        code: INTERNAL_ERROR,
        type: NOT_FOUND,
        message: 'Organization with provided TIN does not have an active acquiring integration',
    },
    RECEIPT_ALREADY_PAID: {
        mutation: 'validateQRCode',
        code: BAD_USER_INPUT,
        type: ALREADY_EXISTS_ERROR,
        message: 'Provided receipt already paid',
        messageForUser: 'api.billing.billingReceipt.RECEIPT_ALREADY_PAID_ERROR',
    },
    INVALID_QR_CODE_STRING: {
        mutation: 'validateQRCode',
        variable: ['data', 'qrCode'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid QR code',
    },
    NO_BILLING_ACCOUNT: {
        mutation: 'validateQRCode',
        code: INTERNAL_ERROR,
        type: NOT_FOUND,
        message: 'No billing account was found',
    },
    MUCH_BILLING_ACCOUNTS: {
        mutation: 'validateQRCode',
        code: INTERNAL_ERROR,
        type: WRONG_VALUE,
        message: 'More than one billing accounts were found',
    },
    BANK_ACCOUNT_IS_INVALID: {
        mutation: 'validateQRCode',
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Provided bank account is not in the system',
    },
    NO_PREV_RECEIPT: {
        mutation: 'validateQRCode',
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'No previous receipt was found',
    },
}

/**
 * @typedef {object} ValidateQRCodeInput
 * @property {string} qrCode
 */

/**
 * @typedef {object} ValidateQRCodeInputArgs
 * @property {ValidateQRCodeInput} data
 */

const ValidateQRCodeService = new GQLCustomSchema('ValidateQRCodeService', {
    types: [
        {
            access: true,
            type: 'input ValidateQRCodeInput { dv: Int!, sender: SenderFieldInput!, qrCode: String! }',
        },
        {
            access: true,
            type: 'type ValidateQRCodeLastReceiptDataOutput { id: ID!, period: String!, toPay: String! }',
        },
        {
            access: true,
            type: 'type ValidateQRCodeFeesOutput { explicitServiceCharge: String, explicitFee: String }',
        },
        {
            access: true,
            type: 'type ValidateQRCodeOutput { qrCodeFields: JSON!, lastReceiptData: ValidateQRCodeLastReceiptDataOutput, explicitFees: ValidateQRCodeFeesOutput!, amount: String!, acquiringIntegrationHostUrl: String!, currencyCode: String! }',
        },
    ],

    mutations: [
        {
            schemaDoc: 'Validates qr-code received from mobile application. This mutation receives base64 encoded raw data from scanned qr-code.',
            access: access.canValidateQRCode,
            schema: 'validateQRCode(data: ValidateQRCodeInput!): ValidateQRCodeOutput',
            resolver: async (parent, /** ValidateQRCodeInputArgs */ args, context) => {
                const { data } = args
                const { qrCode } = data

                const currentUserId = get(context, ['authedItem', 'id'])
                if (!currentUserId) {
                    const ip = context.req.ip
                    await redisGuard.checkCustomLimitCounters(
                        `validate-QR-code-${ip}`,
                        BILLING_VALIDATE_QR_CODE_WINDOW,
                        MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW,
                        context,
                    )
                }

                let qrCodeFields
                try {
                    // For now, we have only single implementation for parsing qr-codes, so place 'ru' directly
                    qrCodeFields = getCountrySpecificQRCodeParser(RUSSIA_COUNTRY)(qrCode)
                } catch (err) {
                    throw new GQLError(ERRORS.INVALID_QR_CODE_STRING, context)
                }

                const missedFields = getQRCodeMissedFields(qrCodeFields)

                if (missedFields.length > 0) {
                    throw new GQLError(ERRORS.INVALID_QR_CODE_FIELDS(missedFields), context)
                }

                const qrCodeAmount = String(Big(getQRCodeField(qrCodeFields, 'Sum')).div(100))
                const { persAcc, personalAcc, payeeINN } = getQRCodeFields(qrCodeFields, ['persAcc', 'personalAcc', 'payeeINN'])

                const billingAccounts = await find('BillingAccount', {
                    number: persAcc,
                    context: {
                        organization: { tin: payeeINN, deletedAt: null },
                        status: BILLING_CONTEXT_FINISHED_STATUS,
                        deletedAt: null,
                    },
                    deletedAt: null,
                })

                if (billingAccounts.length === 0) {
                    throw new GQLError(ERRORS.NO_BILLING_ACCOUNT, context)
                }

                if (billingAccounts.length > 1) {
                    throw new GQLError(ERRORS.MUCH_BILLING_ACCOUNTS, context)
                }

                const [billingAccount] = billingAccounts

                const [billingContext] = await find('BillingIntegrationOrganizationContext', {
                    id: billingAccount.context,
                    status: BILLING_CONTEXT_FINISHED_STATUS,
                    deletedAt: null,
                })

                const organizationId = billingContext.organization

                const [acquiringContext] = await find('AcquiringIntegrationContext', {
                    organization: { id: organizationId, deletedAt: null },
                    status: ACQUIRING_CONTEXT_FINISHED_STATUS,
                    deletedAt: null,
                })

                if (!acquiringContext) throw new GQLError(ERRORS.NO_ACQUIRING_CONTEXT, context)

                const paymPeriod = getQRCodePaymPeriod(qrCodeFields, billingContext)

                if (!qrCodeFields['PaymPeriod']) {
                    qrCodeFields['PaymPeriod'] = paymPeriod
                }

                const period = formatPeriodFromQRCode(paymPeriod)

                const acquiringContextRecipient = get(acquiringContext, 'recipient')

                if (!acquiringContextRecipient) throw new GQLError(ERRORS.BANK_ACCOUNT_IS_INVALID, context)

                const billingIntegration = await getById('BillingIntegration', billingContext.integration)

                /** @type {BillingReceipt} */
                let foundReceipt
                let amount
                const setDataFromReceipt = async (lastBillingReceipt) => {
                    if (await isReceiptPaid(context, persAcc, lastBillingReceipt.period, [organizationId], personalAcc)) {
                        throw new GQLError(ERRORS.RECEIPT_ALREADY_PAID, context)
                    }
                    foundReceipt = lastBillingReceipt
                    amount = foundReceipt.toPay
                }

                /** @type {TCompareQRResolvers} */
                const resolvers = {
                    onNoReceipt: async () => {
                        throw new GQLError(ERRORS.NO_PREV_RECEIPT, context)
                    },
                    onReceiptPeriodEqualsQrCodePeriod: setDataFromReceipt,
                    onReceiptPeriodNewerThanQrCodePeriod: setDataFromReceipt,
                    onReceiptPeriodOlderThanQrCodePeriod: async (lastBillingReceipt) => {
                        if (await isReceiptPaid(context, persAcc, period, [organizationId], personalAcc)) {
                            throw new GQLError(ERRORS.RECEIPT_ALREADY_PAID, context)
                        }
                        foundReceipt = lastBillingReceipt
                        amount = qrCodeAmount
                    },
                }

                await compareQRCodeWithLastReceipt(context, qrCodeFields, resolvers)

                // Calculate fees
                const acquiringIntegration = await getById('AcquiringIntegration', acquiringContext.integration)
                let acquiringDistributionSchema = get(acquiringIntegration, 'explicitFeeDistributionSchema', [])
                let contextDistributionSchema = get(acquiringContext, 'implicitFeeDistributionSchema', [])
                if (!Array.isArray(acquiringDistributionSchema)) {
                    acquiringDistributionSchema = []
                }
                if (!Array.isArray(contextDistributionSchema)) {
                    contextDistributionSchema = []
                }
                const formula = compactDistributionSettings(acquiringDistributionSchema.concat(contextDistributionSchema))
                const feeCalculator = new FeeDistribution(formula)

                const { type, explicitFee = '0' } = feeCalculator.calculate(amount)

                const explicitFees = type === 'service' ? {
                    explicitServiceCharge: String(explicitFee),
                    explicitFee: '0',
                } : {
                    explicitServiceCharge: '0',
                    explicitFee: String(explicitFee),
                }

                return {
                    qrCodeFields,
                    lastReceiptData: foundReceipt ? pick(foundReceipt, ['id', 'period', 'toPay']) : null,
                    explicitFees,
                    amount,
                    acquiringIntegrationHostUrl: get(acquiringIntegration, 'hostUrl'),
                    currencyCode: get(billingIntegration, 'currencyCode'),
                }
            },
        },
    ],

})

module.exports = {
    ValidateQRCodeService,
}
