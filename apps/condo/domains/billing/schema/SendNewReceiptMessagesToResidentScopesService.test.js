/**
 * Generated by `createservice resident.SendNewReceiptMessagesToResidentScopesService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { isEmpty } = require('lodash')

const conf = require('@open-condo/config')
const {
    makeLoggedInAdminClient, makeClient,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowGQLError, waitFor, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const {
    createTestBillingIntegration,
    createTestBillingIntegrationOrganizationContext,
    makeServiceUserForIntegration, createTestBillingProperty,
    createTestBillingAccount, createTestBillingReceipt,
} = require('@condo/domains/billing/utils/testSchema')
const { BillingIntegration, sendNewReceiptMessagesToResidentScopesByTestClient } = require('@condo/domains/billing/utils/testSchema')
const { SUCCESS_STATUS } = require('@condo/domains/common/constants')
const { DATE_FORMAT, getStartDates } = require('@condo/domains/common/utils/date')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const {
    BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
    DEVICE_PLATFORM_ANDROID, APP_MASTER_ID_ANDROID, MESSAGE_SENT_STATUS,
} = require('@condo/domains/notification/constants/constants')
const { syncRemoteClientWithPushTokenByTestClient, Message } = require('@condo/domains/notification/utils/testSchema')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithProperty } = require('@condo/domains/property/utils/testSchema')
const { Resident, registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const { createTestResident, createTestServiceConsumer } = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')


const { ERRORS } = require('./SendNewReceiptMessagesToResidentScopesService')

// Billing categories are constants within DB and added via migration 0121, so it's safe to use this value
const CATEGORY_HOUSING_ID = '928c97ef-5289-4daa-b80e-4b9fed50c629'
const CATEGORY_HOUSING_KEY = 'billing.category.housing.name.declined'

describe('SendNewReceiptMessagesToResidentScopesService', () => {

    let adminClient, supportClient, serviceClient, integrationServiceClient,
        anonymousClient, userClient0, userClient, residentClient,
        sender, property, organization,
        integration, integrationContext, billingProperty,
        dates

    beforeAll(async () => {
        dates = getStartDates()
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        userClient0 = await makeClientWithProperty()
        userClient = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymousClient = await makeClient()
        residentClient = await makeClientWithResidentUser()
        serviceClient = await makeClientWithServiceUser()
        sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
        organization = userClient0.organization
        property = userClient0.property

        const [resident0] = await createTestResident(adminClient, userClient0.user, userClient0.property)
        const [resident] = await createTestResident(adminClient, userClient.user, userClient0.property)
        const integrationData = await createTestBillingIntegration(adminClient)

        integration = integrationData[0]
        integrationServiceClient = await makeServiceUserForIntegration(integration)

        const contextData = await createTestBillingIntegrationOrganizationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })

        integrationContext = contextData[0]

        const billingPropertyData = await createTestBillingProperty(adminClient, integrationContext, { address: property.address })

        billingProperty = billingPropertyData[0]

        const [billingAccount] = await createTestBillingAccount(adminClient, integrationContext, billingProperty)
        const [consumer0] = await createTestServiceConsumer(adminClient, resident0, userClient0.organization, { billingAccount: { connect: { id: billingAccount.id } } })
    })
    afterAll( () => {
        if (global.gc) {
            global.gc()
        }
    })
    describe('sendNewReceiptMessagesToResidentScopes tests', () => {
        describe('check access', () => {
            let payload

            beforeAll( async () => {
                payload = {
                    sender,
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ billingProperty: { id: billingProperty.id } }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
            })

            test('admin can', async () => {
                console.log('payload:', JSON.stringify(payload, null, 2))
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)
            })

            test('service user without access can not', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(serviceClient, payload)
                })
            })

            test('service user with access can', async () => {
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)
            })

            test('support can not', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(supportClient, payload)
                })
            })

            test('random user can not', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(userClient, payload)
                })
            })

            test('resident user can not', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(residentClient, payload)
                })
            })

            test('anonymous user can not', async () => {
                await expectToThrowAuthenticationErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(anonymousClient, payload)
                })
            })
        })

        describe('validations', () => {
            let payload

            beforeAll( async () => {
                payload = {
                    sender,
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ billingProperty: { id: billingProperty.id } }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
            })

            test('throws on non existent context id for admin client', async () => {
                const casePayload = {
                    ...payload,
                    context: { id: faker.datatype.uuid() },
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_BILLING_CONTEXT_PROVIDED },
                    'result'
                )
            })

            test('throws on invalid period format (without day)', async () => {
                const casePayload = {
                    ...payload,
                    period: dates.thisMonthStart.substring(0, 7),
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_PERIOD_PROVIDED },
                    'result'
                )
            })

            test('doesn\'t throw on invalid period format (non-01 day)', async () => {
                const period = dates.thisMonthStart.substring(0, 7) + '-' + Math.floor(Math.random() * 20 + 10)
                const casePayload = { ...payload, period }
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, casePayload)

                expect(data.status).toEqual(SUCCESS_STATUS)
            })

            test('throws on invalid period format', async () => {
                const casePayload = {
                    ...payload,
                    period: faker.random.alphaNumeric(10),
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_PERIOD_PROVIDED },
                    'result'
                )
            })

            test('throws on period in future', async () => {
                const casePayload = {
                    ...payload,
                    period: dates.nextMonthStart,
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_PERIOD_PROVIDED },
                    'result'
                )
            })

            test('throws on period in past before previous month start', async () => {
                const casePayload = {
                    ...payload,
                    period: dayjs(dates.prevMonthStart).subtract('1', 'month').format(DATE_FORMAT),
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_PERIOD_PROVIDED },
                    'result'
                )
            })

            test('throws on non existent category id for admin client', async () => {
                const casePayload = {
                    ...payload,
                    category: { id: faker.datatype.uuid() },
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_BILLING_CATEGORY_PROVIDED },
                    'result'
                )
            })

            test('throws on non existent context id for service client', async () => {
                const casePayload = {
                    ...payload,
                    context: { id: faker.datatype.uuid() },
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_BILLING_CONTEXT_PROVIDED },
                    'result'
                )
            })

            test('throws on empty scopes', async () => {
                const casePayload = {
                    ...payload,
                    scopes: [],
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.SCOPES_IS_EMPTY },
                    'result'
                )
            })

            test('throws on missing property id', async () => {
                const casePayload = {
                    ...payload,
                    scopes: [{ billingProperty: { id: billingProperty.id } }, {}],
                }
                const expectedErrorMessage = 'Variable "$data" got invalid value {} at "data.scopes[1]"; Field "billingProperty" of required type "BillingPropertyWhereUniqueInput!" was not provided.'

                await catchErrorFrom(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    ({ errors, data }) => {
                        expect(errors).toMatchObject([{ message: expectedErrorMessage }])
                        expect(data).toBeUndefined()
                    }
                )
            })

            test('throws on non context organization property id', async () => {
                const casePayload = {
                    ...payload,
                    scopes: [{ billingProperty: { id: billingProperty.id } }, { billingProperty: { id: faker.datatype.uuid() } }],
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_BILLING_PROPERTY_PROVIDED },
                    'result'
                )
            })

        })

        describe('messages', () => {
            test('sends messages with proper contents to all residents of a property', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentsCount = Math.floor(Math.random() * 2) + 2

                let residentUsers = [], residents = []

                for (let i = 0; i < residentsCount; i++) {
                    residentUsers[i] = await makeClientWithResidentUser()

                    const [residentData] = await registerResidentByTestClient(residentUsers[i], residentPayload)

                    residents[i] = residentData
                    await syncRemoteClientWithPushTokenByTestClient(residentUsers[i], remoteClientPayload)
                }

                const payload = {
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ billingProperty: { id: billingProperty.id } }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const residentUserIds = residents.map(resident => resident.user.id)
                const messageWhere = { user: { id_in: residentUserIds }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(residentUsers.length)

                    for (const message of messages) {
                        expect(message.status).toEqual(MESSAGE_SENT_STATUS)
                    }
                })
            })

            test('properly fills urlTemplate and uniqKeyTemplate', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentUser = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUser, residentPayload)

                await syncRemoteClientWithPushTokenByTestClient(residentUser, remoteClientPayload)

                const payload = {
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ billingProperty: { id: billingProperty.id } }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId={paymentCategoryId}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const messageWhere = { user: { id_in: [resident.user.id] }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }
                const url = `payments/addaccount/?residentId=${resident.id}&categoryId=1&organizationTIN=${organization.tin}`
                const uniqKey = [CATEGORY_HOUSING_ID, dates.thisMonthStart, resident.id ].join(':')

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(1)

                    const [message] = messages

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message.uniqKey).toEqual(uniqKey)
                    expect(message.meta.data.url).toEqual(url)
                    expect(message.meta.data.categoryId).toEqual(payload.category.id)
                    expect(message.meta.categoryName).not.toBeUndefined()
                    expect(message.meta.categoryName).toEqual(CATEGORY_HOUSING_KEY)
                    expect(message.processingMeta.messageContext.notification.body).not.toContain(message.meta.categoryName)
                })
            })


            test('no duplicate notifications sent', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentUser = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUser, residentPayload)

                await syncRemoteClientWithPushTokenByTestClient(residentUser, remoteClientPayload)

                const payload = {
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ billingProperty: { id: billingProperty.id } }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const messageWhere = { user: { id_in: [resident.user.id] }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(1)
                    expect(messages[0].status).toEqual(MESSAGE_SENT_STATUS)
                })
            })


            test('doesn\'t sent notifications to deleted residents', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentUser = await makeClientWithResidentUser()
                const residentUser2 = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUser, residentPayload)
                const [resident2] = await registerResidentByTestClient(residentUser2, residentPayload)

                await Resident.softDelete(adminClient, resident2.id)

                await syncRemoteClientWithPushTokenByTestClient(residentUser, remoteClientPayload)

                const payload = {
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ billingProperty: { id: billingProperty.id } }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const messageWhere = { user: { id_in: [resident.user.id, resident2.user.id] }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(1)
                    expect(messages[0].status).toEqual(MESSAGE_SENT_STATUS)
                })
            })


            test('doesn\'t sent notifications to residents with skipped billing accounts', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentUser = await makeClientWithResidentUser()
                const residentUser2 = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUser, residentPayload)
                const [resident2] = await registerResidentByTestClient(residentUser2, residentPayload)
                const [billingAccount] = await createTestBillingAccount(adminClient, integrationContext, billingProperty)

                await createTestServiceConsumer(adminClient, resident2, organization, { billingAccount: { connect: { id: billingAccount.id } } })
                await syncRemoteClientWithPushTokenByTestClient(residentUser, remoteClientPayload)
                await syncRemoteClientWithPushTokenByTestClient(residentUser2, remoteClientPayload)

                const payload = {
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ billingProperty: { id: billingProperty.id }, skipAccountNumbers: [billingAccount.number] }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const messageWhere = { user: { id_in: [resident.user.id, resident2.user.id] }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(1)
                    expect(messages[0].status).toEqual(MESSAGE_SENT_STATUS)
                })
            })

        })
    })

    // NOT FOR CI
    // This test should be executed ONLY LOCALLY with following .env entity added:
    // EPS_INTEGRATION='{"endpoint":"http://localhost:3000/admin/api", "authRequisites":{"phone":"<phone>", "email": "<email>", "password":"<password>"}, "integration": "<integrationId>" }'
    // All this data is generated within this tests pack above
    // This workaround is needed to be able to semi-automatically test complex chain of interconnected processes of condo and integrated service (EPS) on LOCAL environment
    // It needs condo and EPS worker tasks to be separated, so both workers should be running independently.
    // To do so you need to add another Redis docker instance on different port and map it to EPS integration, in order to everything work properly.
    // docker-compose.yml && apps/eps/.env should be patched (add instance of Redis to different port, map the port to apps/eps/.env)
    // How to test:
    //     1. run this test
    //     2. wait till it creates all entities for all models and await is executed
    //     3. execute script at apps/eps/bin/triggerEpsNewReceiptsNotifications.js, it should find new EPS receipts and trigger sendNewReceiptMessagesToResidentScopes mutation
    //     4. test will detect new messages of proper type for resident users and succeed
    // Algo:
    //     - generate organization +
    //     - connect organization to integration via context +
    //     - generate property within organization +
    //     - generate resident within property +
    //     - generate billing account +
    //     - connect billing account to resident via service consumer +
    //     - generate billing property +
    //     - generate billing receipt for billing account +
    //     - wait for proper notification to be sent to resident's user +
    describe.skip('Non CI complex manual testing for sendNewReceiptMessagesToResidentScopes', () => {
        let billingIntegration

        beforeAll(async () => {
            const { integration: integrationId } = conf['EPS_INTEGRATION'] ? JSON.parse(conf['EPS_INTEGRATION']) : {}

            if (!integrationId) throw new Error('Missing integration in EPS_INTEGRATION entity of .env')

            billingIntegration = await BillingIntegration.getOne(adminClient, { id: integrationId })

            if (!billingIntegration) throw new Error('Provided integration id in EPS_INTEGRATION entity of .env is invalid')
        })

        it('generates RSO billing receipts and checks that mutation is triggered from integrated service and proper notifications sent to users without billing accounts', async () => {
            const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
            const userClient = await makeClientWithProperty()
            const userClient1 = await makeClientWithNewRegisteredAndLoggedInUser()
            const userClient2 = await makeClientWithNewRegisteredAndLoggedInUser()
            const userClient3 = await makeClientWithNewRegisteredAndLoggedInUser()
            const userClient4 = await makeClientWithNewRegisteredAndLoggedInUser()

            await syncRemoteClientWithPushTokenByTestClient(userClient3, remoteClientPayload)
            await syncRemoteClientWithPushTokenByTestClient(userClient4, remoteClientPayload)

            const [billingContext] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, billingIntegration, { status: CONTEXT_FINISHED_STATUS })
            const [billingProperty] = await createTestBillingProperty(adminClient, billingContext, { address: userClient.property.address })
            const [billingAccount] = await createTestBillingAccount(adminClient, billingContext, billingProperty)
            const [billingAccount1] = await createTestBillingAccount(adminClient, billingContext, billingProperty)
            const [billingAccount2] = await createTestBillingAccount(adminClient, billingContext, billingProperty)
            const [resident] = await createTestResident(adminClient, userClient.user, userClient.property)
            const [resident1] = await createTestResident(adminClient, userClient1.user, userClient.property)
            const [resident2] = await createTestResident(adminClient, userClient2.user, userClient.property)
            const [resident3] = await createTestResident(adminClient, userClient3.user, userClient.property)
            const [resident4] = await createTestResident(adminClient, userClient4.user, userClient.property)
            const [consumer] = await createTestServiceConsumer(adminClient, resident, userClient.organization, { billingAccount: { connect: { id: billingAccount.id } } })
            const [consumer1] = await createTestServiceConsumer(adminClient, resident1, userClient.organization, { billingAccount: { connect: { id: billingAccount1.id } } })
            const [consumer2] = await createTestServiceConsumer(adminClient, resident2, userClient.organization, { billingAccount: { connect: { id: billingAccount2.id } } })
            const receiptExtraData = { period: dates.thisMonthStart, category: { connect: { id: CATEGORY_HOUSING_ID } } }
            const [receipt] = await createTestBillingReceipt(adminClient, billingContext, billingProperty, billingAccount, receiptExtraData)
            const [receipt1] = await createTestBillingReceipt(adminClient, billingContext, billingProperty, billingAccount1, receiptExtraData)
            const [receipt2] = await createTestBillingReceipt(adminClient, billingContext, billingProperty, billingAccount2, receiptExtraData)

            /**
             * to trigger new receipts notifications run manually at this point
             * yarn workspace @app/eps node ./bin/triggerEpsNewReceiptsNotifications.js
             */

            /** only users of resident3 & resident4 should receive notifications */

            const messageWhere = {
                user: {
                    id_in: [resident.user.id, resident1.user.id, resident2.user.id, resident3.user.id, resident4.user.id],
                },
                type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
            }

            await waitFor(async () => {
                const messages = await Message.getAll(adminClient, messageWhere)

                expect(isEmpty(messages)).toBeFalsy()
                expect(messages).toHaveLength(2)
                expect(messages[0].status).toEqual(MESSAGE_SENT_STATUS)

                const userIds = [messages[0].user.id, messages[1].user.id]

                expect(userIds.includes(resident3.user.id)).toBeTruthy()
                expect(userIds.includes(resident4.user.id)).toBeTruthy()
            }, { interval: 1000, delay: 500, timeout: 1000 * 60 * 5 })
        })

        it('checks that new billing receipts for RSO integrations trigger sending proper notifications to users in ordinary organizations and without billing accounts', async () => {
            const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }

            const userClient = await makeClientWithProperty()
            const userClient1 = await makeClientWithNewRegisteredAndLoggedInUser()
            const userClient2 = await makeClientWithNewRegisteredAndLoggedInUser()
            const [resident] = await createTestResident(adminClient, userClient.user, userClient.property)
            const [resident1] = await createTestResident(adminClient, userClient1.user, userClient.property)
            const [resident2] = await createTestResident(adminClient, userClient2.user, userClient.property)

            await syncRemoteClientWithPushTokenByTestClient(userClient, remoteClientPayload)
            await syncRemoteClientWithPushTokenByTestClient(userClient1, remoteClientPayload)

            const [organizationRSO] = await registerNewOrganization(adminClient)
            const [billingContextRSO] = await createTestBillingIntegrationOrganizationContext(adminClient, userClient.organization, billingIntegration, { status: CONTEXT_FINISHED_STATUS })
            const [billingPropertyRSO] = await createTestBillingProperty(adminClient, billingContextRSO, { address: userClient.property.address })
            const [billingAccount] = await createTestBillingAccount(adminClient, billingContextRSO, billingPropertyRSO, { unitType: resident.unitType, unitName: resident.unitName })
            const [serviceConsumer] = await createTestServiceConsumer(adminClient, resident, organizationRSO, { billingAccount: { connect: { id: billingAccount.id } } })
            const receiptExtraData = { period: dates.thisMonthStart, category: { connect: { id: CATEGORY_HOUSING_ID } } }
            const [billingReceipt] = await createTestBillingReceipt(adminClient, billingContextRSO, billingPropertyRSO, billingAccount, receiptExtraData)

            /**
             * to trigger new receipts notifications run manually at this point
             * yarn workspace @app/eps node ./bin/triggerEpsNewReceiptsNotifications.js
             */

            const messageWhere = {
                user: { id_in: [resident.user.id, resident1.user.id, resident2.user.id] },
                type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
            }

            await waitFor(async () => {
                const messages = await Message.getAll(adminClient, messageWhere)

                expect(isEmpty(messages)).toBeFalsy()
                expect(messages).toHaveLength(2)
                expect(messages[0].status).toEqual(MESSAGE_SENT_STATUS)

                const userIds = [messages[0].user.id, messages[1].user.id]

                expect(userIds.includes(resident1.user.id)).toBeTruthy()
                expect(userIds.includes(resident2.user.id)).toBeTruthy()
            }, { interval: 1000, delay: 500, timeout: 1000 * 60 * 5 })

        })
    })
})