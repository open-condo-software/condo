/**
 * Generated by `createservice resident.SendNewReceiptMessagesToResidentScopesService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { isEmpty } = require('lodash')

const {
    makeLoggedInAdminClient, makeClient,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowGQLError, waitFor, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const {
    createTestBillingIntegration,
    createTestBillingIntegrationOrganizationContext,
    makeServiceUserForIntegration,
} = require('@condo/domains/billing/utils/testSchema')
const { sendNewReceiptMessagesToResidentScopesByTestClient } = require('@condo/domains/billing/utils/testSchema')
const { SUCCESS_STATUS } = require('@condo/domains/common/constants')
const { DATE_FORMAT, getStartDates } = require('@condo/domains/common/utils/date')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const {
    BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE,
    DEVICE_PLATFORM_ANDROID, APP_MASTER_ID_ANDROID, MESSAGE_SENT_STATUS,
} = require('@condo/domains/notification/constants/constants')
const { syncRemoteClientWithPushTokenByTestClient, Message } = require('@condo/domains/notification/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { registerResidentByTestClient } = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')


const { ERRORS } = require('./SendNewReceiptMessagesToResidentScopesService')

// Billing categories are constants within DB and added via migration 0121, so it's safe to use this value
const CATEGORY_HOUSING_ID = '928c97ef-5289-4daa-b80e-4b9fed50c629'
const CATEGORY_HOUSING_KEY = 'billing.category.housing.name.declined'

describe('SendNewReceiptMessagesToResidentScopesService', () => {

    let adminClient, supportClient, serviceClient, integrationServiceClient,
        anonymousClient, userClient, residentClient,
        sender, property, organization,
        integration, integrationContext,
        dates

    beforeAll(async () => {
        dates = getStartDates()
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        userClient = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymousClient = await makeClient()
        sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
        const organizationData = await createTestOrganization(adminClient)
        organization = organizationData[0]
        const propertyData = await createTestProperty(adminClient, organization)
        property = propertyData[0]
        residentClient = await makeClientWithResidentUser()
        serviceClient = await makeClientWithServiceUser()
        const integrationData = await createTestBillingIntegration(adminClient)
        integration = integrationData[0]
        integrationServiceClient = await makeServiceUserForIntegration(integration)
        const contextData = await createTestBillingIntegrationOrganizationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        integrationContext = contextData[0]
    })

    describe('sendNewReceiptMessagesToResidentScopes tests', () => {
        describe('check access', () => {
            let payload

            beforeAll( async () => {
                payload = {
                    sender,
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ property: { id: property.id } }],
                    meta: {
                        categoryName: faker.random.alphaNumeric(8), // TODO: remove, this will be auto substituted in service
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
            })

            test('admin can', async () => {
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)
            })

            test('service user without access can not', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(serviceClient, payload)
                })
            })

            test('service user with access can', async () => {
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)
            })

            test('support can not', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(supportClient, payload)
                })
            })

            test('random user can not', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(userClient, payload)
                })
            })

            test('resident user can not', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(residentClient, payload)
                })
            })

            test('anonymous user can not', async () => {
                await expectToThrowAuthenticationErrorToResult(async () => {
                    await sendNewReceiptMessagesToResidentScopesByTestClient(anonymousClient, payload)
                })
            })
        })

        describe('validations', () => {
            let payload

            beforeAll( async () => {
                payload = {
                    sender,
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ property: { id: property.id } }],
                    meta: {
                        categoryName: faker.random.alphaNumeric(8), // TODO: remove, this will be auto substituted in service
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
            })

            test('throws on non existent context id for admin client', async () => {
                const casePayload = {
                    ...payload,
                    context: { id: faker.datatype.uuid() },
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_BILLING_CONTEXT_PROVIDED },
                    'result'
                )
            })

            test('throws on invalid period format', async () => {
                const casePayload = {
                    ...payload,
                    period: faker.random.alphaNumeric(10),
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_PERIOD_PROVIDED },
                    'result'
                )
            })

            test('throws on period in future', async () => {
                const casePayload = {
                    ...payload,
                    period: dates.nextMonthStart,
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_PERIOD_PROVIDED },
                    'result'
                )
            })

            test('throws on period in past before previous month start', async () => {
                const casePayload = {
                    ...payload,
                    period: dayjs(dates.prevMonthStart).subtract('1', 'month').format(DATE_FORMAT),
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_PERIOD_PROVIDED },
                    'result'
                )
            })

            test('throws on non existent category id for admin client', async () => {
                const casePayload = {
                    ...payload,
                    category: { id: faker.datatype.uuid() },
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_BILLING_CATEGORY_PROVIDED },
                    'result'
                )
            })

            test('throws on non existent context id for service client', async () => {
                const casePayload = {
                    ...payload,
                    context: { id: faker.datatype.uuid() },
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_BILLING_CONTEXT_PROVIDED },
                    'result'
                )
            })

            test('throws on empty scopes', async () => {
                const casePayload = {
                    ...payload,
                    scopes: [],
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.SCOPES_IS_EMPTY },
                    'result'
                )
            })

            test('throws on missing property id', async () => {
                const casePayload = {
                    ...payload,
                    scopes: [{ property: { id: property.id } }, {}],
                }
                const expectedErrorMessage = 'Variable "$data" got invalid value {} at "data.scopes[1]"; Field "property" of required type "PropertyWhereUniqueInput!" was not provided.'

                await catchErrorFrom(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    ({ errors, data }) => {
                        expect(errors).toMatchObject([{ message: expectedErrorMessage }])
                        expect(data).toBeUndefined()
                    }
                )
            })

            test('throws on non context organization property id', async () => {
                const casePayload = {
                    ...payload,
                    scopes: [{ property: { id: property.id } }, { property: { id: faker.datatype.uuid() } }],
                }

                await expectToThrowGQLError(
                    async () => { await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, casePayload) },
                    { ...ERRORS.INVALID_PROPERTY_PROVIDED },
                    'result'
                )
            })

        })

        describe('messages', () => {
            test('sends messages with proper contents to all residents of a property', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentsCount = Math.floor(Math.random() * 2) + 2

                let residentUsers = [], residents = []

                for (let i = 0; i < residentsCount; i++) {
                    residentUsers[i] = await makeClientWithResidentUser()

                    const [residentData] = await registerResidentByTestClient(residentUsers[i], residentPayload)

                    residents[i] = residentData
                    await syncRemoteClientWithPushTokenByTestClient(residentUsers[i], remoteClientPayload)
                }

                const payload = {
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ property: { id: property.id } }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const residentUserIds = residents.map(resident => resident.user.id)
                const messageWhere = { user: { id_in: residentUserIds }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(residentUsers.length)

                    for (const message of messages) {
                        expect(message.status).toEqual(MESSAGE_SENT_STATUS)
                    }
                })
            })

            test('properly fills urlTemplate and uniqKeyTemplate', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentUser = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUser, residentPayload)

                await syncRemoteClientWithPushTokenByTestClient(residentUser, remoteClientPayload)

                const payload = {
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ property: { id: property.id } }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const messageWhere = { user: { id_in: [resident.user.id] }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }
                const url = `payments/addaccount/?residentId=${resident.id}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`
                const uniqKey = [CATEGORY_HOUSING_ID, dates.thisMonthStart, resident.id ].join(':')

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(1)

                    const [message] = messages

                    expect(message.status).toEqual(MESSAGE_SENT_STATUS)
                    expect(message.uniqKey).toEqual(uniqKey)
                    expect(message.meta.data.url).toEqual(url)
                    expect(message.meta.data.categoryId).toEqual(payload.category.id)
                    expect(message.meta.categoryName).not.toBeUndefined()
                    expect(message.meta.categoryName).toEqual(CATEGORY_HOUSING_KEY)
                    expect(message.processingMeta.messageContext.notification.body).not.toContain(message.meta.categoryName)
                })
            })


            test('no duplicate notifications sent', async () => {
                // Create some residents and sync their users with remoteClients to be able to emulate sending push notifications
                const residentPayload = { address: property.address, addressMeta: property.addressMeta }
                const remoteClientPayload = { devicePlatform: DEVICE_PLATFORM_ANDROID, appId: APP_MASTER_ID_ANDROID }
                const residentUser = await makeClientWithResidentUser()
                const [resident] = await registerResidentByTestClient(residentUser, residentPayload)

                await syncRemoteClientWithPushTokenByTestClient(residentUser, remoteClientPayload)

                const payload = {
                    context: { id: integrationContext.id },
                    category: { id: CATEGORY_HOUSING_ID },
                    period: dates.thisMonthStart,
                    scopes: [{ property: { id: property.id } }],
                    meta: {
                        data: {
                            urlTemplate: `payments/addaccount/?residentId={residentId}&categoryId=${CATEGORY_HOUSING_ID}&organizationTIN=${organization.tin}`,
                        },
                    },
                }
                const [data] = await sendNewReceiptMessagesToResidentScopesByTestClient(integrationServiceClient, payload)

                await sendNewReceiptMessagesToResidentScopesByTestClient(adminClient, payload)

                expect(data.status).toEqual(SUCCESS_STATUS)

                const messageWhere = { user: { id_in: [resident.user.id] }, type: BILLING_RECEIPT_CATEGORY_AVAILABLE_TYPE }

                await waitFor(async () => {
                    const messages = await Message.getAll(adminClient, messageWhere)

                    expect(isEmpty(messages)).toBeFalsy()
                    expect(messages).toHaveLength(1)
                    expect(messages[0].status).toEqual(MESSAGE_SENT_STATUS)
                })
            })

        })
    })
})