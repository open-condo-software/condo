/**
 * Generated by `createservice billing.ValidateQRCodeService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { omit } = require('lodash')

const {
    makeLoggedInAdminClient,
    makeClient,
    catchErrorFrom,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { PAYMENT_DONE_STATUS } = require('@condo/domains/acquiring/constants/payment')
const {
    createTestAcquiringIntegrationContext,
    createTestAcquiringIntegration,
    generateVirtualReceipt,
    registerMultiPaymentForVirtualReceiptByTestClient,
    updateTestPayment,
} = require('@condo/domains/acquiring/utils/testSchema')
const { updateTestAcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/testSchema')
const {
    addAcquiringIntegrationAndContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const { Payment } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBankAccount } = require('@condo/domains/banking/utils/testSchema')
const {
    createValidRuRoutingNumber,
    createValidRuNumber,
    createValidRuTin10,
} = require('@condo/domains/banking/utils/testSchema/bankAccount')
const { MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW } = require('@condo/domains/billing/constants')
const {
    validateQRCodeByTestClient,
    addBillingIntegrationAndContext,
    createTestBillingProperty,
    createTestBillingAccount,
    createTestBillingRecipient,
    createTestBillingReceipt,
    createTestRecipient,
} = require('@condo/domains/billing/utils/testSchema')
const { ALREADY_EXISTS_ERROR } = require('@condo/domains/common/constants/errors')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithStaffUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

function stringifyQrCode (qrCodeObj) {
    return Object.keys(qrCodeObj).reduce((qrStr, field) => {
        return `${qrStr}|${field}=${qrCodeObj[field]}`
    }, 'ST00012')
}

async function createBillingReceiptAndAllDependencies (admin, organization, property, qrCodeAttrs, period, sum, acquiringIntegrationFeePercent, serviceFeePercent) {
    const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, organization, {}, { status: CONTEXT_FINISHED_STATUS })
    const { acquiringIntegrationContext } = await addAcquiringIntegrationAndContext(admin, organization, {
        explicitFeeDistributionSchema: [{
            recipient: 'acquiring',
            percent: acquiringIntegrationFeePercent,
        }, {
            recipient: 'service',
            percent: serviceFeePercent,
        }],
    }, {
        status: CONTEXT_FINISHED_STATUS,
        recipient: createTestRecipient({
            name: organization.name,
            tin: organization.tin,
            bic: qrCodeAttrs.BIC,
            bankAccount: qrCodeAttrs.PersonalAcc,
        }),
    })

    const [bankAccount] = await createTestBankAccount(admin, organization, {
        number: qrCodeAttrs.PersonalAcc,
        routingNumber: qrCodeAttrs.BIC,
    })
    const [billingProperty] = await createTestBillingProperty(admin, billingIntegrationContext, { address: property.address })
    const [billingAccount] = await createTestBillingAccount(admin, billingIntegrationContext, billingProperty, { number: qrCodeAttrs.PersAcc })
    const [billingRecipient] = await createTestBillingRecipient(admin, billingIntegrationContext, {
        bankAccount: qrCodeAttrs.PersonalAcc,
        bic: qrCodeAttrs.BIC,
    })
    const [billingReceipt] = await createTestBillingReceipt(admin, billingIntegrationContext, billingProperty, billingAccount, {
        period,
        receiver: { connect: { id: billingRecipient.id } },
        recipient: createTestRecipient({
            bic: billingRecipient.bic,
        }),
        toPay: String(sum),
    })

    return { billingReceipt, bankAccount, acquiringIntegrationContext, billingIntegrationContext }
}

function generateQrCodeObj (extraAttrs = {}) {
    const bic = createValidRuRoutingNumber()

    return {
        PersonalAcc: createValidRuNumber(bic),
        PayeeINN: createValidRuTin10(),
        PayerAddress: faker.address.streetAddress(true),
        Sum: faker.random.numeric(6),
        LastName: faker.random.alpha(10),
        PaymPeriod: `${faker.datatype.number({ min: 1, max: 12 })}.${faker.datatype.number({
            min: 2024,
            max: 2099,
        })}`,
        BIC: bic,
        PersAcc: faker.random.numeric(20),
        ...extraAttrs,
    }
}

describe('ValidateQRCodeService', () => {
    let adminClient, supportClient, userClient, staffClient, serviceClient, anonymous, organization
    let qrCodeObj, qrCodeString
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        userClient = await makeClientWithResidentUser()
        anonymous = await makeClient()
        staffClient = await makeClientWithStaffUser()
        serviceClient = await makeClientWithServiceUser()

        const [testOrganization] = await createTestOrganization(adminClient)
        const [testProperty] = await createTestProperty(adminClient, testOrganization)
        await addBillingIntegrationAndContext(adminClient, testOrganization, {}, { status: CONTEXT_FINISHED_STATUS })
        qrCodeObj = generateQrCodeObj({
            PayeeINN: testOrganization.tin,
            PayerAddress: `${testProperty.address}, кв. 1`,
        })
        const recipient = createTestRecipient({
            name: testOrganization.name,
            tin: qrCodeObj.BIC,
            bankAccount: qrCodeObj.PersonalAcc,
        })
        await addAcquiringIntegrationAndContext(adminClient, testOrganization, {}, { status: CONTEXT_FINISHED_STATUS, recipient })
        organization = testOrganization

        qrCodeString = stringifyQrCode(qrCodeObj)
    })

    test('should parse fields correctly', async () => {
        const [{ qrCodeFields }] = await validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString })

        expect(qrCodeFields.PersonalAcc).toBe(qrCodeObj.PersonalAcc)
        expect(qrCodeFields.PayeeINN).toBe(qrCodeObj.PayeeINN)
        expect(qrCodeFields.PayerAddress).toBe(qrCodeObj.PayerAddress)
        expect(qrCodeFields.Sum).toBe(qrCodeObj.Sum)
        expect(qrCodeFields.lastName).toBe(qrCodeObj.lastName)
        expect(qrCodeFields.PaymPeriod).toBe(qrCodeObj.PaymPeriod)
    })

    describe('Field validations', () => {
        const cases = [
            'BIC',
            'PayerAddress',
            'Sum',
            'PaymPeriod',
            'PersAcc',
            'PayeeINN',
            'PersonalAcc',
        ]

        test.each(cases)('should throw if QR code doesn\'t have "%s"', async (field) => {
            const qrCode = stringifyQrCode(omit(qrCodeObj, field))
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: `Provided QR code doesn't have required fields: ${field}`,
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'BAD_USER_INPUT',
                        type: 'WRONG_FORMAT',
                        message: `Provided QR code doesn't have required fields: ${field}`,
                    },
                }])
            })
        })

        test('should throw an error if QR code is wrong', async () => {
            const qrCode = 'ST0012|field1=Hello|Field2=world'
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode })
            }, ({ errors }) => {
                expect(errors).toMatchObject([{
                    message: 'Invalid QR code',
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'BAD_USER_INPUT',
                        type: 'WRONG_FORMAT',
                        message: 'Invalid QR code',
                    },
                }])
            })
        })

        test('should throw an error if no recipient in acquiring context', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)
            await addBillingIntegrationAndContext(adminClient, o10n, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, o10n, {}, { status: CONTEXT_FINISHED_STATUS })
            const qrCodeObj = generateQrCodeObj({
                PayeeINN: o10n.tin,
                PayerAddress: `${property.address}, кв. 1`,
            })

            const qrCodeString = stringifyQrCode(qrCodeObj)
            await expectToThrowGQLError(
                async () => validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString }),
                {
                    mutation: 'validateQRCode',
                    code: 'BAD_USER_INPUT',
                    type: 'WRONG_FORMAT',
                    message: 'Provided bank account is not in the system',
                },
                'result'
            )
        })
    })

    describe('Validate organization', () => {
        test('should throw if no organization with provided TIN exists', async () => {
            const qrCode = qrCodeString.replace(qrCodeObj.PayeeINN, '000000000')
            await expectToThrowGQLError(
                async () => {
                    await validateQRCodeByTestClient(adminClient, { qrCode })
                },
                {
                    mutation: 'validateQRCode',
                    code: 'INTERNAL_ERROR',
                    type: 'NOT_FOUND',
                    message: 'Organization with provided TIN and having provided address is not registered',
                },
                'result',
            )
        })

        test('should throw if 2+ organization with provided TIN and address exists', async () => {
            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [anotherProperty] = await createTestProperty(adminClient, anotherOrganization)
            await addBillingIntegrationAndContext(adminClient, anotherOrganization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, anotherOrganization, {}, { status: CONTEXT_FINISHED_STATUS })

            const [anotherOrganization2] = await createTestOrganization(adminClient, { tin: anotherOrganization.tin })
            await createTestProperty(adminClient, anotherOrganization2, { address: anotherProperty.address })
            await addBillingIntegrationAndContext(adminClient, anotherOrganization2, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, anotherOrganization2, {}, { status: CONTEXT_FINISHED_STATUS })

            const anotherQrCodeObj = generateQrCodeObj({
                PayeeINN: anotherOrganization.tin,
                PayerAddress: `${anotherProperty.address}, кв. 1`,
            })
            await expectToThrowGQLError(
                async () => {
                    await validateQRCodeByTestClient(adminClient, { qrCode: stringifyQrCode(anotherQrCodeObj) })
                },
                {
                    mutation: 'validateQRCode',
                    code: 'INTERNAL_ERROR',
                    type: 'SEVERAL_ORGANIZATIONS',
                    message: 'Found 2 organizations with provided TIN and having provided address',
                },
                'result',
            )
        })

        test('should throw if no billing context was found', async () => {
            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [anotherProperty] = await createTestProperty(adminClient, anotherOrganization)
            await addAcquiringIntegrationAndContext(adminClient, anotherOrganization, {}, { status: CONTEXT_FINISHED_STATUS })
            const anotherQrCodeObj = generateQrCodeObj({
                PayeeINN: anotherOrganization.tin,
                PayerAddress: `${anotherProperty.address}, кв. 1`,
            })
            await expectToThrowGQLError(
                async () => {
                    await validateQRCodeByTestClient(adminClient, { qrCode: stringifyQrCode(anotherQrCodeObj) })
                },
                {
                    mutation: 'validateQRCode',
                    code: 'INTERNAL_ERROR',
                    type: 'NOT_FOUND',
                    message: 'Organization with provided TIN does not have an active billing integration',
                },
                'result',
            )
        })

        test('should throw if no AcquiringIntegrationContext was found', async () => {
            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [anotherProperty] = await createTestProperty(adminClient, anotherOrganization)
            await addBillingIntegrationAndContext(adminClient, anotherOrganization, {}, { status: CONTEXT_FINISHED_STATUS })
            const anotherQrCodeObj = generateQrCodeObj({
                PayeeINN: anotherOrganization.tin,
                PayerAddress: `${anotherProperty.address}, кв. 1`,
            })
            await expectToThrowGQLError(
                async () => {
                    await validateQRCodeByTestClient(adminClient, { qrCode: stringifyQrCode(anotherQrCodeObj) })
                },
                {
                    mutation: 'validateQRCode',
                    code: 'INTERNAL_ERROR',
                    type: 'NOT_FOUND',
                    message: 'Organization with provided TIN does not have an active acquiring integration',
                },
                'result',
            )
        })

        test('should throw if found billing integration context is not active (status !== Finished)', async () => {
            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [anotherProperty] = await createTestProperty(adminClient, anotherOrganization)
            await addAcquiringIntegrationAndContext(adminClient, anotherOrganization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addBillingIntegrationAndContext(adminClient, anotherOrganization)
            const anotherQrCodeObj = generateQrCodeObj({
                PayeeINN: anotherOrganization.tin,
                PayerAddress: `${anotherProperty.address}, кв. 1`,
            })
            await expectToThrowGQLError(
                async () => {
                    await validateQRCodeByTestClient(adminClient, { qrCode: stringifyQrCode(anotherQrCodeObj) })
                },
                {
                    mutation: 'validateQRCode',
                    code: 'INTERNAL_ERROR',
                    type: 'NOT_FOUND',
                    message: 'Organization with provided TIN does not have an active billing integration',
                },
                'result',
            )
        })

        test('should throw if found acquiring context is not active (status !== Finished)', async () => {
            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [anotherProperty] = await createTestProperty(adminClient, anotherOrganization)
            await addAcquiringIntegrationAndContext(adminClient, anotherOrganization)
            await addBillingIntegrationAndContext(adminClient, anotherOrganization, {}, { status: CONTEXT_FINISHED_STATUS })
            const anotherQrCodeObj = generateQrCodeObj({
                PayeeINN: anotherOrganization.tin,
                PayerAddress: `${anotherProperty.address}, кв. 1`,
            })
            await expectToThrowGQLError(
                async () => {
                    await validateQRCodeByTestClient(adminClient, { qrCode: stringifyQrCode(anotherQrCodeObj) })
                },
                {
                    mutation: 'validateQRCode',
                    code: 'INTERNAL_ERROR',
                    type: 'NOT_FOUND',
                    message: 'Organization with provided TIN does not have an active acquiring integration',
                },
                'result',
            )
        })
    })

    describe('The error on requests limit reached', () => {

        test('should be thrown for anonymous ', async () => {
            const ipLike = Array(4).fill(null).map(() => faker.random.numeric(3)).join('.')
            const anonymousClient = await makeClient()
            anonymousClient.setHeaders({ 'x-forwarded-for': ipLike })

            for await (const i of Array.from(Array(MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW + 1).keys())) {
                if (i === MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW) {
                    await catchErrorFrom(async () => {
                        await validateQRCodeByTestClient(anonymousClient, { qrCode: qrCodeString })
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            path: ['result'],
                            extensions: {
                                code: 'BAD_USER_INPUT',
                                type: 'TOO_MANY_REQUESTS',
                                message: 'You have to wait {secondsRemaining} seconds to be able to send request again',
                            },
                        }])
                    })
                } else {
                    await validateQRCodeByTestClient(anonymousClient, { qrCode: qrCodeString })
                }
            }
        })

        test('shouldn\'t be throw for registered user', async () => {
            const ipLike = Array(4).fill(null).map(() => faker.random.numeric(3)).join('.')
            const userClient = await makeClientWithResidentUser()
            userClient.setHeaders({ 'x-forwarded-for': ipLike })

            for (let i = 0; i < MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW + 1; i++) {
                await validateQRCodeByTestClient(userClient, { qrCode: qrCodeString })
            }
        })
    })

    test('resident: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const [organization] = await createTestOrganization(adminClient, { tin: qrCodeObj.PayeeINN })
        const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [{ qrCodeFields }] = await validateQRCodeByTestClient(userClient, { qrCode: qrCodeString })
        await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })

        expect(qrCodeFields.PersonalAcc).toBe(qrCodeObj.PersonalAcc)
        expect(qrCodeFields.PayeeINN).toBe(qrCodeObj.PayeeINN)
        expect(qrCodeFields.PayerAddress).toBe(qrCodeObj.PayerAddress)
        expect(qrCodeFields.Sum).toBe(qrCodeObj.Sum)
        expect(qrCodeFields.lastName).toBe(qrCodeObj.lastName)
        expect(qrCodeFields.PaymPeriod).toBe(qrCodeObj.PaymPeriod)
    })

    test('anonymous: can execute', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)
        await addBillingIntegrationAndContext(adminClient, organization, {}, { status: CONTEXT_FINISHED_STATUS })
        const recipient = createTestRecipient({
            name: organization.name,
            tin: organization.tin,
        })
        await addAcquiringIntegrationAndContext(adminClient, organization, {}, { status: CONTEXT_FINISHED_STATUS, recipient })
        const qr = {
            ...qrCodeObj,
            PayeeINN: organization.tin,
            PayerAddress: `${property.address}, кв 1`,
            PersonalAcc: recipient.bankAccount,
            BIC: recipient.bic,
        }
        const qrStr = stringifyQrCode(qr)
        const [result] = await validateQRCodeByTestClient(anonymous, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('support: can execute', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)
        await addBillingIntegrationAndContext(adminClient, organization, {}, { status: CONTEXT_FINISHED_STATUS })
        const recipient = createTestRecipient({
            name: organization.name,
            tin: organization.tin,
        })
        await addAcquiringIntegrationAndContext(adminClient, organization, {}, { status: CONTEXT_FINISHED_STATUS, recipient })
        const qr = {
            ...qrCodeObj,
            PayeeINN: organization.tin,
            PayerAddress: `${property.address}, кв 1`,
            PersonalAcc: recipient.bankAccount,
            BIC: recipient.bic,
        }
        const qrStr = stringifyQrCode(qr)
        const [result] = await validateQRCodeByTestClient(supportClient, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('staff: can execute', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)
        await addBillingIntegrationAndContext(adminClient, organization, {}, { status: CONTEXT_FINISHED_STATUS })
        const recipient = createTestRecipient({
            name: organization.name,
            tin: organization.tin,
        })
        await addAcquiringIntegrationAndContext(adminClient, organization, {}, { status: CONTEXT_FINISHED_STATUS, recipient })
        const qr = {
            ...qrCodeObj,
            PayeeINN: organization.tin,
            PayerAddress: `${property.address}, кв 1`,
            PersonalAcc: recipient.bankAccount,
            BIC: recipient.bic,
        }
        const qrStr = stringifyQrCode(qr)
        const [result] = await validateQRCodeByTestClient(staffClient, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('service: can\'t execute', async () => {
        await expectToThrowAccessDeniedErrorToResult(async () => {
            await validateQRCodeByTestClient(serviceClient, { qrCode: qrCodeString })
        })
    })

    describe('Periods comparison logic', () => {
        test('scanned receipt period equals the last billing receipt in out database', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)
            const recipient = createTestRecipient({
                name: o10n.name,
                tin: o10n.tin,
            })

            const PaymPeriod = '05.2024' // for QR code
            const period = '2024-05-01' // for receipt
            const sum = 1000
            const qrObj = {
                ...qrCodeObj,
                PayeeINN: o10n.tin,
                PayerAddress: `${property.address}, кв 1`,
                PaymPeriod,
                Sum: String(sum * 100),
                PersAcc: faker.random.numeric(20),
            }
            const qrStr = stringifyQrCode(qrObj)

            // create the receipt
            const {
                billingIntegrationContext,
                billingReceipt,
                acquiringIntegrationContext,
            } = await createBillingReceiptAndAllDependencies(adminClient, o10n, property, qrObj, period, sum, '0.5', '1')

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: {
                    id: billingReceipt.id,
                    period,
                    toPay: `${sum}.00000000`,
                },
                explicitFees: {
                    explicitServiceCharge: '15',
                    explicitFee: '0',
                },
                amount: '1000.00000000',
                acquiringIntegrationHostUrl: acquiringIntegrationContext.integration.hostUrl,
                currencyCode: billingIntegrationContext.integration.currencyCode,
            })
        })

        test('scanned receipt period less the last billing receipt in out database', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const PaymPeriod = '04.2024' // for QR code
            const period = '2024-05-01' // for receipt
            const sum = 1000
            const qrObj = {
                ...qrCodeObj,
                PayeeINN: o10n.tin,
                PayerAddress: `${property.address}, кв 1`,
                PaymPeriod,
                Sum: String(sum * 100),
                PersAcc: faker.random.numeric(20),
            }
            const qrStr = stringifyQrCode(qrObj)

            // create the receipt
            const {
                billingIntegrationContext,
                billingReceipt,
                acquiringIntegrationContext,
            } = await createBillingReceiptAndAllDependencies(adminClient, o10n, property, qrObj, period, sum, '1', '1.5')

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: {
                    id: billingReceipt.id,
                    period,
                    toPay: `${sum}.00000000`,
                },
                explicitFees: {
                    explicitServiceCharge: '25',
                    explicitFee: '0',
                },
                amount: '1000.00000000',
                acquiringIntegrationHostUrl: acquiringIntegrationContext.integration.hostUrl,
                currencyCode: billingIntegrationContext.integration.currencyCode,
            })
        })

        test('scanned receipt period greater than the last billing receipt in out database', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const PaymPeriod = '05.2024' // for QR code
            const period = '2024-04-01' // for receipt
            const sum = 1000
            const olderReceiptSum = 2000
            const qrObj = {
                ...qrCodeObj,
                PayeeINN: o10n.tin,
                PayerAddress: `${property.address}, кв 1`,
                PaymPeriod,
                Sum: String(sum * 100),
                PersAcc: faker.random.numeric(20),
            }
            const qrStr = stringifyQrCode(qrObj)

            // create the receipt
            const {
                billingIntegrationContext,
                billingReceipt,
                acquiringIntegrationContext,
            } = await createBillingReceiptAndAllDependencies(adminClient, o10n, property, qrObj, period, olderReceiptSum, '1.5', '1')

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: {
                    id: billingReceipt.id,
                    period,
                    toPay: `${olderReceiptSum}.00000000`,
                },
                explicitFees: {
                    explicitServiceCharge: '25',
                    explicitFee: '0',
                },
                amount: '1000',
                acquiringIntegrationHostUrl: acquiringIntegrationContext.integration.hostUrl,
                currencyCode: billingIntegrationContext.integration.currencyCode,
            })
        })

        test('scanned receipt not in out database', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const PaymPeriod = '05.2024' // for QR code
            const sum = 2000
            const qrObj = {
                ...qrCodeObj,
                PayeeINN: o10n.tin,
                PayerAddress: `${property.address}, кв 1`,
                PaymPeriod,
                Sum: String(sum * 100),
                PersAcc: faker.random.numeric(20),
            }
            const qrStr = stringifyQrCode(qrObj)

            const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, o10n, {}, { status: CONTEXT_FINISHED_STATUS })
            const recipient = createTestRecipient({
                name: organization.name,
                tin: organization.tin,
                bic: qrObj.BIC,
                bankAccount: qrObj.PersonalAcc,
            })
            const { acquiringIntegration } = await addAcquiringIntegrationAndContext(adminClient, o10n, {
                explicitFeeDistributionSchema: [{
                    recipient: 'acquiring',
                    percent: '1',
                }, {
                    recipient: 'service',
                    percent: '2',
                }],
            }, { status: CONTEXT_FINISHED_STATUS, recipient })

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: null,
                explicitFees: {
                    explicitServiceCharge: '60',
                    explicitFee: '0',
                },
                amount: '2000',
                acquiringIntegrationHostUrl: acquiringIntegration.hostUrl,
                currencyCode: billingIntegrationContext.integration.currencyCode,
            })
        })
    })

    test('error if scan qr-code of paid receipt', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)

        const PaymPeriod = '04.2024' // for QR code
        const period = '2024-04-01' // for receipt
        const sum = 1000
        const qrObj = {
            ...qrCodeObj,
            PayeeINN: organization.tin,
            PayerAddress: `${property.address}, кв 1`,
            PaymPeriod,
            Sum: String(sum * 100),
        }
        const qrStr = stringifyQrCode(qrObj)

        // create the receipt
        const {
            bankAccount,
            acquiringIntegrationContext,
        } = await createBillingReceiptAndAllDependencies(adminClient, organization, property, qrObj, period, sum, '1.5', '1')

        // register multi payment
        const receipt = generateVirtualReceipt({
            period,
            bankAccount,
            accountNumber: qrObj.PersAcc,
        })
        const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(adminClient, receipt, {
            id: acquiringIntegrationContext.id,
        })

        // get payments
        const payments = await Payment.getAll(adminClient, {
            multiPayment: {
                id: result.multiPaymentId,
            },
        })

        // mark payment as paid
        await updateTestPayment(adminClient, payments[0].id, {
            status: PAYMENT_DONE_STATUS,
            advancedAt: dayjs().toISOString(),
        })

        await expectToThrowGQLError(
            async () => await validateQRCodeByTestClient(adminClient, { qrCode: qrStr }),
            {
                code: 'BAD_USER_INPUT',
                type: ALREADY_EXISTS_ERROR,
                message: 'Provided receipt already paid',
                mutation: 'validateQRCode',
            },
            'result',
        )
    })
})
