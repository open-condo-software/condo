/**
 * Generated by `createservice billing.ValidateQRCodeService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const dayjs = require('dayjs')
const { omit } = require('lodash')

const {
    makeLoggedInAdminClient,
    makeClient,
    catchErrorFrom,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowGQLError,
    expectToThrowGQLErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { PAYMENT_DONE_STATUS } = require('@condo/domains/acquiring/constants/payment')
const {
    createTestAcquiringIntegrationContext,
    createTestAcquiringIntegration,
    generateVirtualReceipt,
    registerMultiPaymentForVirtualReceiptByTestClient,
    updateTestPayment,
} = require('@condo/domains/acquiring/utils/testSchema')
const { updateTestAcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/testSchema')
const {
    addAcquiringIntegrationAndContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const { Payment } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBankAccount } = require('@condo/domains/banking/utils/testSchema')
const {
    createValidRuRoutingNumber,
    createValidRuNumber,
    createValidRuTin10,
} = require('@condo/domains/banking/utils/testSchema/bankAccount')
const { MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW } = require('@condo/domains/billing/constants')
const {
    validateQRCodeByTestClient,
    addBillingIntegrationAndContext,
    createTestBillingProperty,
    createTestBillingAccount,
    createTestBillingRecipient,
    createTestBillingReceipt,
    createTestRecipient,
    updateTestBillingReceipt,
} = require('@condo/domains/billing/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithStaffUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

function stringifyQrCode (qrCodeObj) {
    return Buffer.from(Object.keys(qrCodeObj).reduce((qrStr, field) => {
        return `${qrStr}|${field}=${qrCodeObj[field]}`
    }, 'ST00012')).toString('base64')
}

async function createBillingReceiptAndAllDependencies (admin, organization, property, qrCodeAttrs, period, sum, acquiringIntegrationFeePercent, serviceFeePercent) {
    const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, organization, {}, { status: CONTEXT_FINISHED_STATUS })
    const { acquiringIntegrationContext } = await addAcquiringIntegrationAndContext(admin, organization, {
        explicitFeeDistributionSchema: [{
            recipient: 'acquiring',
            percent: acquiringIntegrationFeePercent,
        }, {
            recipient: 'service',
            percent: serviceFeePercent,
        }],
    }, {
        status: CONTEXT_FINISHED_STATUS,
        recipient: createTestRecipient({
            name: organization.name,
            tin: organization.tin,
            bic: qrCodeAttrs.BIC,
            bankAccount: qrCodeAttrs.PersonalAcc,
        }),
    })

    const [bankAccount] = await createTestBankAccount(admin, organization, {
        number: qrCodeAttrs.PersonalAcc,
        routingNumber: qrCodeAttrs.BIC,
    })
    const [billingProperty] = await createTestBillingProperty(admin, billingIntegrationContext, { address: property.address })
    const [billingAccount] = await createTestBillingAccount(admin, billingIntegrationContext, billingProperty, { number: qrCodeAttrs.PersAcc })
    const [billingRecipient] = await createTestBillingRecipient(admin, billingIntegrationContext, {
        bankAccount: qrCodeAttrs.PersonalAcc,
        bic: qrCodeAttrs.BIC,
        tin: qrCodeAttrs.PayeeINN,
    })
    const [billingReceipt] = await createTestBillingReceipt(admin, billingIntegrationContext, billingProperty, billingAccount, {
        period,
        receiver: { connect: { id: billingRecipient.id } },
        recipient: createTestRecipient({
            bic: billingRecipient.bic,
        }),
        toPay: String(sum),
    })

    return {
        billingReceipt,
        bankAccount,
        acquiringIntegrationContext,
        billingIntegrationContext,
        billingProperty,
        billingAccount,
        billingRecipient,
    }
}

function generateQrCodeObj (extraAttrs = {}) {
    const bic = createValidRuRoutingNumber()
    let periodM = String(faker.datatype.number({ min: 1, max: 12 }))
    if (periodM.length === 1) {
        periodM = `0${periodM}`
    }
    const periodY = faker.datatype.number({ min: 2024, max: 2099 })

    return {
        PersonalAcc: createValidRuNumber(bic),
        PayeeINN: createValidRuTin10(),
        PayerAddress: faker.address.streetAddress(true),
        Sum: faker.random.numeric(6),
        LastName: faker.random.alpha(10),
        PaymPeriod: `${periodM}.${periodY}`,
        BIC: bic,
        PersAcc: faker.random.numeric(20),
        ...extraAttrs,
    }
}

describe('ValidateQRCodeService', () => {
    let adminClient, supportClient, userClient, staffClient, serviceClient, anonymous, organization
    let qrCodeObj, qrCodeString
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        userClient = await makeClientWithResidentUser()
        anonymous = await makeClient()
        staffClient = await makeClientWithStaffUser()
        serviceClient = await makeClientWithServiceUser()

        const [testOrganization] = await createTestOrganization(adminClient)
        const [testProperty] = await createTestProperty(adminClient, testOrganization)
        const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, testOrganization, {}, { status: CONTEXT_FINISHED_STATUS })
        qrCodeObj = generateQrCodeObj({
            PayeeINN: testOrganization.tin,
            PayerAddress: `${testProperty.address}, кв. 1`,
        })
        const recipient = createTestRecipient({
            name: testOrganization.name,
            tin: qrCodeObj.BIC,
            bankAccount: qrCodeObj.PersonalAcc,
        })
        await addAcquiringIntegrationAndContext(adminClient, testOrganization, {}, {
            status: CONTEXT_FINISHED_STATUS,
            recipient,
        })
        organization = testOrganization

        const [property] = await createTestProperty(adminClient, testOrganization)
        const [billingProperty] = await createTestBillingProperty(adminClient, billingIntegrationContext, { address: property.address })
        await createTestBillingAccount(adminClient, billingIntegrationContext, billingProperty, { number: qrCodeObj.PersAcc })

        qrCodeString = stringifyQrCode(qrCodeObj)
    })

    test('should parse fields correctly', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)
        const [periodM, periodY] = qrCodeObj.PaymPeriod.split('.')

        await createBillingReceiptAndAllDependencies(adminClient, organization, property, qrCodeObj, `${periodY}-${periodM}-01`, qrCodeObj.Sum, '0.5', '1')

        const [{ qrCodeFields }] = await validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString })

        expect(qrCodeFields.PersonalAcc).toBe(qrCodeObj.PersonalAcc)
        expect(qrCodeFields.PayeeINN).toBe(qrCodeObj.PayeeINN)
        expect(qrCodeFields.PayerAddress).toBe(qrCodeObj.PayerAddress)
        expect(qrCodeFields.Sum).toBe(qrCodeObj.Sum)
        expect(qrCodeFields.lastName).toBe(qrCodeObj.lastName)
        expect(qrCodeFields.PaymPeriod).toBe(qrCodeObj.PaymPeriod)
    })

    test('should parse fields case-insensitively', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)
        const bic = createValidRuRoutingNumber()
        let periodM = String(faker.datatype.number({ min: 1, max: 12 }))
        if (periodM.length === 1) {
            periodM = `0${periodM}`
        }
        const periodY = faker.datatype.number({ min: 2024, max: 2099 })
        const sum = faker.random.numeric(6)
        const qrCodeObj = {
            PersonalAcc: createValidRuNumber(bic),
            PayeeINN: organization.tin,
            PayerAddress: `${property.address}, кв. 1`,
            Sum: sum,
            Lastname: faker.random.alpha(10),
            PaymPeriod: `${periodM}.${periodY}`,
            BIC: bic,
            PersAcc: faker.random.numeric(20),
        }
        const qrCodeObjWithWrongCase = {
            personalAcc: qrCodeObj.PersonalAcc,
            PayeeInn: qrCodeObj.PayeeINN,
            payeraddress: qrCodeObj.PayerAddress,
            sUM: qrCodeObj.Sum,
            LastnamE: qrCodeObj.Lastname,
            paymPeriod: qrCodeObj.PaymPeriod,
            BIC: qrCodeObj.BIC,
            PersAcc: qrCodeObj.PersAcc,
        }

        await createBillingReceiptAndAllDependencies(adminClient, organization, property, qrCodeObj, `${periodY}-${periodM}-01`, sum, '0.5', '1')

        const qrCodeString = stringifyQrCode(qrCodeObjWithWrongCase)
        const [{ amount }] = await validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString })

        // NOTE(YEgorLu): amount in qrcode exists without "." between parts ("1000.11" -> "100011"), so let's add it
        expect(amount).toBe(Big(qrCodeObj.Sum).div(100).toFixed(8))
    })

    describe('Field validations', () => {
        const cases = [
            'BIC',
            'Sum',
            'PersAcc',
            'PayeeINN',
            'PersonalAcc',
        ]

        test.each(cases)('should throw if QR code doesn\'t have "%s"', async (field) => {
            const qrCode = stringifyQrCode(omit(qrCodeObj, field))
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: `Provided QR code doesn't have required fields: ${field}`,
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'BAD_USER_INPUT',
                        type: 'WRONG_FORMAT',
                        message: `Provided QR code doesn't have required fields: ${field}`,
                    },
                }])
            })
        })
    })

    test('should throw an error if QR code is wrong', async () => {
        const qrCode = 'ST0012|field1=Hello|Field2=world'
        await catchErrorFrom(async () => {
            await validateQRCodeByTestClient(adminClient, { qrCode })
        }, ({ errors }) => {
            expect(errors).toMatchObject([{
                message: 'Invalid QR code',
                path: ['result'],
                extensions: {
                    mutation: 'validateQRCode',
                    code: 'BAD_USER_INPUT',
                    type: 'WRONG_FORMAT',
                    message: 'Invalid QR code',
                },
            }])
        })
    })

    // NOTE (YEgorLu): recipient in context is not used, only validation for some reason. Maybe remove this test later
    test.skip('should throw an error if no recipient in acquiring context', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, o10n)
        const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, o10n, {}, { status: CONTEXT_FINISHED_STATUS })
        await addAcquiringIntegrationAndContext(adminClient, o10n, {}, { status: CONTEXT_FINISHED_STATUS })
        const qrCodeObj = generateQrCodeObj({
            PayeeINN: o10n.tin,
            PayerAddress: `${property.address}, кв. 1`,
        })
        const [billingProperty] = await createTestBillingProperty(adminClient, billingIntegrationContext, { address: property.address })
        await createTestBillingAccount(adminClient, billingIntegrationContext, billingProperty, { number: qrCodeObj.PersAcc })

        const qrCodeString = stringifyQrCode(qrCodeObj)
        await expectToThrowGQLError(
            async () => validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString }),
            {
                mutation: 'validateQRCode',
                code: 'BAD_USER_INPUT',
                type: 'WRONG_FORMAT',
                message: 'Provided bank account is not in the system',
            },
            'result',
        )
    })

    describe('Validate organization', () => {
        test('should throw if no billing account exists', async () => {
            const qrCode = stringifyQrCode({ ...qrCodeObj, PayeeINN: '000000000' })
            await expectToThrowGQLError(
                async () => {
                    await validateQRCodeByTestClient(adminClient, { qrCode })
                },
                {
                    mutation: 'validateQRCode',
                    code: 'INTERNAL_ERROR',
                    type: 'NOT_FOUND',
                    message: 'No billing account was found',
                },
                'result',
            )
        })

        test('should throw if 2+ billing accounts exists', async () => {
            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [anotherProperty] = await createTestProperty(adminClient, anotherOrganization)
            const { billingIntegrationContext: billingIntegrationContext1 } = await addBillingIntegrationAndContext(adminClient, anotherOrganization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, anotherOrganization, {}, { status: CONTEXT_FINISHED_STATUS })
            const [billingProperty1] = await createTestBillingProperty(adminClient, billingIntegrationContext1, { address: anotherProperty.address })
            await createTestBillingAccount(adminClient, billingIntegrationContext1, billingProperty1, { number: qrCodeObj.PersAcc })

            const [anotherOrganization2] = await createTestOrganization(adminClient, { tin: anotherOrganization.tin })
            const [anotherProperty2] = await createTestProperty(adminClient, anotherOrganization2, { address: anotherProperty.address })
            const { billingIntegrationContext: billingIntegrationContext2 } = await addBillingIntegrationAndContext(adminClient, anotherOrganization2, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, anotherOrganization2, {}, { status: CONTEXT_FINISHED_STATUS })
            const [billingProperty2] = await createTestBillingProperty(adminClient, billingIntegrationContext2, { address: anotherProperty2.address })
            await createTestBillingAccount(adminClient, billingIntegrationContext2, billingProperty2, { number: qrCodeObj.PersAcc })

            const anotherQrCodeObj = generateQrCodeObj({
                PayeeINN: anotherOrganization.tin,
                PayerAddress: `${anotherProperty.address}, кв. 1`,
                PersAcc: qrCodeObj.PersAcc,
            })
            await expectToThrowGQLError(
                async () => {
                    await validateQRCodeByTestClient(adminClient, { qrCode: stringifyQrCode(anotherQrCodeObj) })
                },
                {
                    mutation: 'validateQRCode',
                    code: 'INTERNAL_ERROR',
                    type: 'WRONG_VALUE',
                    message: 'More than one billing accounts were found',
                },
                'result',
            )
        })

        test('should throw if no AcquiringIntegrationContext in status finished was found', async () => {
            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [anotherProperty] = await createTestProperty(adminClient, anotherOrganization)
            const { billingIntegrationContext } = await addBillingIntegrationAndContext(adminClient, anotherOrganization, {}, { status: CONTEXT_FINISHED_STATUS })

            const anotherQrCodeObj = generateQrCodeObj({
                PayeeINN: anotherOrganization.tin,
                PayerAddress: `${anotherProperty.address}, кв. 1`,
            })

            const [billingProperty] = await createTestBillingProperty(adminClient, billingIntegrationContext, { address: anotherProperty.address })
            await createTestBillingAccount(adminClient, billingIntegrationContext, billingProperty, { number: anotherQrCodeObj.PersAcc })

            await expectToThrowGQLError(
                async () => {
                    await validateQRCodeByTestClient(adminClient, { qrCode: stringifyQrCode(anotherQrCodeObj) })
                },
                {
                    mutation: 'validateQRCode',
                    code: 'INTERNAL_ERROR',
                    type: 'NOT_FOUND',
                    message: 'Organization with provided TIN does not have an active acquiring integration',
                },
                'result',
            )
        })
    })

    describe('The error on requests limit reached', () => {

        test('should be thrown for anonymous ', async () => {
            const ipLike = Array(4).fill(null).map(() => faker.random.numeric(3)).join('.')
            const anonymousClient = await makeClient()
            anonymousClient.setHeaders({ 'x-forwarded-for': ipLike })

            for await (const i of Array.from(Array(MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW + 1).keys())) {
                if (i === MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW) {
                    await expectToThrowGQLError(
                        async () => await validateQRCodeByTestClient(anonymousClient, { qrCode: qrCodeString }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'TOO_MANY_REQUESTS',
                            message: 'You have to wait {secondsRemaining} seconds to be able to send request again',
                        },
                        'result',
                    )
                } else {
                    await validateQRCodeByTestClient(anonymousClient, { qrCode: qrCodeString })
                }
            }
        })

        test('shouldn\'t be throw for registered user', async () => {
            const ipLike = Array(4).fill(null).map(() => faker.random.numeric(3)).join('.')
            const userClient = await makeClientWithResidentUser()
            userClient.setHeaders({ 'x-forwarded-for': ipLike })

            for (let i = 0; i < MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW + 1; i++) {
                await validateQRCodeByTestClient(userClient, { qrCode: qrCodeString })
            }
        })
    })

    test('resident: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const [organization] = await createTestOrganization(adminClient, { tin: qrCodeObj.PayeeINN })
        const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [{ qrCodeFields }] = await validateQRCodeByTestClient(userClient, { qrCode: qrCodeString })
        await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })

        expect(qrCodeFields.PersonalAcc).toBe(qrCodeObj.PersonalAcc)
        expect(qrCodeFields.PayeeINN).toBe(qrCodeObj.PayeeINN)
        expect(qrCodeFields.PayerAddress).toBe(qrCodeObj.PayerAddress)
        expect(qrCodeFields.Sum).toBe(qrCodeObj.Sum)
        expect(qrCodeFields.lastName).toBe(qrCodeObj.lastName)
        expect(qrCodeFields.PaymPeriod).toBe(qrCodeObj.PaymPeriod)
    })

    test('anonymous: can execute', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)

        const qr = generateQrCodeObj({
            ...qrCodeObj,
            PayeeINN: organization.tin,
            PayerAddress: `${property.address}, кв 1`,
        })

        const [periodM, periodY] = qr.PaymPeriod.split('.')

        await createBillingReceiptAndAllDependencies(adminClient, organization, property, qr, `${periodY}-${periodM}-01`, qr.Sum, '0.5', '1')

        const qrStr = stringifyQrCode(qr)
        const [result] = await validateQRCodeByTestClient(anonymous, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('support: can execute', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)

        const qr = generateQrCodeObj({
            ...qrCodeObj,
            PayeeINN: organization.tin,
            PayerAddress: `${property.address}, кв 1`,
        })

        const [periodM, periodY] = qr.PaymPeriod.split('.')

        await createBillingReceiptAndAllDependencies(adminClient, organization, property, qr, `${periodY}-${periodM}-01`, qr.Sum, '0.5', '1')

        const qrStr = stringifyQrCode(qr)
        const [result] = await validateQRCodeByTestClient(supportClient, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('staff: can execute', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)

        const qr = generateQrCodeObj({
            ...qrCodeObj,
            PayeeINN: organization.tin,
            PayerAddress: `${property.address}, кв 1`,
        })

        const [periodM, periodY] = qr.PaymPeriod.split('.')

        await createBillingReceiptAndAllDependencies(adminClient, organization, property, qr, `${periodY}-${periodM}-01`, qr.Sum, '0.5', '1')

        const qrStr = stringifyQrCode(qr)
        const [result] = await validateQRCodeByTestClient(staffClient, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('service: can\'t execute', async () => {
        await expectToThrowAccessDeniedErrorToResult(async () => {
            await validateQRCodeByTestClient(serviceClient, { qrCode: qrCodeString })
        })
    })

    describe('Periods comparison logic', () => {
        test('scanned receipt period equals the last billing receipt in out database', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const PaymPeriod = '05.2024' // for QR code
            const period = '2024-05-01' // for receipt
            const sum = 1000
            const qrObj = {
                ...qrCodeObj,
                PayeeINN: o10n.tin,
                PayerAddress: `${property.address}, кв 1`,
                PaymPeriod,
                Sum: String(sum * 100),
                PersAcc: faker.random.numeric(20),
            }

            // create the receipt
            const {
                billingIntegrationContext,
                acquiringIntegrationContext,
                billingProperty,
                billingAccount,
                billingRecipient,
            } = await createBillingReceiptAndAllDependencies(adminClient, o10n, property, qrObj, period, sum, '0.5', '1')

            const [billingReceiptLast] = await createTestBillingReceipt(adminClient, billingIntegrationContext, billingProperty, billingAccount, {
                period: '2024-06-01',
                receiver: { connect: { id: billingRecipient.id } },
                recipient: createTestRecipient({
                    bic: billingRecipient.bic,
                }),
                toPay: '2000',
            })

            const qrObjLast = { ...qrObj, PaymPeriod: '06.2024', sum: '200000' }
            const qrStr = stringifyQrCode(qrObjLast)

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObjLast,
                lastReceiptData: {
                    id: billingReceiptLast.id,
                    period: '2024-06-01',
                    toPay: '2000.00000000',
                    createdAt: billingReceiptLast.createdAt,
                    category: {
                        id: billingReceiptLast.category.id,
                        name: billingReceiptLast.category.name,
                    },
                },
                explicitFees: {
                    explicitServiceCharge: '30',
                    explicitFee: '0',
                },
                amount: '2000.00000000',
                acquiringIntegrationHostUrl: acquiringIntegrationContext.integration.hostUrl,
                currencyCode: billingIntegrationContext.integration.currencyCode,
            })
        })

        test('scanned receipt period less the last billing receipt in out database', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const PaymPeriod = '04.2024' // for QR code
            const period = '2024-05-01' // for receipt
            const sum = 1000
            const qrObj = {
                ...qrCodeObj,
                PayeeINN: o10n.tin,
                PayerAddress: `${property.address}, кв 1`,
                PaymPeriod,
                Sum: String(sum * 100),
                PersAcc: faker.random.numeric(20),
            }
            const qrStr = stringifyQrCode(qrObj)

            // create the receipt
            const {
                billingIntegrationContext,
                billingReceipt,
                acquiringIntegrationContext,
            } = await createBillingReceiptAndAllDependencies(adminClient, o10n, property, qrObj, period, sum, '1', '1.5')

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: {
                    id: billingReceipt.id,
                    period,
                    toPay: `${sum}.00000000`,
                    createdAt: billingReceipt.createdAt,
                    category: {
                        id: billingReceipt.category.id,
                        name: billingReceipt.category.name,
                    },
                },
                explicitFees: {
                    explicitServiceCharge: '25',
                    explicitFee: '0',
                },
                amount: '1000.00000000',
                acquiringIntegrationHostUrl: acquiringIntegrationContext.integration.hostUrl,
                currencyCode: billingIntegrationContext.integration.currencyCode,
            })
        })

        test('scanned receipt period greater than the last billing receipt in out database', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const PaymPeriod = '05.2024' // for QR code
            const period = '2024-04-01' // for receipt
            const sum = 1000
            const olderReceiptSum = 2000
            const qrObj = {
                ...qrCodeObj,
                PayeeINN: o10n.tin,
                PayerAddress: `${property.address}, кв 1`,
                PaymPeriod,
                Sum: String(sum * 100),
                PersAcc: faker.random.numeric(20),
            }
            const qrStr = stringifyQrCode(qrObj)

            // create the receipt
            const {
                billingIntegrationContext,
                billingReceipt,
                acquiringIntegrationContext,
            } = await createBillingReceiptAndAllDependencies(adminClient, o10n, property, qrObj, period, olderReceiptSum, '1.5', '1')

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: {
                    id: billingReceipt.id,
                    period,
                    toPay: `${olderReceiptSum}.00000000`,
                    createdAt: billingReceipt.createdAt,
                    category: {
                        id: billingReceipt.category.id,
                        name: billingReceipt.category.name,
                    },
                },
                explicitFees: {
                    explicitServiceCharge: '25',
                    explicitFee: '0',
                },
                amount: '1000.00000000',
                acquiringIntegrationHostUrl: acquiringIntegrationContext.integration.hostUrl,
                currencyCode: billingIntegrationContext.integration.currencyCode,
            })
        })

        test('scanned receipt not in out database', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)

            const PaymPeriod = '05.2024' // for QR code
            const sum = 2000
            const qrObj = {
                ...qrCodeObj,
                PayeeINN: o10n.tin,
                PayerAddress: `${property.address}, кв 1`,
                PaymPeriod,
                Sum: String(sum * 100),
                PersAcc: faker.random.numeric(20),
            }
            const qrStr = stringifyQrCode(qrObj)

            const [periodM, periodY] = qrObj.PaymPeriod.split('.')

            const { billingReceipt } = await createBillingReceiptAndAllDependencies(adminClient, o10n, property, qrObj, `${periodY}-${periodM}-01`, qrObj.Sum, '1', '2')

            await updateTestBillingReceipt(adminClient, billingReceipt.id, { deletedAt: faker.date.past() })

            await expectToThrowGQLErrorToResult(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })
            }, {
                mutation: 'validateQRCode',
                code: 'BAD_USER_INPUT',
                type: 'NOT_FOUND',
                message: 'No previous receipt was found',
            })
        })
    })

    test('no error if scan qr-code of paid receipt', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, organization)

        const PaymPeriod = '04.2024' // for QR code
        const period = '2024-04-01' // for receipt
        const sum = 1000
        const qrObj = generateQrCodeObj({
            PayeeINN: organization.tin,
            PayerAddress: `${property.address}, кв 1`,
            PaymPeriod,
            Sum: String(sum * 100),
        })
        const qrStr = stringifyQrCode(qrObj)

        // create the receipt
        const {
            bankAccount,
            acquiringIntegrationContext,
            billingReceipt,
            billingIntegrationContext,
        } = await createBillingReceiptAndAllDependencies(adminClient, organization, property, qrObj, period, sum, '1.5', '1')

        // register multi payment
        const receipt = generateVirtualReceipt({
            period,
            bankAccount,
            accountNumber: qrObj.PersAcc,
        })
        const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(adminClient, receipt, {
            id: acquiringIntegrationContext.id,
        })

        // get payments
        const payments = await Payment.getAll(adminClient, {
            multiPayment: {
                id: result.multiPaymentId,
            },
        })

        // mark payment as paid
        await updateTestPayment(adminClient, payments[0].id, {
            status: PAYMENT_DONE_STATUS,
            advancedAt: dayjs().toISOString(),
        })

        const [validationResult] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })
        expect(validationResult).toEqual({
            qrCodeFields: qrObj,
            lastReceiptData: {
                id: billingReceipt.id,
                period: billingReceipt.period,
                toPay: billingReceipt.toPay,
                createdAt: billingReceipt.createdAt,
                category: {
                    id: billingReceipt.category.id,
                    name: billingReceipt.category.name,
                },
            },
            explicitFees: {
                explicitServiceCharge: '25',
                explicitFee: '0',
            },
            amount: Big(sum).toFixed(8),
            acquiringIntegrationHostUrl: acquiringIntegrationContext.integration.hostUrl,
            currencyCode: billingIntegrationContext.integration.currencyCode,
        })
    })
})
