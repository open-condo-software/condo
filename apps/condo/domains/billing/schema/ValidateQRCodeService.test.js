/**
 * Generated by `createservice billing.ValidateQRCodeService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { omit } = require('lodash')

const {
    makeLoggedInAdminClient,
    makeClient,
    catchErrorFrom,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const { PAYMENT_DONE_STATUS } = require('@condo/domains/acquiring/constants/payment')
const {
    createTestAcquiringIntegrationContext,
    createTestAcquiringIntegration,
    generateVirtualReceipt,
    registerMultiPaymentForVirtualReceiptByTestClient,
    updateTestPayment,
} = require('@condo/domains/acquiring/utils/testSchema')
const { updateTestAcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/testSchema')
const {
    addAcquiringIntegrationAndContext,
} = require('@condo/domains/acquiring/utils/testSchema')
const { Payment } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBankAccount } = require('@condo/domains/banking/utils/testSchema')
const {
    createValidRuRoutingNumber,
    createValidRuNumber,
    createValidRuTin10,
} = require('@condo/domains/banking/utils/testSchema/bankAccount')
const { MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW } = require('@condo/domains/billing/constants')
const {
    validateQRCodeByTestClient,
    addBillingIntegrationAndContext,
    createTestBillingProperty,
    createTestBillingAccount,
    createTestBillingRecipient,
    createTestBillingReceipt,
    createTestRecipient,
} = require('@condo/domains/billing/utils/testSchema')
const { ALREADY_EXISTS_ERROR } = require('@condo/domains/common/constants/errors')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithStaffUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

function stringifyQrCode (qrCodeObj) {
    return 'ST00012|'.concat(
        JSON.stringify(qrCodeObj).replace(/["{}]+/g, '')
            .replace(/:+/g, '=')
            .replace(/,+/g, '|'),
    )
}

async function createBillingReceiptAndAllDependencies (admin, organization, qrCodeAttrs, period, sum, acquiringIntegrationFeePercent, serviceFeePercent) {
    const { billingIntegrationContext } = await addBillingIntegrationAndContext(admin, organization, {}, { status: CONTEXT_FINISHED_STATUS })
    const { acquiringIntegrationContext } = await addAcquiringIntegrationAndContext(admin, organization, {
        explicitFeeDistributionSchema: [{
            recipient: 'acquiring',
            percent: acquiringIntegrationFeePercent,
        }, {
            recipient: 'service',
            percent: serviceFeePercent,
        }],
    }, { status: CONTEXT_FINISHED_STATUS })

    const [bankAccount] = await createTestBankAccount(admin, organization, {
        number: qrCodeAttrs.PersonalAcc,
        routingNumber: qrCodeAttrs.BIC,
    })
    const [billingProperty] = await createTestBillingProperty(admin, billingIntegrationContext, { address: qrCodeAttrs.PayerAddress })
    const [billingAccount] = await createTestBillingAccount(admin, billingIntegrationContext, billingProperty, { number: qrCodeAttrs.PersAcc })
    const [billingRecipient] = await createTestBillingRecipient(admin, billingIntegrationContext, {
        bankAccount: qrCodeAttrs.PersonalAcc,
        bic: qrCodeAttrs.BIC,
    })
    const [billingReceipt] = await createTestBillingReceipt(admin, billingIntegrationContext, billingProperty, billingAccount, {
        period,
        receiver: { connect: { id: billingRecipient.id } },
        recipient: createTestRecipient({
            bic: billingRecipient.bic,
        }),
        toPay: String(sum),
    })

    return { billingReceipt, bankAccount, acquiringIntegrationContext }
}

function generateQrCodeObj (extraAttrs = {}) {
    const bic = createValidRuRoutingNumber()

    return {
        PersonalAcc: createValidRuNumber(bic),
        PayeeINN: createValidRuTin10(),
        PayerAddress: faker.address.streetAddress(true),
        Sum: faker.random.numeric(6),
        LastName: faker.random.alpha(10),
        PaymPeriod: `${faker.datatype.number({ min: 1, max: 12 })}.${faker.datatype.number({
            min: 2024,
            max: 2099,
        })}`,
        BIC: bic,
        PersAcc: faker.random.numeric(20),
        ...extraAttrs,
    }
}

describe('ValidateQRCodeService', () => {
    let adminClient, supportClient, userClient, staffClient, serviceClient, anonymous, organization
    let qrCodeObj, qrCodeString
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        userClient = await makeClientWithResidentUser()
        anonymous = await makeClient()
        staffClient = await makeClientWithStaffUser()
        serviceClient = await makeClientWithServiceUser()

        qrCodeObj = generateQrCodeObj()
        const [testOrganization] = await createTestOrganization(adminClient, { tin: qrCodeObj.PayeeINN })
        organization = testOrganization

        qrCodeString = stringifyQrCode(qrCodeObj)
    })

    test('should parse fields correctly', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [{ qrCodeFields }] = await validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString })
        await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })

        expect(qrCodeFields.PersonalAcc).toBe(qrCodeObj.PersonalAcc)
        expect(qrCodeFields.PayeeINN).toBe(qrCodeObj.PayeeINN)
        expect(qrCodeFields.payerAddress).toBe(qrCodeObj.payerAddress)
        expect(qrCodeFields.Sum).toBe(qrCodeObj.Sum)
        expect(qrCodeFields.lastName).toBe(qrCodeObj.lastName)
        expect(qrCodeFields.paymPeriod).toBe(qrCodeObj.paymPeriod)
    })

    describe('Field validations', () => {
        const cases = [
            'BIC',
            'PayerAddress',
            'Sum',
            'PaymPeriod',
            'PersAcc',
            'PayeeINN',
            'PersonalAcc',
        ]

        test.each(cases)('should throw if QR code doesn\'t have "%s"', async (field) => {
            const qrCode = stringifyQrCode(omit(qrCodeObj, field))
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: `Provided QR code doesn't have required fields: ${field}`,
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'BAD_USER_INPUT',
                        type: 'WRONG_FORMAT',
                        message: `Provided QR code doesn't have required fields: ${field}`,
                    },
                }])
            })
        })

        test('should throw an error if QR code is wrong', async () => {
            const qrCode = 'ST0012|field1=Hello|Field2=world'
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode })
            }, ({ errors }) => {
                expect(errors).toMatchObject([{
                    message: 'Invalid QR code',
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'BAD_USER_INPUT',
                        type: 'WRONG_FORMAT',
                        message: 'Invalid QR code',
                    },
                }])
            })
        })
    })

    describe('Validate organization', () => {
        test('should throw if no organization with provided TIN exists', async () => {
            const qrCode = qrCodeString.replace(qrCodeObj.PayeeINN, '000000000')
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: 'Organization with provided TIN is not registered with Doma.ai',
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'INTERNAL_ERROR',
                        type: 'NOT_FOUND',
                        message: 'Organization with provided TIN is not registered with Doma.ai',
                    },
                }])
            })
        })

        test('should throw if no AcquiringIntegrationContext was found', async () => {
            const [integration] = await createTestAcquiringIntegration(adminClient)
            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, anotherOrganization, integration)
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'INTERNAL_ERROR',
                        type: 'NOT_FOUND',
                        message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
                    },
                }])
            })
            await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })
        })

        test('should throw if found AcquiringIntegrationContext is not active (status !== Finished)', async () => {
            const [integration] = await createTestAcquiringIntegration(adminClient)
            const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: 'InProgress' })
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'INTERNAL_ERROR',
                        type: 'NOT_FOUND',
                        message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
                    },
                }])
            })
            await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })
        })
    })

    describe('The error on requests limit reached', () => {
        let integration, acquiringContext

        beforeAll(async () => {
            [integration] = await createTestAcquiringIntegration(adminClient)
            ;[acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        })

        afterAll(async () => {
            await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })
        })

        test('should be thrown for anonymous ', async () => {
            const ipLike = Array(4).fill(null).map(() => faker.random.numeric(3)).join('.')
            const anonymousClient = await makeClient()
            anonymousClient.setHeaders({ 'x-forwarded-for': ipLike })

            for await (const i of Array.from(Array(MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW + 1).keys())) {
                if (i === MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW) {
                    await catchErrorFrom(async () => {
                        await validateQRCodeByTestClient(anonymousClient, { qrCode: qrCodeString })
                    }, ({ errors }) => {
                        expect(errors).toMatchObject([{
                            path: ['result'],
                            extensions: {
                                code: 'BAD_USER_INPUT',
                                type: 'TOO_MANY_REQUESTS',
                                message: 'You have to wait {secondsRemaining} seconds to be able to send request again',
                            },
                        }])
                    })
                } else {
                    await validateQRCodeByTestClient(anonymousClient, { qrCode: qrCodeString })
                }
            }
        })

        test('shouldn\'t be throw for registered user', async () => {
            const ipLike = Array(4).fill(null).map(() => faker.random.numeric(3)).join('.')
            const userClient = await makeClientWithResidentUser()
            userClient.setHeaders({ 'x-forwarded-for': ipLike })

            for (let i = 0; i < MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW + 1; i++) {
                await validateQRCodeByTestClient(userClient, { qrCode: qrCodeString })
            }
        })
    })

    test('resident: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const [organization] = await createTestOrganization(adminClient, { tin: qrCodeObj.PayeeINN })
        const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [{ qrCodeFields }] = await validateQRCodeByTestClient(userClient, { qrCode: qrCodeString })
        await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })

        expect(qrCodeFields.PersonalAcc).toBe(qrCodeObj.PersonalAcc)
        expect(qrCodeFields.PayeeINN).toBe(qrCodeObj.PayeeINN)
        expect(qrCodeFields.payerAddress).toBe(qrCodeObj.payerAddress)
        expect(qrCodeFields.Sum).toBe(qrCodeObj.Sum)
        expect(qrCodeFields.lastName).toBe(qrCodeObj.lastName)
        expect(qrCodeFields.paymPeriod).toBe(qrCodeObj.paymPeriod)
    })

    test('anonymous: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const qr = { ...qrCodeObj, PayeeINN: faker.random.numeric(8) }
        const qrStr = stringifyQrCode(qr)
        const [organization] = await createTestOrganization(adminClient, { tin: qr.PayeeINN })
        await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [result] = await validateQRCodeByTestClient(anonymous, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('support: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const qr = { ...qrCodeObj, PayeeINN: faker.random.numeric(8) }
        const qrStr = stringifyQrCode(qr)
        const [organization] = await createTestOrganization(adminClient, { tin: qr.PayeeINN })
        await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [result] = await validateQRCodeByTestClient(supportClient, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('staff: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const qr = { ...qrCodeObj, PayeeINN: faker.random.numeric(8) }
        const qrStr = stringifyQrCode(qr)
        const [organization] = await createTestOrganization(adminClient, { tin: qr.PayeeINN })
        await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [result] = await validateQRCodeByTestClient(staffClient, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('service: can\'t execute', async () => {
        await expectToThrowAccessDeniedErrorToResult(async () => {
            await validateQRCodeByTestClient(serviceClient, { qrCode: qrCodeString })
        })
    })

    describe('Periods comparison logic', () => {
        test('scanned receipt period equals the last billing receipt in out database', async () => {
            const fakeTin = faker.random.numeric(8)
            const PaymPeriod = '05.2024' // for QR code
            const period = '2024-05-01' // for receipt
            const sum = 1000
            const qrObj = generateQrCodeObj({ PayeeINN: fakeTin, PaymPeriod, Sum: String(sum * 100) })
            const [organization] = await createTestOrganization(adminClient, { tin: qrObj.PayeeINN })
            await createTestProperty(adminClient, organization, { address: qrObj.PayerAddress })
            const qrStr = stringifyQrCode(qrObj)

            // create the receipt
            const { billingReceipt } = await createBillingReceiptAndAllDependencies(adminClient, organization, qrObj, period, sum, '0.5', '1')

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: {
                    id: billingReceipt.id,
                    period,
                    toPay: `${sum}.00000000`,
                },
                explicitFees: {
                    explicitServiceCharge: '15',
                    explicitFee: '0',
                },
                amount: '1000.00000000',
            })
        })

        test('scanned receipt period less the last billing receipt in out database', async () => {
            const fakeTin = faker.random.numeric(8)
            const PaymPeriod = '04.2024' // for QR code
            const period = '2024-05-01' // for receipt
            const sum = 1000
            const qrObj = generateQrCodeObj({ PayeeINN: fakeTin, PaymPeriod, Sum: String(sum * 100) })
            const [organization] = await createTestOrganization(adminClient, { tin: qrObj.PayeeINN })
            await createTestProperty(adminClient, organization, { address: qrObj.PayerAddress })
            const qrStr = stringifyQrCode(qrObj)

            // create the receipt
            const { billingReceipt } = await createBillingReceiptAndAllDependencies(adminClient, organization, qrObj, period, sum, '1', '1.5')

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: {
                    id: billingReceipt.id,
                    period,
                    toPay: `${sum}.00000000`,
                },
                explicitFees: {
                    explicitServiceCharge: '25',
                    explicitFee: '0',
                },
                amount: '1000.00000000',
            })
        })

        test('scanned receipt period greater than the last billing receipt in out database', async () => {
            const fakeTin = faker.random.numeric(8)
            const PaymPeriod = '05.2024' // for QR code
            const period = '2024-04-01' // for receipt
            const sum = 1000
            const olderReceiptSum = 2000
            const qrObj = generateQrCodeObj({ PayeeINN: fakeTin, PaymPeriod, Sum: String(sum * 100) })
            const [organization] = await createTestOrganization(adminClient, { tin: qrObj.PayeeINN })
            await createTestProperty(adminClient, organization, { address: qrObj.PayerAddress })
            const qrStr = stringifyQrCode(qrObj)

            // create the receipt
            const { billingReceipt } = await createBillingReceiptAndAllDependencies(adminClient, organization, qrObj, period, olderReceiptSum, '1.5', '1')

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: {
                    id: billingReceipt.id,
                    period,
                    toPay: `${olderReceiptSum}.00000000`,
                },
                explicitFees: {
                    explicitServiceCharge: '25',
                    explicitFee: '0',
                },
                amount: '1000',
            })
        })

        test('scanned receipt not in out database', async () => {
            const fakeTin = faker.random.numeric(8)
            const PaymPeriod = '05.2024' // for QR code
            const sum = 2000
            const qrObj = generateQrCodeObj({ PayeeINN: fakeTin, PaymPeriod, Sum: String(sum * 100) })
            const [organization] = await createTestOrganization(adminClient, { tin: qrObj.PayeeINN })
            await createTestProperty(adminClient, organization, { address: qrObj.PayerAddress })
            const qrStr = stringifyQrCode(qrObj)

            await addBillingIntegrationAndContext(adminClient, organization, {}, { status: CONTEXT_FINISHED_STATUS })
            await addAcquiringIntegrationAndContext(adminClient, organization, {
                explicitFeeDistributionSchema: [{
                    recipient: 'acquiring',
                    percent: '1',
                }, {
                    recipient: 'service',
                    percent: '2',
                }],
            }, { status: CONTEXT_FINISHED_STATUS })

            const [result] = await validateQRCodeByTestClient(adminClient, { qrCode: qrStr })

            expect(result).toEqual({
                qrCodeFields: qrObj,
                lastReceiptData: null,
                explicitFees: {
                    explicitServiceCharge: '60',
                    explicitFee: '0',
                },
                amount: '2000',
            })
        })
    })

    test('error if scan qr-code of paid receipt', async () => {
        const fakeTin = faker.random.numeric(8)
        const PaymPeriod = '04.2024' // for QR code
        const period = '2024-04-01' // for receipt
        const sum = 1000
        const qrObj = generateQrCodeObj({ PayeeINN: fakeTin, PaymPeriod, Sum: String(sum * 100) })
        const [organization] = await createTestOrganization(adminClient, { tin: qrObj.PayeeINN })
        await createTestProperty(adminClient, organization, { address: qrObj.PayerAddress })
        const qrStr = stringifyQrCode(qrObj)

        // create the receipt
        const {
            bankAccount,
            acquiringIntegrationContext,
        } = await createBillingReceiptAndAllDependencies(adminClient, organization, qrObj, period, sum, '1.5', '1')

        // register multi payment
        const receipt = generateVirtualReceipt({
            period,
            bankAccount,
            accountNumber: qrObj.PersAcc,
        })
        const [result] = await registerMultiPaymentForVirtualReceiptByTestClient(adminClient, receipt, {
            id: acquiringIntegrationContext.id,
        })

        // get payments
        const payments = await Payment.getAll(adminClient, {
            multiPayment: {
                id: result.multiPaymentId,
            },
        })

        // mark payment as paid
        await updateTestPayment(adminClient, payments[0].id, {
            status: PAYMENT_DONE_STATUS,
            advancedAt: dayjs().toISOString(),
        })

        await expectToThrowGQLError(
            async () => await validateQRCodeByTestClient(adminClient, { qrCode: qrStr }),
            {
                code: 'BAD_USER_INPUT',
                type: ALREADY_EXISTS_ERROR,
                message: 'Provided receipt already paid',
                mutation: 'validateQRCode',
            },
            'result'
        )
    })
})
