/**
 * Generated by `createservice billing.ValidateQRCodeService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const { omit } = require('lodash')

const {
    makeLoggedInAdminClient,
    makeClient,
    catchErrorFrom,
    expectToThrowAccessDeniedErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    createTestAcquiringIntegrationContext,
    createTestAcquiringIntegration,
} = require('@condo/domains/acquiring/utils/testSchema')
const { updateTestAcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/testSchema')
const { MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW } = require('@condo/domains/billing/constants')
const { validateQRCodeByTestClient } = require('@condo/domains/billing/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithStaffUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

function stringifyQrCode (qrCodeObj) {
    return 'ST00012|'.concat(
        JSON.stringify(qrCodeObj).replace(/["{}]+/g, '')
            .replace(/[:]+/g, '=')
            .replace(/[,]+/g, '|'),
    )
}

describe('ValidateQRCodeService', () => {
    let adminClient, supportClient, userClient, staffClient, serviceClient, anonymous, organization
    let qrCodeObj, qrCodeString
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        userClient = await makeClientWithResidentUser()
        anonymous = await makeClient()
        staffClient = await makeClientWithStaffUser()
        serviceClient = await makeClientWithServiceUser()
        qrCodeObj = {
            PersonalAcc: faker.random.numeric(20),
            PayeeINN: faker.random.numeric(8),
            PayerAddress: faker.address.streetAddress(true),
            Sum: faker.random.numeric(6),
            LastName: faker.random.alpha(10),
            PaymPeriod: faker.random.numeric(6),
            BIC: faker.random.numeric(8),
            PersAcc: faker.random.numeric(20),
        }
        const [testOrganization] = await createTestOrganization(adminClient, { tin: qrCodeObj.PayeeINN })
        organization = testOrganization

        qrCodeString = stringifyQrCode(qrCodeObj)
    })

    test('should parse fields correctly', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [{ qrCodeFields }] = await validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString })
        await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })

        expect(qrCodeFields.PersonalAcc).toBe(qrCodeObj.PersonalAcc)
        expect(qrCodeFields.PayeeINN).toBe(qrCodeObj.PayeeINN)
        expect(qrCodeFields.payerAddress).toBe(qrCodeObj.payerAddress)
        expect(qrCodeFields.Sum).toBe(qrCodeObj.Sum)
        expect(qrCodeFields.lastName).toBe(qrCodeObj.lastName)
        expect(qrCodeFields.paymPeriod).toBe(qrCodeObj.paymPeriod)
    })

    describe('Field validations', () => {
        const cases = [
            'BIC',
            'PayerAddress',
            'Sum',
            'PaymPeriod',
            'PersAcc',
            'PayeeINN',
            'PersonalAcc',
        ]

        test.each(cases)('should throw if QR code doesn\'t have "%s"', async (field) => {
            const qrCode = stringifyQrCode(omit(qrCodeObj, field))
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: `Provided QR code doesn't have required fields: ${field}`,
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'BAD_USER_INPUT',
                        type: 'WRONG_FORMAT',
                        message: `Provided QR code doesn't have required fields: ${field}`,
                    },
                }])
            })
        })
    })

    describe('Validate organization', () => {
        test('should throw if no organization with provided TIN exists', async () => {
            const qrCode = qrCodeString.replace(qrCodeObj.PayeeINN, '000000000')
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: 'Organization with provided TIN is not registered with Doma.ai',
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'INTERNAL_ERROR',
                        type: 'NOT_FOUND',
                        message: 'Organization with provided TIN is not registered with Doma.ai',
                    },
                }])
            })
        })

        test('should throw if no AcquiringIntegrationContext was found', async () => {
            const [integration] = await createTestAcquiringIntegration(adminClient)
            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, anotherOrganization, integration)
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'INTERNAL_ERROR',
                        type: 'NOT_FOUND',
                        message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
                    },
                }])
            })
            await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })
        })

        test('should throw if found AcquiringIntegrationContext is not active (status !== Finished)', async () => {
            const [integration] = await createTestAcquiringIntegration(adminClient)
            const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: 'InProgress' })
            await catchErrorFrom(async () => {
                await validateQRCodeByTestClient(adminClient, { qrCode: qrCodeString })
            }, ({ errors }) => {

                expect(errors).toMatchObject([{
                    message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
                    path: ['result'],
                    extensions: {
                        mutation: 'validateQRCode',
                        code: 'INTERNAL_ERROR',
                        type: 'NOT_FOUND',
                        message: 'Organization with provided TIN does not have an active AcquiringIntegrationContext',
                    },
                }])
            })
            await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })
        })
    })

    test('should throw limit exceeded error on too many calls', async () => {
        const ipLike = Array(4).fill(null).map(() => faker.random.numeric(3)).join('.')
        const userClient2 = await makeClientWithResidentUser()
        userClient2.setHeaders({ 'x-forwarded-for': ipLike })
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })

        for await (const i of Array.from(Array(MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW + 1).keys())) {
            if (i === MAX_CLIENT_VALIDATE_QR_CODE_BY_WINDOW) {
                await catchErrorFrom(async () => {
                    await validateQRCodeByTestClient(userClient2, { qrCode: qrCodeString })
                }, ({ errors }) => {
                    expect(errors).toMatchObject([{
                        path: ['result'],
                        extensions: {
                            code: 'BAD_USER_INPUT',
                            type: 'TOO_MANY_REQUESTS',
                            message: 'You have to wait {secondsRemaining} seconds to be able to send request again',
                        },
                    }])
                })
            } else {
                await validateQRCodeByTestClient(userClient2, { qrCode: qrCodeString })
            }
        }
        await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })
    })


    test('resident: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const [organization] = await createTestOrganization(adminClient, { tin: qrCodeObj.PayeeINN })
        const [acquiringContext] = await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [{ qrCodeFields }] = await validateQRCodeByTestClient(userClient, { qrCode: qrCodeString })
        await updateTestAcquiringIntegrationContext(adminClient, acquiringContext.id, { deletedAt: faker.date.past() })

        expect(qrCodeFields.PersonalAcc).toBe(qrCodeObj.PersonalAcc)
        expect(qrCodeFields.PayeeINN).toBe(qrCodeObj.PayeeINN)
        expect(qrCodeFields.payerAddress).toBe(qrCodeObj.payerAddress)
        expect(qrCodeFields.Sum).toBe(qrCodeObj.Sum)
        expect(qrCodeFields.lastName).toBe(qrCodeObj.lastName)
        expect(qrCodeFields.paymPeriod).toBe(qrCodeObj.paymPeriod)
    })

    test('anonymous: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const qr = { ...qrCodeObj, PayeeINN: faker.random.numeric(8) }
        const qrStr = stringifyQrCode(qr)
        const [organization] = await createTestOrganization(adminClient, { tin: qr.PayeeINN })
        await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [result] = await validateQRCodeByTestClient(anonymous, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('support: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const qr = { ...qrCodeObj, PayeeINN: faker.random.numeric(8) }
        const qrStr = stringifyQrCode(qr)
        const [organization] = await createTestOrganization(adminClient, { tin: qr.PayeeINN })
        await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [result] = await validateQRCodeByTestClient(supportClient, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('staff: can execute', async () => {
        const [integration] = await createTestAcquiringIntegration(adminClient)
        const qr = { ...qrCodeObj, PayeeINN: faker.random.numeric(8) }
        const qrStr = stringifyQrCode(qr)
        const [organization] = await createTestOrganization(adminClient, { tin: qr.PayeeINN })
        await createTestAcquiringIntegrationContext(adminClient, organization, integration, { status: CONTEXT_FINISHED_STATUS })
        const [result] = await validateQRCodeByTestClient(staffClient, { qrCode: qrStr })

        expect(result).toMatchObject({ qrCodeFields: expect.objectContaining({ PayeeINN: qr.PayeeINN }) })
    })

    test('service: can\'t execute', async () => {
        await expectToThrowAccessDeniedErrorToResult(async () => {
            await validateQRCodeByTestClient(serviceClient, { qrCode: qrCodeString })
        })
    })

})
