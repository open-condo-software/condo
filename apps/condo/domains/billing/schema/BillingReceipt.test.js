/**
 * Generated by `createschema billing.BillingReceipt 'context:Relationship:BillingIntegrationOrganizationContext:CASCADE; importId?:Text; property:Relationship:BillingProperty:CASCADE; account:Relationship:BillingAccount:CASCADE; period:CalendarDay; raw:Json; toPay:Text; services:Json; meta:Json'`
 */
const path = require('path')

const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const dayjs = require('dayjs')
const pick = require('lodash/pick')

const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAccessDeniedErrorToObjects,
    expectToThrowUniqueConstraintViolationError,
    expectToThrowValidationFailureError,
    expectToThrowGraphQLRequestError,
    catchErrorFrom, expectToThrowGQLError,
    makeClient,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/acquiring/constants/context')
const {
    createTestAcquiringIntegration,
    createTestAcquiringIntegrationContext,
    updateTestAcquiringIntegrationContext,
    createTestPaymentStatusChangeWebhookUrl,
    updateTestPaymentStatusChangeWebhookUrl,
} = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBankAccount } = require('@condo/domains/banking/utils/testSchema')
const { CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/billing/constants/constants')
const {
    makeServiceUserForIntegration,
    makeOrganizationIntegrationManager,
    makeContextWithOrganizationAndIntegrationAsAdmin,
    makeResidentClientWithOwnReceipt,
    createReceiptsReader,
    createTestRecipient,
    createTestBillingProperty,
    createTestBillingAccount,
    updateTestBillingAccount,
    createTestBillingRecipient,
    BillingReceipt,
    createTestBillingReceipt,
    createTestBillingReceipts,
    updateTestBillingReceipt,
    updateTestBillingReceipts,
    createTestBillingReceiptFile,
    PUBLIC_FILE,
    PRIVATE_FILE,
    generateServicesData,
    createTestBillingIntegration,
    createTestBillingIntegrationOrganizationContext,
    updateTestBillingIntegrationOrganizationContext,
} = require('@condo/domains/billing/utils/testSchema')
const { createTestBillingCategory } = require('@condo/domains/billing/utils/testSchema')
const { WRONG_TEXT_FORMAT, UNEQUAL_CONTEXT_ERROR } = require('@condo/domains/common/constants/errors')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRightSet,
    createTestB2BAppAccessRight,
} = require('@condo/domains/miniapp/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const {
    registerServiceConsumerByTestClient,
    updateTestServiceConsumer,
} = require('@condo/domains/resident/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
} = require('@condo/domains/user/utils/testSchema')
const { createTestUserRightsSet, updateTestUser, makeClientWithServiceUser } = require('@condo/domains/user/utils/testSchema')

describe('BillingReceipt', () => {
    let admin
    let support
    let anonymous
    let user
    let context
    let property
    let account
    let integrationUser
    let integrationManager
    let anotherContext
    let anotherProperty
    let anotherAccount
    let acquiringContext

    beforeAll(async () => {
        const { admin: adminClient, context: billingContext, integration, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
        admin = adminClient
        context = billingContext
        const [acquiringIntegration] = await createTestAcquiringIntegration(admin)
        const [createdAcquiringContext] = await createTestAcquiringIntegrationContext(admin, organization, acquiringIntegration, {
            status: CONTEXT_FINISHED_STATUS,
        })
        acquiringContext = createdAcquiringContext
        const [firstProperty] = await createTestBillingProperty(admin, context)
        const [firstAccount] = await createTestBillingAccount(admin, context, firstProperty)
        property = firstProperty
        account = firstAccount
        integrationUser = await makeServiceUserForIntegration(integration)
        support = await makeClientWithSupportUser()
        const { context: secondContext } = await makeContextWithOrganizationAndIntegrationAsAdmin()
        anotherContext = secondContext
        const [secondProperty] = await createTestBillingProperty(admin, anotherContext)
        const [secondAccount] = await createTestBillingAccount(admin, anotherContext, secondProperty)
        anotherProperty = secondProperty
        anotherAccount = secondAccount
        anonymous = await makeClient()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        const { managerUserClient } = await makeOrganizationIntegrationManager({ context })
        integrationManager = managerUserClient
    })
    describe('CRUD', () => {
        describe('Create', () => {
            describe('Single object', () => {
                test('Admin can', async () => {
                    const [receipt] = await createTestBillingReceipt(admin, context, property, account)

                    expect(receipt).toBeDefined()
                    expect(receipt).toHaveProperty(['context', 'id'], context.id)
                    expect(receipt).toHaveProperty(['property', 'id'], property.id)
                    expect(receipt).toHaveProperty(['account', 'id'], account.id)
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestBillingReceipt(support, context, property, account)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration, property, account via context', async () => {
                            const [receipt] = await createTestBillingReceipt(integrationUser, context, property, account)

                            expect(receipt).toBeDefined()
                            expect(receipt).toHaveProperty(['context', 'id'], context.id)
                            expect(receipt).toHaveProperty(['property', 'id'], property.id)
                            expect(receipt).toHaveProperty(['account', 'id'], account.id)
                        })
                        test('Cannot otherwise', async () => {
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await createTestBillingReceipt(integrationUser, anotherContext, anotherProperty, anotherAccount)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await createTestBillingReceipt(integrationManager, context, property, account)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await createTestBillingReceipt(user, anotherContext, anotherProperty, anotherAccount)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await createTestBillingReceipt(anonymous, anotherContext, anotherProperty, anotherAccount)
                    })
                })
            })
            describe('Multiple objects', () => {
                test('Admin can for any context', async () => {
                    const [receipts] = await createTestBillingReceipts(admin,
                        [context, anotherContext],
                        [property, anotherProperty],
                        [account, anotherAccount]
                    )

                    expect(receipts).toBeDefined()
                    expect(receipts).toHaveLength(2)
                    expect(receipts).toEqual(expect.arrayContaining([
                        expect.objectContaining({
                            context: expect.objectContaining({ id: context.id }),
                            property: expect.objectContaining({ id: property.id }),
                            account: expect.objectContaining({ id: account.id }),
                        }),
                        expect.objectContaining({
                            context: expect.objectContaining({ id: anotherContext.id }),
                            property: expect.objectContaining({ id: anotherProperty.id }),
                            account: expect.objectContaining({ id: anotherAccount.id }),
                        }),
                    ]))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await createTestBillingReceipts(support, [context], [property], [account])
                    })
                })
                describe('User', () => {
                    describe('Integration account can if linked to permitted integration, property and account via context', () => {
                        test('All permitted contexts should pass', async () => {
                            const [receipts] = await createTestBillingReceipts(integrationUser,
                                [context, context],
                                [property, property],
                                [account, account])

                            expect(receipts).toBeDefined()
                            expect(receipts).toHaveLength(2)
                            expect(receipts[0]).toEqual(expect.objectContaining({
                                context: expect.objectContaining({ id: context.id }),
                                property: expect.objectContaining({ id: property.id }),
                                account: expect.objectContaining({ id: account.id }),
                            }))

                            expect(receipts[1]).toEqual(expect.objectContaining({
                                context: expect.objectContaining({ id: context.id }),
                                property: expect.objectContaining({ id: property.id }),
                                account: expect.objectContaining({ id: account.id }),
                            }))
                        })
                        test('Partly permitted must fail', async () => {
                            await expectToThrowAccessDeniedErrorToObjects(async () => {
                                await createTestBillingReceipts(integrationUser,
                                    [context, anotherContext],
                                    [property, property],
                                    [account, anotherAccount])
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await createTestBillingReceipts(integrationManager, [context], [property], [account])
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await createTestBillingReceipts(user, [context], [property], [account])
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await createTestBillingReceipts(anonymous, [anotherContext], [anotherProperty], [account])
                    })
                })
            })
        })
        describe('Update', () => {
            let receipt
            beforeAll(async () => {
                [receipt] = await createTestBillingReceipt(admin, context, property, account)
            })
            describe('Single object', () => {
                let payload
                beforeEach(() => {
                    payload = {
                        printableNumber:  faker.random.alphaNumeric(32),
                    }
                })
                test('Admin can', async () => {
                    const [updatedReceipt] = await updateTestBillingReceipt(admin, receipt.id, payload)

                    expect(updatedReceipt).toBeDefined()
                    expect(updatedReceipt).toEqual(expect.objectContaining(payload))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestBillingReceipt(support, receipt.id, payload)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

                            expect(updatedReceipt).toBeDefined()
                            expect(updatedReceipt).toEqual(expect.objectContaining(payload))
                        })
                        test('Cannot otherwise', async () => {
                            const [anotherReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount)
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await updateTestBillingReceipt(integrationUser, anotherReceipt.id, payload)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingReceipt(integrationManager, receipt.id, payload)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingReceipt(user, receipt.id, payload)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestBillingReceipt(anonymous, receipt.id, payload)
                    })
                })
            })
            describe('Multiple objects', () => {
                let anotherReceipt
                let payload
                let anotherPayload
                beforeAll(async () => {
                    [anotherReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount)
                })
                beforeEach(() => {
                    payload = {
                        id: receipt.id,
                        data:  {
                            printableNumber: faker.random.alphaNumeric(32),
                        },
                    }
                    anotherPayload = {
                        id: anotherReceipt.id,
                        data:  {
                            printableNumber: faker.random.alphaNumeric(32),
                        },
                    }
                })
                test('Admin can for any context', async () => {
                    const [updatedReceipts] = await updateTestBillingReceipts(admin, [payload, anotherPayload])

                    expect(updatedReceipts).toBeDefined()
                    expect(updatedReceipts).toHaveLength(2)
                    expect(updatedReceipts).toEqual(expect.arrayContaining([
                        expect.objectContaining({ id: payload.id, ...payload.data }),
                        expect.objectContaining({ id: anotherPayload.id, ...anotherPayload.data }),
                    ]))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await updateTestBillingReceipts(support, [payload])
                    })
                })
                describe('User', () => {
                    describe('Integration account can if linked to permitted integration via context', () => {
                        test('All permitted must pass', async () => {
                            const [secondReceipt] = await createTestBillingReceipt(admin, context, property, account)
                            const secondPayload = { ...anotherPayload, id: secondReceipt.id }
                            const [updatedReceipts] = await updateTestBillingReceipts(integrationUser, [payload, secondPayload])

                            expect(updatedReceipts).toBeDefined()
                            expect(updatedReceipts).toHaveLength(2)
                            expect(updatedReceipts).toEqual(expect.arrayContaining([
                                expect.objectContaining({ id: payload.id, ...payload.data }),
                                expect.objectContaining({ id: secondReceipt.id, ...secondPayload.data }),
                            ]))
                        })
                        test('Partly permitted must fail', async () => {
                            await expectToThrowAccessDeniedErrorToObjects(async () => {
                                await updateTestBillingReceipts(integrationUser, [payload, anotherPayload])
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await updateTestBillingReceipts(integrationManager, [payload])
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await updateTestBillingReceipts(user, [payload])
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await updateTestBillingReceipts(anonymous, [payload])
                    })
                })
            })
        })
        describe('Read', () => {
            let receipt, receiptFile, anotherReceipt

            beforeAll(async () => {
                const [firstReceipt] = await createTestBillingReceipt(admin, context, property, account)
                const [secondReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount)
                const [fileForReceipt] = await createTestBillingReceiptFile(admin, firstReceipt, context)

                // set receipts to global vars
                receipt = firstReceipt
                anotherReceipt = secondReceipt
                receiptFile = fileForReceipt

                // set primary file
                await updateTestBillingReceipt(admin, receipt.id, {
                    file: { connect: { id: receiptFile.id } },
                })
            })
            test('Admin can read all', async () => {
                const receipts = await BillingReceipt.getAll(admin, {
                    id_in: [receipt.id, anotherReceipt.id],
                })

                expect(receipts).toHaveLength(2)
                expect(receipts).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipt.id }),
                    expect.objectContaining({ id: anotherReceipt.id }),
                ]))
            })
            test('Support cannot', async () => {
                const receipts = await BillingReceipt.getAll(support, {
                    id_in: [receipt.id, anotherReceipt.id],
                })

                expect(receipts).toHaveLength(0)
            })
            describe('User', () => {
                test('Integration account can, but only for permitted integration', async () => {
                    const receipts = await BillingReceipt.getAll(integrationUser, {
                        id_in: [receipt.id, anotherReceipt.id],
                    })

                    expect(receipts).toHaveLength(1)
                    expect(receipts[0]).toHaveProperty('id', receipt.id)
                    expect(receipts[0]).toHaveProperty('file.file.originalFilename', path.basename(PRIVATE_FILE))
                })
                test('Integration manager can, but only for his organization', async () => {
                    const receipts = await BillingReceipt.getAll(integrationManager, {
                        id_in: [receipt.id, anotherReceipt.id],
                    })

                    expect(receipts).toHaveLength(1)
                    expect(receipts[0]).toHaveProperty('id', receipt.id)
                    expect(receipts[0]).toHaveProperty('file.file.originalFilename', path.basename(PRIVATE_FILE))
                })
                test('Employee with `canReadBillingReceipts` can, but only for permitted organization', async () => {
                    const reader = await createReceiptsReader(context.organization)
                    const receipts = await BillingReceipt.getAll(reader, {
                        id_in: [receipt.id, anotherReceipt.id],
                    })

                    expect(receipts).toHaveLength(1)
                    expect(receipts[0]).toHaveProperty('id', receipt.id)
                    expect(receipts[0]).toHaveProperty('file.file.originalFilename', path.basename(PRIVATE_FILE))
                })
                describe('With type resident', () => {
                    let residentWithReceipt, setPrimaryFile
                    beforeEach(async () => {
                        residentWithReceipt = await makeResidentClientWithOwnReceipt()
                        setPrimaryFile = async (receipt, context) => {
                            const [receiptFile] = await createTestBillingReceiptFile(admin, receipt, context)

                            // set primary file
                            await updateTestBillingReceipt(admin, receipt.id, {
                                file: { connect: { id: receiptFile.id } },
                            })
                        }
                        await setPrimaryFile(residentWithReceipt.receipt, residentWithReceipt.context)
                    })
                    describe('Can see his own receipt', () => {
                        // NOTE: Using raw requests, since resident have not got access to some fields from gql.js
                        test('With single resident and serviceConsumer', async () => {
                            const { data: { objs: receipts } } = await BillingReceipt.getAll(residentWithReceipt.residentClient, {
                                id: residentWithReceipt.receipt.id,
                            }, { raw: true })

                            expect(receipts).toBeDefined()
                            expect(receipts).toHaveLength(1)
                            expect(receipts[0]).toHaveProperty('id', residentWithReceipt.receipt.id)

                            // Fields with access
                            expect(receipts[0].category).not.toBeNull()
                            expect(receipts[0].toPay).not.toBeNull()
                            expect(receipts[0].toPayDetails).not.toBeNull()
                            expect(receipts[0].services).not.toBeNull()
                            expect(receipts[0].recipient).not.toBeNull()

                            // Fields without access
                            expect(receipts[0].context).toBeNull()
                            expect(receipts[0].property).toBeNull()
                            expect(receipts[0].account).toBeNull()
                            expect(receipts[0].importId).toBeNull()

                            // File field
                            expect(receipts[0]).toHaveProperty('file.file.originalFilename', path.basename(PUBLIC_FILE))
                        })
                        test('With multiple residents and serviceConsumers', async () => {
                            // Add second receipt in same property
                            const [secondAccount] = await createTestBillingAccount(admin, residentWithReceipt.context, residentWithReceipt.billingProperty, {
                                unitName: residentWithReceipt.resident.unitName,
                                unitType: residentWithReceipt.resident.unitType,
                            })
                            await registerServiceConsumerByTestClient(residentWithReceipt.residentClient, {
                                residentId: residentWithReceipt.resident.id,
                                accountNumber: secondAccount.number,
                                organizationId: residentWithReceipt.organization.id,
                            })
                            const [anotherUnitReceipt] = await createTestBillingReceipt(admin, residentWithReceipt.context, residentWithReceipt.billingProperty, secondAccount)
                            await setPrimaryFile(anotherUnitReceipt, residentWithReceipt.context)
                            // Add third receipt in another property
                            const { receipt: anotherPropertyReceipt, context: anotherPropertyContext } = await makeResidentClientWithOwnReceipt(residentWithReceipt.residentClient)
                            await setPrimaryFile(anotherPropertyReceipt, anotherPropertyContext)
                            // Fetch all 3 receipts
                            const { data: { objs: receipts } } = await BillingReceipt.getAll(residentWithReceipt.residentClient, {
                                id_in: [residentWithReceipt.receipt.id, anotherUnitReceipt.id, anotherPropertyReceipt.id],
                            }, { raw: true })

                            expect(receipts).toHaveLength(3)
                            expect(receipts).toEqual(expect.arrayContaining([
                                expect.objectContaining({
                                    id: residentWithReceipt.receipt.id,
                                    file: expect.objectContaining({
                                        file: expect.objectContaining({
                                            originalFilename: path.basename(PUBLIC_FILE),
                                        }),
                                    }),
                                }),
                                expect.objectContaining({
                                    id: anotherUnitReceipt.id,
                                    file: expect.objectContaining({
                                        file: expect.objectContaining({
                                            originalFilename: path.basename(PUBLIC_FILE),
                                        }),
                                    }),
                                }),
                                expect.objectContaining({
                                    id: anotherPropertyReceipt.id,
                                    file: expect.objectContaining({
                                        file: expect.objectContaining({
                                            originalFilename: path.basename(PUBLIC_FILE),
                                        }),
                                    }),
                                }),
                            ]))
                        })
                        test('If billingAccount unitName is wrong', async () => {
                            const { billingAccount, residentClient, receipt: residentReceipt } = residentWithReceipt
                            await updateTestBillingAccount(admin, billingAccount.id, {
                                unitName: billingAccount.unitName + '1',
                            })
                            const { data: { objs: receipts } } = await BillingReceipt.getAll(residentClient, {
                                id: residentReceipt.id,
                            }, { raw: true })

                            expect(receipts).toHaveLength(1)
                            expect(receipts).toEqual(expect.arrayContaining([
                                expect.objectContaining({
                                    id: residentWithReceipt.receipt.id,
                                    file: expect.objectContaining({
                                        file: expect.objectContaining({
                                            originalFilename: path.basename(PUBLIC_FILE),
                                        }),
                                    }),
                                }),
                            ]))
                        })
                    })
                    describe('Cannot see receipt', () => {
                        test('If serviceConsumer accountNumber is wrong', async () => {
                            const { residentClient, serviceConsumer, receipt: residentReceipt } = residentWithReceipt
                            await updateTestServiceConsumer(admin, serviceConsumer.id, {
                                accountNumber: serviceConsumer.accountNumber + '1',
                            })
                            const { data: { objs: receipts } } = await BillingReceipt.getAll(residentClient, {
                                id: residentReceipt.id,
                            }, { raw: true })

                            expect(receipts).toHaveLength(0)
                        })
                    })
                })
                test('Other users cannot', async () => {
                    const receipts = await BillingReceipt.getAll(user, {
                        id_in: [receipt.id, anotherReceipt.id],
                    })

                    expect(receipts).not.toBeFalsy()
                    expect(receipts).toHaveLength(0)
                })
                test('User with directAccess can', async () => {
                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const [userRightsSet] = await createTestUserRightsSet(admin, { canReadBillingReceipts: true })
                    await updateTestUser(admin, userClient.user.id, { rightsSet: { connect: { id: userRightsSet.id } } })

                    const receipts = await BillingReceipt.getAll(userClient, {
                        id_in: [receipt.id, anotherReceipt.id],
                    })
                    expect(receipts).toHaveLength(2)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await BillingReceipt.getAll(anonymous, {
                        id_in: [account.id, anotherAccount.id],
                    })
                })
            })
        })
        describe('Delete', () => {
            let receipt
            let payload
            beforeEach(async () => {
                [receipt] = await createTestBillingReceipt(admin, context, property, account)
                payload = { deletedAt: dayjs().toISOString() }
            })
            describe('Hard delete is restricted for everyone', () => {
                test('Single object mutation', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(admin, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(support, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(integrationUser, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(integrationManager, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(user, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(anonymous, receipt.id)
                    })
                })
                test('Multiple objects mutation', async () => {
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(admin, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(support, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(integrationUser, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(integrationManager, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(user, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(anonymous, [receipt.id])
                    })
                })
            })
            describe('Soft delete', () => {
                test('Admin can', async () => {
                    const [updatedReceipt] = await updateTestBillingReceipt(admin, receipt.id, payload)

                    expect(updatedReceipt).toBeDefined()
                    expect(updatedReceipt).toHaveProperty('deletedAt')
                    expect(updatedReceipt.deletedAt).not.toBeNull()
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestBillingReceipt(support, receipt.id, payload)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [updatedAccount] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

                            expect(updatedAccount).toBeDefined()
                            expect(updatedAccount).toHaveProperty('deletedAt')
                            expect(updatedAccount.deletedAt).not.toBeNull()
                        })
                        test('Cannot otherwise', async () => {
                            const [anotherReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount)
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await updateTestBillingReceipt(integrationUser, anotherReceipt.id, payload)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingReceipt(integrationManager, receipt.id, payload)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingReceipt(user, receipt.id, payload)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestBillingReceipt(anonymous, receipt.id, payload)
                    })
                })
            })
        })
    })
    describe('Constraints', () => {
        describe('Import ID', () => {
            let importId
            let receipt
            beforeEach(async () => {
                importId = faker.datatype.uuid()
                const [firstReceipt] = await createTestBillingReceipt(admin, context, property, account, { importId })
                receipt = firstReceipt
            })
            test('Receipt with same importId can exist in different context', async () => {
                const [anotherReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount, { importId })

                expect(receipt).toHaveProperty('importId', importId)
                expect(anotherReceipt).toHaveProperty('importId', importId)
            })
            test('Receipt with same importId cannot exist in same context', async () => {
                await expectToThrowUniqueConstraintViolationError(async () => {
                    await createTestBillingReceipt(admin, context, property, account, { importId })
                }, 'billingReceipt_unique_context_and_importId')
            })
            test('Two identical importIds are allowed in one context if one of the receipts is deleted', async () => {
                importId = faker.datatype.uuid()
                const [firstReceipt] = await createTestBillingReceipt(admin, context, property, account, { importId })
                await updateTestBillingReceipt(admin, firstReceipt.id, { deletedAt: faker.date.past() })
                const [anotherReceipt] = await createTestBillingReceipt(admin, context, property, account, { importId })

                expect(firstReceipt).toHaveProperty('importId', importId)
                expect(anotherReceipt).toHaveProperty('importId', importId)
            })
        })
    })
    describe('Validations', () => {
        let importId
        let receipt
        beforeEach(async () => {
            importId = faker.datatype.uuid()
            const [firstReceipt] = await createTestBillingReceipt(admin, context, property, account, { importId })
            receipt = firstReceipt
        })
        describe('importId', () => {
            describe('Cannot create receipt with falsy importId', () => {
                const cases = [
                    ['null', null, '"importId" is null or undefined'],
                    ['undefined', undefined, '"importId" is null or undefined'],
                    ['empty string', '', `${WRONG_TEXT_FORMAT}importId]`],
                ]
                test.each(cases)('%p', async (name, value, errorMessageContains) => {
                    await expectToThrowValidationFailureError(async () => {
                        await createTestBillingReceipt(admin, context, property, account, { importId: value })
                    }, errorMessageContains)
                })
            })
            describe('Can update importId', () => {
                test('To different value', async () => {
                    expect(receipt).toHaveProperty('importId', importId)

                    const newImportId = faker.datatype.uuid()
                    const [updatedReceipt] = await updateTestBillingReceipt(admin, receipt.id, { importId: newImportId })

                    expect(updatedReceipt).toHaveProperty('importId', newImportId)
                })
                test('To same value', async () => {
                    expect(receipt).toHaveProperty('importId', importId)

                    const [updatedReceipt] = await updateTestBillingReceipt(admin, receipt.id, { importId })

                    expect(updatedReceipt).toHaveProperty('importId', importId)
                })
            })
        })
        describe('period', () => {
            test('Day of period must be equal to 01', async () => {
                await expectToThrowValidationFailureError(async () => {
                    await createTestBillingReceipt(admin, context, property, account, {
                        period: '2022-02-15',
                    })
                }, 'period field validation error. Period should always be the 1st day of the month')
            })
        })
        describe('services', () => {
            test('Each service must have a name', async () => {
                const payload = {
                    services: [
                        {
                            toPay: '1200.22',
                            toPayDetails: {
                                formula: 'charge+penalty',
                                charge: '12341.21',
                                penalty: '200.12',
                            },
                        },
                    ],
                }
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestBillingReceipt(admin, receipt.id, payload)
                }, '"data.services[0]"; Field "name" of required type "String!" was not provided.')
            })
        })
        describe('Hooks', () => {
            describe('receiver field', () => {
                test('Should create recipient and set receiver field automatically', async () => {
                    const [receipt, attrs] = await createTestBillingReceipt(admin, context, property, account)

                    expect(attrs).not.toHaveProperty('receiver')
                    expect(attrs).toHaveProperty(['recipient', 'tin'])
                    expect(receipt).toHaveProperty(['recipient', 'tin'])
                    expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
                })
                test('Should create recipient and set receiver.isApproved field automatically if billing integration is trusted and tin matches', async () => {
                    const {
                        context: trustedBillingContext,
                        organization: trustedOrganization,
                    } = await makeContextWithOrganizationAndIntegrationAsAdmin({ isTrustedBankAccountSource: true })
                    const tin = trustedOrganization.tin
                    const [trustedProperty] = await createTestBillingProperty(admin, trustedBillingContext)
                    const [trustedAccount] = await createTestBillingAccount(admin, trustedBillingContext, trustedProperty)
                    const [receipt, attrs] = await createTestBillingReceipt(admin, trustedBillingContext, trustedProperty, trustedAccount, { recipient: createTestRecipient({ tin: tin }) })

                    expect(attrs).not.toHaveProperty('receiver')
                    expect(attrs).toHaveProperty(['recipient', 'tin'])
                    expect(receipt).toHaveProperty(['recipient', 'tin'])
                    expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
                    expect(receipt).toHaveProperty(['receiver', 'isApproved'], true)
                })
                test('Should create recipient and not set receiver.isApproved field automatically if billing integration is trusted and tin do not match', async () => {
                    const {
                        context: trustedBillingContext,
                        organization: trustedOrganization,
                    } = await makeContextWithOrganizationAndIntegrationAsAdmin({ isTrustedBankAccountSource: true })
                    const tin = trustedOrganization.tin
                    const [trustedProperty] = await createTestBillingProperty(admin, trustedBillingContext)
                    const [trustedAccount] = await createTestBillingAccount(admin, trustedBillingContext, trustedProperty)
                    const [receipt, attrs] = await createTestBillingReceipt(admin, trustedBillingContext, trustedProperty, trustedAccount, { recipient: createTestRecipient({ tin: tin + '0' }) })

                    expect(attrs).not.toHaveProperty('receiver')
                    expect(attrs).toHaveProperty(['recipient', 'tin'])
                    expect(receipt).toHaveProperty(['recipient', 'tin'])
                    expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
                    expect(receipt).toHaveProperty(['receiver', 'isApproved'], false)
                })
                test('Should connect to existing recipient, if passed explicitly', async () => {
                    const recipientAttrs = createTestRecipient()
                    const receiptRecipientField = pick(recipientAttrs, ['tin', 'bic', 'iec', 'bankAccount'])
                    const [recipient] = await createTestBillingRecipient(admin, context, recipientAttrs)
                    const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                        recipient: receiptRecipientField,
                        receiver: { connect: { id: recipient.id } },
                    })

                    expect(receipt).toHaveProperty(['recipient', 'tin'], recipient.tin)
                    expect(receipt).toHaveProperty(['receiver', 'id'], recipient.id)
                })
                test('Should automatically connect to existing recipient, if receiver is not passed', async () => {
                    const recipientAttrs = createTestRecipient()
                    const receiptRecipientField = pick(recipientAttrs, ['tin', 'bic', 'iec', 'bankAccount'])
                    const [recipient] = await createTestBillingRecipient(admin, context, recipientAttrs)
                    const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                        recipient: receiptRecipientField,
                    })

                    expect(receipt).toHaveProperty(['recipient', 'tin'], recipient.tin)
                    expect(receipt).toHaveProperty(['receiver', 'id'], recipient.id)
                })
                test('Should validate that services add up to the total sum (toPay)', async () => {
                    const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                        services: generateServicesData(1, '9000'), toPay: '9000.00',
                    })
                    const [receipt2] = await createTestBillingReceipt(admin, context, property, account, {
                        services: generateServicesData(1, '9000'), toPay: '9999.00',
                    })
                    const [receipt3] = await createTestBillingReceipt(admin, context, property, account, {
                        services: [],
                    })

                    expect(receipt).toHaveProperty(['invalidServicesError'], null)
                    expect(receipt2).toHaveProperty(['invalidServicesError'],
                        'Services sum (9000) does not add up to the toPay (9999) amount correctly')
                    expect(receipt3).toHaveProperty(['invalidServicesError'], null)
                })
            })
        })
        describe('toPay', () => {
            test('Must be Decimal', async () => {
                const payload = {
                    toPay: '22.92',
                }
                const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

                expect(updatedReceipt).toHaveProperty('toPay', '22.92000000')
            })
        })
        describe('toPayDetails', () => {
            const cases = [
                ['paid', faker.datatype.number(), 'Field "paid" is not defined by type "BillingReceipt'],
                ['penalty', faker.datatype.number(), 'Field "penalty" is not defined by type "BillingReceipt'],
                ['privilege', faker.datatype.number(), 'Field "privilege" is not defined by type "BillingReceipt'],
                ['recalculation', faker.datatype.number(), 'Field "recalculation" is not defined by type "BillingReceipt'],
                ['charge', faker.datatype.number(), 'Field "charge" is not defined by type "BillingReceipt'],
                ['formula', faker.datatype.string(), 'Field "formula" is not defined by type "BillingReceipt'],
                ['balance', faker.datatype.number(), 'Field "balance" is not defined by type "BillingReceipt'],
            ]

            test.each(cases)('Field %p cannot be created directly', async (field, value, error) => {
                // TODO(pahaz): DOMA-10368 use expectToThrowGraphQLRequestError
                await catchErrorFrom(async () => {
                    await createTestBillingReceipt(admin, context, property, account, {
                        [field]: value,
                    })
                }, (e) => {
                    expect(e).toHaveProperty('errors')
                    expect(e.errors).toHaveLength(1)
                    expect(e.errors[0].message).toContain(error)
                })
            })

            test.each(cases)('Field %p cannot be updated directly', async (field, value, error) => {
                const [receipt] = await createTestBillingReceipt(admin, context, property, account)
                // TODO(pahaz): DOMA-10368 use expectToThrowGraphQLRequestError
                await catchErrorFrom(async () => {
                    await updateTestBillingReceipt(admin, receipt.id, {
                        [field]: value,
                    })
                }, (e) => {
                    expect(e).toHaveProperty('errors')
                    expect(e.errors).toHaveLength(1)
                    expect(e.errors[0].message).toContain(error)
                })
            })
        })
        describe('context', () => {
            test('Context field cannot be changed', async () => {
                const [billingReceipt] = await createTestBillingReceipt(admin, context, property, account)
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestBillingReceipt(admin, billingReceipt.id, {
                        context: { connect: { id: anotherContext.id } },
                    })
                }, 'Field "context" is not defined')
            })
        })
        test('Context and contexts from "account" and "property" fields must be equal', async () => {
            const [billingReceipt] = await createTestBillingReceipt(admin, context, property, account)
            await expectToThrowValidationFailureError(async () => {
                await updateTestBillingReceipt(admin, billingReceipt.id, {
                    account: { connect: { id: anotherAccount.id } },
                })
            }, `${UNEQUAL_CONTEXT_ERROR}:account:context] Context is not equal to account.context`)
            await expectToThrowValidationFailureError(async () => {
                await updateTestBillingReceipt(admin, billingReceipt.id, {
                    property: { connect: { id: anotherProperty.id } },
                })
            }, `${UNEQUAL_CONTEXT_ERROR}:property:context] Context is not equal to property.context`)
        })
        describe('validate distribution', () => {
            describe('must throw an error if', () => {
                let o10n
                let bankAccount1, bankAccount2, bankAccount3
                let recipient1, recipient2, recipient3
                let serviceClient
                let context, property, account
                let integrationUser

                beforeAll(async () => {
                    [o10n] = await createTestOrganization(admin);
                    [bankAccount1] = await createTestBankAccount(support, o10n);
                    [bankAccount2] = await createTestBankAccount(support, o10n);
                    [bankAccount3] = await createTestBankAccount(support, o10n)

                    const [integration] = await createTestBillingIntegration(admin);
                    [context] = await createTestBillingIntegrationOrganizationContext(admin, o10n, integration, { status: CONTEXT_FINISHED_STATUS });
                    [property] = await createTestBillingProperty(admin, context);
                    [account] = await createTestBillingAccount(admin, context, property)

                    integrationUser = await makeServiceUserForIntegration(integration)

                    recipient1 = createTestRecipient({
                        tin: bankAccount1.tin,
                        bic: bankAccount1.routingNumber,
                        bankAccount: bankAccount1.number,
                    })
                    recipient2 = createTestRecipient({
                        tin: bankAccount2.tin,
                        bic: bankAccount2.routingNumber,
                        bankAccount: bankAccount2.number,
                    })
                    recipient3 = createTestRecipient({
                        tin: bankAccount3.tin,
                        bic: bankAccount3.routingNumber,
                        bankAccount: bankAccount3.number,
                    })

                    serviceClient = await makeClientWithServiceUser()
                    const [app] = await createTestB2BApp(admin)
                    await createTestB2BAppContext(support, app, o10n, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(support, app, {
                        canReadOrganizations: true,
                        canReadInvoices: true,
                        canManageInvoices: true,
                    })
                    await createTestB2BAppAccessRight(support, serviceClient.user, app, accessRightSet)
                    const [acquiringIntegration] = await createTestAcquiringIntegration(support, { canGroupReceipts: true })
                    await createTestAcquiringIntegrationContext(admin, o10n, acquiringIntegration, {
                        invoiceStatus: CONTEXT_FINISHED_STATUS,
                        invoiceRecipient: createTestRecipient(),
                    })
                })

                test('no approved bank account for recipient', async () => {
                    const unapprovedRecipient = createTestRecipient()
                    await expectToThrowGQLError(async () => {
                        await createTestBillingReceipt(integrationUser, context, property, account, {
                            toPay: '500',
                            amountDistribution: [
                                { recipient: unapprovedRecipient, amount: '200' },
                                {
                                    recipient: recipient2,
                                    amount: '300',
                                    vor: true,
                                    overpaymentPart: 1,
                                    isFeePayer: true,
                                },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'NO_APPROVED_BANK_ACCOUNT',
                        message: 'Some recipients not approved. Please connect to support.',
                        notApprovedRecipients: [unapprovedRecipient],
                    })
                })

                test('sums not match', async () => {
                    await expectToThrowGQLError(async () => {
                        await createTestBillingReceipt(integrationUser, context, property, account, {
                            toPay: '500',
                            amountDistribution: [
                                { recipient: recipient1, amount: '100' },
                                {
                                    recipient: recipient2,
                                    amount: '300',
                                    vor: true,
                                    overpaymentPart: 1,
                                    isFeePayer: true,
                                },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'SUMS_NOT_MATCH',
                        message: 'Total sum (toPay={toPay}) is not match to sum of distributions ({distributionsSum})',
                        messageInterpolation: { toPay: '500', distributionsSum: '400' },
                    })
                })

                describe('no single victim of rounding in each group', () => {
                    test('when no such item', async () => {
                        await expectToThrowGQLError(async () => {
                            await createTestBillingReceipt(integrationUser, context, property, account, {
                                toPay: '500',
                                amountDistribution: [
                                    { recipient: recipient1, amount: '200' },
                                    { recipient: recipient2, amount: '300', overpaymentPart: 1, isFeePayer: true },
                                ],
                            })
                        }, {
                            code: 'BAD_USER_INPUT',
                            type: 'NO_VOR_IN_GROUP',
                            message: 'Group {order} does not contains a SINGLE element with vor=true',
                            messageInterpolation: { order: 0 },
                        })
                    })

                    test('when 2 such items', async () => {
                        await expectToThrowGQLError(async () => {
                            await createTestBillingReceipt(integrationUser, context, property, account, {
                                toPay: '500',
                                amountDistribution: [
                                    {
                                        recipient: recipient1,
                                        amount: '100',
                                        order: 0,
                                        vor: true,
                                        overpaymentPart: 1,
                                        isFeePayer: true,
                                    },
                                    {
                                        recipient: recipient2,
                                        amount: '300',
                                        order: 1,
                                        vor: true,
                                        overpaymentPart: 1,
                                        isFeePayer: true,
                                    },
                                    {
                                        recipient: recipient3,
                                        amount: '100',
                                        order: 1,
                                        vor: true,
                                        overpaymentPart: 1,
                                        isFeePayer: true,
                                    },
                                ],
                            })
                        }, {
                            code: 'BAD_USER_INPUT',
                            type: 'NO_VOR_IN_GROUP',
                            message: 'Group {order} does not contains a SINGLE element with vor=true',
                            messageInterpolation: { order: 1 },
                        })
                    })
                })

                test('vor-item is not fee payer', async () => {
                    await expectToThrowGQLError(async () => {
                        await createTestBillingReceipt(integrationUser, context, property, account, {
                            toPay: '500',
                            amountDistribution: [
                                { recipient: recipient1, amount: '200' },
                                { recipient: recipient2, amount: '300', vor: true, overpaymentPart: 1 },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'VOR_MUST_BE_FEE_PAYER',
                        message: 'The victim of rounding (vor) must have isFeePayer=true',
                    })
                })

                test('vor-item is not overpayment receiver', async () => {
                    await expectToThrowGQLError(async () => {
                        await createTestBillingReceipt(integrationUser, context, property, account, {
                            toPay: '500',
                            amountDistribution: [
                                { recipient: recipient1, amount: '200' },
                                { recipient: recipient2, amount: '300', vor: true, isFeePayer: true },
                            ],
                        })
                    }, {
                        code: 'BAD_USER_INPUT',
                        type: 'VOR_MUST_BE_OVERPAYMENT_RECEIVER',
                        message: 'The victim of rounding (vor) must have overpaymentPart value',
                    })
                })
            })
        })
    })
    describe('Integration user can perform all needed actions', () => {
        let importId
        let receipt
        beforeEach(async () => {
            importId = faker.datatype.uuid()
            const [firstReceipt] = await createTestBillingReceipt(admin, context, property, account, { importId })
            receipt = firstReceipt
        })
        test('Restore soft-deleted receipt', async () => {
            expect(receipt).toHaveProperty('deletedAt')
            expect(receipt.deletedAt).toBeNull()

            const [deletedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, { deletedAt: dayjs().toISOString() })

            expect(deletedReceipt).toHaveProperty('id', receipt.id)
            expect(deletedReceipt).toHaveProperty('deletedAt')
            expect(deletedReceipt.deletedAt).not.toBeNull()

            const [restoredReceipt] = await updateTestBillingReceipt(integrationUser, deletedReceipt.id, { deletedAt: null })

            expect(restoredReceipt).toHaveProperty('id', receipt.id)
            expect(restoredReceipt).toHaveProperty('deletedAt')
            expect(restoredReceipt.deletedAt).toBeNull()
        })
        test('Update toPayDetail field', async () => {
            const payload = {
                toPayDetails: {
                    formula: 'charge+penalty',
                    charge: '12341.21',
                    penalty: '200.12',
                    privilege: null,
                },
            }
            const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

            expect(updatedReceipt).toEqual(expect.objectContaining({
                toPayDetails: expect.objectContaining(payload.toPayDetails),
            }))
        })
        test('Update services field', async () => {
            const payload = { services: generateServicesData() }
            const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

            expect(updatedReceipt).toEqual(expect.objectContaining({
                services: expect.arrayContaining(
                    payload.services.map(service => expect.objectContaining({
                        ...service,
                        toPayDetails: expect.objectContaining(service.toPayDetails),
                    }))
                ),
            }))
        })
        test('Update period field', async () => {
            const payload = {
                period: '2011-12-01',
            }
            const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

            expect(updatedReceipt).toEqual(expect.objectContaining(payload))
        })
    })
    describe('Cache tests', () => {
        test('Time value is always ready to be parsed', async () => {
            const [billingReceipt] = await createTestBillingReceipt(admin, context, property, account)
            await expectToThrowValidationFailureError(async () => {
                await updateTestBillingReceipt(admin, billingReceipt.id, {
                    account: { connect: { id: anotherAccount.id } },
                })
            }, `${UNEQUAL_CONTEXT_ERROR}:account:context] Context is not equal to account.context`)
            await expectToThrowValidationFailureError(async () => {
                await updateTestBillingReceipt(admin, billingReceipt.id, {
                    property: { connect: { id: anotherProperty.id } },
                })
            }, `${UNEQUAL_CONTEXT_ERROR}:property:context] Context is not equal to property.context`)
            await expectToThrowValidationFailureError(async () => {
                await updateTestBillingReceipt(admin, billingReceipt.id, {
                    account: { connect: { id: anotherAccount.id } },
                })
            }, `${UNEQUAL_CONTEXT_ERROR}:account:context] Context is not equal to account.context`)
            await expectToThrowValidationFailureError(async () => {
                await updateTestBillingReceipt(admin, billingReceipt.id, {
                    property: { connect: { id: anotherProperty.id } },
                })
            }, `${UNEQUAL_CONTEXT_ERROR}:property:context] Context is not equal to property.context`)
        })
        test('Multiple updates are working', async () => {
            const [billingReceipt] = await createTestBillingReceipt(admin, context, property, account)
            await updateTestBillingReceipt(admin, billingReceipt.id, {
                toPay: '250.00',
            })
            await updateTestBillingReceipt(admin, billingReceipt.id, {
                toPay: '550.00',
            })
            const updatedReceipt = await BillingReceipt.getOne(admin, { id: billingReceipt.id })
            expect(updatedReceipt.id).toEqual(billingReceipt.id)
            expect(updatedReceipt.period).toEqual(billingReceipt.period)
            expect(updatedReceipt.account.id).toEqual(billingReceipt.account.id)
            expect(updatedReceipt.property.id).toEqual(billingReceipt.property.id)
            expect(updatedReceipt.toPay).toEqual('550.00000000')
        })
    })
    describe('Hooks', () => {
        describe('receiver field', () => {
            test('Should create recipient and set receiver field automatically', async () => {
                const [receipt, attrs] = await createTestBillingReceipt(admin, context, property, account)

                expect(attrs).not.toHaveProperty('receiver')
                expect(attrs).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
            })
            test('Should create recipient and set receiver.isApproved field automatically if billing integration is trusted and tin matches', async () => {
                const { context: trustedBillingContext, organization: trustedOrganization } = await makeContextWithOrganizationAndIntegrationAsAdmin( { isTrustedBankAccountSource: true })
                const tin = trustedOrganization.tin
                const [trustedProperty] = await createTestBillingProperty(admin, trustedBillingContext)
                const [trustedAccount] = await createTestBillingAccount(admin, trustedBillingContext, trustedProperty)
                const [receipt, attrs] = await createTestBillingReceipt(admin, trustedBillingContext, trustedProperty, trustedAccount, { recipient: createTestRecipient({ tin: tin }) })

                expect(attrs).not.toHaveProperty('receiver')
                expect(attrs).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
                expect(receipt).toHaveProperty(['receiver', 'isApproved'], true)
            })
            test('Should create recipient and not set receiver.isApproved field automatically if billing integration is trusted and tin do not match', async () => {
                const { context: trustedBillingContext, organization: trustedOrganization } = await makeContextWithOrganizationAndIntegrationAsAdmin( { isTrustedBankAccountSource: true })
                const tin = trustedOrganization.tin
                const [trustedProperty] = await createTestBillingProperty(admin, trustedBillingContext)
                const [trustedAccount] = await createTestBillingAccount(admin, trustedBillingContext, trustedProperty)
                const [receipt, attrs] = await createTestBillingReceipt(admin, trustedBillingContext, trustedProperty, trustedAccount, { recipient: createTestRecipient({ tin: tin + '0' }) })

                expect(attrs).not.toHaveProperty('receiver')
                expect(attrs).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
                expect(receipt).toHaveProperty(['receiver', 'isApproved'], false)
            })
            test('Should connect to existing recipient, if passed explicitly', async () => {
                const recipientAttrs = createTestRecipient()
                const receiptRecipientField = pick(recipientAttrs, ['tin', 'bic', 'iec', 'bankAccount'])
                const [recipient] = await createTestBillingRecipient(admin, context, recipientAttrs)
                const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                    recipient: receiptRecipientField,
                    receiver: { connect: { id: recipient.id } },
                })

                expect(receipt).toHaveProperty(['recipient', 'tin'], recipient.tin)
                expect(receipt).toHaveProperty(['receiver', 'id'], recipient.id)
            })
            test('Should automatically connect to existing recipient, if receiver is not passed', async () => {
                const recipientAttrs = createTestRecipient()
                const receiptRecipientField = pick(recipientAttrs, ['tin', 'bic', 'iec', 'bankAccount'])
                const [recipient] = await createTestBillingRecipient(admin, context, recipientAttrs)
                const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                    recipient: receiptRecipientField,
                })

                expect(receipt).toHaveProperty(['recipient', 'tin'], recipient.tin)
                expect(receipt).toHaveProperty(['receiver', 'id'], recipient.id)
            })
            test('Should validate that services add up to the total sum (toPay)', async () => {
                const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                    services: generateServicesData(1, '9000'), toPay: '9000.00',
                })
                const [receipt2] = await createTestBillingReceipt(admin, context, property, account, {
                    services: generateServicesData(1, '9000'), toPay: '9999.00',
                })
                const [receipt3] = await createTestBillingReceipt(admin, context, property, account, {
                    services: [],
                })

                expect(receipt).toHaveProperty(['invalidServicesError'], null)
                expect(receipt2).toHaveProperty(['invalidServicesError'],
                    'Services sum (9000) does not add up to the toPay (9999) amount correctly')
                expect(receipt3).toHaveProperty(['invalidServicesError'], null)
            })
        })
        describe('toPayDetails field', () => {
            const toPayDetails = {
                formula: 'charge + penalty',
                charge: new Big(faker.datatype.number()).toFixed(8),
                penalty: new Big(faker.datatype.number()).toFixed(8),
                balance: new Big(faker.datatype.number()).toFixed(8),
                recalculation: new Big(faker.datatype.number()).toFixed(8),
                privilege: new Big(faker.datatype.number()).toFixed(8),
                paid: new Big(faker.datatype.number()).toFixed(8),
            }

            test('should fill all of the explicit toPayDetails fields from original one on create', async () => {
                const [receipt, attrs] = await createTestBillingReceipt(admin, context, property, account, {
                    toPayDetails,
                })

                expect(attrs).not.toHaveProperty('formula')
                expect(attrs).not.toHaveProperty('charge')
                expect(attrs).not.toHaveProperty('penalty')
                expect(attrs).not.toHaveProperty('balance')
                expect(attrs).not.toHaveProperty('recalculation')
                expect(attrs).not.toHaveProperty('privilege')
                expect(attrs).not.toHaveProperty('paid')

                expect(receipt).toHaveProperty('formula', receipt.toPayDetails.formula)
                expect(receipt).toHaveProperty('charge', receipt.toPayDetails.charge)
                expect(receipt).toHaveProperty('penalty', receipt.toPayDetails.penalty)
                expect(receipt).toHaveProperty('balance', receipt.toPayDetails.balance)
                expect(receipt).toHaveProperty('recalculation', receipt.toPayDetails.recalculation)
                expect(receipt).toHaveProperty('privilege', receipt.toPayDetails.privilege)
                expect(receipt).toHaveProperty('paid', receipt.toPayDetails.paid)
            })
            test('should change all of the explicit toPayDetails fields after update operation', async () => {
                const [originalReceipt] = await createTestBillingReceipt(admin, context, property, account, {
                    toPayDetails,
                })

                const [receipt] = await updateTestBillingReceipt(admin, originalReceipt.id, {
                    toPayDetails: { ...toPayDetails, paid: new Big(faker.datatype.number()).toFixed(8) },
                })

                expect(receipt).toHaveProperty('formula', originalReceipt.toPayDetails.formula)
                expect(receipt).toHaveProperty('charge', originalReceipt.toPayDetails.charge)
                expect(receipt).toHaveProperty('penalty', originalReceipt.toPayDetails.penalty)
                expect(receipt).toHaveProperty('balance', originalReceipt.toPayDetails.balance)
                expect(receipt).toHaveProperty('recalculation', originalReceipt.toPayDetails.recalculation)
                expect(receipt).toHaveProperty('privilege', originalReceipt.toPayDetails.privilege)
                expect(receipt).toHaveProperty('paid', receipt.toPayDetails.paid)
            })
        })
        describe('virtual fields check', () => {
            it('checking the completion of virtual fields: canGroupReceipts, hostUrl, acquiringIntegrationId, currencyCode', async () => {
                const [organization] = await createTestOrganization(admin)
                const [acquiringIntegration] = await createTestAcquiringIntegration(admin)
                const [billingIntegration] = await createTestBillingIntegration(admin)
                const [acquiringContext] = await createTestAcquiringIntegrationContext(admin, organization, acquiringIntegration)
                const [context] = await createTestBillingIntegrationOrganizationContext(admin, organization, billingIntegration)
                const [property] = await createTestBillingProperty(admin, context)
                const [account] = await createTestBillingAccount(admin, context, property)
                await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, { status: CONTEXT_FINISHED_STATUS })
                const [billingReceipt] = await createTestBillingReceipt(admin, context, property, account)

                expect(billingReceipt.acquiringIntegrationId).toEqual(acquiringIntegration.id)
                expect(billingReceipt.acquiringHostUrl).toEqual(acquiringIntegration.hostUrl)
                expect(billingReceipt.canGroupReceipts).toEqual(acquiringIntegration.canGroupReceipts)
                expect(billingReceipt.currencyCode).toEqual(context.integration.currencyCode)
            })

            describe('isPayable virtual field', () => {
                let billingIntegration
                let acquiringIntegration

                beforeAll(async () => {
                    [billingIntegration] = await createTestBillingIntegration(admin);
                    [acquiringIntegration] = await createTestAcquiringIntegration(admin)
                })

                test('should return true for a receipt within validity period with no newer receipts', async () => {
                    const period = dayjs().subtract(1, 'month').format('YYYY-MM-01') // 1 month ago
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 3,
                    })
                    const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                    })

                    expect(receipt.isPayable).toBe(true)
                })

                test('should return false when current date exceeds validity period', async () => {
                    const period = dayjs().subtract(3, 'month').format('YYYY-MM-01') // 3 months ago
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 3,
                    })
                    const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                    })

                    expect(receipt.isPayable).toBe(false)
                })

                test('should return false when newer receipt exists', async () => {
                    const period = dayjs().subtract(1, 'month').format('YYYY-MM-01')
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 3,
                    })
                    const [olderReceipt] = await createTestBillingReceipt(admin, context, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                    })

                    await createTestBillingReceipt(admin, context, property, account, {
                        period: dayjs().format('YYYY-MM-01'),
                        category: { connect: { id: category.id } },
                    })

                    const oldReceipt = await BillingReceipt.getOne(admin, { id: olderReceipt.id })
                    expect(oldReceipt.isPayable).toBe(false)
                })

                test('should use custom validity months from category', async () => {
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 6,
                    })

                    const period = dayjs().subtract(4, 'month').format('YYYY-MM-01')

                    const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                        recipient: {
                            bankAccount: faker.finance.account(12).toString(),
                            bankName: faker.company.name(),
                            territoryCode: faker.datatype.number().toString(),
                            bic: faker.finance.bic().toString(),
                            tin: faker.random.alphaNumeric(8),
                        },
                    })

                    expect(receipt.isPayable).toBe(true)
                })

                test('should handle last day when receipt is payable correctly', async () => {
                    const validityMonths = 3
                    const period = dayjs().subtract(validityMonths - 1, 'month').format('YYYY-MM-01')
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 3,
                    })

                    // Mock system time to last valid day (end of validity month)
                    const lastValidDay = dayjs(period)
                        .add(validityMonths - 1, 'month')
                        .endOf('month')

                    jest.useFakeTimers().setSystemTime(lastValidDay.toDate())

                    const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                    })

                    expect(receipt.isPayable).toBe(true)
                    jest.useRealTimers()
                })

                test('should return false when billing context was soft deleted', async () => {
                    const period = dayjs().subtract(1, 'month').format('YYYY-MM-01')
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 3,
                    })

                    const [organization] = await createTestOrganization(admin)
                    const [context] = await createTestBillingIntegrationOrganizationContext(admin, organization, billingIntegration)
                    const [property] = await createTestBillingProperty(admin, context)
                    const [account] = await createTestBillingAccount(admin, context, property)
                    const [createdReceipt] = await createTestBillingReceipt(admin, context, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                    })
                    await updateTestBillingIntegrationOrganizationContext(admin, context.id, { deletedAt: new Date().toISOString() })
                    const receipt = await BillingReceipt.getOne(admin, { id: createdReceipt.id })
                    expect(receipt.isPayable).toBe(false)
                })

                test('should return false when no acquiring context with status Finished exists for organization', async () => {
                    const period = dayjs().subtract(1, 'month').format('YYYY-MM-01')
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 3,
                    })
        
                    const [o10n] = await createTestOrganization(admin)
                    const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, o10n, billingIntegration)
                    const [property] = await createTestBillingProperty(admin, billingContext)
                    const [account] = await createTestBillingAccount(admin, billingContext, property)
                    const [receipt] = await createTestBillingReceipt(admin, billingContext, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                    })

                    expect(receipt.isPayable).toBe(false)
                })

                test('should return false when acquiring context exists but not in Finished status', async () => {
                    const period = dayjs().subtract(1, 'month').format('YYYY-MM-01')
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 3,
                    })
        
                    const [o10n] = await createTestOrganization(admin)
                    await createTestAcquiringIntegrationContext(admin, o10n, acquiringIntegration, {
                        status: CONTEXT_IN_PROGRESS_STATUS,
                    })
        
                    const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, o10n, billingIntegration)
                    const [property] = await createTestBillingProperty(admin, billingContext)
                    const [account] = await createTestBillingAccount(admin, billingContext, property)
                    const [receipt] = await createTestBillingReceipt(admin, billingContext, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                    })

                    expect(receipt.isPayable).toBe(false)
                })

                test('should return false when all acquiring contexts are deleted', async () => {
                    const period = dayjs().subtract(1, 'month').format('YYYY-MM-01')
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 3,
                    })
        
                    const [o10n] = await createTestOrganization(admin)
                    const [acquiringContext] = await createTestAcquiringIntegrationContext(admin, o10n, acquiringIntegration, {
                        status: CONTEXT_FINISHED_STATUS,
                    })
                    await updateTestAcquiringIntegrationContext(admin, acquiringContext.id, { deletedAt: new Date().toISOString() })
        
                    const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, o10n, billingIntegration)
                    const [property] = await createTestBillingProperty(admin, billingContext)
                    const [account] = await createTestBillingAccount(admin, billingContext, property)
                    const [receipt] = await createTestBillingReceipt(admin, billingContext, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                    })

                    expect(receipt.isPayable).toBe(false)
                })

                test('should return true when exactly one acquiring context in status Finished exists', async () => {
                    const period = dayjs().subtract(1, 'month').format('YYYY-MM-01')
                    const [category] = await createTestBillingCategory(admin, {
                        receiptValidityMonths: 3,
                    })
        
                    const [o10n] = await createTestOrganization(admin)
                    await createTestAcquiringIntegrationContext(admin, o10n, acquiringIntegration, {
                        status: CONTEXT_IN_PROGRESS_STATUS,
                    })
                    await createTestAcquiringIntegrationContext(admin, o10n, acquiringIntegration, {
                        status: CONTEXT_FINISHED_STATUS,
                    })
        
                    const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, o10n, billingIntegration)
                    const [property] = await createTestBillingProperty(admin, billingContext)
                    const [account] = await createTestBillingAccount(admin, billingContext, property)
                    const [receipt] = await createTestBillingReceipt(admin, billingContext, property, account, {
                        period,
                        category: { connect: { id: category.id } },
                    })

                    expect(receipt.isPayable).toBe(true)
                })
            })
        })
    })

    describe('Webhook callback URL whitelist validation', () => {
        let acquiringIntegration
        let billingIntegration

        beforeAll(async () => {
            [acquiringIntegration] = await createTestAcquiringIntegration(admin)
            billingIntegration = (await makeContextWithOrganizationAndIntegrationAsAdmin()).integration
        })

        test('can create billing receipt with whitelisted callback URL', async () => {
            const callbackUrl = `https://billing-whitelisted-${faker.random.alphaNumeric(10)}.com/webhook`

            // Add URL to whitelist
            await createTestPaymentStatusChangeWebhookUrl(admin, {
                url: callbackUrl,
                isEnabled: true,
            })

            // Create billing receipt with whitelisted URL
            const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                paymentStatusChangeWebhookUrl: callbackUrl,
            })

            expect(receipt.paymentStatusChangeWebhookUrl).toBe(callbackUrl)
            expect(receipt.paymentStatusChangeWebhookSecret).toBeTruthy()
        })

        test('cannot create billing receipt with non-whitelisted callback URL', async () => {
            const callbackUrl = `https://billing-not-whitelisted-${faker.random.alphaNumeric(10)}.com/webhook`

            await expectToThrowGQLError(
                async () => {
                    await createTestBillingReceipt(admin, context, property, account, {
                        paymentStatusChangeWebhookUrl: callbackUrl,
                    })
                },
                {
                    code: 'BAD_USER_INPUT',
                    type: 'WEBHOOK_URL_NOT_IN_WHITELIST',
                    message: 'The webhook URL must be registered in PaymentStatusChangeWebhookUrl',
                },
                'obj'
            )
        })

        test('cannot create billing receipt with disabled whitelist URL', async () => {
            const callbackUrl = `https://billing-disabled-${faker.random.alphaNumeric(10)}.com/webhook`

            // Add URL to whitelist but disabled
            await createTestPaymentStatusChangeWebhookUrl(admin, {
                url: callbackUrl,
                isEnabled: false,
            })

            await expectToThrowGQLError(
                async () => {
                    await createTestBillingReceipt(admin, context, property, account, {
                        paymentStatusChangeWebhookUrl: callbackUrl,
                    })
                },
                {
                    code: 'BAD_USER_INPUT',
                    type: 'WEBHOOK_URL_NOT_IN_WHITELIST',
                    message: 'The webhook URL must be registered in PaymentStatusChangeWebhookUrl',
                },
                'obj'
            )
        })

        test('cannot create billing receipt with soft-deleted whitelist URL', async () => {
            const callbackUrl = `https://billing-deleted-${faker.random.alphaNumeric(10)}.com/webhook`

            const [webhookUrl] = await createTestPaymentStatusChangeWebhookUrl(admin, {
                url: callbackUrl,
                isEnabled: true,
            })

            await updateTestPaymentStatusChangeWebhookUrl(admin, webhookUrl.id, {
                deletedAt: dayjs().toISOString(),
            })

            await expectToThrowGQLError(
                async () => {
                    await createTestBillingReceipt(admin, context, property, account, {
                        paymentStatusChangeWebhookUrl: callbackUrl,
                    })
                },
                {
                    code: 'BAD_USER_INPUT',
                    type: 'WEBHOOK_URL_NOT_IN_WHITELIST',
                    message: 'The webhook URL must be registered in PaymentStatusChangeWebhookUrl',
                },
                'obj'
            )
        })

        test('can create billing receipt without callback URL', async () => {
            const [receipt] = await createTestBillingReceipt(admin, context, property, account)

            expect(receipt.paymentStatusChangeWebhookUrl).toBeNull()
            expect(receipt.paymentStatusChangeWebhookSecret).toBeNull()
        })

        test('integration user can create billing receipt with whitelisted callback URL', async () => {
            const callbackUrl = `https://integration-whitelisted-${faker.random.alphaNumeric(10)}.com/webhook`

            // Add URL to whitelist
            await createTestPaymentStatusChangeWebhookUrl(admin, {
                url: callbackUrl,
                isEnabled: true,
            })

            const [receipt] = await createTestBillingReceipt(integrationUser, context, property, account, {
                paymentStatusChangeWebhookUrl: callbackUrl,
            })

            expect(receipt.paymentStatusChangeWebhookUrl).toBe(callbackUrl)
        })

        test('integration user cannot create billing receipt with non-whitelisted callback URL', async () => {
            const callbackUrl = `https://integration-not-whitelisted-${faker.random.alphaNumeric(10)}.com/webhook`

            await expectToThrowGQLError(
                async () => {
                    await createTestBillingReceipt(integrationUser, context, property, account, {
                        paymentStatusChangeWebhookUrl: callbackUrl,
                    })
                },
                {
                    code: 'BAD_USER_INPUT',
                    type: 'WEBHOOK_URL_NOT_IN_WHITELIST',
                    message: 'The webhook URL must be registered in PaymentStatusChangeWebhookUrl',
                },
                'obj'
            )
        })

        test('can update billing receipt to add whitelisted callback URL', async () => {
            const callbackUrl = `https://billing-update-whitelisted-${faker.random.alphaNumeric(10)}.com/webhook`

            // Create billing receipt without callback URL
            const [receipt] = await createTestBillingReceipt(admin, context, property, account)
            expect(receipt.paymentStatusChangeWebhookUrl).toBeNull()

            // Add URL to whitelist
            await createTestPaymentStatusChangeWebhookUrl(admin, {
                url: callbackUrl,
                isEnabled: true,
            })

            // Update billing receipt with whitelisted URL
            const [updatedReceipt] = await updateTestBillingReceipt(admin, receipt.id, {
                paymentStatusChangeWebhookUrl: callbackUrl,
            })

            expect(updatedReceipt.paymentStatusChangeWebhookUrl).toBe(callbackUrl)
            expect(updatedReceipt.paymentStatusChangeWebhookSecret).toBeTruthy()
        })

        test('cannot update billing receipt to add non-whitelisted callback URL', async () => {
            const callbackUrl = `https://billing-update-not-whitelisted-${faker.random.alphaNumeric(10)}.com/webhook`

            // Create billing receipt without callback URL
            const [receipt] = await createTestBillingReceipt(admin, context, property, account)

            await expectToThrowGQLError(
                async () => {
                    await updateTestBillingReceipt(admin, receipt.id, {
                        paymentStatusChangeWebhookUrl: callbackUrl,
                    })
                },
                {
                    code: 'BAD_USER_INPUT',
                    type: 'WEBHOOK_URL_NOT_IN_WHITELIST',
                    message: 'The webhook URL must be registered in PaymentStatusChangeWebhookUrl',
                },
                'obj'
            )
        })
    })
})
