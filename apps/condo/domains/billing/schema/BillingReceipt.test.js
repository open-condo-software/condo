/**
 * Generated by `createschema billing.BillingReceipt 'context:Relationship:BillingIntegrationOrganizationContext:CASCADE; importId?:Text; property:Relationship:BillingProperty:CASCADE; account:Relationship:BillingAccount:CASCADE; period:CalendarDay; raw:Json; toPay:Text; services:Json; meta:Json'`
 */
const faker = require('faker')
const dayjs = require('dayjs')
const pick = require('lodash/pick')
const {
    makeServiceUserForIntegration,
    makeOrganizationIntegrationManager,
    makeContextWithOrganizationAndIntegrationAsAdmin,
    makeResidentClientWithOwnReceipt,
    createReceiptsReader,
    createTestRecipient,
    createTestBillingProperty,
    createTestBillingAccount,
    updateTestBillingAccount,
    createTestBillingRecipient,
    BillingReceipt,
    createTestBillingReceipt,
    createTestBillingReceipts,
    updateTestBillingReceipt,
    updateTestBillingReceipts,
} = require('@condo/domains/billing/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
} = require('@condo/domains/user/utils/testSchema')
const {
    registerServiceConsumerByTestClient,
    updateTestServiceConsumer,
} = require('@condo/domains/resident/utils/testSchema')
const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAccessDeniedErrorToObjects,
    expectToThrowInternalError,
    expectToThrowValidationFailureError,
    expectToThrowGraphQLRequestError,
} = require('@open-condo/keystone/test.utils')
const { makeClient } = require('@open-condo/keystone/test.utils')
const { WRONG_TEXT_FORMAT, UNEQUAL_CONTEXT_ERROR } = require('@condo/domains/common/constants/errors')

describe('BillingReceipt', () => {
    let admin
    let support
    let anonymous
    let user
    let context
    let property
    let account
    let integrationUser
    let integrationManager
    let anotherContext
    let anotherProperty
    let anotherAccount
    beforeAll(async () => {
        const { admin: adminClient, context: billingContext, integration } = await makeContextWithOrganizationAndIntegrationAsAdmin()
        admin = adminClient
        context = billingContext
        const [firstProperty] = await createTestBillingProperty(admin, context)
        const [firstAccount] = await createTestBillingAccount(admin, context, firstProperty)
        property = firstProperty
        account = firstAccount
        integrationUser = await makeServiceUserForIntegration(integration)
        support = await makeClientWithSupportUser()
        const { context: secondContext } = await makeContextWithOrganizationAndIntegrationAsAdmin()
        anotherContext = secondContext
        const [secondProperty] = await createTestBillingProperty(admin, anotherContext)
        const [secondAccount] = await createTestBillingAccount(admin, anotherContext, secondProperty)
        anotherProperty = secondProperty
        anotherAccount = secondAccount
        anonymous = await makeClient()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        const { managerUserClient } = await makeOrganizationIntegrationManager(context)
        integrationManager = managerUserClient
    })
    describe('CRUD', () => {
        describe('Create', () => {
            describe('Single object', () => {
                test('Admin can', async () => {
                    const [receipt] = await createTestBillingReceipt(admin, context, property, account)

                    expect(receipt).toBeDefined()
                    expect(receipt).toHaveProperty(['context', 'id'], context.id)
                    expect(receipt).toHaveProperty(['property', 'id'], property.id)
                    expect(receipt).toHaveProperty(['account', 'id'], account.id)
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestBillingReceipt(support, context, property, account)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration, property, account via context', async () => {
                            const [receipt] = await createTestBillingReceipt(integrationUser, context, property, account)

                            expect(receipt).toBeDefined()
                            expect(receipt).toHaveProperty(['context', 'id'], context.id)
                            expect(receipt).toHaveProperty(['property', 'id'], property.id)
                            expect(receipt).toHaveProperty(['account', 'id'], account.id)
                        })
                        test('Cannot otherwise', async () => {
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await createTestBillingReceipt(integrationUser, anotherContext, anotherProperty, anotherAccount)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await createTestBillingReceipt(integrationManager, context, property, account)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await createTestBillingReceipt(user, anotherContext, anotherProperty, anotherAccount)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await createTestBillingReceipt(anonymous, anotherContext, anotherProperty, anotherAccount)
                    })
                })
            })
            describe('Multiple objects', () => {
                test('Admin can for any context', async () => {
                    const [receipts] = await createTestBillingReceipts(admin,
                        [context, anotherContext],
                        [property, anotherProperty],
                        [account, anotherAccount]
                    )

                    expect(receipts).toBeDefined()
                    expect(receipts).toHaveLength(2)
                    expect(receipts).toEqual(expect.arrayContaining([
                        expect.objectContaining({
                            context: expect.objectContaining({ id: context.id }),
                            property: expect.objectContaining({ id: property.id }),
                            account: expect.objectContaining({ id: account.id }),
                        }),
                        expect.objectContaining({
                            context: expect.objectContaining({ id: anotherContext.id }),
                            property: expect.objectContaining({ id: anotherProperty.id }),
                            account: expect.objectContaining({ id: anotherAccount.id }),
                        }),
                    ]))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await createTestBillingReceipts(support, [context], [property], [account])
                    })
                })
                describe('User', () => {
                    describe('Integration account can if linked to permitted integration, property and account via context', () => {
                        test('All permitted contexts should pass', async () => {
                            const [receipts] = await createTestBillingReceipts(integrationUser,
                                [context, context],
                                [property, property],
                                [account, account])

                            expect(receipts).toBeDefined()
                            expect(receipts).toHaveLength(2)
                            expect(receipts[0]).toEqual(expect.objectContaining({
                                context: expect.objectContaining({ id: context.id }),
                                property: expect.objectContaining({ id: property.id }),
                                account: expect.objectContaining({ id: account.id }),
                            }))

                            expect(receipts[1]).toEqual(expect.objectContaining({
                                context: expect.objectContaining({ id: context.id }),
                                property: expect.objectContaining({ id: property.id }),
                                account: expect.objectContaining({ id: account.id }),
                            }))
                        })
                        test('Partly permitted must fail', async () => {
                            await expectToThrowAccessDeniedErrorToObjects(async () => {
                                await createTestBillingReceipts(integrationUser,
                                    [context, anotherContext],
                                    [property, property],
                                    [account, anotherAccount])
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await createTestBillingReceipts(integrationManager, [context], [property], [account])
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await createTestBillingReceipts(user, [context], [property], [account])
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await createTestBillingReceipts(anonymous, [anotherContext], [anotherProperty], [account])
                    })
                })
            })
        })
        describe('Update', () => {
            let receipt
            beforeAll(async () => {
                [receipt] = await createTestBillingReceipt(admin, context, property, account)
            })
            describe('Single object', () => {
                let payload
                beforeEach(() => {
                    payload = {
                        printableNumber:  faker.random.alphaNumeric(32),
                    }
                })
                test('Admin can', async () => {
                    const [updatedReceipt] = await updateTestBillingReceipt(admin, receipt.id, payload)

                    expect(updatedReceipt).toBeDefined()
                    expect(updatedReceipt).toEqual(expect.objectContaining(payload))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestBillingReceipt(support, receipt.id, payload)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

                            expect(updatedReceipt).toBeDefined()
                            expect(updatedReceipt).toEqual(expect.objectContaining(payload))
                        })
                        test('Cannot otherwise', async () => {
                            const [anotherReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount)
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await updateTestBillingReceipt(integrationUser, anotherReceipt.id, payload)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingReceipt(integrationManager, receipt.id, payload)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingReceipt(user, receipt.id, payload)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestBillingReceipt(anonymous, receipt.id, payload)
                    })
                })
            })
            describe('Multiple objects', () => {
                let anotherReceipt
                let payload
                let anotherPayload
                beforeAll(async () => {
                    [anotherReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount)
                })
                beforeEach(() => {
                    payload = {
                        id: receipt.id,
                        data:  {
                            printableNumber: faker.random.alphaNumeric(32),
                        },
                    }
                    anotherPayload = {
                        id: anotherReceipt.id,
                        data:  {
                            printableNumber: faker.random.alphaNumeric(32),
                        },
                    }
                })
                test('Admin can for any context', async () => {
                    const [updatedReceipts] = await updateTestBillingReceipts(admin, [payload, anotherPayload])

                    expect(updatedReceipts).toBeDefined()
                    expect(updatedReceipts).toHaveLength(2)
                    expect(updatedReceipts).toEqual(expect.arrayContaining([
                        expect.objectContaining({ id: payload.id, ...payload.data }),
                        expect.objectContaining({ id: anotherPayload.id, ...anotherPayload.data }),
                    ]))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await updateTestBillingReceipts(support, [payload])
                    })
                })
                describe('User', () => {
                    describe('Integration account can if linked to permitted integration via context', () => {
                        test('All permitted must pass', async () => {
                            const [secondReceipt] = await createTestBillingReceipt(admin, context, property, account)
                            const secondPayload = { ...anotherPayload, id: secondReceipt.id }
                            const [updatedReceipts] = await updateTestBillingReceipts(integrationUser, [payload, secondPayload])

                            expect(updatedReceipts).toBeDefined()
                            expect(updatedReceipts).toHaveLength(2)
                            expect(updatedReceipts).toEqual(expect.arrayContaining([
                                expect.objectContaining({ id: payload.id, ...payload.data }),
                                expect.objectContaining({ id: secondReceipt.id, ...secondPayload.data }),
                            ]))
                        })
                        test('Partly permitted must fail', async () => {
                            await expectToThrowAccessDeniedErrorToObjects(async () => {
                                await updateTestBillingReceipts(integrationUser, [payload, anotherPayload])
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await updateTestBillingReceipts(integrationManager, [payload])
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await updateTestBillingReceipts(user, [payload])
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await updateTestBillingReceipts(anonymous, [payload])
                    })
                })
            })
        })
        describe('Read', () => {
            let receipt
            let anotherReceipt
            beforeAll(async () => {
                [receipt] = await createTestBillingReceipt(admin, context, property, account)
                const [secondReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount)
                anotherReceipt = secondReceipt
            })
            test('Admin can read all', async () => {
                const receipts = await BillingReceipt.getAll(admin, {
                    id_in: [receipt.id, anotherReceipt.id],
                })

                expect(receipts).toHaveLength(2)
                expect(receipts).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: receipt.id }),
                    expect.objectContaining({ id: anotherReceipt.id }),
                ]))
            })
            test('Support cannot', async () => {
                const receipts = await BillingReceipt.getAll(support, {
                    id_in: [receipt.id, anotherReceipt.id],
                })

                expect(receipts).toHaveLength(0)
            })
            describe('User', () => {
                test('Integration account can, but only for permitted integration', async () => {
                    const receipts = await BillingReceipt.getAll(integrationUser, {
                        id_in: [receipt.id, anotherReceipt.id],
                    })

                    expect(receipts).toHaveLength(1)
                    expect(receipts[0]).toHaveProperty('id', receipt.id)
                })
                test('Integration manager can, but only for his organization', async () => {
                    const receipts = await BillingReceipt.getAll(integrationManager, {
                        id_in: [receipt.id, anotherReceipt.id],
                    })

                    expect(receipts).toHaveLength(1)
                    expect(receipts[0]).toHaveProperty('id', receipt.id)
                })
                test('Employee with `canReadBillingReceipts` can, but only for permitted organization', async () => {
                    const reader = await createReceiptsReader(context.organization)
                    const receipts = await BillingReceipt.getAll(reader, {
                        id_in: [receipt.id, anotherReceipt.id],
                    })

                    expect(receipts).toHaveLength(1)
                    expect(receipts[0]).toHaveProperty('id', receipt.id)
                })
                describe('With type resident', () => {
                    let residentWithReceipt
                    beforeEach(async () => {
                        residentWithReceipt = await makeResidentClientWithOwnReceipt()
                    })
                    describe('Can see his own receipt', () => {
                        // NOTE: Using raw requests, since resident have not got access to some fields from gql.js
                        test('With single resident and serviceConsumer', async () => {
                            const { data: { objs: receipts } } = await BillingReceipt.getAll(residentWithReceipt.residentClient, {
                                id: residentWithReceipt.receipt.id,
                            }, { raw: true })

                            expect(receipts).toBeDefined()
                            expect(receipts).toHaveLength(1)
                            expect(receipts[0]).toHaveProperty('id', residentWithReceipt.receipt.id)

                            // Fields with access
                            expect(receipts[0].category).not.toBeNull()
                            expect(receipts[0].toPay).not.toBeNull()
                            expect(receipts[0].toPayDetails).not.toBeNull()
                            expect(receipts[0].services).not.toBeNull()
                            expect(receipts[0].recipient).not.toBeNull()

                            // Fields without access
                            expect(receipts[0].context).toBeNull()
                            expect(receipts[0].property).toBeNull()
                            expect(receipts[0].account).toBeNull()
                            expect(receipts[0].importId).toBeNull()
                            expect(receipts[0].raw).toBeNull()
                        })
                        test('With multiple residents and serviceConsumers', async () => {
                            // Add second receipt in same property
                            const [secondAccount] = await createTestBillingAccount(admin, residentWithReceipt.context, residentWithReceipt.billingProperty, {
                                unitName: residentWithReceipt.resident.unitName,
                                unitType: residentWithReceipt.resident.unitType,
                            })
                            await registerServiceConsumerByTestClient(residentWithReceipt.residentClient, {
                                residentId: residentWithReceipt.resident.id,
                                accountNumber: secondAccount.number,
                                organizationId: residentWithReceipt.organization.id,
                            })
                            const [anotherUnitReceipt] = await createTestBillingReceipt(admin, residentWithReceipt.context, residentWithReceipt.billingProperty, secondAccount)
                            // Add third receipt in another property
                            const { receipt: anotherPropertyReceipt } = await makeResidentClientWithOwnReceipt(residentWithReceipt.residentClient)
                            // Fetch all 3 receipts
                            const { data: { objs: receipts } } = await BillingReceipt.getAll(residentWithReceipt.residentClient, {
                                id_in: [residentWithReceipt.receipt.id, anotherUnitReceipt.id, anotherPropertyReceipt.id],
                            }, { raw: true })

                            expect(receipts).toHaveLength(3)
                            expect(receipts).toEqual(expect.arrayContaining([
                                expect.objectContaining({ id: residentWithReceipt.receipt.id }),
                                expect.objectContaining({ id: anotherUnitReceipt.id }),
                                expect.objectContaining({ id: anotherPropertyReceipt.id }),
                            ]))
                        })
                    })
                    describe('Cannot see receipt', () => {
                        test('If billingAccount unitName is wrong', async () => {
                            const { billingAccount, residentClient, receipt: residentReceipt } = residentWithReceipt
                            await updateTestBillingAccount(admin, billingAccount.id, {
                                unitName: billingAccount.unitName + '1',
                            })
                            const { data: { objs: receipts } } = await BillingReceipt.getAll(residentClient, {
                                id: residentReceipt.id,
                            }, { raw: true })

                            expect(receipts).toHaveLength(0)
                        })
                        test('If serviceConsumer accountNumber is wrong', async () => {
                            const { residentClient, serviceConsumer, receipt: residentReceipt } = residentWithReceipt
                            await updateTestServiceConsumer(admin, serviceConsumer.id, {
                                accountNumber: serviceConsumer.accountNumber + '1',
                            })
                            const { data: { objs: receipts } } = await BillingReceipt.getAll(residentClient, {
                                id: residentReceipt.id,
                            }, { raw: true })

                            expect(receipts).toHaveLength(0)
                        })
                        test('If serviceConsumer context is wrong', async () => {
                            const { residentClient, serviceConsumer, receipt: residentReceipt } = residentWithReceipt
                            const { context: secondContext } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                            await updateTestServiceConsumer(admin, serviceConsumer.id, {
                                billingIntegrationContext: { connect: { id: secondContext.id } },
                            })
                            const { data: { objs: receipts } } = await BillingReceipt.getAll(residentClient, {
                                id: residentReceipt.id,
                            }, { raw: true })

                            expect(receipts).toHaveLength(0)
                        })
                    })
                })
                test('Other users cannot', async () => {
                    const receipts = await BillingReceipt.getAll(user, {
                        id_in: [receipt.id, anotherReceipt.id],
                    })

                    expect(receipts).not.toBeFalsy()
                    expect(receipts).toHaveLength(0)
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await BillingReceipt.getAll(anonymous, {
                        id_in: [account.id, anotherAccount.id],
                    })
                })
            })
        })
        describe('Delete', () => {
            let receipt
            let payload
            beforeEach(async () => {
                [receipt] = await createTestBillingReceipt(admin, context, property, account)
                payload = { deletedAt: dayjs().toISOString() }
            })
            describe('Hard delete is restricted for everyone', () => {
                test('Single object mutation', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(admin, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(support, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(integrationUser, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(integrationManager, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(user, receipt.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingReceipt.delete(anonymous, receipt.id)
                    })
                })
                test('Multiple objects mutation', async () => {
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(admin, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(support, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(integrationUser, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(integrationManager, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(user, [receipt.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingReceipt.deleteMany(anonymous, [receipt.id])
                    })
                })
            })
            describe('Soft delete', () => {
                test('Admin can', async () => {
                    const [updatedReceipt] = await updateTestBillingReceipt(admin, receipt.id, payload)

                    expect(updatedReceipt).toBeDefined()
                    expect(updatedReceipt).toHaveProperty('deletedAt')
                    expect(updatedReceipt.deletedAt).not.toBeNull()
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestBillingReceipt(support, receipt.id, payload)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [updatedAccount] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

                            expect(updatedAccount).toBeDefined()
                            expect(updatedAccount).toHaveProperty('deletedAt')
                            expect(updatedAccount.deletedAt).not.toBeNull()
                        })
                        test('Cannot otherwise', async () => {
                            const [anotherReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount)
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await updateTestBillingReceipt(integrationUser, anotherReceipt.id, payload)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingReceipt(integrationManager, receipt.id, payload)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingReceipt(user, receipt.id, payload)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestBillingReceipt(anonymous, receipt.id, payload)
                    })
                })
            })
        })
    })
    describe('Constraints', () => {
        describe('Import ID', () => {
            let importId
            let receipt
            beforeEach(async () => {
                importId = faker.datatype.uuid()
                const [firstReceipt] = await createTestBillingReceipt(admin, context, property, account, { importId })
                receipt = firstReceipt
            })
            test('Receipt with same importId can exist in different context', async () => {
                const [anotherReceipt] = await createTestBillingReceipt(admin, anotherContext, anotherProperty, anotherAccount, { importId })

                expect(receipt).toHaveProperty('importId', importId)
                expect(anotherReceipt).toHaveProperty('importId', importId)
            })
            test('Receipt with same importId cannot exist in same context', async () => {
                await expectToThrowInternalError(async () => {
                    await createTestBillingReceipt(admin, context, property, account, { importId })
                }, 'BillingReceipt_importId_9da6acbf_uniq')
            })
        })
    })
    describe('Validations', () => {
        let importId
        let receipt
        beforeEach(async () => {
            importId = faker.datatype.uuid()
            const [firstReceipt] = await createTestBillingReceipt(admin, context, property, account, { importId })
            receipt = firstReceipt
        })
        describe('importId', () => {
            describe('Cannot create receipt with falsy importId', () => {
                const cases = [
                    ['null', null, '"importId" is null or undefined'],
                    ['undefined', undefined, '"importId" is null or undefined'],
                    ['empty string', '', `${WRONG_TEXT_FORMAT}importId]`],
                ]
                test.each(cases)('%p', async (name, value, errorMessageContains) => {
                    await expectToThrowValidationFailureError(async () => {
                        await createTestBillingReceipt(admin, context, property, account, { importId: value })
                    }, errorMessageContains)
                })
            })
            describe('Can update importId', () => {
                test('To different value', async () => {
                    expect(receipt).toHaveProperty('importId', importId)

                    const newImportId = faker.datatype.uuid()
                    const [updatedReceipt] = await updateTestBillingReceipt(admin, receipt.id, { importId: newImportId })

                    expect(updatedReceipt).toHaveProperty('importId', newImportId)
                })
                test('To same value', async () => {
                    expect(receipt).toHaveProperty('importId', importId)

                    const [updatedReceipt] = await updateTestBillingReceipt(admin, receipt.id, { importId })

                    expect(updatedReceipt).toHaveProperty('importId', importId)
                })
            })
        })
        describe('toPayDetails', () => {
            test('Must have formula', async () => {
                const payload = {
                    toPayDetails: {
                        charge: '12341.21',
                        penalty: '200.12',
                    },
                }
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestBillingReceipt(admin, receipt.id, payload)
                }, '"data.toPayDetails"; Field "formula" of required type "String!" was not provided.')
            })
        })
        describe('period', () => {
            test('Day of period must be equal to 01', async () => {
                await expectToThrowValidationFailureError(async () => {
                    await createTestBillingReceipt(admin, context, property, account, {
                        period: '2022-02-15',
                    })
                }, 'period field validation error. Period day should always be equal to 01')
            })
        })
        describe('services', () => {
            describe('toPayDetails', () => {
                test('Must have formula', async () => {
                    const payload = {
                        services: [
                            {
                                id: '1',
                                toPay: '1200.00',
                                name: 'Water',
                                // No formula
                                toPayDetails: {
                                    charge: '12341.21',
                                    penalty: '200.12',
                                },
                            },
                        ],
                    }
                    await expectToThrowGraphQLRequestError(async () => {
                        await updateTestBillingReceipt(admin, receipt.id, payload)
                    }, '"data.services[0].toPayDetails"; Field "formula" of required type "String!" was not provided.')
                })
            })
            test('Each service must have a name', async () => {
                const payload = {
                    services: [
                        {
                            toPay: '1200.22',
                            toPayDetails: {
                                formula: 'charge+penalty',
                                charge: '12341.21',
                                penalty: '200.12',
                            },
                        },
                    ],
                }
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestBillingReceipt(admin, receipt.id, payload)
                }, '"data.services[0]"; Field "name" of required type "String!" was not provided.')
            })
        })
        describe('toPay', () => {
            test('Must be Decimal', async () => {
                const payload = {
                    toPay: '22.92',
                }
                const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

                expect(updatedReceipt).toHaveProperty('toPay', '22.92000000')
            })
        })
        describe('context', () => {
            test('Context field cannot be changed', async () => {
                const [billingReceipt] = await createTestBillingReceipt(admin, context, property, account)
                await expectToThrowGraphQLRequestError(async () => {
                    await updateTestBillingReceipt(admin, billingReceipt.id, {
                        context: { connect: { id: anotherContext.id } },
                    })
                }, 'Field "context" is not defined')
            })
        })
        test('Context and contexts from "account" and "property" fields must be equal', async () => {
            const [billingReceipt] = await createTestBillingReceipt(admin, context, property, account)
            await expectToThrowValidationFailureError(async () => {
                await updateTestBillingReceipt(admin, billingReceipt.id, {
                    account: { connect: { id: anotherAccount.id } },
                })
            }, `${UNEQUAL_CONTEXT_ERROR}:account:context] Context is not equal to account.context`)
            await expectToThrowValidationFailureError(async () => {
                await updateTestBillingReceipt(admin, billingReceipt.id, {
                    property: { connect: { id: anotherProperty.id } },
                })
            }, `${UNEQUAL_CONTEXT_ERROR}:property:context] Context is not equal to property.context`)
        })
    })
    describe('Integration user can perform all needed actions', () => {
        let importId
        let receipt
        beforeEach(async () => {
            importId = faker.datatype.uuid()
            const [firstReceipt] = await createTestBillingReceipt(admin, context, property, account, { importId })
            receipt = firstReceipt
        })
        test('Restore soft-deleted receipt', async () => {
            expect(receipt).toHaveProperty('deletedAt')
            expect(receipt.deletedAt).toBeNull()

            const [deletedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, { deletedAt: dayjs().toISOString() })

            expect(deletedReceipt).toHaveProperty('id', receipt.id)
            expect(deletedReceipt).toHaveProperty('deletedAt')
            expect(deletedReceipt.deletedAt).not.toBeNull()

            const [restoredReceipt] = await updateTestBillingReceipt(integrationUser, deletedReceipt.id, { deletedAt: null })

            expect(restoredReceipt).toHaveProperty('id', receipt.id)
            expect(restoredReceipt).toHaveProperty('deletedAt')
            expect(restoredReceipt.deletedAt).toBeNull()
        })
        test('Update toPayDetail field', async () => {
            const payload = {
                toPayDetails: {
                    formula: 'charge+penalty',
                    charge: '12341.21',
                    penalty: '200.12',
                    privilege: null,
                },
            }
            const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

            expect(updatedReceipt).toEqual(expect.objectContaining({
                toPayDetails: expect.objectContaining(payload.toPayDetails),
            }))
        })
        test('Update services field', async () => {
            const payload = {
                services: [
                    {
                        id: 'COLD-WATER',
                        name: 'Cold water',
                        toPay: '3000.00',
                        toPayDetails: {
                            formula: 'charge+penalty',
                            charge: '6000.00',
                            penalty: '3000.12',
                        },
                    },
                    {
                        id: 'HOT-WATER',
                        name: 'Hot water',
                        toPay: '3000.00',
                        toPayDetails: {
                            formula: 'charge+penalty',
                            charge: '6000.00',
                            penalty: '3000.12',
                        },
                    },
                    {
                        id: 'ELECTRICITY',
                        name: 'Electricity to power your toxicity!',
                        toPay: '3000.00',
                        toPayDetails: {
                            formula: 'charge+penalty',
                            charge: '6000.00',
                            penalty: '3000.12',
                        },
                    },
                ],
            }
            const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

            expect(updatedReceipt).toEqual(expect.objectContaining({
                services: expect.arrayContaining(
                    payload.services.map(service => expect.objectContaining({
                        ...service,
                        toPayDetails: expect.objectContaining(service.toPayDetails),
                    }))
                ),
            }))
        })
        test('Update period field', async () => {
            const payload = {
                period: '2011-12-01',
            }
            const [updatedReceipt] = await updateTestBillingReceipt(integrationUser, receipt.id, payload)

            expect(updatedReceipt).toEqual(expect.objectContaining(payload))
        })
    })
    describe('Hooks', () => {
        describe('receiver field', () => {
            test('Should create recipient and set receiver field automatically', async () => {
                const [receipt, attrs] = await createTestBillingReceipt(admin, context, property, account)

                expect(attrs).not.toHaveProperty('receiver')
                expect(attrs).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
            })
            test('Should create recipient and set receiver.isApproved field automatically if billing integration is trusted and tin matches', async () => {
                const { context: trustedBillingContext, organization: trustedOrganization } = await makeContextWithOrganizationAndIntegrationAsAdmin( { isTrustedBankAccountSource: true })
                const tin = trustedOrganization.tin
                const [trustedProperty] = await createTestBillingProperty(admin, trustedBillingContext)
                const [trustedAccount] = await createTestBillingAccount(admin, trustedBillingContext, trustedProperty)
                const [receipt, attrs] = await createTestBillingReceipt(admin, trustedBillingContext, trustedProperty, trustedAccount, { recipient: createTestRecipient({ tin: tin }) })

                expect(attrs).not.toHaveProperty('receiver')
                expect(attrs).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
                expect(receipt).toHaveProperty(['receiver', 'isApproved'], true)
            })
            test('Should create recipient and not set receiver.isApproved field automatically if billing integration is not trusted and tin matches', async () => {
                const { context: trustedBillingContext, organization: trustedOrganization } = await makeContextWithOrganizationAndIntegrationAsAdmin( { isTrustedBankAccountSource: false })
                const tin = trustedOrganization.tin
                const [trustedProperty] = await createTestBillingProperty(admin, trustedBillingContext)
                const [trustedAccount] = await createTestBillingAccount(admin, trustedBillingContext, trustedProperty)
                const [receipt, attrs] = await createTestBillingReceipt(admin, trustedBillingContext, trustedProperty, trustedAccount, { recipient: createTestRecipient({ tin: tin }) })

                expect(attrs).not.toHaveProperty('receiver')
                expect(attrs).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
                expect(receipt).toHaveProperty(['receiver', 'isApproved'], false)
            })
            test('Should create recipient and not set receiver.isApproved field automatically if billing integration is trusted and tin do not match', async () => {
                const { context: trustedBillingContext, organization: trustedOrganization } = await makeContextWithOrganizationAndIntegrationAsAdmin( { isTrustedBankAccountSource: true })
                const tin = trustedOrganization.tin
                const [trustedProperty] = await createTestBillingProperty(admin, trustedBillingContext)
                const [trustedAccount] = await createTestBillingAccount(admin, trustedBillingContext, trustedProperty)
                const [receipt, attrs] = await createTestBillingReceipt(admin, trustedBillingContext, trustedProperty, trustedAccount, { recipient: createTestRecipient({ tin: tin + '0' }) })

                expect(attrs).not.toHaveProperty('receiver')
                expect(attrs).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['recipient', 'tin'])
                expect(receipt).toHaveProperty(['receiver', 'tin'], receipt.recipient.tin)
                expect(receipt).toHaveProperty(['receiver', 'isApproved'], false)
            })
            test('Should connect to existing recipient, if passed explicitly', async () => {
                const recipientAttrs = createTestRecipient()
                const receiptRecipientField = pick(recipientAttrs, ['tin', 'bic', 'iec', 'bankAccount'])
                const [recipient] = await createTestBillingRecipient(admin, context, recipientAttrs)
                const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                    recipient: receiptRecipientField,
                    receiver: { connect: { id: recipient.id } },
                })

                expect(receipt).toHaveProperty(['recipient', 'tin'], recipient.tin)
                expect(receipt).toHaveProperty(['receiver', 'id'], recipient.id)
            })
            test('Should automatically connect to existing recipient, if receiver is not passed', async () => {
                const recipientAttrs = createTestRecipient()
                const receiptRecipientField = pick(recipientAttrs, ['tin', 'bic', 'iec', 'bankAccount'])
                const [recipient] = await createTestBillingRecipient(admin, context, recipientAttrs)
                const [receipt] = await createTestBillingReceipt(admin, context, property, account, {
                    recipient: receiptRecipientField,
                })

                expect(receipt).toHaveProperty(['recipient', 'tin'], recipient.tin)
                expect(receipt).toHaveProperty(['receiver', 'id'], recipient.id)
            })
        })
    })
})