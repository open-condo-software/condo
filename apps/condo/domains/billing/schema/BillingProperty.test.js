/**
 * Generated by `createschema billing.BillingProperty 'context:Relationship:BillingIntegrationOrganizationContext:CASCADE; importId?:Text; bindingId:Text; address:Text; raw:Json; meta:Json'`
 */
const faker = require('faker')
const dayjs = require('dayjs')
const {
    makeServiceUserForIntegration,
    makeOrganizationIntegrationManager,
    makeContextWithOrganizationAndIntegrationAsAdmin,
    createReceiptsReader,
    BillingProperty,
    createTestBillingProperty,
    updateTestBillingProperty,
} = require('@condo/domains/billing/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
} = require('@condo/domains/user/utils/testSchema')
const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowInternalError,
} = require('@condo/domains/common/utils/testSchema')
const { makeClient } = require('@core/keystone/test.utils')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')


describe('BillingProperty', () => {
    let admin
    let support
    let anonymous
    let user
    let context
    let integrationUser
    let integrationManager
    let anotherContext
    beforeAll(async () => {
        const { admin: adminClient, context: billingContext, integration } = await makeContextWithOrganizationAndIntegrationAsAdmin()
        admin = adminClient
        context = billingContext
        integrationUser = await makeServiceUserForIntegration(integration)
        support = await makeClientWithSupportUser()
        const { context: secondContext } = await makeContextWithOrganizationAndIntegrationAsAdmin()
        anotherContext = secondContext
        anonymous = await makeClient()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        const { managerUserClient } = await makeOrganizationIntegrationManager(context)
        integrationManager = managerUserClient
    })
    describe('CRUD', () => {
        describe('Create', () => {
            describe('Single object', () => {
                test('Admin can', async () => {
                    const [property] = await createTestBillingProperty(admin, context)
                    expect(property).toBeDefined()
                    expect(property).toHaveProperty(['context', 'id'], context.id)
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestBillingProperty(support, anotherContext)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [property] = await createTestBillingProperty(integrationUser, context)
                            expect(property).toBeDefined()
                            expect(property).toHaveProperty(['context', 'id'], context.id)
                        })
                        test('Cannot otherwise', async () => {
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await createTestBillingProperty(integrationUser, anotherContext)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await createTestBillingProperty(integrationManager, anotherContext)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await createTestBillingProperty(user, anotherContext)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await createTestBillingProperty(anonymous, anotherContext)
                    })
                })
            })
        })
        describe('Update', () => {
            let property
            let payload
            beforeAll(async () => {
                [property] = await createTestBillingProperty(admin, context)
            })
            beforeEach(async () => {
                payload = {
                    raw: faker.lorem.words(),
                    // TODO (DOMA-2224): generate address correctly
                    address: faker.lorem.words(),
                }
            })
            describe('Single object', () => {
                test('Admin can', async () => {
                    const [updatedProperty] = await updateTestBillingProperty(admin, property.id, payload)
                    expect(updatedProperty).toBeDefined()
                    expect(updatedProperty).toEqual(expect.objectContaining(payload))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestBillingProperty(support, property.id, payload)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [updatedProperty] = await updateTestBillingProperty(integrationUser, property.id, payload)
                            expect(updatedProperty).toBeDefined()
                            expect(updatedProperty).toEqual(expect.objectContaining(payload))
                        })
                        test('Cannot otherwise', async () => {
                            const [anotherProperty] = await createTestBillingProperty(admin, anotherContext)
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await updateTestBillingProperty(integrationUser, anotherProperty.id, payload)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingProperty(integrationManager, property.id, payload)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingProperty(user, property.id, payload)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestBillingProperty(anonymous, property.id, payload)
                    })
                })
            })
        })
        describe('Read', () => {
            let property
            let anotherProperty
            beforeAll(async () => {
                [property] = await createTestBillingProperty(admin, context)
                const [secondProperty] = await createTestBillingProperty(admin, anotherContext)
                anotherProperty = secondProperty
            })
            test('Admin can read all', async () => {
                const properties = await BillingProperty.getAll(admin, {
                    id_in: [property.id, anotherProperty.id],
                })
                expect(properties).toHaveLength(2)
                expect(properties).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: property.id }),
                    expect.objectContaining({ id: anotherProperty.id }),
                ]))
            })
            test('Support can read all', async () => {
                const properties = await BillingProperty.getAll(support, {
                    id_in: [property.id, anotherProperty.id],
                })
                expect(properties).toHaveLength(2)
                expect(properties).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: property.id }),
                    expect.objectContaining({ id: anotherProperty.id }),
                ]))
            })
            describe('User', () => {
                test('Integration account can, but only for permitted integration', async () => {
                    const properties = await BillingProperty.getAll(integrationUser, {
                        id_in: [property.id, anotherProperty.id],
                    })
                    expect(properties).toHaveLength(1)
                    expect(properties[0]).toHaveProperty('id', property.id)
                })
                test('Integration manager can, but only for his organization', async () => {
                    const properties = await BillingProperty.getAll(integrationUser, {
                        id_in: [property.id, anotherProperty.id],
                    })
                    expect(properties).toHaveLength(1)
                    expect(properties[0]).toHaveProperty('id', property.id)
                })
                test('Employee with `canReadBillingReceipts` can, but only for permitted organization', async () => {
                    const reader = await createReceiptsReader(context.organization)
                    const properties = await BillingProperty.getAll(reader, {
                        id_in: [property.id, anotherProperty.id],
                    })
                    expect(properties).toHaveLength(1)
                    expect(properties[0]).toHaveProperty('id', property.id)
                })
                test('Other users cannot', async () => {
                    const properties = await BillingProperty.getAll(user, {
                        id_in: [property.id, anotherProperty.id],
                    })
                    expect(properties).not.toBeFalsy()
                    expect(properties).toHaveLength(0)
                })
            })
            test('Anonymous cannot', async () => {
                const properties = await BillingProperty.getAll(user, {
                    id_in: [property.id, anotherProperty.id],
                })
                expect(properties).not.toBeFalsy()
                expect(properties).toHaveLength(0)
            })
        })
        describe('Delete', () => {
            let property
            let payload
            beforeEach(async () => {
                [property] = await createTestBillingProperty(admin, context)
                payload = { deletedAt: dayjs().toISOString() }
            })
            test('Hard delete is restricted for everyone', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BillingProperty.delete(admin, property.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BillingProperty.delete(support, property.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BillingProperty.delete(integrationUser, property.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BillingProperty.delete(integrationManager, property.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BillingProperty.delete(user, property.id)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BillingProperty.delete(anonymous, property.id)
                })
            })
            describe('Soft delete', () => {
                test('Admin can', async () => {
                    const [updatedProperty] = await updateTestBillingProperty(admin, property.id, payload)
                    expect(updatedProperty).toBeDefined()
                    expect(updatedProperty).toHaveProperty('deletedAt')
                    expect(updatedProperty.deletedAt).not.toBeNull()
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestBillingProperty(support, property.id, payload)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [updatedProperty] = await updateTestBillingProperty(integrationUser, property.id, payload)
                            expect(updatedProperty).toBeDefined()
                            expect(updatedProperty).toHaveProperty('deletedAt')
                            expect(updatedProperty.deletedAt).not.toBeNull()
                        })
                        test('Cannot otherwise', async () => {
                            const [anotherProperty] = await createTestBillingProperty(admin, anotherContext)
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await updateTestBillingProperty(integrationUser, anotherProperty.id, payload)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingProperty(integrationManager, property.id, payload)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingProperty(user, property.id, payload)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestBillingProperty(anonymous, property.id, payload)
                    })
                })
            })
        })
    })
    describe('Constraints', () => {
        describe('globalId', () => {
            let globalId
            beforeEach(async () => {
                globalId = faker.datatype.uuid()
            })
            test('Can be same if context is different', async () => {
                const [property] = await createTestBillingProperty(admin, context, {
                    globalId,
                })
                expect(property).toBeDefined()
                expect(property).toHaveProperty('globalId', globalId)
                const [anotherProperty] = await createTestBillingProperty(admin, anotherContext, {
                    globalId,
                })
                expect(anotherProperty).toBeDefined()
                expect(anotherProperty).toHaveProperty('globalId', globalId)
            })
            test('Must be unique within the same context', async () => {
                const [property] = await createTestBillingProperty(admin, context, {
                    globalId,
                })
                expect(property).toBeDefined()
                expect(property).toHaveProperty('globalId', globalId)
                await expectToThrowInternalError(async () => {
                    await createTestBillingProperty(admin, context, {
                        globalId,
                    })
                }, 'billingProperty_unique_context_globalId')
            })
        })
    })
    describe('Resolvers', () => {
        describe('Property field resolver', () => {
            test('Property with same address and organization must be assigned to BillingProperty', async () => {
                const [property] = await createTestProperty(admin, context.organization)
                const [billingProperty] = await createTestBillingProperty(admin, context, {
                    address: property.address,
                })
                expect(billingProperty).toBeDefined()
                expect(billingProperty).toHaveProperty(['property', 'id'], property.id)
            })
            test('Property with same address and different organization must not be assigned to BillingProperty', async () => {
                const [property] = await createTestProperty(admin, context.organization)
                const [billingProperty] = await createTestBillingProperty(admin, anotherContext, {
                    address: property.address,
                })
                expect(billingProperty).toBeDefined()
                expect(billingProperty).toHaveProperty('property', null)
            })
            test('Property with different address and same organization must not be assigned to BillingProperty', async () => {
                const [property] = await createTestProperty(admin, context.organization)
                const [billingProperty] = await createTestBillingProperty(admin, context, {
                    // TODO (DOMA-2224): generate address correctly
                    address: `${property.address}${faker.random.alphaNumeric(1)}`,
                })
                expect(billingProperty).toBeDefined()
                expect(billingProperty).toHaveProperty('property', null)
            })
        })
    })
})