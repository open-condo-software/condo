/**
 * Generated by `createschema billing.BillingProperty 'context:Relationship:BillingIntegrationOrganizationContext:CASCADE; importId?:Text; bindingId:Text; address:Text; raw:Json; meta:Json'`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAccessDeniedErrorToObjects,
    expectToThrowInternalError,
    expectToThrowGraphQLRequestError,
} = require('@open-condo/keystone/test.utils')
const { makeClient } = require('@open-condo/keystone/test.utils')

const {
    makeServiceUserForIntegration,
    makeOrganizationIntegrationManager,
    makeContextWithOrganizationAndIntegrationAsAdmin,
    createReceiptsReader,
    BillingProperty,
    createTestBillingProperty,
    createTestBillingProperties,
    updateTestBillingProperty,
    updateTestBillingProperties,
} = require('@condo/domains/billing/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithSupportUser,
} = require('@condo/domains/user/utils/testSchema')


describe('BillingProperty', () => {
    let admin
    let support
    let anonymous
    let user
    let context
    let integrationUser
    let integrationManager
    let anotherContext
    beforeAll(async () => {
        const { admin: adminClient, context: billingContext, integration } = await makeContextWithOrganizationAndIntegrationAsAdmin()
        admin = adminClient
        context = billingContext
        integrationUser = await makeServiceUserForIntegration(integration)
        support = await makeClientWithSupportUser()
        const { context: secondContext } = await makeContextWithOrganizationAndIntegrationAsAdmin()
        anotherContext = secondContext
        anonymous = await makeClient()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        const { managerUserClient } = await makeOrganizationIntegrationManager({ context })
        integrationManager = managerUserClient
    })
    describe('CRUD', () => {
        describe('Create', () => {
            describe('Single object', () => {
                test('Admin can', async () => {
                    const [property] = await createTestBillingProperty(admin, context)
                    expect(property).toBeDefined()
                    expect(property).toHaveProperty(['context', 'id'], context.id)
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestBillingProperty(support, anotherContext)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [property] = await createTestBillingProperty(integrationUser, context)
                            expect(property).toBeDefined()
                            expect(property).toHaveProperty(['context', 'id'], context.id)
                        })
                        test('Cannot otherwise', async () => {
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await createTestBillingProperty(integrationUser, anotherContext)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await createTestBillingProperty(integrationManager, context)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await createTestBillingProperty(user, anotherContext)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await createTestBillingProperty(anonymous, anotherContext)
                    })
                })
            })
            describe('Multiple objects', () => {
                test('Admin can for any context', async () => {
                    const [properties] = await createTestBillingProperties(admin, [context, anotherContext])
                    expect(properties).toBeDefined()
                    expect(properties).toHaveLength(2)
                    expect(properties).toEqual(expect.arrayContaining([
                        expect.objectContaining({ context: expect.objectContaining({ id: context.id }) }),
                        expect.objectContaining({ context: expect.objectContaining({ id: anotherContext.id }) }),
                    ]))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await createTestBillingProperties(support, [context])
                    })
                })
                describe('User', () => {
                    describe('Integration account can if linked to permitted integration via context', () => {
                        test('All permitted contexts should pass', async () => {
                            const [properties] = await createTestBillingProperties(integrationUser, [context, context])
                            expect(properties).toBeDefined()
                            expect(properties).toHaveLength(2)
                            expect(properties[0]).toEqual(expect.objectContaining({ context: expect.objectContaining({ id: context.id }) }))
                            expect(properties[1]).toEqual(expect.objectContaining({ context: expect.objectContaining({ id: context.id }) }))
                        })
                        test('Partly permitted must fail', async () => {
                            await expectToThrowAccessDeniedErrorToObjects(async () => {
                                await createTestBillingProperties(integrationUser, [context, anotherContext])
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await createTestBillingProperties(integrationManager, [context])
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await createTestBillingProperties(user, [context])
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await createTestBillingProperties(anonymous, [anotherContext])
                    })
                })
            })
        })
        describe('Update', () => {
            let property
            beforeAll(async () => {
                [property] = await createTestBillingProperty(admin, context)
            })
            describe('Single object', () => {
                let payload
                beforeEach(() => {
                    payload = {
                        raw: faker.lorem.words(),
                        // TODO (DOMA-2224): generate address correctly
                        address: faker.lorem.words(),
                    }
                })
                test('Admin can', async () => {
                    const [updatedProperty] = await updateTestBillingProperty(admin, property.id, payload)
                    expect(updatedProperty).toBeDefined()
                    expect(updatedProperty).toEqual(expect.objectContaining(payload))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestBillingProperty(support, property.id, payload)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [updatedProperty] = await updateTestBillingProperty(integrationUser, property.id, payload)
                            expect(updatedProperty).toBeDefined()
                            expect(updatedProperty).toEqual(expect.objectContaining(payload))
                        })
                        test('Cannot otherwise', async () => {
                            const [anotherProperty] = await createTestBillingProperty(admin, anotherContext)
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await updateTestBillingProperty(integrationUser, anotherProperty.id, payload)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingProperty(integrationManager, property.id, payload)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingProperty(user, property.id, payload)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestBillingProperty(anonymous, property.id, payload)
                    })
                })
            })
            describe('Multiple objects', () => {
                let anotherProperty
                let payload
                let anotherPayload
                beforeAll(async () => {
                    [anotherProperty] = await createTestBillingProperty(admin, anotherContext)
                })
                beforeEach(() => {
                    payload = {
                        id: property.id,
                        data: {
                            raw: faker.lorem.words(),
                            // TODO (DOMA-2224): generate address correctly
                            address: faker.lorem.words(),
                        },
                    }
                    anotherPayload = {
                        id: anotherProperty.id,
                        data: {
                            raw: faker.lorem.words(),
                            // TODO (DOMA-2224): generate address correctly
                            address: faker.lorem.words(),
                        },
                    }
                })
                test('Admin can for any context', async () => {
                    const [updatedProperties] = await updateTestBillingProperties(admin, [payload, anotherPayload])
                    expect(updatedProperties).toBeDefined()
                    expect(updatedProperties).toHaveLength(2)
                    expect(updatedProperties).toEqual(expect.arrayContaining([
                        expect.objectContaining({ id: payload.id, ...payload.data }),
                        expect.objectContaining({ id: anotherPayload.id, ...anotherPayload.data }),
                    ]))
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await updateTestBillingProperties(support, [payload])
                    })
                })
                describe('User', () => {
                    describe('Integration account can if linked to permitted integration via context', () => {
                        test('All permitted must pass', async () => {
                            const [secondProperty] = await createTestBillingProperty(admin, context)
                            const secondPayload = { ...anotherPayload, id: secondProperty.id }
                            const [updatedProperties] = await updateTestBillingProperties(integrationUser, [payload, secondPayload])
                            expect(updatedProperties).toBeDefined()
                            expect(updatedProperties).toHaveLength(2)
                            expect(updatedProperties).toEqual(expect.arrayContaining([
                                expect.objectContaining({ id: payload.id, ...payload.data }),
                                expect.objectContaining({ id: secondProperty.id, ...secondPayload.data }),
                            ]))
                        })
                        test('Partly permitted must fail', async () => {
                            await expectToThrowAccessDeniedErrorToObjects(async () => {
                                await updateTestBillingProperties(integrationUser, [payload, anotherPayload])
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await updateTestBillingProperties(integrationManager, [payload])
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObjects(async () => {
                            await updateTestBillingProperties(user, [payload])
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await updateTestBillingProperties(anonymous, [payload])
                    })
                })
            })
        })
        describe('Read', () => {
            let property
            let anotherProperty
            beforeAll(async () => {
                [property] = await createTestBillingProperty(admin, context)
                const [secondProperty] = await createTestBillingProperty(admin, anotherContext)
                anotherProperty = secondProperty
            })
            test('Admin can read all', async () => {
                const properties = await BillingProperty.getAll(admin, {
                    id_in: [property.id, anotherProperty.id],
                })
                expect(properties).toHaveLength(2)
                expect(properties).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: property.id }),
                    expect.objectContaining({ id: anotherProperty.id }),
                ]))
            })
            test('Support can read all', async () => {
                const properties = await BillingProperty.getAll(support, {
                    id_in: [property.id, anotherProperty.id],
                })
                expect(properties).toHaveLength(2)
                expect(properties).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: property.id }),
                    expect.objectContaining({ id: anotherProperty.id }),
                ]))
            })
            describe('User', () => {
                test('Integration account can, but only for permitted integration', async () => {
                    const properties = await BillingProperty.getAll(integrationUser, {
                        id_in: [property.id, anotherProperty.id],
                    })
                    expect(properties).toHaveLength(1)
                    expect(properties[0]).toHaveProperty('id', property.id)
                })
                test('Integration manager can, but only for his organization', async () => {
                    const properties = await BillingProperty.getAll(integrationUser, {
                        id_in: [property.id, anotherProperty.id],
                    })
                    expect(properties).toHaveLength(1)
                    expect(properties[0]).toHaveProperty('id', property.id)
                })
                test('Employee with `canReadBillingReceipts` can, but only for permitted organization', async () => {
                    const reader = await createReceiptsReader(context.organization)
                    const properties = await BillingProperty.getAll(reader, {
                        id_in: [property.id, anotherProperty.id],
                    })
                    expect(properties).toHaveLength(1)
                    expect(properties[0]).toHaveProperty('id', property.id)
                })
                test('Other users cannot', async () => {
                    const properties = await BillingProperty.getAll(user, {
                        id_in: [property.id, anotherProperty.id],
                    })
                    expect(properties).not.toBeFalsy()
                    expect(properties).toHaveLength(0)
                })
            })
            test('Anonymous cannot', async () => {
                const properties = await BillingProperty.getAll(user, {
                    id_in: [property.id, anotherProperty.id],
                })
                expect(properties).not.toBeFalsy()
                expect(properties).toHaveLength(0)
            })
        })
        describe('Delete', () => {
            let property
            let payload
            beforeEach(async () => {
                [property] = await createTestBillingProperty(admin, context)
                payload = { deletedAt: dayjs().toISOString() }
            })
            describe('Hard delete is restricted for everyone', () => {
                test('Single object mutation', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingProperty.delete(admin, property.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingProperty.delete(support, property.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingProperty.delete(integrationUser, property.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingProperty.delete(integrationManager, property.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingProperty.delete(user, property.id)
                    })
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await BillingProperty.delete(anonymous, property.id)
                    })
                })
                test('Multiple objects mutation', async () => {
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingProperty.deleteMany(admin, [property.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingProperty.deleteMany(support, [property.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingProperty.deleteMany(integrationUser, [property.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingProperty.deleteMany(integrationManager, [property.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingProperty.deleteMany(user, [property.id])
                    })
                    await expectToThrowAccessDeniedErrorToObjects(async () => {
                        await BillingProperty.deleteMany(anonymous, [property.id])
                    })
                })
            })
            describe('Soft delete', () => {
                test('Admin can', async () => {
                    const [updatedProperty] = await updateTestBillingProperty(admin, property.id, payload)
                    expect(updatedProperty).toBeDefined()
                    expect(updatedProperty).toHaveProperty('deletedAt')
                    expect(updatedProperty.deletedAt).not.toBeNull()
                })
                test('Support cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestBillingProperty(support, property.id, payload)
                    })
                })
                describe('User', () => {
                    describe('Integration account', () => {
                        test('Can if linked to permitted integration via context', async () => {
                            const [updatedProperty] = await updateTestBillingProperty(integrationUser, property.id, payload)
                            expect(updatedProperty).toBeDefined()
                            expect(updatedProperty).toHaveProperty('deletedAt')
                            expect(updatedProperty.deletedAt).not.toBeNull()
                        })
                        test('Cannot otherwise', async () => {
                            const [anotherProperty] = await createTestBillingProperty(admin, anotherContext)
                            await expectToThrowAccessDeniedErrorToObj(async () => {
                                await updateTestBillingProperty(integrationUser, anotherProperty.id, payload)
                            })
                        })
                    })
                    test('Integration manager cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingProperty(integrationManager, property.id, payload)
                        })
                    })
                    test('Other users cannot', async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await updateTestBillingProperty(user, property.id, payload)
                        })
                    })
                })
                test('Anonymous cannot', async () => {
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestBillingProperty(anonymous, property.id, payload)
                    })
                })
            })
        })
    })
    describe('Constraints', () => {
        describe('globalId', () => {
            let globalId
            beforeEach(async () => {
                globalId = faker.datatype.uuid()
            })
            test('Can be same if context is different', async () => {
                const [property] = await createTestBillingProperty(admin, context, {
                    globalId,
                })
                expect(property).toBeDefined()
                expect(property).toHaveProperty('globalId', globalId)
                const [anotherProperty] = await createTestBillingProperty(admin, anotherContext, {
                    globalId,
                })
                expect(anotherProperty).toBeDefined()
                expect(anotherProperty).toHaveProperty('globalId', globalId)
            })
            test('Must be unique within the same context', async () => {
                const [property] = await createTestBillingProperty(admin, context, {
                    globalId,
                })
                expect(property).toBeDefined()
                expect(property).toHaveProperty('globalId', globalId)
                await expectToThrowInternalError(async () => {
                    await createTestBillingProperty(admin, context, {
                        globalId,
                    })
                }, 'billingProperty_unique_context_globalId')
            })
        })
    })
    describe('Resolvers', () => {
        describe('Property field resolver', () => {
            test('Property with same address and organization must be assigned to BillingProperty', async () => {
                const [property] = await createTestProperty(admin, context.organization)
                const [billingProperty] = await createTestBillingProperty(admin, context, {
                    address: property.address,
                })
                expect(billingProperty).toBeDefined()
                expect(billingProperty).toHaveProperty(['property', 'id'], property.id)
            })
            test('Property with same address and different organization must not be assigned to BillingProperty', async () => {
                const [property] = await createTestProperty(admin, context.organization)
                const [billingProperty] = await createTestBillingProperty(admin, anotherContext, {
                    address: property.address,
                })
                expect(billingProperty).toBeDefined()
                expect(billingProperty).toHaveProperty('property', null)
            })
            test('Property with different address and same organization must not be assigned to BillingProperty', async () => {
                const [property] = await createTestProperty(admin, context.organization)
                const [billingProperty] = await createTestBillingProperty(admin, context, {
                    // TODO (DOMA-2224): generate address correctly
                    address: `${property.address}${faker.random.alphaNumeric(1)}`,
                })
                expect(billingProperty).toBeDefined()
                expect(billingProperty).toHaveProperty('property', null)
            })
        })
    })
    describe('Validations', () => {
        // NOTE: This is common KeystoneJS behaviour, so it does not depend on any particular access function
        // These tests are used to check this behavior for different keystone versions and there's no need
        // to spread them across all models
        describe('Database must not be changed if have partial access', () => {
            test('On create', async () => {
                const { integration, context: newContext } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const newIntegrationUser = await makeServiceUserForIntegration(integration)
                const propertiesBefore = await BillingProperty.getAll(admin, {
                    context: { id: newContext.id },
                })
                expect(propertiesBefore).toHaveLength(0)
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await createTestBillingProperties(newIntegrationUser, [newContext, anotherContext])
                })
                const propertiesAfter = await BillingProperty.getAll(admin, {
                    context: { id: newContext.id },
                })
                expect(propertiesAfter).toHaveLength(0)
            })
        })
        test('On update', async () => {
            const [[property, anotherProperty]] = await createTestBillingProperties(admin, [context, anotherContext])
            const payload = [
                { id: property.id, data: { deletedAt: dayjs().toISOString() } },
                { id: anotherProperty.id, data: { deletedAt: dayjs().toISOString() } },
            ]
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await updateTestBillingProperties(integrationUser, payload)
            })
            const properties = await BillingProperty.getAll(admin, {
                id_in: [property.id, anotherProperty.id],
            })
            expect(properties).toHaveLength(2)
            expect(properties[0]).toHaveProperty('deletedAt')
            expect(properties[0].deletedAt).toBeNull()
            expect(properties[1]).toHaveProperty('deletedAt')
            expect(properties[1].deletedAt).toBeNull()
        })
        test('Context fields cannot be changed', async () => {
            const [property] = await createTestBillingProperty(admin, context)
            await expectToThrowGraphQLRequestError(async () => {
                await updateTestBillingProperty(admin, property.id, {
                    context: { connect: { id: anotherContext.id } },
                })
            }, 'Field "context" is not defined')
        })
    })
})