/**
 * Generated by `createschema billing.BillingIntegration name:Text;`
 */

const { faker } = require('@faker-js/faker')

const {
    catchErrorFrom,
    expectToThrowValidationFailureError,
} = require('@open-condo/keystone/test.utils')
const { getRandomString } = require('@open-condo/keystone/test.utils')
const { makeLoggedInAdminClient, makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
} = require('@open-condo/keystone/test.utils')

const {
    BILLING_INTEGRATION_WRONG_GROUP_FORMAT_ERROR,
    BILLING_INTEGRATION_EXTENDS_NO_APP_URL_ERROR,
    BILLING_INTEGRATION_SINGLE_CONNECT_WAY_ERROR,
} = require('@condo/domains/billing/constants/errors')
const { BillingIntegration, createTestBillingIntegration, updateTestBillingIntegration } = require('@condo/domains/billing/utils/testSchema')
const { createTestBillingIntegrationAccessRight } = require('@condo/domains/billing/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')
const { makeClientWithServiceUser } = require('@condo/domains/user/utils/testSchema')


describe('BillingIntegration', () => {
    let admin
    let support
    let serviceUser
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        serviceUser = await makeClientWithServiceUser()
    })

    describe('Validators',  () => {
        describe('Group',  () => {
            let billingIntegrationId
            let billingIntegration
            beforeAll(async () => {
                admin = await makeLoggedInAdminClient()
                billingIntegration = (await createTestBillingIntegration(admin))[0]
                billingIntegrationId = billingIntegration.id
            })

            const wrongGroupCases = [
                'common ',
                ' common',
                '"common',
                '123',
                '',
                ' ',
                'commOn',
            ]

            test.each(wrongGroupCases)('group = %p should fail because it is not latin sequence',
                async (group) => {
                    await expectToThrowValidationFailureError(async () => {
                        await updateTestBillingIntegration(admin, billingIntegrationId, {
                            group: group,
                        })
                    }, BILLING_INTEGRATION_WRONG_GROUP_FORMAT_ERROR)
                })
        })

        describe('Format',  () => {

            test('update format with wrong payload', async () => {
                const [billingIntegration] = await createTestBillingIntegration(admin)
                const billingIntegrationId = billingIntegration.id

                const payload = {
                    dataFormat: {
                        hasToPayDetails: true,
                        hasServices: true,
                        // no hasServiceDetail key!
                    },
                }

                await catchErrorFrom(async () => {
                    await updateTestBillingIntegration(admin, billingIntegrationId,
                        payload)
                }, (err) => {
                    expect(err).toBeDefined()
                })
            })

            test('update format with right payload', async () => {
                const [billingIntegration] = await createTestBillingIntegration(admin)
                const billingIntegrationId = billingIntegration.id

                const payload = {
                    dataFormat: {
                        hasToPayDetails: true,
                        hasServices: true,
                        hasServicesDetails: true,
                    },
                }

                const [updatedIntegration] = await updateTestBillingIntegration(
                    admin, billingIntegrationId, payload)

                expect(updatedIntegration.id).toEqual(billingIntegrationId)
                expect(updatedIntegration.dataFormat.hasToPayDetails).toEqual(true)
            })
        })

        describe('extendsBillingPage', () => {
            test('must be followed by appUrl', async () => {
                await expectToThrowValidationFailureError(async () => {
                    await createTestBillingIntegration(admin, {
                        extendsBillingPage: true,
                    })
                }, BILLING_INTEGRATION_EXTENDS_NO_APP_URL_ERROR)
                const [billing] = await createTestBillingIntegration(admin,  {
                    extendsBillingPage: true,
                    appUrl: faker.internet.url(),
                })
                expect(billing).toBeDefined()
                await expectToThrowValidationFailureError(async () => {
                    await updateTestBillingIntegration(admin, billing.id, {
                        appUrl: null,
                    })
                }, BILLING_INTEGRATION_EXTENDS_NO_APP_URL_ERROR)
            })
        })
        describe('setupUrl and instruction', () => {
            test('only one of them must be specified', async () => {
                await expectToThrowValidationFailureError(async () => {
                    await createTestBillingIntegration(admin, {
                        instruction: null,
                        setupUrl: null,
                    })
                }, BILLING_INTEGRATION_SINGLE_CONNECT_WAY_ERROR)
                await expectToThrowValidationFailureError(async () => {
                    await createTestBillingIntegration(admin, {
                        instruction: 'TEST',
                        setupUrl: 'https://github.com',
                    })
                }, BILLING_INTEGRATION_SINGLE_CONNECT_WAY_ERROR)
                const [billing] = await createTestBillingIntegration(admin)
                expect(billing).toHaveProperty('instruction')
                expect(billing).toHaveProperty('setupUrl')
                expect(billing.instruction).not.toBeNull()
                expect(billing.setupUrl).toBeNull()
                await expectToThrowValidationFailureError(async () => {
                    await updateTestBillingIntegration(admin, billing.id, {
                        setupUrl: 'https://github.com',
                    })
                }, BILLING_INTEGRATION_SINGLE_CONNECT_WAY_ERROR)
                const [updatedBilling] = await updateTestBillingIntegration(admin, billing.id, {
                    setupUrl: 'https://github.com',
                    instruction: null,
                })
                expect(updatedBilling.instruction).toBeNull()
                expect(updatedBilling.setupUrl).not.toBeNull()
                await expectToThrowValidationFailureError(async () => {
                    await updateTestBillingIntegration(admin, billing.id, {
                        instruction: 'TEST',
                    })
                }, BILLING_INTEGRATION_SINGLE_CONNECT_WAY_ERROR)
                const [updatedAgainBilling] = await updateTestBillingIntegration(admin, billing.id, {
                    setupUrl: null,
                    instruction: 'TEST',
                })
                expect(updatedAgainBilling.instruction).not.toBeNull()
                expect(updatedAgainBilling.setupUrl).toBeNull()
            })
        })
    })

    describe('Create', () => {
        test('admin can create BillingIntegration', async () => {
            const [integration, attrs] = await createTestBillingIntegration(admin)
            expect(integration).toEqual(expect.objectContaining({
                name: attrs.name,
            }))
        })

        test('admin can\'t create BillingIntegration.accessRights field', async () => {
            const [integration] = await createTestBillingIntegration(admin)
            const [accessRight] = await createTestBillingIntegrationAccessRight(admin, integration, serviceUser.user)
            await catchErrorFrom(async () => {
                await createTestBillingIntegration(support, {
                    accessRights: { connect: accessRight.id },
                })
            }, (caught) => {
                expect(caught.errors[0].message).toContain('Field "accessRights" is not defined by type "BillingIntegrationCreateInput"')
            })
        })

        test('support can create BillingIntegration', async () => {
            const [integration, attrs] = await createTestBillingIntegration(support)
            expect(integration).toEqual(expect.objectContaining({
                name: attrs.name,
            }))
        })

        test('user cannot create BillingIntegration', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestBillingIntegration(client)
            })
        })

        test('anonymous cannot create BillingIntegration', async () => {
            const client = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestBillingIntegration(client)
            })
        })
    })

    describe('Update', () => {
        test('admin can\'t update BillingIntegration.accessRights field', async () => {
            const [integration] = await createTestBillingIntegration(admin)
            const [accessRight] = await createTestBillingIntegrationAccessRight(admin, integration, serviceUser.user)
            await catchErrorFrom(async () => {
                await updateTestBillingIntegration(support, integration.id, {
                    accessRights: { connect: accessRight.id },
                })
            }, (caught) => {
                expect(caught.errors[0].message).toContain('Field "accessRights" is not defined by type "BillingIntegrationUpdateInput"')
            })
        })
        
        test('support can update BillingIntegration', async () => {
            const [objCreated] = await createTestBillingIntegration(admin)
            const payload = { name: 'super-billing!', currencyCode: 'EUR' }
            const [updatedIntegration] = await updateTestBillingIntegration(support, objCreated.id, payload)
            expect(updatedIntegration.id).toEqual(objCreated.id)
            expect(updatedIntegration.name).toEqual('super-billing!')
        })

        test('user cannot update BillingIntegration', async () => {
            const [objCreated] = await createTestBillingIntegration(admin)

            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const payload = { name: getRandomString() }
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestBillingIntegration(client, objCreated.id, payload)
            })
        })

        test('anonymous cannot update BillingIntegration', async () => {
            const [objCreated] = await createTestBillingIntegration(admin)

            const client = await makeClient()
            const payload = {}
            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestBillingIntegration(client, objCreated.id, payload)
            })
        })
    })

    describe('Read', () => {
        test('user can read BillingIntegration', async () => {
            const [obj, attrs] = await createTestBillingIntegration(admin)

            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const objs = await BillingIntegration.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })

            expect(objs.length).toBeGreaterThanOrEqual(1)
            expect(objs).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    id: obj.id,
                    sender: attrs.sender,
                    createdBy: expect.objectContaining({ id: admin.user.id }),
                    updatedBy: expect.objectContaining({ id: admin.user.id }),
                    createdAt: obj.createdAt,
                    updatedAt: obj.updatedAt,
                    name: attrs.name,
                }),
            ]))
        })

        test('anonymous cannot read BillingIntegration', async () => {
            const client = await makeClient()

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await BillingIntegration.getAll(client)
            })
        })
    })

    describe('Delete', () => {
        test('user cannot delete BillingIntegration', async () => {
            const [objCreated] = await createTestBillingIntegration(admin)

            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await BillingIntegration.delete(client, objCreated.id)
            })
        })

        test('anonymous cannot delete BillingIntegration', async () => {
            const [objCreated] = await createTestBillingIntegration(admin)

            const client = await makeClient()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await BillingIntegration.delete(client, objCreated.id)
            })
        })
    })

    describe('Cache', () => {
        test('cache resets if it detects mutation with itemQuery', async () => {
            const [integration] = await createTestBillingIntegration(admin)

            const [integration1] = await BillingIntegration.getAll(admin, { id: integration.id })
            const [updatedIntegration] = await updateTestBillingIntegration(admin, integration.id, { name: 'Kitten!' })
            const [integration2] = await BillingIntegration.getAll(admin, { id: integration.id })

            expect(integration.id).toEqual(integration1.id)
            expect(updatedIntegration.id).toEqual(integration1.id)
            expect(integration2.name).toEqual('Kitten!')
        })

        test('cache resets if it detects mutation with listQuery', async () => {
            const integrationName = faker.datatype.uuid()

            const [integration1] = await createTestBillingIntegration(admin, { name: integrationName })
            const integrationList1 = await BillingIntegration.getAll(admin, { name: integrationName })
            expect(integrationList1).toHaveLength(1)

            const [integration2] = await createTestBillingIntegration(admin, { name: integrationName })
            const integrationList2 = await BillingIntegration.getAll(admin, { name: integrationName })
            expect(integrationList2).toHaveLength(2)
            expect(integrationList2[0].id).not.toEqual(integrationList2[1].id)
            expect(integrationList2[0].name).toEqual(integrationList2[1].name)
            expect(integrationList2[0].name).toEqual(integrationName)

            await updateTestBillingIntegration(admin, integration1.id, { name: 'Kitten!' })

            const integrationList3 = await BillingIntegration.getAll(admin, { name: integrationName })
            expect(integrationList3).toHaveLength(1)
            expect(integrationList3[0].id).toEqual(integration2.id)
        })
    })
})
