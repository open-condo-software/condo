/**
 * Generated by `createservice billing.BillingReceiptsService --type queries`
 */

const Big = require('big.js')
const { pick, get, isNil, min } = require('lodash')

const { generateQuerySortBy } = require('@open-condo/codegen/generate.gql')
const { generateQueryWhereInput } = require('@open-condo/codegen/generate.gql')
const FileAdapter = require('@open-condo/keystone/fileAdapter/fileAdapter')
const { GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const { PAYMENT_DONE_STATUS, PAYMENT_WITHDRAWN_STATUS } = require('@condo/domains/acquiring/constants/payment')
const { AcquiringIntegrationContext } = require('@condo/domains/acquiring/utils/serverSchema')
const {
    getAcquiringIntegrationContextFormulaByInstance,
    FeeDistribution,
} = require('@condo/domains/acquiring/utils/serverSchema/feeDistribution')
const access = require('@condo/domains/billing/access/AllResidentBillingReceipts')
const { BILLING_RECEIPT_FILE_FOLDER_NAME } = require('@condo/domains/billing/constants/constants')
const {
    BILLING_RECEIPT_RECIPIENT_FIELD_NAME,
    BILLING_RECEIPT_TO_PAY_DETAILS_FIELD_NAME,
    BILLING_RECEIPT_SERVICES_FIELD,
} = require('@condo/domains/billing/constants/constants')
const {
    ResidentBillingReceiptAdmin,
    getPaymentsSumByPayments,
} = require('@condo/domains/billing/utils/serverSchema')
const { normalizeUnitName } = require('@condo/domains/billing/utils/unitName.utils')
const { Contact } = require('@condo/domains/contact/utils/serverSchema')


const Adapter = new FileAdapter(BILLING_RECEIPT_FILE_FOLDER_NAME)

const ALL_RESIDENT_BILLING_RECEIPTS_FIELDS = {
    id: 'ID',
    period: 'String',
    toPay: 'String',
    printableNumber: 'String',
    serviceConsumer: 'ServiceConsumer',
}

const getFile = (receipt, contacts) => {
    if (isNil(receipt.file)) {
        return receipt.file
    }
    const accountUnitName = get(receipt, ['account', 'unitName'])
    const accountUnitType = get(receipt, ['account', 'unitType'])
    const propertyAddress = get(receipt, ['account', 'property', 'address'])

    // let's search for a contact
    // if any exists = user allowed to see sensitive data
    const propertyContacts = contacts.filter(contact => normalizeUnitName(contact.unitName) === normalizeUnitName(accountUnitName)
        && contact.unitType === accountUnitType
        && contact.property.address === propertyAddress)
    const file = propertyContacts.length > 0
        ? receipt.file.sensitiveDataFile
        : receipt.file.publicDataFile

    // case when file url is omit in BillingReceiptFile
    if (isNil(file)) {
        return null
    }

    const publicUrl = Adapter.publicUrl({ filename: file.filename })

    return {
        file: { ...file, publicUrl },
        controlSum: receipt.file.controlSum,
    }
}

const AllResidentBillingReceiptsService = new GQLCustomSchema('AllResidentBillingReceiptsService', {
    types: [
        {
            access: true,
            type: generateQueryWhereInput('ResidentBillingReceipt', ALL_RESIDENT_BILLING_RECEIPTS_FIELDS),
        },
        {
            access: true,
            type: generateQuerySortBy('ResidentBillingReceipt', Object.keys(ALL_RESIDENT_BILLING_RECEIPTS_FIELDS)),
        },
        {
            access: true,
            type: 'type ResidentBillingReceiptFile { file: File controlSum: String}',
        },
        {
            access: true,
            type: `type ResidentBillingReceiptOutput { dv: String!, recipient: ${BILLING_RECEIPT_RECIPIENT_FIELD_NAME}!, id: ID!, period: String!, toPay: String!, paid: String!, explicitFee: String!, printableNumber: String, toPayDetails: ${BILLING_RECEIPT_TO_PAY_DETAILS_FIELD_NAME}, services: ${BILLING_RECEIPT_SERVICES_FIELD}, serviceConsumer: ServiceConsumer! currencyCode: String! category: BillingCategory! isPayable: Boolean! file: ResidentBillingReceiptFile }`,
        },
    ],

    queries: [
        {
            access: access.canGetAllResidentBillingReceipts,
            schema: 'allResidentBillingReceipts (where: ResidentBillingReceiptWhereInput, first: Int, skip: Int, sortBy: [SortResidentBillingReceiptsBy!]): [ResidentBillingReceiptOutput]',
            resolver: async (parent, args, context = {}) => {
                const { where, first, skip, sortBy } = args

                const serviceConsumerWhere = get(where, 'serviceConsumer', {})
                const receiptsWhere = pick(where, ['id', 'period', 'toPay', 'printableNumber'])

                const userId = get(context, ['authedItem', 'id'])

                // We can't really use getting service consumer with all access here, since we do not show billingAccount to our user
                const GET_ONLY_OWN_SERVICE_CONSUMER_WHERE = { user: { id: userId } }
                if (!serviceConsumerWhere.resident) {
                    serviceConsumerWhere.resident = GET_ONLY_OWN_SERVICE_CONSUMER_WHERE
                    serviceConsumerWhere.deletedAt = null
                } else {
                    serviceConsumerWhere.resident.user = GET_ONLY_OWN_SERVICE_CONSUMER_WHERE.user
                    serviceConsumerWhere.deletedAt = null
                }

                const serviceConsumers = (await find('ServiceConsumer', serviceConsumerWhere))

                const serviceConsumersWithBillingAccount = serviceConsumers.filter(consumer => (
                    get(consumer, 'billingIntegrationContext')
                ))

                if (!Array.isArray(serviceConsumersWithBillingAccount) || !serviceConsumersWithBillingAccount.length) {
                    return []
                }

                const processedReceipts = []
                const receiptsQuery = []
                for (const serviceConsumer of serviceConsumersWithBillingAccount) {
                    const receiptsQueryForConsumer = {
                        ...receiptsWhere,
                        account: {
                            number: serviceConsumer.accountNumber,
                            deletedAt: null,
                        },
                        context: {
                            organization: { id: serviceConsumer.organization },
                            deletedAt: null,
                        },
                        deletedAt: null,
                    }
                    receiptsQuery.push({ 'AND': [receiptsQueryForConsumer] })
                }

                const joinedReceiptsQuery = {
                    'OR': receiptsQuery,
                }

                const receiptsForConsumer = await ResidentBillingReceiptAdmin.getAll(
                    context,
                    joinedReceiptsQuery,
                    {
                        sortBy, first, skip,
                    }
                )

                // cache verified contacts for authed user
                // in order to determinate if user can see
                // a sensitive version of primary file
                const contacts = await Contact.getAll(context, {
                    phone: context.authedItem.phone,
                    isVerified: true,
                    deletedAt: null,
                })

                // cache billing receipt for calculation of is payable field
                const minPeriod = min(receiptsForConsumer.map(item => item.period))
                const nextPeriodBillingReceiptsCache = await find('BillingReceipt', {
                    account: { id_in: [...new Set(receiptsForConsumer.map(item => item.account.id))], deletedAt: null },
                    OR: [
                        { receiver: { AND: [{ id_in: [...new Set(receiptsForConsumer.map(item => item.account.id))] }, { deletedAt: null } ] } },
                        { category: { AND: [{ id_in: [...new Set(receiptsForConsumer.map(item => item.category.id))] }, { deletedAt: null } ] } },
                    ],
                    period_gt: minPeriod,
                    deletedAt: null,
                })

                // cache acquiring integration contexts
                const aicIds = serviceConsumersWithBillingAccount.map(consumer => consumer.acquiringIntegrationContext)
                    .filter(aic => !isNil(aic))
                const acquiringContexts = await AcquiringIntegrationContext.getAll(context, {
                    id_in: aicIds,
                })

                receiptsForConsumer.forEach(receipt => {
                    const file = getFile(receipt, contacts)
                    const isPayable = nextPeriodBillingReceiptsCache.filter(item => {
                        return receipt.account.id === item.account && (
                            receipt.category.id === item.category ||
                            receipt.receiver.id === item.receiver
                        ) && receipt.period < item.period
                    }).length === 0
                    processedReceipts.push({
                        id: receipt.id,
                        dv: receipt.dv,
                        category: receipt.category,
                        recipient: receipt.recipient,
                        receiver: receipt.receiver,
                        account: receipt.account,
                        period: receipt.period,
                        toPay: receipt.toPay,
                        toPayDetails: receipt.toPayDetails,
                        services: receipt.services,
                        printableNumber: receipt.printableNumber,
                        serviceConsumer: serviceConsumersWithBillingAccount.find(({ accountNumber, organization }) =>
                            get(receipt, ['account', 'number']) === accountNumber &&
                            get(receipt, ['context', 'organization', 'id']) === organization ),
                        currencyCode: get(receipt, ['context', 'integration', 'currencyCode'], null),
                        file,
                        isPayable,
                    })
                })

                // cache already paid payments
                const paymentsCache = await  find('Payment', {
                    organization: { id_in: [... new Set(processedReceipts.map(item => get(item, ['serviceConsumer', 'organization'])))] },
                    accountNumber_in: [... new Set(processedReceipts.map(item => get(item, ['serviceConsumer', 'accountNumber'])))],
                    period: minPeriod,
                    status_in: [PAYMENT_DONE_STATUS, PAYMENT_WITHDRAWN_STATUS],
                })

                //
                // Set receipt.paid field and calculate fees
                //
                const receiptsWithPayments = []
                for (const receipt of processedReceipts) {
                    const organizationId = get(receipt.serviceConsumer, ['organization'])
                    const accountNumber = get(receipt.serviceConsumer, ['accountNumber'])
                    const billingCategory = get(receipt, ['category']) || {}
                    const alreadyPaidPayments = paymentsCache.filter(payment => {
                        return payment.organization === organizationId
                            && payment.accountNumber === accountNumber
                            && payment.period === get(receipt, 'period', null)
                            && payment.recipientBic === get(receipt, ['recipient', 'bic'], null)
                            && payment.recipientBankAccount === get(receipt, ['recipient', 'bankAccount'], null)
                    })
                    const paid = await getPaymentsSumByPayments(alreadyPaidPayments)
                    const acquiringContextId = get(receipt, ['serviceConsumer', 'acquiringIntegrationContext'], null)
                    const toPay = get(receipt, ['toPay'], 0)
                    let fee = '0'
                    if (acquiringContextId) {
                        const acquiringContext = acquiringContexts.find(item => item.id === acquiringContextId) || {}
                        const formula = getAcquiringIntegrationContextFormulaByInstance(acquiringContext)
                        const feeCalculator = new FeeDistribution(formula, billingCategory.id)
                        const { explicitFee } = feeCalculator.calculate(Big(toPay).minus(Big(paid)).toFixed(2))
                        fee = String(explicitFee)
                    }
                    receiptsWithPayments.push(({
                        ...receipt,
                        paid,
                        explicitFee: fee,
                    }))
                }
                return receiptsWithPayments
            },
        },
    ],
})

module.exports = {
    AllResidentBillingReceiptsService,
}
