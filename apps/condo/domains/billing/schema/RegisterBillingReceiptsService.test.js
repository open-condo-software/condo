/**
 * Generated by `createservice billing.RegisterBillingReceiptsService --type mutations`
 */
const { faker  } = require('@faker-js/faker/locale/ru')
const Big = require('big.js')
const dayjs = require('dayjs')

const {
    catchErrorFrom, expectToThrowAuthenticationErrorToResult, expectToThrowAccessDeniedErrorToResult,
} = require('@open-condo/keystone/test.utils')

const {
    BILLING_ACCOUNT_OWNER_TYPE_COMPANY,
    BILLING_ACCOUNT_OWNER_TYPE_PERSON,
} = require('@condo/domains/billing/constants/constants')
const {
    ERRORS,
} = require('@condo/domains/billing/constants/registerBillingReceiptService')
const { registerBillingReceiptsByTestClient } = require('@condo/domains/billing/utils/testSchema')
const { generateServicesData, updateTestBillingRecipient } = require('@condo/domains/billing/utils/testSchema')
const { createTestBillingCategory, BillingIntegrationOrganizationContext: BillingContext } = require('@condo/domains/billing/utils/testSchema')
const { BillingTestUtils } = require('@condo/domains/billing/utils/testSchema/utils')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const HOUSING_CATEGORY_ID = '928c97ef-5289-4daa-b80e-4b9fed50c629'
const REPAIR_CATEGORY_ID = 'c0b9db6a-c351-4bf4-aa35-8e5a500d0195'

describe('RegisterBillingReceiptsService', () => {

    const billingTestUtils = new BillingTestUtils()

    beforeAll(async () => {
        await billingTestUtils.init()
    })

    describe('Permission check', () => {

        test('anonymous: can not execute', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(billingTestUtils.clients.anonymous, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [billingTestUtils.createJSONReceipt()],
                })
            })
        })
        test('user: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(billingTestUtils.clients.user, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [billingTestUtils.createJSONReceipt()],
                })
            })
        })
        test('employee: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(billingTestUtils.clients.employee, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [billingTestUtils.createJSONReceipt()],
                })
            })
        })
        test('support: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(billingTestUtils.clients.support, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [billingTestUtils.createJSONReceipt()],
                })
            })
        })
        test('service user: can execute', async () => {
            const [[receipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.service, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt()],
            })
            expect(receipt).toHaveProperty('id')
        })
        test('admin: can execute', async () => {
            const [[receipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.service, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt()],
            })
            expect(receipt).toHaveProperty('id')
        })

    })

    describe('Mixed output check', () => {
        test('should return errors together with good receipts', async () => {
            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [
                        billingTestUtils.createJSONReceipt(),
                        billingTestUtils.createJSONReceipt({ month: -1 }),
                        billingTestUtils.createJSONReceipt(),
                    ],
                })
            }, ({ data: { result }, errors }) => {
                expect(errors).toHaveLength(1)
                expect(result).toEqual([
                    expect.objectContaining({ id: expect.anything() }),
                    null,
                    expect.objectContaining({ id: expect.anything() }),
                ])
            })
        })
    })

    describe('ReportCreat', () => {

        test('should update lastReport for BillingContext if new period was loaded', async () => {
            const currentMonthPeriod = dayjs().add(5, 'year').format('YYYY-MM-01')
            const nextMonthPeriod = dayjs().add(5, 'year').add(1, 'month').format('YYYY-MM-01')
            const [currentYear, currentMonth] = currentMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ month: currentMonth, year: currentYear })],
            })
            const contextBefore = await BillingContext.getOne(billingTestUtils.clients.admin, { id: billingTestUtils.billingContext.id })
            expect(contextBefore.lastReport.period).toEqual(currentMonthPeriod)
            const [nextYear, nextMonth] = nextMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ month: nextMonth, year: nextYear })],
            })
            const contextAfter = await BillingContext.getOne(billingTestUtils.clients.admin, { id: billingTestUtils.billingContext.id })
            expect(contextAfter.lastReport.period).toEqual(nextMonthPeriod)
        })

        test('should not update lastReport if older receipts was loaded', async () => {
            const currentMonthPeriod = dayjs().add(6, 'year').format('YYYY-MM-01')
            const nextMonthPeriod = dayjs().add(6, 'year').add(1, 'month').format('YYYY-MM-01')
            const [nextYear, nextMonth] = nextMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ month: nextMonth, year: nextYear })],
            })
            const contextBefore = await BillingContext.getOne(billingTestUtils.clients.admin, { id: billingTestUtils.billingContext.id })
            expect(contextBefore.lastReport.period).toEqual(nextMonthPeriod)
            const [currentYear, currentMonth] = currentMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ month: currentMonth, year: currentYear })],
            })
            const contextAfter = await BillingContext.getOne(billingTestUtils.clients.admin, { id: billingTestUtils.billingContext.id })
            expect(contextAfter.lastReport.period).toEqual(nextMonthPeriod)
        })

    })

    describe('PeriodResolver',  () => {
        test('should return an error on a wrong year format', async () => {
            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [billingTestUtils.createJSONReceipt({ year: 23 })],
                })
            }, (e) => {
                expect(e.errors[0].extensions.code).toEqual(ERRORS.WRONG_YEAR.code)
                expect(e.errors[0].extensions.type).toEqual(ERRORS.WRONG_YEAR.type)
            })
        })
        test('should return an error on a wrong month', async () => {
            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [billingTestUtils.createJSONReceipt({ month: 13 })],
                })
            }, (e) => {
                expect(e.errors[0].extensions.code).toEqual(ERRORS.WRONG_MONTH.code)
                expect(e.errors[0].extensions.type).toEqual(ERRORS.WRONG_MONTH.type)
            })
        })
    })

    describe('RecipientResolver', () => {
        test('Should create approved recipient on TIN matched', async () => {
            const recipientInput = billingTestUtils.createRecipient({ tin: billingTestUtils.organization.tin })
            const [[{ receiver }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(recipientInput)],
            })
            expect(receiver.isApproved).toEqual(true)
        })
        test('Should create not approved recipient on TIN  mismatch', async () => {
            const recipientInput = billingTestUtils.createRecipient({ tin: billingTestUtils.organization.tin + '0' })
            const [[{ receiver }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(recipientInput)],
            })
            expect(receiver.isApproved).toEqual(false)
        })
        test('Should not modify isApproved if support user remove this flag', async () => {
            const recipientInput = billingTestUtils.createRecipient({ bankAccount: faker.random.numeric(12), tin: billingTestUtils.organization.tin  })
            const [[{ receiver }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(recipientInput)],
            })
            expect(receiver.isApproved).toBeTruthy()
            await updateTestBillingRecipient(billingTestUtils.clients.admin, receiver.id, { isApproved: false })
            const [[{ receiver: modifiedByAdminReceiver }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(recipientInput)],
            })
            expect(modifiedByAdminReceiver.isApproved).toBeFalsy()
        })
        test('Should fill deprecated recipient field as we do not remove it still', async () => {
            const recipientInput = billingTestUtils.createRecipient({ })
            const [receipts] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(recipientInput)],
            })
            const { recipient } = receipts[0]
            expect(recipient).toHaveProperty('name')
            expect(recipient).toHaveProperty('bankAccount')
            expect(recipient).toHaveProperty('bic')
            expect(recipient).toHaveProperty('tin')
        })
    })

    describe('Address fix', () => {
        test('[REGISTRY] Address can be corrected for account if it starts to match organization property', async () => {
            const organizationPropertyAddress = billingTestUtils.createPropertyAddress()
            await createTestProperty(billingTestUtils.clients.admin, billingTestUtils.organization, {
                address: organizationPropertyAddress,
            })
            const accountNumber = billingTestUtils.randomNumber(10).toString()
            const [[{ account: wrongAddressAccount }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                    }
                )],
            })
            const [[{ account: fixedAddressAccount }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                        address: `${organizationPropertyAddress}, 1`,
                    }
                )],
            })
            expect(wrongAddressAccount.id).toEqual(fixedAddressAccount.id)
        })
        test('[REGISTRY] Old address will be used if it stops to match organization property', async () => {
            const organizationPropertyAddress = billingTestUtils.createPropertyAddress()
            await createTestProperty(billingTestUtils.clients.admin, billingTestUtils.organization, {
                address: organizationPropertyAddress,
            })
            const accountNumber = billingTestUtils.randomNumber(10).toString()
            const [[{ account: correctAddressAccount }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                        address: `${organizationPropertyAddress}, 1`,
                    }
                )],
            })
            const [[{ account: spoiledAddressAccount }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                    }
                )],
            })
            expect(correctAddressAccount.id).toEqual(spoiledAddressAccount.id)
        })
        test('[REGISTRY] two accounts will be created if they both matches organization properties', async () => {
            const organizationProperty1Address = billingTestUtils.createPropertyAddress()
            const organizationProperty2Address = billingTestUtils.createPropertyAddress()
            await createTestProperty(billingTestUtils.clients.admin, billingTestUtils.organization, {
                address: organizationProperty1Address,
            })
            await createTestProperty(billingTestUtils.clients.admin, billingTestUtils.organization, {
                address: organizationProperty2Address,
            })
            const accountNumber = billingTestUtils.randomNumber(10).toString()
            const [[{ id: receipt1Id, account: account1 }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                        address: `${organizationProperty1Address}, 1`,
                    }
                )],
            })
            const [[{ id: receipt2Id, account: account2 }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                        address: `${organizationProperty2Address}, 1`,
                    }
                )],
            })
            expect(account2.id).not.toEqual(account1.id)
            expect(receipt2Id).not.toEqual(receipt1Id)
        })
    })

    describe('AccountResolver', () => {
        test('Can exist 2 accounts with same number if now matching organization properties for both of them', async () => {
            const accountNumber = billingTestUtils.randomNumber(10).toString()
            const [[receipt1, receipt2]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [
                    billingTestUtils.createJSONReceipt({ accountNumber }),
                    billingTestUtils.createJSONReceipt({ accountNumber }),
                ],
            })
            expect(receipt1.account.id).not.toEqual(receipt2.account.id)
        })
        test('[IMPORT_ID] Can exist 2 accounts with same number but different houses if different importIds are passed', async () => {
            const accountNumber = billingTestUtils.randomNumber(10).toString()
            const [[receipt1, receipt2]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [
                    billingTestUtils.createJSONReceipt({ importId: billingTestUtils.randomNumber(50).toString(), accountNumber }),
                    billingTestUtils.createJSONReceipt({ importId: billingTestUtils.randomNumber(50).toString(), accountNumber }),
                ],
            })
            expect(receipt1.account.id).not.toEqual(receipt2.account.id)
        })
        test('Will set information from accountMeta to BillingAccount', async () => {
            const accountMeta = {
                globalId: billingTestUtils.createValidELS(),
                fullName: faker.name.fullName(),
                isClosed: true,
            }
            const [[{ account: personAccount }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ accountMeta })],
            })
            expect(personAccount.fullName).toEqual(accountMeta.fullName)
            expect(personAccount.globalId).toEqual(accountMeta.globalId)
            expect(personAccount.isClosed).toEqual(accountMeta.isClosed)
            expect(personAccount.ownerType).toEqual(BILLING_ACCOUNT_OWNER_TYPE_PERSON)
            const companyAccountMeta = {
                globalId: billingTestUtils.createValidELS() + '0',
                fullName: faker.lorem.sentence(),
                isClosed: false,
            }
            const [[{ account: companyAccount }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ accountMeta: companyAccountMeta })],
            })
            expect(companyAccount.fullName).toEqual(companyAccountMeta.fullName)
            expect(companyAccount.globalId).toBeNull()
            expect(companyAccount.isClosed).toEqual(companyAccountMeta.isClosed)
            expect(companyAccount.ownerType).toEqual(BILLING_ACCOUNT_OWNER_TYPE_COMPANY)
        })
        test('[IMPORT_ID] It will not create another account on address change', async () => {
            const importId = billingTestUtils.randomNumber(50).toString()
            const [[{ account: accountBeforeFix }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ importId } )],
            })
            const [[{ account: accountAfterFix }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ importId } )],
            })
            expect(accountBeforeFix.id).toEqual(accountAfterFix.id)
        })
        test('isPerson validation "company" ownerType test', async () => {
            const [[{ account: { ownerType } }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ accountMeta: { fullName: 'ИП Фамилия' } })],
            })
            expect(ownerType).toEqual(BILLING_ACCOUNT_OWNER_TYPE_COMPANY)
        })
        test('isPerson validation "person" ownerType test', async () => {
            const [[{ account: { ownerType } }]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                context: { id: billingTestUtils.billingContext.id },
                receipts: [billingTestUtils.createJSONReceipt({ accountMeta: { fullName: 'Фамилияоао Имя' } })],
            })
            expect(ownerType).toEqual(BILLING_ACCOUNT_OWNER_TYPE_PERSON)
        })
    })

    describe('ReceiptResolver', () => {
        describe('[registry] Create new receipt if category and bank account are both different', () => {
            test('Overhaul and Housing are on different bank accounts in one request', async () => {
                const tin = faker.random.numeric(8)
                const receipt1 = billingTestUtils.createJSONReceipt({
                    category: { id: HOUSING_CATEGORY_ID },
                    ...billingTestUtils.createRecipient({ tin }),
                    importId: null,
                })
                const receipt2 = billingTestUtils.createJSONReceipt({
                    ...receipt1,
                    category: { id: REPAIR_CATEGORY_ID },
                    ...billingTestUtils.createRecipient({ tin }),
                    importId: null,
                })
                const [createdReceipts] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [receipt1, receipt2],
                })
                expect(createdReceipts).toHaveLength(2)
            })
            test('Overhaul and Housing are on different bank accounts in different requests', async () => {
                const tin = faker.random.numeric(8)
                const receipt1 = billingTestUtils.createJSONReceipt({
                    category: { id: HOUSING_CATEGORY_ID },
                    importId: null,
                    ...billingTestUtils.createRecipient({ tin }),
                })
                const receipt2 = billingTestUtils.createJSONReceipt({
                    ...receipt1,
                    category: { id: REPAIR_CATEGORY_ID },
                    importId: null,
                    ...billingTestUtils.createRecipient({ tin }),
                })
                const [[housingReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [receipt1],
                })
                const [[repairReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [receipt2],
                })
                expect(housingReceipt.id).not.toEqual(repairReceipt.id)
            })
        })
        describe('Do not create new receipt on: ', () => {
            test('[IMPORT_ID] Address change (was resolved wrong and then fixed)', async () => {
                const wrongAddress = billingTestUtils.createAddressWithUnit()
                const receiptWithWrongAddress = billingTestUtils.createJSONReceipt({ address: wrongAddress })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [receiptWithWrongAddress],
                })
                const wrongHouseAddress = createdReceipt.property.address
                const correctAddress = billingTestUtils.createAddressWithUnit()
                const receiptWithCorrectAddress = { ...receiptWithWrongAddress, address: correctAddress }
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [receiptWithCorrectAddress],
                })
                const correctHouseAddress = updatedReceipt.property.address
                expect(updatedReceipt.property.address).not.toEqual(wrongHouseAddress)
                expect(updatedReceipt.property.address).toEqual(correctHouseAddress)
                expect(updatedReceipt.account.property.address).toEqual(correctHouseAddress)
                expect(createdReceipt.account.id).toEqual(updatedReceipt.account.id)
            })
            test('[ALL] Category change (first load without services, then added services)', async () => {
                const name = faker.lorem.sentence(3)
                const serviceName = faker.lorem.sentence(2)
                await createTestBillingCategory(billingTestUtils.clients.admin, { name, serviceNames: [serviceName] })
                const createInput = billingTestUtils.createJSONReceipt({ importId: null, services: null })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [{ ...createInput, services: [{ name: serviceName, toPay: '0' }] }],
                })
                expect(createdReceipt.category.id).not.toEqual(updatedReceipt.category.id)
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
            })
            test('[ALL] Recipient change do not creates new receipt', async () => {
                const wrongRecipient = billingTestUtils.createRecipient()
                const correctRecipient = billingTestUtils.createRecipient()
                const createInput = billingTestUtils.createJSONReceipt({ importId: null, ...wrongRecipient })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [{ ...createInput, ...correctRecipient }],
                })
                expect(createdReceipt.receiver.id).not.toEqual(updatedReceipt.receiver.id)
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
            })
            test('[ALL] Services change updates services in receipt', async () => {
                const createServices = generateServicesData(3, '1000')
                const createInput = billingTestUtils.createJSONReceipt({ services: createServices })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [createInput],
                })
                const updateServices = generateServicesData(4, '1000')
                const updateInput = billingTestUtils.createJSONReceipt({ ...createInput, services: updateServices })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [updateInput],
                })
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
                expect(createdReceipt.services).toHaveLength(3)
                expect(updatedReceipt.services).toHaveLength(4)
                expect(updatedReceipt.services.map(({ id, name, toPay }) => ({ id, name, toPay }) )).toEqual(updateServices.map(({ id, name, toPay }) => ({ id, name, toPay }) ))
            })
        })
        describe('Common behaviour', () => {
            test('Works on several receipts', async () => {
                const receipt1 = billingTestUtils.createJSONReceipt()
                const receipt2 = billingTestUtils.createJSONReceipt({
                    ...receipt1,
                    importId: null,
                    address: billingTestUtils.createAddressWithUnit(),
                    accountNumber: billingTestUtils.randomNumber(10).toString(),
                })
                const [createdReceipts] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [receipt1, receipt2],
                })
                expect(createdReceipts[0].id).not.toEqual(createdReceipts[1].id)
            })
            test('Fields with relations  are created', async () => {
                const createInput = billingTestUtils.createJSONReceipt()
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [createInput],
                })
                expect(createdReceipt.property.id).toBeDefined()
                expect(createdReceipt.account.id).toBeDefined()
                expect(createdReceipt.receiver.id).toBeDefined()
                expect(createdReceipt.context.id).toBeDefined()
            })
            test('Will not invoke update on nothing changed', async () => {
                const createInput = billingTestUtils.createJSONReceipt()
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                    context: { id: billingTestUtils.billingContext.id },
                    receipts: [createInput],
                })
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
                expect(createdReceipt.v).toEqual(updatedReceipt.v)
            })
        })
        describe('Resolvers tests', () => {
            describe('receiptResolver', () => {
                test('Update Receipt toPay field', async () => {
                    const originalToPayValue = Big(faker.finance.amount(-100, 5000)).toFixed(2)
                    const updatedToPayValue = Big(originalToPayValue).add(1000).toFixed(2)
                    const createInput = billingTestUtils.createJSONReceipt({ toPay: originalToPayValue })
                    const updateInput = { ...createInput, toPay: updatedToPayValue }
                    const [[createdReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                        context: { id: billingTestUtils.billingContext.id },
                        receipts: [createInput],
                    })
                    const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(billingTestUtils.clients.admin, {
                        context: { id: billingTestUtils.billingContext.id },
                        receipts: [updateInput],
                    })
                    expect(createdReceipt.id).toEqual(updatedReceipt.id)
                    expect(Big(updatedReceipt.toPay).toFixed(2)).toEqual(updatedToPayValue)
                })
            })

        })
    })

})
