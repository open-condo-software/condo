/**
 * Generated by `createservice billing.RegisterBillingReceiptsService --type mutations`
 */
const { faker  } = require('@faker-js/faker/locale/ru')
const Big = require('big.js')
const dayjs = require('dayjs')

const {
    catchErrorFrom, expectToThrowAuthenticationErrorToResult, expectToThrowAccessDeniedErrorToResult,
} = require('@open-condo/keystone/test.utils')

const {
    BILLING_ACCOUNT_OWNER_TYPE_COMPANY,
    BILLING_ACCOUNT_OWNER_TYPE_PERSON,
} = require('@condo/domains/billing/constants/constants')
const { HOUSING_CATEGORY_ID, REPAIR_CATEGORY_ID, ELECTRICITY_CATEGORY_ID } = require('@condo/domains/billing/constants/constants')
const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/billing/constants/constants')
const {
    ERRORS,
} = require('@condo/domains/billing/constants/registerBillingReceiptService')
const { registerBillingReceiptsByTestClient } = require('@condo/domains/billing/utils/testSchema')
const { generateServicesData } = require('@condo/domains/billing/utils/testSchema')
const { createTestBillingCategory, BillingIntegrationOrganizationContext: BillingContext } = require('@condo/domains/billing/utils/testSchema')
const {
    TestUtils,
    BillingTestMixin,
} = require('@condo/domains/billing/utils/testSchema/testUtils')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')


describe('RegisterBillingReceiptsService', () => {

    const utils = new TestUtils([BillingTestMixin])

    beforeAll(async () => {
        await utils.init()
    })

    describe('Check that billing context is valid for publishing', () => {
        afterEach(async () => {
            await utils.updateOrganization({ deletedAt: null })
            await utils.updateBillingContext({ deletedAt: null, status: CONTEXT_FINISHED_STATUS })
            await utils.updateBillingIntegration({ deletedAt: null })
        })

        test('Do not allow publishing if organization is deleted', async () => {
            await utils.updateOrganization({ deletedAt: new Date().toISOString() })
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.support, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt()],
                })
            })
        })
        test('Do not allow publishing if billingContext is deleted', async () => {
            await utils.updateBillingContext({ deletedAt: new Date().toISOString() })
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.support, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt()],
                })
            })
        })
        test('Do not allow publishing if billingIntegration is deleted', async () => {
            await utils.updateBillingIntegration({ deletedAt: new Date().toISOString() })
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.support, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt()],
                })
            })
        })
        test(`Do not allow publishing if billingContext is in ${CONTEXT_IN_PROGRESS_STATUS} status`, async () => {
            await utils.updateBillingContext({ status: CONTEXT_IN_PROGRESS_STATUS })
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.support, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt()],
                })
            })
        })
    })
    
    describe('Permission check', () => {

        test('anonymous: can not execute', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.anonymous, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt()],
                })
            })
        })
        test('user: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.user, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt()],
                })
            })
        })
        test('employee: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.employee.billing, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt()],
                })
            })
        })
        test('support: can not execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.support, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt()],
                })
            })
        })
        test('service user: can execute', async () => {
            const [[receipt]] = await registerBillingReceiptsByTestClient(utils.clients.service, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt()],
            })
            expect(receipt).toHaveProperty('id')
        })
        test('admin: can execute', async () => {
            const [[receipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt()],
            })
            expect(receipt).toHaveProperty('id')
        })

    })

    describe('Mixed output check', () => {
        test('should return errors together with good receipts', async () => {
            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [
                        utils.createJSONReceipt(),
                        utils.createJSONReceipt({ month: -1 }),
                        utils.createJSONReceipt(),
                    ],
                })
            }, ({ data: { result }, errors }) => {
                expect(errors).toHaveLength(1)
                expect(result).toEqual([
                    expect.objectContaining({ id: expect.anything() }),
                    null,
                    expect.objectContaining({ id: expect.anything() }),
                ])
            })
        })
    })

    describe('ReportCreat', () => {
        test('should update lastReport for BillingContext if new period was loaded', async () => {
            const utils = new TestUtils([BillingTestMixin])
            await utils.init()
            const currentMonthPeriod = dayjs().add(5, 'year').format('YYYY-MM-01')
            const nextMonthPeriod = dayjs().add(5, 'year').add(1, 'month').format('YYYY-MM-01')
            const [currentYear, currentMonth] = currentMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [ REPAIR_CATEGORY_ID, HOUSING_CATEGORY_ID ].map(category => utils.createJSONReceipt({ month: currentMonth, year: currentYear, category: { id : category } })),
            })
            const contextBefore = await BillingContext.getOne(utils.clients.admin, { id: utils.billingContext.id })
            expect(contextBefore.lastReport.period).toEqual(currentMonthPeriod)
            expect(contextBefore.lastReport.categories).toContain(REPAIR_CATEGORY_ID)
            expect(contextBefore.lastReport.categories).toContain(HOUSING_CATEGORY_ID)
            expect(contextBefore.lastReport.totalReceipts).toEqual(2)
            const [nextYear, nextMonth] = nextMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [ ELECTRICITY_CATEGORY_ID, HOUSING_CATEGORY_ID ].map(category => utils.createJSONReceipt({ month: nextMonth, year: nextYear, category: { id : category } })),
            })
            const contextAfter = await BillingContext.getOne(utils.clients.admin, { id: utils.billingContext.id })
            expect(contextAfter.lastReport.period).toEqual(nextMonthPeriod)
            expect(contextAfter.lastReport.categories).toContain(ELECTRICITY_CATEGORY_ID)
            expect(contextAfter.lastReport.categories).toContain(HOUSING_CATEGORY_ID)
            expect(contextAfter.lastReport.categories).not.toContain(REPAIR_CATEGORY_ID)
            expect(contextBefore.lastReport.totalReceipts).toEqual(2)
        })

        test('should not update lastReport if older receipts were loaded', async () => {
            const utils = new TestUtils([BillingTestMixin])
            await utils.init()
            const currentMonthPeriod = dayjs().add(6, 'year').format('YYYY-MM-01')
            const nextMonthPeriod = dayjs().add(6, 'year').add(1, 'month').format('YYYY-MM-01')
            const [nextYear, nextMonth] = nextMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [ REPAIR_CATEGORY_ID, HOUSING_CATEGORY_ID ].map(category => utils.createJSONReceipt({ month: nextMonth, year: nextYear, category: { id : category } })),
            })
            const contextBefore = await BillingContext.getOne(utils.clients.admin, { id: utils.billingContext.id })
            expect(contextBefore.lastReport.period).toEqual(nextMonthPeriod)
            expect(contextBefore.lastReport.categories).toContain(REPAIR_CATEGORY_ID)
            expect(contextBefore.lastReport.categories).toContain(HOUSING_CATEGORY_ID)
            expect(contextBefore.lastReport.totalReceipts).toEqual(2)
            const [currentYear, currentMonth] = currentMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [ ELECTRICITY_CATEGORY_ID, ELECTRICITY_CATEGORY_ID ].map(category => utils.createJSONReceipt({ month: currentMonth, year: currentYear, category: { id : category } })),
            })
            const contextAfter = await BillingContext.getOne(utils.clients.admin, { id: utils.billingContext.id })
            expect(contextAfter.lastReport.period).toEqual(nextMonthPeriod)
            expect(contextAfter.lastReport.categories).toContain(REPAIR_CATEGORY_ID)
            expect(contextAfter.lastReport.categories).toContain(HOUSING_CATEGORY_ID)
            expect(contextAfter.lastReport.categories).not.toContain(ELECTRICITY_CATEGORY_ID)
            expect(contextBefore.lastReport.totalReceipts).toEqual(2)
        })

        test('should update lastReport if categories were changed during the same period', async () => {
            const utils = new TestUtils([BillingTestMixin])
            await utils.init()
            const currentMonthPeriod = dayjs().add(5, 'year').format('YYYY-MM-01')
            const [currentYear, currentMonth] = currentMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [ REPAIR_CATEGORY_ID ].map(category => utils.createJSONReceipt({ month: currentMonth, year: currentYear, category: { id : category } })),
            })
            const contextBefore = await BillingContext.getOne(utils.clients.admin, { id: utils.billingContext.id })
            expect(contextBefore.lastReport.period).toEqual(currentMonthPeriod)
            expect(contextBefore.lastReport.categories).toContain(REPAIR_CATEGORY_ID)
            expect(contextBefore.lastReport.totalReceipts).toEqual(1)
            await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [ ELECTRICITY_CATEGORY_ID ].map(category => utils.createJSONReceipt({ month: currentMonth, year: currentYear, category: { id : category } })),
            })
            const contextAfter = await BillingContext.getOne(utils.clients.admin, { id: utils.billingContext.id })
            expect(contextAfter.lastReport.period).toEqual(currentMonthPeriod)
            expect(contextAfter.lastReport.categories).toContain(ELECTRICITY_CATEGORY_ID)
            expect(contextAfter.lastReport.categories).toContain(REPAIR_CATEGORY_ID)
            expect(contextAfter.lastReport.totalReceipts).toEqual(2)
        })

        test('Should update categories for old lastReport without categories', async () => {
            const utils = new TestUtils([BillingTestMixin])
            await utils.init()
            const currentMonthPeriod = dayjs().format('YYYY-MM-01')
            const [currentYear, currentMonth] = currentMonthPeriod.split('-').map(Number)
            await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [ REPAIR_CATEGORY_ID ].map(category => utils.createJSONReceipt({ month: currentMonth, year: currentYear, category: { id : category } })),
            })
            const contextBefore = await BillingContext.getOne(utils.clients.admin, { id: utils.billingContext.id })
            const oldLastReport = { ...contextBefore.lastReport }
            delete oldLastReport.categories
            await utils.updateBillingContext({ lastReport: oldLastReport })
            await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [ ELECTRICITY_CATEGORY_ID ].map(category => utils.createJSONReceipt({ month: currentMonth, year: currentYear, category: { id : category } })),
            })
            const contextAfter = await BillingContext.getOne(utils.clients.admin, { id: utils.billingContext.id })
            expect(contextAfter.lastReport.period).toEqual(currentMonthPeriod)
            expect(contextAfter.lastReport.categories).toContain(ELECTRICITY_CATEGORY_ID)
            expect(contextAfter.lastReport.categories).not.toContain(REPAIR_CATEGORY_ID)
            expect(contextAfter.lastReport.totalReceipts).toEqual(2)
        })
    })

    describe('PeriodResolver',  () => {
        test('should return an error on a wrong year format', async () => {
            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt({ year: 23 })],
                })
            }, (e) => {
                expect(e.errors[0].extensions.code).toEqual(ERRORS.WRONG_YEAR.code)
                expect(e.errors[0].extensions.type).toEqual(ERRORS.WRONG_YEAR.type)
            })
        })
        test('should return an error on a wrong month', async () => {
            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [utils.createJSONReceipt({ month: 13 })],
                })
            }, (e) => {
                expect(e.errors[0].extensions.code).toEqual(ERRORS.WRONG_MONTH.code)
                expect(e.errors[0].extensions.type).toEqual(ERRORS.WRONG_MONTH.type)
            })
        })
    })

    describe('RecipientResolver', () => {
        test('Should create approved recipient on TIN matched', async () => {
            const recipientInput = utils.createRecipient({ tin: utils.organization.tin })
            const [[{ receiver }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt(recipientInput)],
            })
            expect(receiver.isApproved).toEqual(true)
        })
        test('Should create not approved recipient on TIN  mismatch', async () => {
            const recipientInput = utils.createRecipient({ tin: utils.organization.tin + '0' })
            const [[{ receiver }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt(recipientInput)],
            })
            expect(receiver.isApproved).toEqual(false)
        })
        test('Should fill deprecated recipient field as we do not remove it still', async () => {
            const recipientInput = utils.createRecipient({ })
            const [receipts] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt(recipientInput)],
            })
            const { recipient } = receipts[0]
            expect(recipient).toHaveProperty('name')
            expect(recipient).toHaveProperty('bankAccount')
            expect(recipient).toHaveProperty('bic')
            expect(recipient).toHaveProperty('tin')
        })
    })

    describe('Address fix', () => {
        test('[REGISTRY] Address can be corrected for account if it starts to match organization property', async () => {
            const organizationPropertyAddress = utils.createPropertyAddress()
            await createTestProperty(utils.clients.admin, utils.organization, {
                address: organizationPropertyAddress,
            })
            const accountNumber = utils.randomNumber(10).toString()
            const [[{ account: wrongAddressAccount }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                    }
                )],
            })
            const [[{ account: fixedAddressAccount }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                        address: `${organizationPropertyAddress}, 1`,
                    }
                )],
            })
            expect(wrongAddressAccount.id).toEqual(fixedAddressAccount.id)
        })
        test('[REGISTRY] Old address will be used if it stops to match organization property', async () => {
            const organizationPropertyAddress = utils.createPropertyAddress()
            await createTestProperty(utils.clients.admin, utils.organization, {
                address: organizationPropertyAddress,
            })
            const accountNumber = utils.randomNumber(10).toString()
            const [[{ account: correctAddressAccount }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                        address: `${organizationPropertyAddress}, 1`,
                    }
                )],
            })
            const [[{ account: spoiledAddressAccount }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                    }
                )],
            })
            expect(correctAddressAccount.id).toEqual(spoiledAddressAccount.id)
        })
        test('[REGISTRY] two accounts will be created if they both matches organization properties', async () => {
            const organizationProperty1Address = utils.createPropertyAddress()
            const organizationProperty2Address = utils.createPropertyAddress()
            await createTestProperty(utils.clients.admin, utils.organization, {
                address: organizationProperty1Address,
            })
            await createTestProperty(utils.clients.admin, utils.organization, {
                address: organizationProperty2Address,
            })
            const accountNumber = utils.randomNumber(10).toString()
            const [[{ id: receipt1Id, account: account1 }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                        address: `${organizationProperty1Address}, 1`,
                    }
                )],
            })
            const [[{ id: receipt2Id, account: account2 }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt(
                    {
                        importId: null,
                        accountNumber: accountNumber,
                        address: `${organizationProperty2Address}, 1`,
                    }
                )],
            })
            expect(account2.id).not.toEqual(account1.id)
            expect(receipt2Id).not.toEqual(receipt1Id)
        })
    })

    describe('AccountResolver', () => {
        test('Can exist 2 accounts with same number if now matching organization properties for both of them', async () => {
            const accountNumber = utils.randomNumber(10).toString()
            const [[receipt1, receipt2]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [
                    utils.createJSONReceipt({ accountNumber }),
                    utils.createJSONReceipt({ accountNumber }),
                ],
            })
            expect(receipt1.account.id).not.toEqual(receipt2.account.id)
        })
        test('[IMPORT_ID] Can exist 2 accounts with same number but different houses if different importIds are passed', async () => {
            const accountNumber = utils.randomNumber(10).toString()
            const [[receipt1, receipt2]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [
                    utils.createJSONReceipt({ importId: utils.randomNumber(50).toString(), accountNumber }),
                    utils.createJSONReceipt({ importId: utils.randomNumber(50).toString(), accountNumber }),
                ],
            })
            expect(receipt1.account.id).not.toEqual(receipt2.account.id)
        })
        test('Will set information from accountMeta to BillingAccount', async () => {
            const accountMeta = {
                globalId: utils.createValidELS(),
                fullName: faker.name.fullName(),
                isClosed: true,
            }
            const [[{ account: personAccount }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt({ accountMeta })],
            })
            expect(personAccount.fullName).toEqual(accountMeta.fullName)
            expect(personAccount.globalId).toEqual(accountMeta.globalId)
            expect(personAccount.isClosed).toEqual(accountMeta.isClosed)
            expect(personAccount.ownerType).toEqual(BILLING_ACCOUNT_OWNER_TYPE_PERSON)
            const companyAccountMeta = {
                globalId: utils.createValidELS() + '0',
                fullName: faker.lorem.sentence(),
                isClosed: false,
            }
            const [[{ account: companyAccount }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt({ accountMeta: companyAccountMeta })],
            })
            expect(companyAccount.fullName).toEqual(companyAccountMeta.fullName)
            expect(companyAccount.globalId).toBeNull()
            expect(companyAccount.isClosed).toEqual(companyAccountMeta.isClosed)
            expect(companyAccount.ownerType).toEqual(BILLING_ACCOUNT_OWNER_TYPE_COMPANY)
        })
        test('[IMPORT_ID] It will not create another account on address change', async () => {
            const importId = utils.randomNumber(50).toString()
            const [[{ account: accountBeforeFix }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt({ importId } )],
            })
            const [[{ account: accountAfterFix }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt({ importId } )],
            })
            expect(accountBeforeFix.id).toEqual(accountAfterFix.id)
        })
        test('isPerson validation "company" ownerType test', async () => {
            const [[{ account: { ownerType } }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt({ accountMeta: { fullName: 'ИП Фамилия' } })],
            })
            expect(ownerType).toEqual(BILLING_ACCOUNT_OWNER_TYPE_COMPANY)
        })
        test('isPerson validation "person" ownerType test', async () => {
            const [[{ account: { ownerType } }]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                context: { id: utils.billingContext.id },
                receipts: [utils.createJSONReceipt({ accountMeta: { fullName: 'Фамилияоао Имя' } })],
            })
            expect(ownerType).toEqual(BILLING_ACCOUNT_OWNER_TYPE_PERSON)
        })
    })

    describe('ReceiptResolver', () => {
        describe('[registry] Create new receipt if category and bank account are both different', () => {
            test('Overhaul and Housing are on different bank accounts in one request', async () => {
                const tin = faker.random.numeric(8)
                const receipt1 = utils.createJSONReceipt({
                    category: { id: HOUSING_CATEGORY_ID },
                    ...utils.createRecipient({ tin }),
                    importId: null,
                })
                const receipt2 = utils.createJSONReceipt({
                    ...receipt1,
                    category: { id: REPAIR_CATEGORY_ID },
                    ...utils.createRecipient({ tin }),
                    importId: null,
                })
                const [createdReceipts] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [receipt1, receipt2],
                })
                expect(createdReceipts).toHaveLength(2)
            })
            test('Overhaul and Housing are on different bank accounts in different requests', async () => {
                const tin = faker.random.numeric(8)
                const receipt1 = utils.createJSONReceipt({
                    category: { id: HOUSING_CATEGORY_ID },
                    importId: null,
                    ...utils.createRecipient({ tin }),
                })
                const receipt2 = utils.createJSONReceipt({
                    ...receipt1,
                    category: { id: REPAIR_CATEGORY_ID },
                    importId: null,
                    ...utils.createRecipient({ tin }),
                })
                const [[housingReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [receipt1],
                })
                const [[repairReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [receipt2],
                })
                expect(housingReceipt.id).not.toEqual(repairReceipt.id)
            })
        })
        describe('Do not create new receipt on: ', () => {
            test('[IMPORT_ID] Address change (was resolved wrong and then fixed)', async () => {
                const wrongAddress = utils.createAddressWithUnit()
                const receiptWithWrongAddress = utils.createJSONReceipt({ address: wrongAddress })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [receiptWithWrongAddress],
                })
                const wrongHouseAddress = createdReceipt.property.address
                const correctAddress = utils.createAddressWithUnit()
                const receiptWithCorrectAddress = { ...receiptWithWrongAddress, address: correctAddress }
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [receiptWithCorrectAddress],
                })
                const correctHouseAddress = updatedReceipt.property.address
                expect(updatedReceipt.property.address).not.toEqual(wrongHouseAddress)
                expect(updatedReceipt.property.address).toEqual(correctHouseAddress)
                expect(updatedReceipt.account.property.address).toEqual(correctHouseAddress)
                expect(createdReceipt.account.id).toEqual(updatedReceipt.account.id)
            })
            test('[ALL] Category change (first load without services, then added services)', async () => {
                const name = faker.lorem.sentence(3)
                const serviceName = faker.lorem.sentence(2)
                await createTestBillingCategory(utils.clients.admin, { name, serviceNames: [serviceName] })
                const createInput = utils.createJSONReceipt({ importId: null, services: null })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [{ ...createInput, services: [{ name: serviceName, toPay: '0' }] }],
                })
                expect(createdReceipt.category.id).not.toEqual(updatedReceipt.category.id)
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
            })
            test('[ALL] Recipient change do not creates new receipt', async () => {
                const wrongRecipient = utils.createRecipient()
                const correctRecipient = utils.createRecipient()
                const createInput = utils.createJSONReceipt({ importId: null, ...wrongRecipient })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [{ ...createInput, ...correctRecipient }],
                })
                expect(createdReceipt.receiver.id).not.toEqual(updatedReceipt.receiver.id)
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
            })
            test('[ALL] Services change updates services in receipt', async () => {
                const createServices = generateServicesData(3, '1000')
                const createInput = utils.createJSONReceipt({ services: createServices })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                const updateServices = generateServicesData(4, '1000')
                const updateInput = utils.createJSONReceipt({ ...createInput, services: updateServices })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [updateInput],
                })
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
                expect(createdReceipt.services).toHaveLength(3)
                expect(updatedReceipt.services).toHaveLength(4)
                expect(updatedReceipt.services.map(({ id, name, toPay }) => ({ id, name, toPay }) )).toEqual(updateServices.map(({ id, name, toPay }) => ({ id, name, toPay }) ))
            })
        })
        describe('Common behaviour', () => {
            test('Works on several receipts', async () => {
                const receipt1 = utils.createJSONReceipt()
                const receipt2 = utils.createJSONReceipt({
                    ...receipt1,
                    importId: null,
                    address: utils.createAddressWithUnit(),
                    accountNumber: utils.randomNumber(10).toString(),
                })
                const [createdReceipts] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [receipt1, receipt2],
                })
                expect(createdReceipts[0].id).not.toEqual(createdReceipts[1].id)
            })
            test('Fields with relations  are created', async () => {
                const createInput = utils.createJSONReceipt()
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                expect(createdReceipt.property.id).toBeDefined()
                expect(createdReceipt.account.id).toBeDefined()
                expect(createdReceipt.receiver.id).toBeDefined()
                expect(createdReceipt.context.id).toBeDefined()
            })
            test('Will set balanceUpdatedAt if toPay was changed', async () => {
                const createInput = utils.createJSONReceipt()
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [{ ...createInput, toPay: faker.finance.amount(-100, 500000) }],
                })
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
                expect(createdReceipt.balanceUpdatedAt).toBeNull()
                expect(updatedReceipt.balanceUpdatedAt).not.toBeNull()
            })
            test('Will set balanceUpdatedAt if toPayDetails.paid was changed', async () => {
                const createInput = utils.createJSONReceipt({ toPayDetails: { paid: faker.finance.amount(-100, 500000) } })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [{ ...createInput, toPayDetails: { paid: faker.finance.amount(-100, 500000) } }],
                })
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
                expect(createdReceipt.balanceUpdatedAt).toBeNull()
                expect(updatedReceipt.balanceUpdatedAt).not.toBeNull()
            })
            test('Will not set balanceUpdatedAt if toPayDetails changed and paid remains the same', async () => {
                const createInput = utils.createJSONReceipt({ toPayDetails: { paid: faker.finance.amount(-100, 500000) } })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [{ ...createInput, toPayDetails: { ...createInput.toPayDetails, charge: faker.finance.amount(-100, 500000) } }],
                })
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
                expect(createdReceipt.balanceUpdatedAt).toBeNull()
                expect(updatedReceipt.balanceUpdatedAt).toBeNull()
            })
            test('Will not set balanceUpdatedAt if amount and toPayDetails.paid was not changed', async () => {
                const createInput = utils.createJSONReceipt({ toPayDetails: { paid: faker.finance.amount(-100, 500000) } })
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
                expect(createdReceipt.balanceUpdatedAt).toBeNull()
                expect(updatedReceipt.balanceUpdatedAt).toBeNull()
            })
            test('Will not invoke update on nothing changed', async () => {
                const createInput = utils.createJSONReceipt()
                const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                    context: { id: utils.billingContext.id },
                    receipts: [createInput],
                })
                expect(createdReceipt.id).toEqual(updatedReceipt.id)
                expect(createdReceipt.v).toEqual(updatedReceipt.v)
            })
        })
        describe('Resolvers tests', () => {
            describe('receiptResolver', () => {
                test('Update Receipt toPay field', async () => {
                    const originalToPayValue = Big(faker.finance.amount(-100, 5000)).toFixed(2)
                    const updatedToPayValue = Big(originalToPayValue).add(1000).toFixed(2)
                    const createInput = utils.createJSONReceipt({ toPay: originalToPayValue })
                    const updateInput = { ...createInput, toPay: updatedToPayValue }
                    const [[createdReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                        context: { id: utils.billingContext.id },
                        receipts: [createInput],
                    })
                    const [[updatedReceipt]] = await registerBillingReceiptsByTestClient(utils.clients.admin, {
                        context: { id: utils.billingContext.id },
                        receipts: [updateInput],
                    })
                    expect(createdReceipt.id).toEqual(updatedReceipt.id)
                    expect(Big(updatedReceipt.toPay).toFixed(2)).toEqual(updatedToPayValue)
                })
            })

        })
    })

})
