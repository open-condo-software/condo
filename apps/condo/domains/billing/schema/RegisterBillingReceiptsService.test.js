/**
 * Generated by `createservice billing.RegisterBillingReceiptsService --type mutations`
 */
const { faker } = require('@faker-js/faker')

const {
    catchErrorFrom,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')
const { expectToThrowAuthenticationError, expectToThrowAccessDeniedErrorToResult } = require('@open-condo/keystone/test.utils')
const { makeClient, makeLoggedInAdminClient } = require('@open-condo/keystone/test.utils')

const { DEFAULT_BILLING_CATEGORY_ID } = require('@condo/domains/billing/constants/constants')
const { errors: mutationErrors } = require('@condo/domains/billing/schema/RegisterBillingReceiptsService')
const { registerBillingReceiptsByTestClient } = require('@condo/domains/billing/utils/testSchema')
const {
    makeServiceUserForIntegration,
    makeOrganizationIntegrationManager,
    createTestBillingProperty,
    createTestBillingAccount,
    createTestBillingIntegration,
    createTestBillingIntegrationOrganizationContext,
    BillingReceipt,
    BillingAccount,
    BillingCategory,
    BillingProperty,
    generateServicesData,
    updateTestBillingIntegrationAccessRight,
    createRegisterBillingReceiptsPayload,
} = require('@condo/domains/billing/utils/testSchema')
const { createTestBillingCategory } = require('@condo/domains/billing/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE, APARTMENT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const {
    makeClientWithSupportUser,
    makeLoggedInClient,
} = require('@condo/domains/user/utils/testSchema')


describe('RegisterBillingReceiptsService', () => {
    let admin
    let support
    let anonymous
    let user

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
        user = await makeLoggedInClient()
    })

    describe('Execute', () => {
        test('Admin can execute mutation', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const payload = {
                context: { id: billingContext.id },
                receipts: [],
            }

            const [ data ] = await registerBillingReceiptsByTestClient(admin, payload)

            expect(data).toHaveLength(0)
        })

        test('Billing service account can execute mutation', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const integrationUser = await makeServiceUserForIntegration(integration)

            const payload = {
                context: { id: billingContext.id },
                receipts: [],
            }

            const [ data ] = await registerBillingReceiptsByTestClient(integrationUser, payload)

            expect(data).toHaveLength(0)
        })

        test('Billing service account without Access Right cant execute mutation', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const integrationUser = await makeServiceUserForIntegration(integration)
            await updateTestBillingIntegrationAccessRight(admin, integrationUser.accessRight.id, { deletedAt: 'true' })

            const payload = {
                context: { id: billingContext.id },
                receipts: [],
            }

            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(integrationUser, payload)
            })
        })

        test('Organization employee can not execute mutation', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)
            const { managerUserClient } = await makeOrganizationIntegrationManager({ context: billingContext })
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(managerUserClient, { context: { id: '1234' }, receipts: [] })
            })
        })

        test('Support can not execute mutation', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(support, { context: { id: '1234' }, receipts: [] })
            })
        })

        test('User can not execute mutation', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(user, { context: { id: '1234' }, receipts: [] })
            })
        })

        test('Anonymous can not execute mutation', async () => {
            await expectToThrowAuthenticationError(async () => {
                await registerBillingReceiptsByTestClient(anonymous, { context: { id: '1234' }, receipts: [] })
            }, 'result')
        })
    })

    describe('Business Logic', () => {

        describe('BillingProperties', () => {
            test('BillingProperties are created and not deleted', async () => {
                /**
                 * Existing properties = {p1, p2}
                 * Properties from args = {p1, p3}
                 * Result: {p1, p2, p3}
                 */

                const EXISTING_TEST_ADDRESS_P1 = 'г. Екатеринбург, Тургенева 4'
                const EXISTING_TEST_ADDRESS_P2 = 'г. Екатеринбург, Проспект Ленина, 44'
                const NON_EXISTING_TEST_ADDRESS_P3 = 'г. Екатеринбург, Проспект Космонавтов 11б'

                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                await createTestBillingProperty(admin, billingContext, {
                    address: EXISTING_TEST_ADDRESS_P1,
                })

                await createTestBillingProperty(admin, billingContext, {
                    address: EXISTING_TEST_ADDRESS_P2,
                })

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        createRegisterBillingReceiptsPayload({
                            address: EXISTING_TEST_ADDRESS_P1,
                        }),
                        createRegisterBillingReceiptsPayload({
                            address: NON_EXISTING_TEST_ADDRESS_P3,
                        }),
                    ],
                }

                const [ data ] = await registerBillingReceiptsByTestClient(admin, payload)
                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingAccounts = await BillingAccount.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(3)
                expect(billingAccounts).toHaveLength(2)
                expect(billingReceipts).toHaveLength(2)
                expect(data).toHaveLength(2)
            })
        })

        describe('BillingAccounts', () => {
            test('BillingAccounts are created and not deleted', async () => {
                /**
                 * Existing properties = {p1}
                 * Properties from args = {p2}
                 * Existing accounts = {a1, a2} for p1
                 * Accounts from args = {a1, a3, a1', a2', a3'} // a1' a2' a3' are for p2
                 *
                 * Result Accounts: p1 -> {a1,  a2,  a3 }
                 *                  p2 -> {a1', a2', a3'}
                 */

                const TEST_ADDRESS_P1 = 'г. Екатеринбург, Тургенева 4'
                const TEST_ADDRESS_P2 = 'г. Екатеринбург, Проспект Космонавтов 11б'

                const TEST_BILLING_ACCOUNT_1_UNITNAME = '1'
                const TEST_BILLING_ACCOUNT_1_NUMBER = 'n1'

                const TEST_BILLING_ACCOUNT_2_UNITNAME = '2'
                const TEST_BILLING_ACCOUNT_2_NUMBER = 'n2'

                const TEST_BILLING_ACCOUNT_3_UNITNAME = '3'
                const TEST_BILLING_ACCOUNT_3_NUMBER = 'n3'

                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                const [billingProperty1] = await createTestBillingProperty(admin, billingContext, {
                    address: TEST_ADDRESS_P1,
                })

                await createTestBillingAccount(admin, billingContext, billingProperty1, {
                    number: TEST_BILLING_ACCOUNT_1_NUMBER,
                    unitName: TEST_BILLING_ACCOUNT_1_UNITNAME,
                    unitType: FLAT_UNIT_TYPE,
                })

                await createTestBillingAccount(admin, billingContext, billingProperty1, {
                    number: TEST_BILLING_ACCOUNT_2_NUMBER,
                    unitName: TEST_BILLING_ACCOUNT_2_UNITNAME,
                    unitType: FLAT_UNIT_TYPE,
                })

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        createRegisterBillingReceiptsPayload({
                            address: TEST_ADDRESS_P1,

                            unitType: FLAT_UNIT_TYPE,
                            accountNumber: TEST_BILLING_ACCOUNT_1_NUMBER,
                            unitName: TEST_BILLING_ACCOUNT_1_UNITNAME,
                        }),
                        createRegisterBillingReceiptsPayload({
                            address: TEST_ADDRESS_P1,

                            unitType: FLAT_UNIT_TYPE,
                            accountNumber: TEST_BILLING_ACCOUNT_3_NUMBER,
                            unitName: TEST_BILLING_ACCOUNT_3_UNITNAME,
                        }),
                        createRegisterBillingReceiptsPayload({
                            address: TEST_ADDRESS_P2,

                            unitType: FLAT_UNIT_TYPE,
                            accountNumber: TEST_BILLING_ACCOUNT_1_NUMBER,
                            unitName: TEST_BILLING_ACCOUNT_1_UNITNAME,
                        }),
                        createRegisterBillingReceiptsPayload({
                            address: TEST_ADDRESS_P2,

                            unitType: FLAT_UNIT_TYPE,
                            accountNumber: TEST_BILLING_ACCOUNT_2_NUMBER,
                            unitName: TEST_BILLING_ACCOUNT_2_UNITNAME,
                        }),
                        createRegisterBillingReceiptsPayload({
                            address: TEST_ADDRESS_P2,

                            unitType: FLAT_UNIT_TYPE,
                            accountNumber: TEST_BILLING_ACCOUNT_3_NUMBER,
                            unitName: TEST_BILLING_ACCOUNT_3_UNITNAME,
                        }),
                    ],
                }

                const [ data ] = await registerBillingReceiptsByTestClient(admin, payload)
                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingAccounts = await BillingAccount.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(2)
                expect(billingAccounts).toHaveLength(6)
                expect(billingReceipts).toHaveLength(5)
                expect(data).toHaveLength(5)
            })

            test('BillingAccounts are created if they have different UnitTypes', async () => {

                const TEST_ADDRESS_P1 = 'г. Екатеринбург, Тургенева 4'

                const TEST_BILLING_ACCOUNT_1_UNITNAME = '1'
                const TEST_BILLING_ACCOUNT_1_NUMBER = 'n1'

                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        createRegisterBillingReceiptsPayload({
                            address: TEST_ADDRESS_P1,

                            unitType: FLAT_UNIT_TYPE,
                            accountNumber: TEST_BILLING_ACCOUNT_1_NUMBER,
                            unitName: TEST_BILLING_ACCOUNT_1_UNITNAME,

                            month: 4,
                        }),
                        createRegisterBillingReceiptsPayload({
                            address: TEST_ADDRESS_P1,

                            unitType: APARTMENT_UNIT_TYPE,
                            accountNumber: TEST_BILLING_ACCOUNT_1_NUMBER,
                            unitName: TEST_BILLING_ACCOUNT_1_UNITNAME,

                            month: 4,
                        }),
                        createRegisterBillingReceiptsPayload({
                            address: TEST_ADDRESS_P1,

                            unitType: APARTMENT_UNIT_TYPE,
                            accountNumber: TEST_BILLING_ACCOUNT_1_NUMBER,
                            unitName: TEST_BILLING_ACCOUNT_1_UNITNAME,

                            month: 5,
                        }),
                    ],
                }

                const [ data ] = await registerBillingReceiptsByTestClient(admin, payload)
                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingAccounts = await BillingAccount.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(1)
                expect(billingAccounts).toHaveLength(2)
                expect(billingReceipts).toHaveLength(3)
                expect(data).toHaveLength(3)
            })
        })

        describe('BillingReceipts', () => {
            test('BillingReceipts are created if they are in different addresses', async () => {
                const TEST_ADDRESS_P1 = 'г. Екатеринбург, Тургенева 4'
                const TEST_ADDRESS_P2 = 'г. Екатеринбург, Проспект Ленина, 44'

                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                const receiptInput = createRegisterBillingReceiptsPayload()

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            address: TEST_ADDRESS_P1,
                            importId: faker.random.alphaNumeric(24),
                        },
                        {
                            ...receiptInput,
                            address: TEST_ADDRESS_P2,
                            importId: faker.random.alphaNumeric(24),
                        },
                    ],
                }

                const [ data ] = await registerBillingReceiptsByTestClient(admin, payload)
                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(2)
                expect(billingReceipts).toHaveLength(2)
                expect(data).toHaveLength(2)
            })

            test('BillingReceipts are created if they have different accounts', async () => {

                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                const receiptInput = createRegisterBillingReceiptsPayload()

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            accountNumber: '1',
                            importId: faker.random.alphaNumeric(24),
                        },
                        {
                            ...receiptInput,
                            accountNumber: '2',
                            importId: faker.random.alphaNumeric(24),
                        },
                    ],
                }

                const [ data ] = await registerBillingReceiptsByTestClient(admin, payload)
                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(1)
                expect(billingReceipts).toHaveLength(2)
                expect(data).toHaveLength(2)
            })

            test('BillingReceipts are created if they have different categories', async () => {
                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                // create categories
                const services = generateServicesData()
                const categories = (await BillingCategory.getAll(admin, {}))
                    .filter(category => category.id !== DEFAULT_BILLING_CATEGORY_ID)
                const billingCategoryWithServices = (await createTestBillingCategory(
                    admin, { name: `Category ${new Date()}`, serviceNames: services.map(({ name }) => name) },
                ))[0]

                const receiptInput = createRegisterBillingReceiptsPayload()

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            category: { id: categories[0].id },
                            importId: faker.random.alphaNumeric(24),
                        },
                        {
                            ...receiptInput,
                            category: { id: categories[1].id },
                            importId: faker.random.alphaNumeric(24),
                        },

                        // include 3 receipts with the same category services
                        // (going to be merged into one receipt since it related to the same category)
                        {
                            ...receiptInput,
                            services: services.slice(0, 1),
                            importId: faker.random.alphaNumeric(24),
                        },
                        {
                            ...receiptInput,
                            services: services.slice(0, 2),
                            importId: faker.random.alphaNumeric(24),
                        },
                        {
                            ...receiptInput,
                            services,
                            importId: faker.random.alphaNumeric(24),
                        },

                        // should fall back to default category
                        // for no services case
                        {
                            ...receiptInput,
                            services: [],
                            importId: faker.random.alphaNumeric(24),
                        },
                    ],
                }

                delete payload.receipts[2].category
                delete payload.receipts[3].category
                delete payload.receipts[4].category
                delete payload.receipts[5].category

                const [ data ] = await registerBillingReceiptsByTestClient(admin, payload)
                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })
                const serviceCreatedReceipts = billingReceipts.filter(
                    ({ category: { id } }) => id === billingCategoryWithServices.id
                )
                const receiptsWithNotCategoryInfo = billingReceipts.filter(({ importId }) => importId === payload.receipts[5].importId)

                expect(billingProperties).toHaveLength(1)
                expect(billingReceipts).toHaveLength(4)
                expect(serviceCreatedReceipts).toHaveLength(1)
                expect(receiptsWithNotCategoryInfo).toHaveLength(1)
                expect(receiptsWithNotCategoryInfo[0].category.id).toEqual(DEFAULT_BILLING_CATEGORY_ID)
                expect(data).toHaveLength(4)
            })

            test('BillingReceipts are created if they have different periods', async () => {

                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                const receiptInput = createRegisterBillingReceiptsPayload()

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            month: 3,
                            importId: faker.random.alphaNumeric(24),
                        },
                        {
                            ...receiptInput,
                            month: 10,
                            importId: faker.random.alphaNumeric(24),
                        },
                    ],
                }

                const [ data ] = await registerBillingReceiptsByTestClient(admin, payload)
                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(1)
                expect(billingReceipts).toHaveLength(2)
                expect(data).toHaveLength(2)
            })

            test('BillingReceipts are not changed if they refer to the same receipt', async () => {
                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                const receiptInput = createRegisterBillingReceiptsPayload()

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        receiptInput,
                    ],
                }
                await registerBillingReceiptsByTestClient(admin, payload)

                const existingBillingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })
                const existingBillingReceiptId = existingBillingReceipts[0].id
                const existingBillingReceiptUpdatedAt = existingBillingReceipts[0].updatedAt

                const [data] = await registerBillingReceiptsByTestClient(admin, payload)

                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingAccounts = await BillingAccount.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(1)
                expect(billingAccounts).toHaveLength(1)
                expect(billingReceipts).toHaveLength(1)
                expect(data).toHaveLength(0)
                expect(billingReceipts[0].id).toEqual(existingBillingReceiptId)
                expect(billingReceipts[0].updatedAt).toEqual(existingBillingReceiptUpdatedAt)
            })

            test('BillingReceipts are updated if only toPay is different', async () => {
                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                const receiptInput = createRegisterBillingReceiptsPayload()

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            toPay: '190.00',
                        },
                    ],
                }
                const [ existingBillingReceipts ] = await registerBillingReceiptsByTestClient(admin, payload)
                const existingBillingReceiptId = existingBillingReceipts[0].id

                const payload2 = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            toPay: '200.00',
                        },
                    ],
                }
                const [data] = await registerBillingReceiptsByTestClient(admin, payload2)

                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(1)
                expect(billingReceipts).toHaveLength(1)
                expect(data).toHaveLength(1)
                expect(billingReceipts[0].id).toEqual(existingBillingReceiptId)
                expect(billingReceipts[0].toPay).toEqual('200.00000000')
            })

            test('BillingReceipts are updated if only toPayDetails are different', async () => {
                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                const receiptInput = createRegisterBillingReceiptsPayload()

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            toPayDetails: { 'formula':'balance + charge + recalculation + privilege + penalty', 'charge':'100.00', 'balance':'0.00', 'recalculation':null, 'privilege':null, 'penalty':null },
                        },
                    ],
                }
                const [ existingBillingReceipts ] = await registerBillingReceiptsByTestClient(admin, payload)
                const existingBillingReceiptId = existingBillingReceipts[0].id

                const payload2 = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            toPayDetails: { 'formula':'balance + charge + recalculation + privilege + penalty', 'charge':'150.00', 'balance':'0.00', 'recalculation':null, 'privilege':null, 'penalty':null },
                        },
                    ],
                }
                const [data] = await registerBillingReceiptsByTestClient(admin, payload2)

                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(1)
                expect(billingReceipts).toHaveLength(1)
                expect(data).toHaveLength(1)
                expect(billingReceipts[0].id).toEqual(existingBillingReceiptId)
                expect(billingReceipts[0].toPayDetails.charge).toEqual('150.00')
            })

            test('BillingReceipts are updated if only services are different', async () => {
                const [organization] = await createTestOrganization(admin)
                const [integration] = await createTestBillingIntegration(admin)
                const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

                const receiptInput = createRegisterBillingReceiptsPayload()

                const payload = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            services: undefined,
                        },
                    ],
                }
                const [ existingBillingReceipts ] = await registerBillingReceiptsByTestClient(admin, payload)
                const existingBillingReceiptId = existingBillingReceipts[0].id

                const payload2 = {
                    context: { id: billingContext.id },
                    receipts: [
                        {
                            ...receiptInput,
                            services: [{ 'id':'928c97ef-5289-4daa-b80e-4b9fed50c629', 'name':'Квартплата', 'toPay':'100.00' }],
                        },
                    ],
                }
                const [data] = await registerBillingReceiptsByTestClient(admin, payload2)

                const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
                const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

                expect(billingProperties).toHaveLength(1)
                expect(billingReceipts).toHaveLength(1)
                expect(data).toHaveLength(1)
                expect(billingReceipts[0].id).toEqual(existingBillingReceiptId)
                expect(billingReceipts[0].services[0].id).toEqual('928c97ef-5289-4daa-b80e-4b9fed50c629')
            })
        })
    })

    describe('Real life cases', () => {
        test('Management company loads 50 receipts for first time', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const payload = {
                context: { id: billingContext.id },
                receipts: [],
            }
            for (let i = 0; i < 50; ++i) { payload.receipts.push(createRegisterBillingReceiptsPayload()) }

            const [data] = await registerBillingReceiptsByTestClient(admin, payload)

            const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

            expect(billingReceipts).toHaveLength(50)
            expect(data).toHaveLength(50)
        })

        test('Management company changes billing recipient', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const tin1 = faker.random.alphaNumeric(8)
            const routingNumber1 = faker.random.alphaNumeric(8)
            const bankAccount1 = faker.random.alphaNumeric(8)

            const receipt1 = createRegisterBillingReceiptsPayload({
                tin: tin1,
                routingNumber: routingNumber1,
                bankAccount: bankAccount1,
            })

            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    receipt1,
                ],
            }

            const [data] = await registerBillingReceiptsByTestClient(admin, payload)

            const routingNumber2 = faker.random.alphaNumeric(8)
            const bankAccount2 = faker.random.alphaNumeric(8)

            const payload2 = {
                context: { id: billingContext.id },
                receipts: [
                    { ...receipt1, ...{ routingNumber: routingNumber2, bankAccount: bankAccount2, importId: faker.random.alphaNumeric(8) } },
                ],
            }

            const [data2] = await registerBillingReceiptsByTestClient(admin, payload2)
            const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

            expect(data).toHaveLength(1)
            expect(data2).toHaveLength(1)
            expect(billingReceipts).toHaveLength(1)
            expect(billingReceipts[0].recipient.bankAccount).toEqual(bankAccount2)
            expect(billingReceipts[0].receiver.bankAccount).toEqual(bankAccount2)
        })

        test('Management company signs up for management of new property', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const EXISTING_ADDRESS = 'Washington st, 4'
            const NEW_ADDRESS = 'Washington st, 5'

            const payload1 = {
                context: { id: billingContext.id },
                receipts: [],
            }
            for (let i = 0; i < 20; ++i) { payload1.receipts.push(createRegisterBillingReceiptsPayload({ address: EXISTING_ADDRESS })) }

            const [data1] = await registerBillingReceiptsByTestClient(admin, payload1)

            const payload2 = {
                context: { id: billingContext.id },
                receipts: [],
            }
            for (let i = 0; i < 20; ++i) { payload2.receipts.push(createRegisterBillingReceiptsPayload({ address: NEW_ADDRESS })) }

            const [data2] = await registerBillingReceiptsByTestClient(admin, payload2)

            const payload3 = {
                context: { id: billingContext.id },
                receipts: [],
            }
            for (let i = 0; i < 5; ++i) { payload3.receipts.push(createRegisterBillingReceiptsPayload({ address: EXISTING_ADDRESS })) }
            for (let i = 5; i < 10; ++i) { payload3.receipts.push(createRegisterBillingReceiptsPayload({ address: NEW_ADDRESS })) }

            const [data3] = await registerBillingReceiptsByTestClient(admin, payload3)

            const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
            const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

            expect(data1).toHaveLength(20)
            expect(data2).toHaveLength(20)
            expect(data3).toHaveLength(10)
            expect(billingReceipts).toHaveLength(50)
            expect(billingProperties).toHaveLength(2)
        })

        test('Simple case is handled correctly', async () => {
            const EXISTING_TEST_ADDRESS = 'TEST'
            const EXISTING_TEST_UNIT_NAME = '0'
            const EXISTING_TEST_ACCOUNT_NUMBER = '0'

            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const [billingProperty] = await createTestBillingProperty(admin, billingContext, {
                address: EXISTING_TEST_ADDRESS,
            })

            await createTestBillingAccount(admin, billingContext, billingProperty, {
                unitName: EXISTING_TEST_UNIT_NAME,
                unitType: FLAT_UNIT_TYPE,
                number: EXISTING_TEST_ACCOUNT_NUMBER,
            })

            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: EXISTING_TEST_ADDRESS,

                        unitType: FLAT_UNIT_TYPE,
                        accountNumber: EXISTING_TEST_ACCOUNT_NUMBER,
                        unitName: EXISTING_TEST_UNIT_NAME,
                    }),
                    createRegisterBillingReceiptsPayload({
                        address: EXISTING_TEST_ADDRESS,
                    }),
                    createRegisterBillingReceiptsPayload(),
                ],
            }

            const [ data ] = await registerBillingReceiptsByTestClient(admin, payload)
            const billingProperties = await BillingProperty.getAll(admin, { context: { id: billingContext.id } })
            const billingAccounts = await BillingAccount.getAll(admin, { context: { id: billingContext.id } })
            const billingReceipts = await BillingReceipt.getAll(admin, { context: { id: billingContext.id } })

            expect(billingProperties).toHaveLength(2)
            expect(billingAccounts).toHaveLength(3)
            expect(billingReceipts).toHaveLength(3)
            expect(data).toHaveLength(3)
        })

        test('Hacker can not load receipts into other billing context related to other org', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)
            const { managerUserClient } = await makeOrganizationIntegrationManager({ context: billingContext })

            const [organization2] = await createTestOrganization(admin)
            const [integration2] = await createTestBillingIntegration(admin)
            const [billingContext2] = await createTestBillingIntegrationOrganizationContext(admin, organization2, integration2)
            const { managerUserClient: hackerClient } = await makeOrganizationIntegrationManager({ context: billingContext2 })

            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload(),
                ],
            }

            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerBillingReceiptsByTestClient(hackerClient, payload)
            })

            const billingProperties = await BillingProperty.getAll(managerUserClient, { context: { id: billingContext.id } })
            const billingAccounts = await BillingAccount.getAll(managerUserClient, { context: { id: billingContext.id } })
            const billingReceipts = await BillingReceipt.getAll(managerUserClient, { context: { id: billingContext.id } })

            expect(billingProperties).toHaveLength(0)
            expect(billingAccounts).toHaveLength(0)
            expect(billingReceipts).toHaveLength(0)
        })
    })

    describe('Validations', () => {
        test('Mutation checks wrong context-id', async () => {

            const payload = {
                context: { id: admin.user.id },
                receipts: [],
            }

            await expectToThrowGQLError(async () => {
                await registerBillingReceiptsByTestClient(admin, payload)
            }, { ...mutationErrors.BILLING_CONTEXT_NOT_FOUND }, 'result')
        })

        test('Mutation has limit on receipts', async () => {

            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const RECEIPTS_LIMIT = 100

            const payload = {
                context: { id: billingContext.id },
                receipts: [],
            }

            for (let i = 0; i < RECEIPTS_LIMIT + 1; ++i) {
                payload.receipts.push(createRegisterBillingReceiptsPayload())
            }

            await expectToThrowGQLError(async () => {
                await registerBillingReceiptsByTestClient(admin, payload)
            }, { ...mutationErrors.RECEIPTS_LIMIT_HIT }, 'result')
        })

        test('Mutation checks wrong category-id', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        category: { id: '928c97ef-5289-4daa-b80e-4b9fed50c630' }, // Wrong category id
                    }),
                ],
            }

            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(admin, payload)
            }, (e) => {
                expect(e.errors[0].message).toContain('BillingCategory is not found')
            })
        })

        test('Mutation checks wrong period format (bad year)', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        year: -200,
                    }),
                ],
            }

            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(admin, payload)
            }, (e) => {
                expect(e.errors[0].message).toContain('Year is wrong')
            })
        })

        test('Mutation checks wrong period format (bad month)', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        month: 20,
                    }),
                ],
            }

            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(admin, payload)
            }, (e) => {
                console.log(e)
                expect(e.errors[0].message).toContain('Month is wrong')
                expect(e.errors[0].extensions.inputIndex).toEqual(0)
            })
        })

        test('Mutation checks empty address', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload({
                        address: '',
                    }),
                ],
            }

            await catchErrorFrom(async () => {
                await registerBillingReceiptsByTestClient(admin, payload)
            }, (e) => {
                expect(e.errors[0].message).toContain('Address is empty')
            })
        })

        test('Errors are indexed correctly, mutation creates entities it can create, and sends errors for others', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload(),
                    createRegisterBillingReceiptsPayload({
                        month: 13,
                    }),
                ],
            }
            const [result, errors] = await registerBillingReceiptsByTestClient(admin, payload, { raw: true })

            expect(result).toHaveLength(2)
            expect(result[1]).toBeNull()

            expect(errors).toHaveLength(1)
            expect(errors[0].extensions.inputIndex).toEqual(1)
            expect(errors[0].message).toContain('Month is wrong')
        })

        test('If there is an error, mutation creates entities it can create, and sends errors for others', async () => {
            const [organization] = await createTestOrganization(admin)
            const [integration] = await createTestBillingIntegration(admin)
            const [billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)

            const payload = {
                context: { id: billingContext.id },
                receipts: [
                    createRegisterBillingReceiptsPayload(),
                    createRegisterBillingReceiptsPayload(),
                    createRegisterBillingReceiptsPayload(),
                    createRegisterBillingReceiptsPayload({
                        month: 13,
                    }),
                    createRegisterBillingReceiptsPayload({
                        year: -20,
                    }),
                ],
            }
            const [result, errors] = await registerBillingReceiptsByTestClient(admin, payload, { raw: true })

            expect(result).toHaveLength(5)
            expect(result[3]).toBeNull()
            expect(result[4]).toBeNull()
            expect(errors).toHaveLength(2)
        })
    })
})
