/**
 * Generated by `createschema banking.BankSyncTask 'account:Relationship:BankAccount:CASCADE; integrationContext:Relationship:BankIntegrationContext:CASCADE; organization:Relationship:Organization:CASCADE; status:Select:processing,completed,cancelled,error; file?:File; totalCount?:Integer; processedCount?:Integer; meta:Json;'`
 */

const path = require('path')

const dayjs = require('dayjs')
const { pick } = require('lodash')

const conf = require('@open-condo/config')
const { makeLoggedInAdminClient, makeClient, UUID_RE,  expectToThrowGQLError, catchErrorFrom,
    expectToThrowValidationFailureError, waitFor, expectValuesOfCommonFields,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    UploadingFile,
} = require('@open-condo/keystone/test.utils')
const { i18n } = require('@open-condo/locales/loader')

const {
    _1C_CLIENT_BANK_EXCHANGE,
    TRANSACTIONS_NOT_ADDED,
    BANK_INTEGRATION_IDS,
    BANK_SYNC_TASK_STATUS,
} = require('@condo/domains/banking/constants')
const {
    BankSyncTask,
    BankIntegrationAccountContext,
    BankIntegrationOrganizationContext,
    createTestBankSyncTask,
    updateTestBankSyncTask,
    updateTestBankIntegrationOrganizationContext, updateTestBankIntegrationAccountContext,
} = require('@condo/domains/banking/utils/testSchema')
const { createTestBankIntegrationAccountContext, createTestBankAccount, BankIntegration } = require('@condo/domains/banking/utils/testSchema')
const { BankAccount, BankTransaction, createTestBankIntegrationOrganizationContext } = require('@condo/domains/banking/utils/testSchema')
const { PARSED_TRANSACTIONS_TO_COMPARE } = require('@condo/domains/banking/utils/testSchema/assets/1CClientBankExchangeToKeystoneObjects')
const { TASK_ERROR_STATUS } = require('@condo/domains/common/constants/tasks')
const { HOLDING_TYPE } = require('@condo/domains/organization/constants/common')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee, createTestOrganizationLink,
} = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')

const { errors } = require('./BankSyncTask')


const pathToCorrectFile = path.resolve(conf.PROJECT_ROOT, 'apps/condo/domains/banking/utils/testSchema/assets/1CClientBankExchange.txt')
const pathToInvalidFile = path.resolve(conf.PROJECT_ROOT, 'apps/condo/domains/banking/utils/testSchema/assets/1CClientBankExchange-Invalid.txt')


describe('BankSyncTask', () => {
    let adminClient
    let bankIntegration
    let anonymousClient

    beforeAll(async () => {
        anonymousClient = await makeClient()
        adminClient = await makeLoggedInAdminClient()
        bankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS['1CClientBankExchange'] })
    })

    describe('CRUD tests', () => {
        describe('create', () => {

            test('admin can', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [obj, attrs] = await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                    file: new UploadingFile(pathToCorrectFile),
                })

                expectValuesOfCommonFields(obj, attrs, adminClient)
                expect(obj.account.id).toMatch(account.id)
                expect(obj.integrationContext.id).toMatch(integrationContext.id)
                expect(obj.file).toBeDefined()
            })

            it('should be created with minimal set of fields', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [obj, attrs] = await createTestBankSyncTask(adminClient, organization)

                expectValuesOfCommonFields(obj, attrs, adminClient)
            })

            test('user can if it is an employee of organization with "canManageBankAccounts" permission', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [obj, attrs] = await createTestBankSyncTask(userClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                expectValuesOfCommonFields(obj, attrs, userClient)
            })

            test('user cannot if it is an employee of organization without "canManageBankAccounts" permission', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: false,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestBankSyncTask(userClient, organization, {
                        account: { connect: { id: account.id } },
                        integrationContext: { connect: { id: integrationContext.id } },
                    })
                })
            })

            test('user cannot if it is an employee of another organization with "canManageBankAccounts" permission', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [anotherOrganization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, anotherOrganization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, anotherOrganization, userClient.user, role)
                const [organization] = await createTestOrganization(adminClient)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestBankSyncTask(userClient, organization, {
                        account: { connect: { id: account.id } },
                        integrationContext: { connect: { id: integrationContext.id } },
                    })
                })
            })

            test('user can if it is an employee of linked organization with "canManageBankAccounts" permission', async () => {
                const [parentOrganization] = await createTestOrganization(adminClient, { type: HOLDING_TYPE })
                const [childOrganization] = await createTestOrganization(adminClient)
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                await createTestOrganizationLink(adminClient, parentOrganization, childOrganization)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, parentOrganization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, parentOrganization, userClient.user, role, {})

                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, childOrganization)
                const [account] = await createTestBankAccount(adminClient, childOrganization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [obj, attrs] = await createTestBankSyncTask(userClient, childOrganization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                expectValuesOfCommonFields(obj, attrs, userClient)
            })

            test('user cannot if it is an employee of linked organization without "canManageBankAccounts" permission', async () => {
                const [parentOrganization] = await createTestOrganization(adminClient, { type: HOLDING_TYPE })
                const [childOrganization] = await createTestOrganization(adminClient)
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                await createTestOrganizationLink(adminClient, parentOrganization, childOrganization)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, parentOrganization, {
                    canManageBankAccounts: false,
                })
                await createTestOrganizationEmployee(adminClient, parentOrganization, userClient.user, role, {})

                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, childOrganization)
                const [account] = await createTestBankAccount(adminClient, childOrganization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestBankSyncTask(userClient, childOrganization, {
                        account: { connect: { id: account.id } },
                        integrationContext: { connect: { id: integrationContext.id } },
                    })
                })
            })

            test('anonymous can\'t', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestBankSyncTask(anonymousClient, organization, {
                        account: { connect: { id: account.id } },
                        integrationContext: { connect: { id: integrationContext.id } },
                    })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [objCreated] = await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [obj, attrs] = await updateTestBankSyncTask(adminClient, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            })

            test('user can only cancel his task', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [objCreated] = await createTestBankSyncTask(userClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })


                const [objUpdated, attrs] = await updateTestBankSyncTask(userClient, objCreated.id, {
                    status: BANK_SYNC_TASK_STATUS.CANCELLED,
                })

                expect(objUpdated.dv).toEqual(1)
                expect(objUpdated.sender).toEqual(attrs.sender)
                expect(objUpdated.v).toEqual(2)
                expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            })

            test('no update input for "file" field', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [objCreated] = await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                    file: new UploadingFile(pathToCorrectFile),
                })

                await catchErrorFrom(async () => {
                    await updateTestBankSyncTask(adminClient, objCreated.id, {
                        file: new UploadingFile(pathToCorrectFile),
                    })
                }, ({ errors }) =>{
                    expect(errors[0].message).toContain('Field "file" is not defined by type "BankSyncTaskUpdateInput"')
                })
            })

            test('anonymous can\'t', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [objCreated] = await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestBankSyncTask(anonymousClient, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [objCreated] = await createTestBankSyncTask(userClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BankSyncTask.delete(adminClient, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [objCreated] = await createTestBankSyncTask(userClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BankSyncTask.delete(userClient, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [obj] = await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BankSyncTask.delete(anonymousClient, obj.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [obj] = await createTestBankSyncTask(userClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const objs = await BankSyncTask.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                        account: { id: account.id },
                        integrationContext: { id: integrationContext.id },
                        organization: { id: organization.id },
                        user: { id: userClient.user.id },
                    }),
                ]))
            })

            test('user can only read theirs records', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const [obj] = await createTestBankSyncTask(userClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                const objs = await BankSyncTask.getAll(userClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs).toHaveLength(1)
                expect(objs[0]).toMatchObject({
                    id: obj.id,
                    account: { id: account.id },
                    integrationContext: { id: integrationContext.id },
                    organization: { id: organization.id },
                    user: { id: userClient.user.id },
                })

                const userClient2 = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role2] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient2.user, role2)

                const [obj2] = await createTestBankSyncTask(userClient2, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })
                const objs2 = await BankSyncTask.getAll(userClient2, {}, { sortBy: ['updatedAt_DESC'] })
                expect(objs2).toHaveLength(1)
                expect(objs2[0]).toMatchObject({
                    id: obj2.id,
                    account: { id: account.id },
                    integrationContext: { id: integrationContext.id },
                    organization: { id: organization.id },
                    user: { id: userClient2.user.id },
                })
            })

            test('anonymous can\'t', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [account] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })

                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await BankSyncTask.getAll(anonymousClient, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('Should have correct dv field (=== 1)', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [account] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: integrationContext.id } },
            })

            await expectToThrowGQLError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    dv: 2,
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'DV_VERSION_MISMATCH',
                message: 'Wrong value for data version number',
                mutation: 'createBankSyncTask',
                variable: ['data', 'dv'],
            }, 'obj')
        })

        it('should be connected to property from the same organization', async () => {
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, organization)
            const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                canManageBankAccounts: true,
            })
            await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
            const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [account] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: integrationContext.id } },
            })

            const [obj] = await createTestBankSyncTask(adminClient, organization, {
                account: { connect: { id: account.id } },
                integrationContext: { connect: { id: integrationContext.id } },
                property: { connect: { id: property.id } },
            })

            expect(obj.property).toBeDefined()
            expect(obj.property.id).toEqual(property.id)

            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [propertyFromAnotherOrganization] = await createTestProperty(adminClient, anotherOrganization)

            await catchErrorFrom(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                    property: { connect: { id: propertyFromAnotherOrganization.id } },
                })
            }, ({ errors, data }) => {
                expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                expect(errors[0].data.messages[0]).toEqual(`Specified property with id="${propertyFromAnotherOrganization.id}" should belong to the same organization with id="${organization.id}" as specified in "organization"`)
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('throw an error if BankAccount already connected to requested property in file import', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, organization)
            const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [integrationContext2] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: integrationContext.id } },
                property: { connect: { id: property.id } },
            })
            const [account2] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: integrationContext2.id } },
            })
            const [createdTask] = await createTestBankSyncTask(adminClient, organization, {
                account: { connect: { id: account2.id } },
                integrationContext: { connect: { id: integrationContext.id } },
                property: { connect: { id: property.id } },
                file: new UploadingFile(pathToCorrectFile),
            })
            await waitFor(async () => {
                const task = await BankSyncTask.getOne(adminClient, {
                    id: createdTask.id,
                })
                expect(task.status).toEqual(BANK_SYNC_TASK_STATUS.ERROR)
                expect(task.meta.errorMessage).toContain('Already have an account with the same Property { id:')
            })
        })

        test('JSON schema of "meta" field', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [integrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [account] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: integrationContext.id } },
            })

            await expectToThrowValidationFailureError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                    meta: {
                        forbiddenField: 'forbiddenValue',
                    },
                })
            },  'meta field validation error. JSON not in the correct format - path: msg:must NOT have additional properties')

            await expectToThrowValidationFailureError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    integrationContext: { connect: { id: integrationContext.id } },
                    meta: {
                        duplicatedTransactions: 'not an array',
                    },
                })
            }, 'meta field validation error. JSON not in the correct format - path:/duplicatedTransactions msg:must be array')

            const [obj] = await createTestBankSyncTask(adminClient, organization, {
                account: { connect: { id: account.id } },
                integrationContext: { connect: { id: integrationContext.id } },
                meta: {
                    duplicatedTransactions: ['123', '456'],
                    errorMessage: 'Test error message',
                },
            })
            expect(obj.meta).toMatchObject({
                duplicatedTransactions: ['123', '456'],
                errorMessage: 'Test error message',
            })
        })

        it('requires value of "options" field', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const bankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS.SBBOL })
            const [BankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [account] = await createTestBankAccount(adminClient, organization, {
                number: '40702810801500116391',
                routingNumber: '044525999',
                integrationContext: { connect: { id: BankIntegrationAccountContext.id } },
            })

            await expectToThrowValidationFailureError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    user: { connect: { id: adminClient.user.id } },
                    options: null,
                })
            }, 'Required field "options" is null or undefined')
        })

        it('fails to create if existing BankIntegrationOrganizationContext of corresponding type is disabled', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [first1cTask] = await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
                options: {
                    type: _1C_CLIENT_BANK_EXCHANGE,
                },
            })
            expect(first1cTask).toBeDefined()

            let _1cBankIntegrationOrganizationContext

            await waitFor(async () => {
                _1cBankIntegrationOrganizationContext = await BankIntegrationOrganizationContext.getOne(adminClient, {
                    organization: { id: organization.id },
                    enabled: true,
                })
                expect(_1cBankIntegrationOrganizationContext).toBeDefined()
                expect(_1cBankIntegrationOrganizationContext.enabled).toBeTruthy()
                expect(_1cBankIntegrationOrganizationContext.integration.id).toEqual(BANK_INTEGRATION_IDS['1CClientBankExchange'])
            })

            const anotherIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS.SBBOL })
            const anotherBankIntegrationOrganizationContext = await createTestBankIntegrationOrganizationContext(adminClient, anotherIntegration, organization, {
                enabled: false,
            })
            expect(anotherBankIntegrationOrganizationContext).toBeDefined()

            const [secondSbbolTask] = await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
                options: {
                    type: _1C_CLIENT_BANK_EXCHANGE,
                },
            })
            expect(secondSbbolTask).toBeDefined()

            await updateTestBankIntegrationOrganizationContext(adminClient, _1cBankIntegrationOrganizationContext.id, {
                enabled: false,
            })

            await expectToThrowGQLError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    file: new UploadingFile(pathToCorrectFile),
                })
            }, errors.DISABLED_BANK_INTEGRATION_ORGANIZATION_CONTEXT)
        })
    })

    // NOTE: These tests require to have real running server because `importBankTransaction` uses real fetch request
    describe('usage for 1CClientBankExchange integration', () => {

        const expectCorrectBankTransaction = (obj, transactionDataToCompare, organization, bankAccount) => {
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toMatchObject({ dv: 1, fingerprint: 'importBankTransactions' })
            expect(parseFloat(obj.amount)).toBeCloseTo(parseFloat(transactionDataToCompare.amount), 2)
            expect(obj.date).toEqual(dayjs(transactionDataToCompare.date).format('YYYY-MM-DD'))
            expect(obj).toMatchObject(pick(transactionDataToCompare, ['number', 'isOutcome', 'purpose', 'currencyCode']))
            expect(obj.importId).toEqual([dayjs(transactionDataToCompare.date).format('YYYY-MM-DD'), transactionDataToCompare.number].join('_'))
            expect(obj.importRemoteSystem).toEqual('1CClientBankExchange')
            expect(obj.organization.id).toEqual(organization.id)
            expect(obj.account.id).toEqual(bankAccount.id)
            expect(obj.integrationContext.id).toEqual(bankAccount.integrationContext.id)
        }

        it('creates BankAccount, BankIntegrationOrganizationContext, BankIntegrationAccountContext, BankTransaction and BankContractorAccount records', async () => {
            const [organization] = await createTestOrganization(adminClient)

            await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            await waitFor(async () => {
                const createdBankAccount = await BankAccount.getOne(adminClient, {
                    organization: { id: organization.id },
                })
                expect(createdBankAccount).toBeDefined()
                expect(createdBankAccount.dv).toEqual(1)
                expect(createdBankAccount.sender).toMatchObject({ dv: 1, fingerprint: 'importBankTransactions' })
                expect(createdBankAccount.id).toMatch(UUID_RE)
                expect(createdBankAccount).toMatchObject({
                    number: '40702810801500116391',
                    routingNumber: '044525999',
                    meta: {
                        amount: '135394.23',
                        '1CClientBankExchange': {
                            'v': '1.03',
                            'data': {
                                'ДатаНачала': '01.04.2022',
                                'ДатаКонца': '27.10.2022',
                                'РасчСчет': '40702810801500116391',
                                'НачальныйОстаток': '8300.00',
                                'ВсегоПоступило': '2681831.46',
                                'ВсегоСписано': '2554737.23',
                                'КонечныйОстаток': '135394.23',
                            },
                        },
                    },
                })
                // TODO(antonal): Due to difference in time zone offset between localhost and CI/CD calendar days saved from dayjs objects to Keystone cannot be compared using hardcoded values
                // expect(dayjs(createdBankAccount.meta.amountAt, 'YYYY-MM-DD').diff(dayjs('2022-10-27', 'YYYY-MM-DD'), 'day')).toEqual(0)

                const createdBankIntegrationAccountContext = await BankIntegrationAccountContext.getOne(adminClient, {
                    id: createdBankAccount.integrationContext.id,
                })
                expect(createdBankIntegrationAccountContext).toBeDefined()
                const createdBankIntegrationOrganizationContext = await BankIntegrationOrganizationContext.getOne(adminClient, {
                    organization: { id: organization.id },
                    enabled: true,
                })
                expect(createdBankIntegrationOrganizationContext).toBeDefined()
                expect(createdBankIntegrationOrganizationContext.enabled).toBeTruthy()

                const transactions = await BankTransaction.getAll(adminClient, {
                    account: { id: createdBankAccount.id },
                }, { sortBy: 'createdAt_ASC' })
                expect(transactions).toHaveLength(4)
                expectCorrectBankTransaction(transactions[0], PARSED_TRANSACTIONS_TO_COMPARE[0], organization, createdBankAccount)
                expectCorrectBankTransaction(transactions[1], PARSED_TRANSACTIONS_TO_COMPARE[1], organization, createdBankAccount)
                expectCorrectBankTransaction(transactions[2], PARSED_TRANSACTIONS_TO_COMPARE[2], organization, createdBankAccount)
                expectCorrectBankTransaction(transactions[3], PARSED_TRANSACTIONS_TO_COMPARE[3], organization, createdBankAccount)
            })
        })

        it('creates BankIntegrationAccountContext for existing BankAccount, that does not have it', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [existingBankAccount] = await createTestBankAccount(adminClient, organization, {
                number: '40702810801500116391',
                routingNumber: '044525999',
            })

            await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            await waitFor(async () => {
                const reusedBankAccount = await BankAccount.getOne(adminClient, {
                    organization: { id: organization.id },
                })

                expect(reusedBankAccount.id).toEqual(existingBankAccount.id)

                expect(reusedBankAccount.integrationContext).toBeDefined()
                expect(reusedBankAccount.integrationContext.id).toMatch(UUID_RE)
                expect(reusedBankAccount.integrationContext.integration).toBeDefined()
                expect(reusedBankAccount.integrationContext.integration.id).toEqual(BANK_INTEGRATION_IDS['1CClientBankExchange'])

                const transactions = await BankTransaction.getAll(adminClient, {
                    account: { id: reusedBankAccount.id },
                }, { sortBy: 'createdAt_ASC' })
                expect(transactions).toHaveLength(4)
            })
        })

        it('reuses existing BankAccount and BankIntegrationAccountContext when it has the same integration', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const bankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS['1CClientBankExchange'] })
            const [BankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [existingBankAccount] = await createTestBankAccount(adminClient, organization, {
                number: '40702810801500116391',
                routingNumber: '044525999',
                integrationContext: { connect: { id: BankIntegrationAccountContext.id } },
            })

            await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            await waitFor(async () => {
                const reusedBankAccount = await BankAccount.getOne(adminClient, {
                    organization: { id: organization.id },
                })

                expect(reusedBankAccount).toBeDefined()
                expect(reusedBankAccount.id).toEqual(existingBankAccount.id)
                expect(reusedBankAccount).toMatchObject({
                    number: '40702810801500116391',
                    routingNumber: '044525999',
                    integrationContext: {
                        id: BankIntegrationAccountContext.id,
                    },
                    meta: {
                        amount: '135394.23',
                    },
                })
                // TODO(antonal): Due to difference in time zone offset between localhost and CI/CD calendar days saved from dayjs objects to Keystone cannot be compared using hardcoded values
                // expect(dayjs(reusedBankAccount.meta.amountAt, 'YYYY-MM-DD').diff(dayjs('2022-10-27', 'YYYY-MM-DD'), 'day')).toEqual(0)

                const transactions = await BankTransaction.getAll(adminClient, {
                    account: { id: reusedBankAccount.id },
                }, { sortBy: 'createdAt_ASC' })

                expect(transactions).toHaveLength(4)
                expectCorrectBankTransaction(transactions[0], PARSED_TRANSACTIONS_TO_COMPARE[0], organization, existingBankAccount)
                expectCorrectBankTransaction(transactions[1], PARSED_TRANSACTIONS_TO_COMPARE[1], organization, existingBankAccount)
                expectCorrectBankTransaction(transactions[2], PARSED_TRANSACTIONS_TO_COMPARE[2], organization, existingBankAccount)
                expectCorrectBankTransaction(transactions[3], PARSED_TRANSACTIONS_TO_COMPARE[3], organization, existingBankAccount)
            })
        })

        it('reuses existing BankIntegrationOrganizationContext of the same integration', async () => {
            const [organization] = await createTestOrganization(adminClient)

            await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            let obj

            await waitFor(async () => {
                obj = await BankIntegrationOrganizationContext.getOne(adminClient, {
                    organization: { id: organization.id },
                    enabled: true,
                })
                expect(obj).toBeDefined()
                expect(obj.enabled).toBeTruthy()
                expect(obj.integration.id).toEqual(BANK_INTEGRATION_IDS['1CClientBankExchange'])
            })

            const [secondTask] = await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            await waitFor(async () => {
                // Before getting records, produced by worker operation we should wait until it will be completed
                // Otherwise, checks below will use records, produced by previous worker operation
                const secondUpdatedTask = await BankSyncTask.getOne(adminClient, { id: secondTask.id })
                expect(secondUpdatedTask.status).toEqual(BANK_SYNC_TASK_STATUS.COMPLETED)

                const sameObj = await BankIntegrationOrganizationContext.getOne(adminClient, {
                    organization: { id: organization.id },
                    enabled: true,
                })
                expect(sameObj).toBeDefined()
                expect(sameObj.id).toEqual(obj.id)
            })
        })

        it('skips duplicated BankTransaction records by (number, date) uniqueness rule', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [task1] = await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            let transactions

            await waitFor(async () => {
                const createdBankAccount = await BankAccount.getOne(adminClient, {
                    organization: { id: organization.id },
                })
                expect(createdBankAccount).toBeDefined()

                transactions = await BankTransaction.getAll(adminClient, {
                    account: { id: createdBankAccount.id },
                }, { sortBy: 'createdAt_ASC' })

                expect(transactions).toHaveLength(4)
                expectCorrectBankTransaction(transactions[0], PARSED_TRANSACTIONS_TO_COMPARE[0], organization, createdBankAccount)
                expectCorrectBankTransaction(transactions[1], PARSED_TRANSACTIONS_TO_COMPARE[1], organization, createdBankAccount)
                expectCorrectBankTransaction(transactions[2], PARSED_TRANSACTIONS_TO_COMPARE[2], organization, createdBankAccount)
                expectCorrectBankTransaction(transactions[3], PARSED_TRANSACTIONS_TO_COMPARE[3], organization, createdBankAccount)

                const updatedTask1 = await BankSyncTask.getOne(adminClient, { id: task1.id })
                expect(updatedTask1.meta).toBeNull()
            })

            const [task2] = await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            await waitFor(async () => {
                const createdTransactions = await BankTransaction.getAll(adminClient, {
                    organization: { id: organization.id },
                    id_not_in: transactions.map(t => t.id),
                })
                expect(createdTransactions).toHaveLength(0)

                const updatedTask2 = await BankSyncTask.getOne(adminClient, { id: task2.id })
                expect(updatedTask2.status).toEqual(TASK_ERROR_STATUS)
                expect(updatedTask2.meta.errorMessage).toEqual(i18n(TRANSACTIONS_NOT_ADDED.messageForUser))
                expect(updatedTask2.meta).toBeTruthy()
                expect(updatedTask2.meta).toMatchObject({
                    duplicatedTransactions: ['2022-04-15_61298', '2022-04-15_6032', '2022-04-18_656731', '2022-04-18_239'],
                })
            })
        })

        it('sets error to task when another integration of different type exist', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const bankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS.SBBOL })
            const [BankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            await createTestBankAccount(adminClient, organization, {
                number: '40702810801500116391',
                routingNumber: '044525999',
                integrationContext: { connect: { id: BankIntegrationAccountContext.id } },
            })

            const [task] = await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            await waitFor(async () => {
                const updatedTask = await BankSyncTask.getOne(adminClient, { id: task.id })
                expect(updatedTask.meta).toMatchObject({
                    errorMessage: 'Another integration is used for this bank account, that fetches transactions in a different way. You cannot import transactions from file in this case',
                })
            })
        })

        it('sets error to task in case of file parsing error', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [task] = await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToInvalidFile),
            })

            await waitFor(async () => {
                const updatedTask = await BankSyncTask.getOne(adminClient, { id: task.id })
                expect(updatedTask.meta).toMatchObject({
                    errorMessage: 'Cannot parse uploaded file in 1CClientBankExchange format. Error: Line "КонечныйОстаток" not found in node "СекцияРасчСчет".',
                })
            })
        })

        it('sets error to task in case of disabled BankIntegrationAccountContext', async () => {
            const [organization] = await createTestOrganization(adminClient)

            await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            let bankAccount
            await waitFor(async () => {
                bankAccount = await BankAccount.getOne(adminClient, {
                    organization: { id: organization.id },
                })
                expect(bankAccount).toBeDefined()
            })

            await updateTestBankIntegrationAccountContext(adminClient, bankAccount.integrationContext.id, {
                enabled: false,
            })

            const [task] = await createTestBankSyncTask(adminClient, organization, {
                file: new UploadingFile(pathToCorrectFile),
            })

            await waitFor(async () => {
                const updatedTask = await BankSyncTask.getOne(adminClient, { id: task.id })
                expect(updatedTask.meta).toMatchObject({
                    errorMessage: `Manually disabled BankIntegrationAccountContext(id="${bankAccount.integrationContext.id}") for BankAccount(id="${bankAccount.id}"). Operation cannot be executed`,
                })
            })
        })

        it('validates value of "options" field', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const bankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS.SBBOL })
            const [BankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [account] = await createTestBankAccount(adminClient, organization, {
                number: '40702810801500116391',
                routingNumber: '044525999',
                integrationContext: { connect: { id: BankIntegrationAccountContext.id } },
            })

            await expectToThrowValidationFailureError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    user: { connect: { id: adminClient.user.id } },
                    options: { },
                })
            }, 'options field validation error. JSON not in the correct format - path: msg:must have required property \'type\'')

            const [obj, attrs] = await createTestBankSyncTask(adminClient, organization, {
                account: { connect: { id: account.id } },
                user: { connect: { id: adminClient.user.id } },
                options: {
                    type: '1CClientBankExchange',
                },
            })
            expect(obj.options).toMatchObject(attrs.options)
        })
    })

    describe('usage for SBBOL integration', () => {
        it('starts task worker that updates BankSyncTask inside of worker', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const bankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS.SBBOL })
            const [BankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [account] = await createTestBankAccount(adminClient, organization, {
                number: '40702810801500116391',
                routingNumber: '044525999',
                integrationContext: { connect: { id: BankIntegrationAccountContext.id } },
            })

            const [createdTask] = await createTestBankSyncTask(adminClient, organization, {
                account: { connect: { id: account.id } },
                user: { connect: { id: adminClient.user.id } },
                options: {
                    type: 'sbbol',
                    dateFrom: dayjs().format('YYYY-MM-DD'),
                    dateTo: dayjs().format('YYYY-MM-DD'),
                },
            })
            expect(createdTask).toBeDefined()

            await waitFor(async () => {
                const updatedTask = await BankSyncTask.getOne(adminClient, { id: createdTask.id })
                expect(updatedTask.v).toBeGreaterThan(createdTask.v)
            })
        })

        it('requires value for "account" field', async () => {
            const [organization] = await createTestOrganization(adminClient)

            await expectToThrowGQLError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    user: { connect: { id: adminClient.user.id } },
                    options: {
                        type: 'sbbol',
                        dateFrom: dayjs().format('YYYY-MM-DD'),
                        dateTo: dayjs().format('YYYY-MM-DD'),
                    },
                })
            }, errors.ACCOUNT_IS_REQUIRED)
        })

        it('validates value of "options" field', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const bankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS.SBBOL })
            const [BankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [account] = await createTestBankAccount(adminClient, organization, {
                number: '40702810801500116391',
                routingNumber: '044525999',
                integrationContext: { connect: { id: BankIntegrationAccountContext.id } },
            })

            await expectToThrowValidationFailureError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    user: { connect: { id: adminClient.user.id } },
                    options: {
                        type: 'wrong-value',
                        dateFrom: dayjs().format('YYYY-MM-DD'),
                        dateTo: dayjs().format('YYYY-MM-DD'),
                    },
                })
            }, 'options field validation error. JSON not in the correct format - path: msg:value of tag "type" must be in oneOf')

            await expectToThrowValidationFailureError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    user: { connect: { id: adminClient.user.id } },
                    options: {
                        type: 'sbbol',
                        dateFrom: 'wrong-value',
                        dateTo: dayjs().format('YYYY-MM-DD'),
                    },
                })
            }, 'options field validation error. JSON not in the correct format - path:/dateFrom msg:must match format "date"')

            await expectToThrowValidationFailureError(async () => {
                await createTestBankSyncTask(adminClient, organization, {
                    account: { connect: { id: account.id } },
                    user: { connect: { id: adminClient.user.id } },
                    options: {
                        type: 'sbbol',
                        dateFrom: dayjs().format('YYYY-MM-DD'),
                        dateTo: 'wrong-value',
                    },
                })
            }, 'options field validation error. JSON not in the correct format - path:/dateTo msg:must match format "date"')

            const [obj, attrs] = await createTestBankSyncTask(adminClient, organization, {
                account: { connect: { id: account.id } },
                user: { connect: { id: adminClient.user.id } },
                options: {
                    type: 'sbbol',
                    dateFrom: dayjs().format('YYYY-MM-DD'),
                    dateTo: dayjs().format('YYYY-MM-DD'),
                },
            })

            expect(obj.options).toMatchObject(attrs.options)
        })
    })
})
