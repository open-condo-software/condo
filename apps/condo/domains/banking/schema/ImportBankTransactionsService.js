/**
 * Generated by `createservice banking.ImportBankTransactionsService`
 */
const { get } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/banking/access/ImportBankTransactionsService')
const { BANK_INTEGRATION_IDS, _1C_CLIENT_BANK_EXCHANGE } = require('@condo/domains/banking/constants')
const { convertFrom1CExchangeToSchema } = require('@condo/domains/banking/utils/serverSchema/converters/convertFrom1CExchangeToSchema')
const { BankAccount, BankIntegrationContext, BankIntegration, BankTransaction, BankContractorAccount } = require('@condo/domains/banking/utils/serverSchema/index')
const { Organization } = require('@condo/domains/organization/utils/serverSchema')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const errors = {
    INVALID_FILE_FORMAT: {
        mutation: 'importBankTransactions',
        variable: ['data', 'file'],
        code: BAD_USER_INPUT,
        type: 'INVALID_FILE_FORMAT',
        message: 'Cannot parse uploaded file',
        messageForUser: 'api.banking.importBankTransactions.INVALID_FILE_FORMAT',
    },
    CANNOT_FIND_BANK_INTEGRATION: {
        mutation: 'importBankTransactions',
        code: INTERNAL_ERROR,
        type: 'CANNOT_FIND_BANK_INTEGRATION',
        message: 'Cannot find BankIntegration with id "61e3d767-bd62-40e3-a503-f885b242d262" corresponding to import from file in "1CClientBankExchange" format',
    },
    SOMETHING_WENT_WRONG: {
        mutation: 'importBankTransactions',
        code: INTERNAL_ERROR,
        type: INTERNAL_ERROR,
        message: 'Error during import',
        messageForUser: 'api.user.importBankTransactions.SOMETHING_WENT_WRONG',
    },
    ANOTHER_INTEGRATION_IS_USED: {
        mutation: 'importBankTransactions',
        variable: ['data', 'file'],
        code: BAD_USER_INPUT,
        type: 'ANOTHER_INTEGRATION_IS_USED',
        message: 'Another integration is used for this bank account, that fetches transactions in a different way. You cannot import transactions from file in this case',
        messageForUser: 'api.banking.importBankTransactions.ANOTHER_INTEGRATION_IS_USED',
    },
    BANK_ACCOUNT_HAS_NO_INTEGRATION: {
        mutation: 'importBankTransactions',
        variable: ['data', 'file'],
        code: BAD_USER_INPUT,
        type: 'BANK_ACCOUNT_HAS_NO_INTEGRATION',
        message: 'For this import operation was found bank account with id "${id}" and it does not have integration. It means that this bank account has been initially used for something different or something goes wrong. In this case it cannot be used to fetch data from file',
        messageForUser: 'api.banking.importBankTransactions.BANK_ACCOUNT_HAS_NO_INTEGRATION',
    },
}

const ImportBankTransactionsService = new GQLCustomSchema('ImportBankTransactionsService', {
    doc: {
        summary: 'Imports bank transactions from file in 1CClientBankExchange format of version 1.03',
        errors,
    },
    types: [
        {
            access: true,
            type: 'input ImportBankTransactionsInput { dv: Int!, sender: JSON!, file: Upload!, organizationId: ID!, propertyId: ID! }',
        },
        {
            access: true,
            type: 'type ImportBankTransactionsOutput { bankAccount: BankAccount }',
        },
    ],
    
    mutations: [
        {
            access: access.canImportBankTransactions,
            schema: 'importBankTransactions(data: ImportBankTransactionsInput!): ImportBankTransactionsOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { sender, file, organizationId, propertyId } = data
                const dvSender = { dv: 1, sender }
                let conversionResult
                try {
                    const fileUpload = await Promise.resolve(file)
                    const fileStream = fileUpload.createReadStream()
                    conversionResult = await convertFrom1CExchangeToSchema(fileStream)
                } catch (error) {
                    throw new GQLError({
                        ...errors.INVALID_FILE_FORMAT,
                        messageInterpolation: {
                            message: error.message,
                        },
                    }, context)
                }
                const { bankAccountData, bankTransactionsData } = conversionResult
                const organization = await Organization.getOne(context, { id: organizationId })
                const integration = await BankIntegration.getOne(context, { id: BANK_INTEGRATION_IDS['1CClientBankExchange'] })
                let bankAccount = await BankAccount.getOne(context, {
                    number: bankAccountData.number,
                    organization: { id: organizationId },
                })
                let integrationContext
                if (!bankAccount) {
                    if (!integration) {
                        throw new GQLError(errors.CANNOT_FIND_BANK_INTEGRATION, context)
                    }
                    integrationContext = await BankIntegrationContext.create(context, {
                        ...dvSender,
                        integration: { connect: { id: integration.id } },
                        organization: { connect: { id: organizationId } },
                    })
                    bankAccount = await BankAccount.create(context, {
                        ...dvSender,
                        number: bankAccountData.number,
                        routingNumber: bankAccountData.routingNumber,
                        tin: organization.tin,
                        country: organization.country,
                        currencyCode: 'RUB',
                        meta: bankAccountData.meta,
                        organization: { connect: { id: organizationId } },
                        integrationContext: { connect: { id: integrationContext.id } },
                        property: { connect: { id: propertyId } },
                    })
                } else {
                    if (bankAccount.integrationContext) {
                        if (get(bankAccount, ['integrationContext', 'integration', 'id']) !== BANK_INTEGRATION_IDS['1CClientBankExchange']) {
                            throw new GQLError(errors.ANOTHER_INTEGRATION_IS_USED, context)
                        } else {
                            integrationContext = bankAccount.integrationContext
                        }
                    } else {
                        throw new GQLError({
                            ...errors.BANK_ACCOUNT_HAS_NO_INTEGRATION,
                            messageInterpolation: {
                                id: bankAccount.id,
                            },
                        }, context)
                    }

                    bankAccount = await BankAccount.update(context, bankAccount.id, {
                        ...dvSender,
                        meta: bankAccountData.meta,
                    })
                }
                for (const transactionData of bankTransactionsData) {
                    const existingTransaction = await BankTransaction.getOne(context, {
                        number: transactionData.number,
                        date: transactionData.date.toISOString(),
                    })
                    if (existingTransaction) continue
                    const payload = {
                        ...dvSender,
                        number: transactionData.number,
                        date: transactionData.date.format('YYYY-MM-DD'),
                        isOutcome: transactionData.isOutcome,
                        purpose: transactionData.purpose,
                        currencyCode: 'RUB',
                        amount: transactionData.amount.toString(),
                        importId: transactionData.number,
                        importRemoteSystem: _1C_CLIENT_BANK_EXCHANGE,
                        organization: { connect: { id: organizationId } },
                        account: { connect: { id: bankAccount.id } },
                        integrationContext: { connect: { id: integrationContext.id } },
                        meta: transactionData.meta,
                    }
                    if (transactionData.contractorAccount) {
                        let existingContractorAccount = await BankContractorAccount.getOne(context, {
                            organization: { id: organizationId },
                            number: transactionData.contractorAccount.number,
                            tin: transactionData.contractorAccount.tin,
                        })
                        let contractorAccountId
                        if (existingContractorAccount) {
                            contractorAccountId = existingContractorAccount.id
                        } else {
                            const newContractorAccount = await BankContractorAccount.create(context, {
                                ...dvSender,
                                ...transactionData.contractorAccount,
                                country: organization.country,
                                currencyCode: 'RUB',
                                organization: { connect: { id: organizationId } },
                            })
                            contractorAccountId = newContractorAccount.id
                        }
                        payload.contractorAccount = { connect: { id: contractorAccountId } }
                    }

                    await BankTransaction.create(context, payload)
                }
                return {
                    bankAccount: await getById('BankAccount', bankAccount.id),
                }
            },
        },
    ],
    
})

module.exports = {
    ImportBankTransactionsService,
}
