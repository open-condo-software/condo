/**
 * Generated by `createschema banking.BankAccount 'organization:Relationship:Organization:CASCADE; tin:Text; country:Text; routingNumber:Text; number:Text; currency:Text; approvedAt?:DateTimeUtc; approvedBy?:Text; importId?:Text; territoryCode?:Text; bankName?:Text; meta?:Json; tinMeta?:Json; routingNumberMeta?:Json'`
 */

const dayjs = require('dayjs')
const { pick } = require('lodash')

const { makeLoggedInAdminClient, makeClient, expectToThrowValidationFailureError, UUID_RE } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const {
    BankAccount,
    createTestBankAccount,
    updateTestBankAccount,
    createTestBankContractorAccount,
    createTestBankTransaction,
} = require('@condo/domains/banking/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestOrganizationEmployeeRole, createTestOrganizationEmployee } = require('@condo/domains/organization/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

const { BANK_INTEGRATION_IDS } = require('../constants')
const { BankIntegration, createTestBankIntegrationAccountContext } = require('../utils/testSchema')

const ISO_8601_FULL = /^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i

let adminClient
let supportClient
let bankIntegration

describe('BankAccount', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        bankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS['1CClientBankExchange'] })
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [bankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [objCreated] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: bankIntegrationAccountContext.id } },
                })

                expect(objCreated.organization.id).toEqual(organization.id)
                expect(objCreated.tin).toBeDefined()
                expect(objCreated.country).toEqual('ru')
                expect(objCreated.routingNumber).toBeDefined()
                expect(objCreated.number).toBeDefined()
                expect(objCreated.currencyCode).toEqual('RUB')
                expect(objCreated.integrationContext).toMatchObject(pick(bankIntegrationAccountContext, ['id', 'enabled']))
                expect(objCreated).toHaveProperty('reportVisible', false)
            })

            test('support can', async () => {
                const [organization] = await createTestOrganization(supportClient)
                const [bankAccount] = await createTestBankAccount(supportClient, organization)

                expect(bankAccount.organization.id).toEqual(organization.id)
                expect(bankAccount.tin).toBeDefined()
                expect(bankAccount.country).toEqual('ru')
                expect(bankAccount.routingNumber).toBeDefined()
                expect(bankAccount.number).toBeDefined()
                expect(bankAccount.currencyCode).toEqual('RUB')
            })

            test('user can\'t', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(adminClient)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestBankAccount(user, organization)
                })
            })

            test('user can if it is an employee of organization with "canManageBankAccounts" permission ', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [bankIntegrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)

                const [objCreated, attrs] = await createTestBankAccount(userClient, organization, {
                    integrationContext: { connect: { id: bankIntegrationContext.id } },
                })

                expect(objCreated.id).toMatch(UUID_RE)
                expect(objCreated.dv).toEqual(1)
                expect(objCreated.sender).toEqual(attrs.sender)
                expect(objCreated.createdBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            })

            test('anonymous can\'t', async () => {
                const anonymous = await makeClient()

                const [organization] = await createTestOrganization(adminClient)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestBankAccount(anonymous, organization)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)
                const [readObj] = await BankAccount.getAll(adminClient, { id: createdObj.id })

                expect(createdObj.organization.id).toEqual(readObj.organization.id)
                expect(createdObj.tin).toEqual(readObj.tin)
                expect(createdObj.country).toEqual(readObj.country)
                expect(createdObj.routingNumber).toEqual(readObj.routingNumber)
                expect(createdObj.number).toEqual(readObj.number)
                expect(createdObj.currencyCode).toEqual(readObj.currencyCode)
            })

            test('support can', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)
                const [readObj] = await BankAccount.getAll(supportClient, { id: createdObj.id })

                expect(createdObj.organization.id).toEqual(readObj.organization.id)
                expect(createdObj.tin).toEqual(readObj.tin)
                expect(createdObj.country).toEqual(readObj.country)
                expect(createdObj.routingNumber).toEqual(readObj.routingNumber)
                expect(createdObj.number).toEqual(readObj.number)
                expect(createdObj.currencyCode).toEqual(readObj.currencyCode)
            })

            test('user can only for organization it employed in', async () => {
                const employeeUserClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [ organization ] = await createTestOrganization(adminClient)
                const [ role ] = await createTestOrganizationEmployeeRole(adminClient, organization)
                await createTestOrganizationEmployee(adminClient, organization, employeeUserClient.user, role)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)

                const [ readObj ] = await BankAccount.getAll(employeeUserClient, {})

                expect(createdObj.organization.id).toEqual(readObj.organization.id)
                expect(createdObj.tin).toEqual(readObj.tin)
                expect(createdObj.country).toEqual(readObj.country)
                expect(createdObj.routingNumber).toEqual(readObj.routingNumber)
                expect(createdObj.number).toEqual(readObj.number)
                expect(createdObj.currencyCode).toEqual(readObj.currencyCode)
            })

            test('user can\'t  when it\'s an employee of another organization', async () => {
                const employeeUserClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [ organization ] = await createTestOrganization(adminClient)

                const [ anotherOrganization ] = await createTestOrganization(adminClient)
                const [ role ] = await createTestOrganizationEmployeeRole(adminClient, anotherOrganization)
                await createTestOrganizationEmployee(adminClient, anotherOrganization, employeeUserClient.user, role)

                await createTestBankAccount(adminClient, organization)

                const readObj = await BankAccount.getAll(employeeUserClient, {})

                expect(readObj).toHaveLength(0)
            })

            test('user can\'t when it\'s not an employee of organization', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()

                const [ organization ] = await createTestOrganization(adminClient)

                await createTestBankAccount(adminClient, organization)

                const readObjects = await BankAccount.getAll(user, {})

                expect(readObjects).toHaveLength(0)
            })

            test('anonymous can\'t', async () => {
                const anonymous = await makeClient()

                const [ organization ] = await createTestOrganization(adminClient)

                await createTestBankAccount(adminClient, organization)

                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await BankAccount.getAll(anonymous, {})
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)
                const [ updatedObj ] = await updateTestBankAccount(adminClient, createdObj.id, { bankName: 'NewBankName' })

                expect(createdObj.id).toEqual(updatedObj.id)
                expect(updatedObj.bankName).toEqual('NewBankName')
            })

            test('support can', async () => {
                const [organization] = await createTestOrganization(supportClient)

                const [ createdObj ] = await createTestBankAccount(supportClient, organization)
                const [ updatedObj ] = await updateTestBankAccount(supportClient, createdObj.id, { bankName: 'NewBankName' })

                expect(createdObj.id).toEqual(updatedObj.id)
                expect(updatedObj.bankName).toEqual('NewBankName')
            })

            test('user can if it is an employee of organization with "canManageBankAccounts" permission', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [bankIntegrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)

                const [objCreated] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: bankIntegrationContext.id } },
                })

                const [obj, attrs] = await updateTestBankAccount(userClient, objCreated.id, { bankName: 'NewBankName' })

                expect(obj).toHaveProperty('dv', 1)
                expect(obj).toHaveProperty('sender', attrs.sender)
                expect(obj).toHaveProperty('v', 2)
            })

            test('user can\'t', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {await updateTestBankAccount(user,
                    createdObj.id, { bankName: 'NewBankName' })
                })
            })

            test('anonymous can\'t', async () => {
                const anonymous = await makeClient()
                const [organization] = await createTestOrganization(adminClient)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)

                await expectToThrowAuthenticationErrorToObj(async () => {await updateTestBankAccount(anonymous,
                    createdObj.id, { bankName: 'NewBankName' })
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BankAccount.delete(adminClient, createdObj.id)
                })
            })

            test('support can\'t', async () => {
                const [organization] = await createTestOrganization(supportClient)

                const [createdObj] = await createTestBankAccount(supportClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BankAccount.delete(supportClient, createdObj.id)
                })
            })

            test('user can\'t', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BankAccount.delete(user, createdObj.id)
                })
            })
        })
    })

    describe('fields', () => {
        describe('approvedAt', () => {
            test('can create approved bankAccount', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization, { approvedAt: 'true'  })

                expect(createdObj.approvedAt).toMatch(ISO_8601_FULL)
                expect(createdObj.approvedBy.id).toEqual(adminClient.user.id)
            })

            test('setting approvedAt automatically sets approvedBy', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)
                const [updatedObj] = await updateTestBankAccount(adminClient, createdObj.id, { approvedAt: 'true'  })

                expect(createdObj.id).toEqual(updatedObj.id)
                expect(createdObj.approvedAt).toBeNull()
                expect(createdObj.approvedBy).toBeNull()

                expect(updatedObj.approvedAt).toMatch(ISO_8601_FULL)
                expect(updatedObj.approvedBy.id).toEqual(adminClient.user.id)
            })

            test('when model is updated, approvedAt and approvedBy are set to NULL', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization, { approvedAt: 'true' })
                const [updatedObj] = await updateTestBankAccount(adminClient, createdObj.id, { bankName: 'NewBankName' })

                expect(createdObj.id).toEqual(updatedObj.id)
                expect(createdObj.approvedBy.id).toEqual(adminClient.user.id)

                expect(updatedObj.approvedBy).toBeNull()
                expect(updatedObj.approvedAt).toBeNull()
                expect(updatedObj.bankName).toEqual('NewBankName')
            })

            test('support can update approved fields', async () => {
                const [organization] = await createTestOrganization(supportClient)

                const [createdObj] = await createTestBankAccount(supportClient, organization)
                const [updatedObj] = await updateTestBankAccount(supportClient, createdObj.id, { approvedAt: 'true' })

                expect(createdObj.id).toEqual(updatedObj.id)
                expect(createdObj.approvedAt).toBeNull()
                expect(createdObj.approvedBy).toBeNull()
                expect(updatedObj.approvedBy.id).toEqual(supportClient.user.id)
            })

            test('user can\'t update isApproved field', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestBankAccount(user, createdObj.id, { approvedAt: 'true' })
                })
            })
        })

        describe('approvedBy', () => {
            test('approvedBy field is not creatable', async () => {
                const [organization] = await createTestOrganization(adminClient)

                await catchErrorFrom(
                    async () => {
                        await createTestBankAccount(adminClient, organization, { approvedBy: { connect: { id: adminClient.user.id } } })
                    }, (e) => {
                        const msg = e.errors[0].message
                        expect(msg).toContain('Field "approvedBy" is not defined by type "BankAccountCreateInput"')
                    }
                )
            })

            test('approvedBy field is not updatable', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)

                await catchErrorFrom(
                    async () => {
                        await updateTestBankAccount(adminClient, createdObj.id, { approvedBy: { connect: { id: adminClient.user.id } } })
                    }, (e) => {
                        const msg = e.errors[0].message
                        expect(msg).toContain('Field "approvedBy" is not defined by type "BankAccountUpdateInput"')
                    }
                )
            })
        })
    })

    describe('constraints', () => {
        test('can\'t create same BankAccount', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [bankAccount] = await createTestBankAccount(adminClient, organization)

            await catchErrorFrom(
                async () => {
                    await createTestBankAccount(adminClient, organization, {
                        tin: bankAccount.tin,
                        routingNumber: bankAccount.routingNumber,
                        number: bankAccount.number,
                    })
                }, (e) => {
                    const msg = e.errors[0].message
                    expect(msg).toContain('duplicate key value violates unique constraint')
                }
            )
        })

        test('can delete and then create another BankAccount with same requisites', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [firstBankAccount] = await createTestBankAccount(adminClient, organization)

            await updateTestBankAccount(adminClient, firstBankAccount.id, { deletedAt: 'true' })

            const [secondBankAccount] = await createTestBankAccount(adminClient, organization,  {
                tin: firstBankAccount.tin,
                routingNumber: firstBankAccount.routingNumber,
                number: firstBankAccount.number,
            })

            expect(firstBankAccount.id).toBeDefined()
            expect(secondBankAccount.id).toBeDefined()
            expect(firstBankAccount.id).not.toEqual(secondBankAccount.id)
        })

        test('can\'t connect new BankAccount to BankIntegrationAccountContext used by another BankAccount', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [bankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)

            const [anotherBankAccount] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: bankIntegrationAccountContext.id } },
            })
            await expectToThrowValidationFailureError(async () => {
                await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: anotherBankAccount.integrationContext.id } },
                })
            }, `Cannot connect to BankIntegrationAccountContext, used by another BankAccount(id="${anotherBankAccount.id}")`)
        })

        test('can\'t connect existing BankAccount without BankIntegrationAccountContext to BankIntegrationAccountContext used by another BankAccount', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [bankAccount] = await createTestBankAccount(adminClient, organization)
            const [anotherBankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [anotherBankAccount] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: anotherBankIntegrationAccountContext.id } },
            })
            await expectToThrowValidationFailureError(async () => {
                await updateTestBankAccount(adminClient, bankAccount.id, {
                    integrationContext: {
                        connect: { id: anotherBankIntegrationAccountContext.id },
                    },
                })
            }, `Cannot connect to BankIntegrationAccountContext, used by another BankAccount(id="${anotherBankAccount.id}")`)

        })

        test('cannot connect BankIntegrationAccountContext if BankAccount is already connected to some integrationContext', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [BankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [anotherIntegrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)

            const [bankAccount] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: BankIntegrationAccountContext.id } },
            })

            await expectToThrowValidationFailureError(async () => {
                await updateTestBankAccount(adminClient, bankAccount.id, {
                    integrationContext: { connect: { id: anotherIntegrationContext.id } },
                })
            }, `Integration reassignment is not allowed for BankAccount with id="${bankAccount.id}"`)
        })
    })
})
