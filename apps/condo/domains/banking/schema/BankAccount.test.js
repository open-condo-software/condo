/**
 * Generated by `createschema banking.BankAccount 'organization:Relationship:Organization:CASCADE; tin:Text; country:Text; routingNumber:Text; number:Text; currency:Text; approvedAt?:DateTimeUtc; approvedBy?:Text; importId?:Text; territoryCode?:Text; bankName?:Text; meta?:Json; tinMeta?:Json; routingNumberMeta?:Json'`
 */

const dayjs = require('dayjs')
const { pick } = require('lodash')

const {
    makeClient,
    makeLoggedInAdminClient,
    UUID_RE,
    expectToThrowUniqueConstraintViolationError,
    expectValuesOfCommonFields, expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const {
    BankAccount,
    BankIntegration,
    createTestBankAccount,
    updateTestBankAccount,
    createTestBankIntegrationAccessRight,
    createTestBankIntegrationAccountContext,
    createTestBankIntegrationOrganizationContext,
} = require('@condo/domains/banking/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployee,
    createTestOrganizationEmployeeRole,
} = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { createTestResident } = require('@condo/domains/resident/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')
const { makeClientWithServiceUser } = require('@condo/domains/user/utils/testSchema')
const { makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')

const { BANK_INTEGRATION_IDS } = require('../constants')

const ISO_8601_FULL = /^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i

let adminClient
let supportClient
let serviceClient
let bankIntegration
let SBBOLBankIntegration

describe('BankAccount', () => {
    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        bankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS['1CClientBankExchange'] })
        SBBOLBankIntegration = await BankIntegration.getOne(adminClient, { id: BANK_INTEGRATION_IDS.SBBOL })
        serviceClient = await makeClientWithServiceUser()
        await createTestBankIntegrationAccessRight(adminClient, SBBOLBankIntegration, serviceClient.user)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [bankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [obj, attrs] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: bankIntegrationAccountContext.id } },
                })

                expectValuesOfCommonFields(obj, attrs, adminClient)
                expect(obj.organization.id).toEqual(organization.id)
                expect(obj.tin).toBeDefined()
                expect(obj.country).toEqual('ru')
                expect(obj.routingNumber).toBeDefined()
                expect(obj.number).toBeDefined()
                expect(obj.currencyCode).toEqual('RUB')
                expect(obj.integrationContext).toMatchObject(pick(bankIntegrationAccountContext, ['id', 'enabled']))
            })

            test('support can', async () => {
                const [organization] = await createTestOrganization(supportClient)
                const [obj, attrs] = await createTestBankAccount(supportClient, organization)

                expectValuesOfCommonFields(obj, attrs, supportClient)
                expect(obj.organization.id).toEqual(organization.id)
                expect(obj.tin).toBeDefined()
                expect(obj.country).toEqual('ru')
                expect(obj.routingNumber).toBeDefined()
                expect(obj.number).toBeDefined()
                expect(obj.currencyCode).toEqual('RUB')
            })

            test('service can if organization have context', async () => {
                const [organization] = await createTestOrganization(adminClient)
                await createTestBankIntegrationOrganizationContext(adminClient, SBBOLBankIntegration, organization)

                const [obj, attrs] = await createTestBankAccount(serviceClient, organization, {
                    isApproved: undefined, // since isApproved can be set up only by supports & admins
                })

                expectValuesOfCommonFields(obj, attrs, serviceClient)
                expect(obj.organization.id).toEqual(organization.id)
                expect(obj.tin).toBeDefined()
                expect(obj.country).toEqual('ru')
                expect(obj.routingNumber).toBeDefined()
                expect(obj.number).toBeDefined()
                expect(obj.currencyCode).toEqual('RUB')
            })

            test('service can\'t if organization does not have context', async () => {
                const [organization] = await createTestOrganization(adminClient)
                try {
                    await createTestBankAccount(serviceClient, organization)
                } catch (error) {
                    expect(error.message).toContain('You do not have access to this resource')
                }
            })


            test('user can\'t', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()

                const [organization] = await createTestOrganization(adminClient)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestBankAccount(user, organization)
                })
            })

            test('user can if it is an employee of organization with "canManageBankAccounts" permission ', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [bankIntegrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)

                const [obj, attrs] = await createTestBankAccount(userClient, organization, {
                    isApproved: undefined, // since isApproved can be set up only by supports & admins
                    integrationContext: { connect: { id: bankIntegrationContext.id } },
                })

                expectValuesOfCommonFields(obj, attrs, userClient)
                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.createdBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            })

            test('anonymous can\'t', async () => {
                const anonymous = await makeClient()

                const [organization] = await createTestOrganization(adminClient)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestBankAccount(anonymous, organization)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)
                const [readObj] = await BankAccount.getAll(adminClient, { id: createdObj.id })

                expect(createdObj.organization.id).toEqual(readObj.organization.id)
                expect(createdObj.tin).toEqual(readObj.tin)
                expect(createdObj.country).toEqual(readObj.country)
                expect(createdObj.routingNumber).toEqual(readObj.routingNumber)
                expect(createdObj.number).toEqual(readObj.number)
                expect(createdObj.currencyCode).toEqual(readObj.currencyCode)
            })

            test('service can', async () => {
                const [organization] = await createTestOrganization(adminClient)
                await createTestBankIntegrationOrganizationContext(adminClient, SBBOLBankIntegration, organization)
                const [integrationContext] = await createTestBankIntegrationAccountContext(serviceClient, SBBOLBankIntegration, organization)

                const [createdObj] = await createTestBankAccount(serviceClient, organization, {
                    isApproved: undefined, // since isApproved can be set up only by supports & admins
                    integrationContext: { connect: { id: integrationContext.id } },
                })
                const [readObj] = await BankAccount.getAll(serviceClient, { id: createdObj.id })

                expect(createdObj.organization.id).toEqual(readObj.organization.id)
                expect(createdObj.tin).toEqual(readObj.tin)
                expect(createdObj.country).toEqual(readObj.country)
                expect(createdObj.routingNumber).toEqual(readObj.routingNumber)
                expect(createdObj.number).toEqual(readObj.number)
                expect(createdObj.currencyCode).toEqual(readObj.currencyCode)
            })

            test('service can if BankAccount has no connected integration', async () => {
                // Billing uses BankAccount as an account directory.
                // If you receive the same BankAccount from SBBOL, you must connect the SBBOL integration to this BankAccount, and not create a new one.
                // Therefore, the service user must be able to read such BankAccount.
                const [organization] = await createTestOrganization(adminClient)
                await createTestBankIntegrationOrganizationContext(adminClient, SBBOLBankIntegration, organization)

                const [createdObj] = await createTestBankAccount(adminClient, organization)
                const [readObj] = await BankAccount.getAll(serviceClient, { id: createdObj.id })

                expect(createdObj.organization.id).toEqual(readObj.organization.id)
                expect(createdObj.tin).toEqual(readObj.tin)
                expect(createdObj.country).toEqual(readObj.country)
                expect(createdObj.routingNumber).toEqual(readObj.routingNumber)
                expect(createdObj.number).toEqual(readObj.number)
                expect(createdObj.currencyCode).toEqual(readObj.currencyCode)
            })

            test('support can', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)
                const [readObj] = await BankAccount.getAll(supportClient, { id: createdObj.id })

                expect(createdObj.organization.id).toEqual(readObj.organization.id)
                expect(createdObj.tin).toEqual(readObj.tin)
                expect(createdObj.country).toEqual(readObj.country)
                expect(createdObj.routingNumber).toEqual(readObj.routingNumber)
                expect(createdObj.number).toEqual(readObj.number)
                expect(createdObj.currencyCode).toEqual(readObj.currencyCode)
            })

            test('user can only for organization it employed in', async () => {
                const employeeUserClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [ organization ] = await createTestOrganization(adminClient)
                const [ role ] = await createTestOrganizationEmployeeRole(adminClient, organization)
                await createTestOrganizationEmployee(adminClient, organization, employeeUserClient.user, role)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)

                const [ readObj ] = await BankAccount.getAll(employeeUserClient, {})

                expect(createdObj.organization.id).toEqual(readObj.organization.id)
                expect(createdObj.tin).toEqual(readObj.tin)
                expect(createdObj.country).toEqual(readObj.country)
                expect(createdObj.routingNumber).toEqual(readObj.routingNumber)
                expect(createdObj.number).toEqual(readObj.number)
                expect(createdObj.currencyCode).toEqual(readObj.currencyCode)
            })

            test('user can\'t  when it\'s an employee of another organization', async () => {
                const employeeUserClient = await makeClientWithNewRegisteredAndLoggedInUser()

                const [ organization ] = await createTestOrganization(adminClient)

                const [ anotherOrganization ] = await createTestOrganization(adminClient)
                const [ role ] = await createTestOrganizationEmployeeRole(adminClient, anotherOrganization)
                await createTestOrganizationEmployee(adminClient, anotherOrganization, employeeUserClient.user, role)

                await createTestBankAccount(adminClient, organization)

                const readObj = await BankAccount.getAll(employeeUserClient, {})

                expect(readObj).toHaveLength(0)
            })

            test('user can\'t when it\'s not an employee of organization', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()

                const [ organization ] = await createTestOrganization(adminClient)

                await createTestBankAccount(adminClient, organization)

                const readObjects = await BankAccount.getAll(user, {})

                expect(readObjects).toHaveLength(0)
            })

            test('resident user can read for its property', async () => {
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [bankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                const [obj] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: bankIntegrationAccountContext.id } },
                    property: { connect: { id: property.id } },
                })

                const userClient = await makeClientWithResidentUser()
                await createTestResident(adminClient, userClient.user, property)

                expect(userClient).toBeDefined()

                const objs = await BankAccount.getAll(userClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs).toHaveLength(1)
                expect(objs[0]).toMatchObject({
                    id: obj.id,
                })

                const [anotherProperty] = await createTestProperty(adminClient, organization)
                const [anotherBankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
                await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: anotherBankIntegrationAccountContext.id } },
                    property: { connect: { id: anotherProperty.id } },
                })

                const sameObjs = await BankAccount.getAll(userClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(sameObjs).toHaveLength(1)
                expect(sameObjs[0]).toMatchObject({
                    id: obj.id,
                })

                const notResidentUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const objsForNotResident = await BankAccount.getAll(notResidentUserClient, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objsForNotResident).toHaveLength(0)
            })

            test('anonymous can\'t', async () => {
                const anonymous = await makeClient()

                const [ organization ] = await createTestOrganization(adminClient)

                await createTestBankAccount(adminClient, organization)

                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await BankAccount.getAll(anonymous, {})
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)
                const [ updatedObj ] = await updateTestBankAccount(adminClient, createdObj.id, { bankName: 'NewBankName' })

                expect(createdObj.id).toEqual(updatedObj.id)
                expect(updatedObj.bankName).toEqual('NewBankName')
            })

            test('support can', async () => {
                const [organization] = await createTestOrganization(supportClient)

                const [ createdObj ] = await createTestBankAccount(supportClient, organization)
                const [ updatedObj ] = await updateTestBankAccount(supportClient, createdObj.id, { bankName: 'NewBankName' })

                expect(createdObj.id).toEqual(updatedObj.id)
                expect(updatedObj.bankName).toEqual('NewBankName')
            })

            test('user can if it is an employee of organization with "canManageBankAccounts" permission', async () => {
                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [role] = await createTestOrganizationEmployeeRole(adminClient, organization, {
                    canManageBankAccounts: true,
                })
                await createTestOrganizationEmployee(adminClient, organization, userClient.user, role)
                const [bankIntegrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)

                const [objCreated] = await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: bankIntegrationContext.id } },
                })

                const [obj, attrs] = await updateTestBankAccount(userClient, objCreated.id, { bankName: 'NewBankName' })

                expect(obj).toHaveProperty('dv', 1)
                expect(obj).toHaveProperty('sender', attrs.sender)
                expect(obj).toHaveProperty('v', 2)
            })

            test('service can', async () => {
                const meta = { test: 'test' }
                const [organization] = await createTestOrganization(adminClient)
                await createTestBankIntegrationOrganizationContext(adminClient, SBBOLBankIntegration, organization)
                const [integrationContext] = await createTestBankIntegrationAccountContext(serviceClient, SBBOLBankIntegration, organization)

                const [createdObj] = await createTestBankAccount(serviceClient, organization, {
                    isApproved: undefined, // since isApproved can be set up only by supports & admins
                    integrationContext: { connect: { id: integrationContext.id } },
                })
                const [updated] = await updateTestBankAccount(serviceClient, createdObj.id, { meta })

                expect(createdObj.organization.id).toEqual(updated.organization.id)
                expect(createdObj.id).toEqual(updated.id)
                expect(updated.meta).toEqual(meta)
            })

            test('user can\'t', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {await updateTestBankAccount(user,
                    createdObj.id, { bankName: 'NewBankName' })
                })
            })

            test('anonymous can\'t', async () => {
                const anonymous = await makeClient()
                const [organization] = await createTestOrganization(adminClient)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)

                await expectToThrowAuthenticationErrorToObj(async () => {await updateTestBankAccount(anonymous,
                    createdObj.id, { bankName: 'NewBankName' })
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BankAccount.delete(adminClient, createdObj.id)
                })
            })

            test('support can\'t', async () => {
                const [organization] = await createTestOrganization(supportClient)

                const [createdObj] = await createTestBankAccount(supportClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BankAccount.delete(supportClient, createdObj.id)
                })
            })

            test('user can\'t', async () => {
                const user = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)

                const [ createdObj ] = await createTestBankAccount(adminClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await BankAccount.delete(user, createdObj.id)
                })
            })
        })
    })

    describe('fields', () => {
        describe('approvedAt', () => {
            test('approvedAt field is not creatable', async () => {
                const [organization] = await createTestOrganization(adminClient)

                await catchErrorFrom(
                    async () => {
                        await createTestBankAccount(adminClient, organization, {
                            approvedAt: dayjs().toString(),
                        })
                    }, (e) => {
                        const msg = e.errors[0].message
                        expect(msg).toContain('Field "approvedAt" is not defined by type "BankAccountCreateInput"')
                    }
                )
            })

            test('approvedAt field is not updatable', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)

                await catchErrorFrom(
                    async () => {
                        await updateTestBankAccount(adminClient, createdObj.id, {
                            approvedAt: dayjs().toString(),
                        })
                    }, (e) => {
                        const msg = e.errors[0].message
                        expect(msg).toContain('Field "approvedAt" is not defined by type "BankAccountUpdateInput"')
                    }
                )
            })
        })

        describe('approvedBy', () => {
            test('approvedBy field is not creatable', async () => {
                const [organization] = await createTestOrganization(adminClient)

                await catchErrorFrom(
                    async () => {
                        await createTestBankAccount(adminClient, organization, { approvedBy: { connect: { id: adminClient.user.id } } })
                    }, (e) => {
                        const msg = e.errors[0].message
                        expect(msg).toContain('Field "approvedBy" is not defined by type "BankAccountCreateInput"')
                    }
                )
            })

            test('approvedBy field is not updatable', async () => {
                const [organization] = await createTestOrganization(adminClient)

                const [createdObj] = await createTestBankAccount(adminClient, organization)

                await catchErrorFrom(
                    async () => {
                        await updateTestBankAccount(adminClient, createdObj.id, { approvedBy: { connect: { id: adminClient.user.id } } })
                    }, (e) => {
                        const msg = e.errors[0].message
                        expect(msg).toContain('Field "approvedBy" is not defined by type "BankAccountUpdateInput"')
                    }
                )
            })
        })
    })

    describe('constraints', () => {
        test('can\'t create same BankAccount', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [bankAccount] = await createTestBankAccount(adminClient, organization)

            await expectToThrowUniqueConstraintViolationError(async () => {
                await createTestBankAccount(adminClient, organization, {
                    tin: bankAccount.tin,
                    routingNumber: bankAccount.routingNumber,
                    number: bankAccount.number,
                })
            }, 'Bank_account_unique_organization_tin_routingNumber_number')
        })

        test('can delete and then create another BankAccount with same requisites', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [firstBankAccount] = await createTestBankAccount(adminClient, organization)

            await updateTestBankAccount(adminClient, firstBankAccount.id, { deletedAt: 'true' })

            const [secondBankAccount] = await createTestBankAccount(adminClient, organization,  {
                tin: firstBankAccount.tin,
                routingNumber: firstBankAccount.routingNumber,
                number: firstBankAccount.number,
            })

            expect(firstBankAccount.id).toBeDefined()
            expect(secondBankAccount.id).toBeDefined()
            expect(firstBankAccount.id).not.toEqual(secondBankAccount.id)
        })

        test('can\'t connect new BankAccount to BankIntegrationAccountContext used by another BankAccount', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [bankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)

            const [anotherBankAccount] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: bankIntegrationAccountContext.id } },
            })

            await expectToThrowGQLError(async () => {
                await createTestBankAccount(adminClient, organization, {
                    integrationContext: { connect: { id: anotherBankAccount.integrationContext.id } },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'BANK_INTEGRATION_ACCOUNT_CONTEXT_ALREADY_USED',
                message: `Cannot connect to BankIntegrationAccountContext, used by another BankAccount(id="${anotherBankAccount.id}")`,
                variable: ['data', 'integrationContext'],
            })
        })

        test('can\'t connect existing BankAccount without BankIntegrationAccountContext to BankIntegrationAccountContext used by another BankAccount', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [bankAccount] = await createTestBankAccount(adminClient, organization)
            const [anotherBankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [anotherBankAccount] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: anotherBankIntegrationAccountContext.id } },
            })
            await expectToThrowGQLError(async () => {
                await updateTestBankAccount(adminClient, bankAccount.id, {
                    integrationContext: {
                        connect: { id: anotherBankIntegrationAccountContext.id },
                    },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'BANK_INTEGRATION_ACCOUNT_CONTEXT_ALREADY_USED',
                message: `Cannot connect to BankIntegrationAccountContext, used by another BankAccount(id="${anotherBankAccount.id}")`,
                variable: ['data', 'integrationContext'],
            })
        })

        test('cannot connect BankIntegrationAccountContext if BankAccount is already connected to some integrationContext', async () => {
            const [organization] = await createTestOrganization(adminClient)

            const [BankIntegrationAccountContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)
            const [anotherIntegrationContext] = await createTestBankIntegrationAccountContext(adminClient, bankIntegration, organization)

            const [bankAccount] = await createTestBankAccount(adminClient, organization, {
                integrationContext: { connect: { id: BankIntegrationAccountContext.id } },
            })

            await expectToThrowGQLError(async () => {
                await updateTestBankAccount(adminClient, bankAccount.id, {
                    integrationContext: { connect: { id: anotherIntegrationContext.id } },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INTEGRATION_REASSIGNMENT_NOT_ALLOWED',
                message: `Integration reassignment is not allowed for BankAccount with id="${bankAccount.id}"`,
                variable: ['data', 'integrationContext'],
            })
        })
    })
})
