/**
 * Generated by `createservice meter._internalDeleteMeterAndMeterReadingsService --type mutations`
 */

const { isArray, map } = require('lodash')

const { GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { getLogger } = require('@open-condo/keystone/logging')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, itemsQuery } = require('@open-condo/keystone/schema')

const { DV_VERSION_MISMATCH, WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const { loadListByChunks } = require('@condo/domains/common/utils/serverSchema')
const access = require('@condo/domains/meter/access/_internalDeleteMeterAndMeterReadingsService')
const { METER_DELETE_STATUS } = require('@condo/domains/meter/constants')
const { Meter } = require('@condo/domains/meter/utils/serverSchema')


const logger = getLogger()

const ERRORS = {
    DV_VERSION_MISMATCH: {
        query: '_internalDeleteMeterAndMeterReadingsService',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
    },
    WRONG_SENDER_FORMAT: {
        query: '_internalDeleteMeterAndMeterReadingsService',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value',
        correctExample: '{ "dv": 1, "fingerprint": "uniq-device-or-container-id" }',
    },
}

const _internalDeleteMeterAndMeterReadingsService = new GQLCustomSchema('_internalDeleteMeterAndMeterReadingsService', {
    schemaDoc: 'Mutation to delete meters and meter readings for property',
    types: [
        {
            access: true,
            type: 'input _internalDeleteMeterAndMeterReadingsInput { dv: Int!, sender: SenderFieldInput!, propertyIds: [ID], organizationId: ID!, resourcesIds: [ID] }',
        },
        {
            access: true,
            type: 'enum Status { success, error }',
        },
        {
            access: true,
            type: 'type _internalDeleteMeterAndMeterReadingsOutput { status: Status!, metersToDelete: Int!, deletedMeters: Int! }',
        },
    ],

    mutations: [
        {
            access: access.can_internalDeleteMeterAndMeterReadings,
            schema: '_internalDeleteMeterAndMeterReadings(data: _internalDeleteMeterAndMeterReadingsInput!): _internalDeleteMeterAndMeterReadingsOutput',
            doc: {
                summary: 'This mutation deletes meters and meter readings in specified organization.',
                description: 'This mutation deletes meters in specified organization for specified period.' +
                    '\n Readings are deleted automatically in a deferred task.' +
                    '\n You can also specify properties in which meters need to be deleted.' +
                    '\n The response will return the status of the operation: “success” if all meters for the specified filter were deleted, otherwise “error”.',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { dv, sender, propertyIds, organizationId, resourcesIds } = data

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                const metersWhere = {
                    deletedAt: null,
                    organization: { id: organizationId },
                    ...(isArray(propertyIds) ? { property: { id_in: propertyIds } } : undefined),
                    ...(isArray(resourcesIds) ? { resource: { id_in: resourcesIds } } : undefined),
                }

                const { count: metersCount } = await itemsQuery('Meter', {
                    where: metersWhere,
                }, { meta: true })

                logger.info({
                    msg: 'meters found to delete',
                    count: metersCount,
                    data: {
                        meterReadingsWhere: metersWhere,
                        sender,
                    },
                })

                if (!metersCount) {
                    logger.info({ msg: 'meters not found', data: { sender } })
                    return { status: METER_DELETE_STATUS.SUCCESS, metersToDelete: 0, deletedMeters: 0 }
                }

                const meterIdsToDeleteByChunk = []

                await loadListByChunks({
                    context,
                    list: Meter,
                    where: metersWhere,
                    sortBy: ['createdAt_ASC'],
                    chunkSize: 100,
                    limit: 200_000,
                    fields: 'id',
                    chunkProcessor: async (chunk) => {
                        const meterIdsToDelete = map(chunk, 'id')
                        // Why not delete objects immediately in "chunkProcessor"?
                        // Then at each iteration i > 0, objects that have not yet been deleted will be skipped (i * chunkSize)
                        meterIdsToDeleteByChunk.push(meterIdsToDelete)
                        return []
                    },
                })

                let deletedMeters = 0
                let processing = 0
                for (const meterIdsToDelete of meterIdsToDeleteByChunk) {
                    processing += meterIdsToDelete.length
                    logger.info({
                        msg: 'process of deleting meters',
                        count: processing,
                        data: {
                            meterIdsToDelete,
                            sender,
                            total: metersCount,
                        },
                    })

                    try {
                        const deleted = await Meter.softDeleteMany(context, meterIdsToDelete, 'id', { dv, sender })
                        deletedMeters += deleted.length
                    } catch (error) {
                        logger.error({
                            msg: 'failed to delete a meters',
                            error,
                            data: {
                                meterIds: meterIdsToDelete,
                                sender,
                            },
                        })
                    }

                }

                const deleteStatus = metersCount === deletedMeters
                    ? METER_DELETE_STATUS.SUCCESS : METER_DELETE_STATUS.ERROR

                logger.info({
                    msg: 'deleting meters completed',
                    status: deleteStatus,
                    data: {
                        metersToDelete: metersCount,
                        deletedMeters,
                        sender,
                    },
                })

                return { status: deleteStatus, metersToDelete: metersCount, deletedMeters }
            },
        },
    ],

})

module.exports = {
    _internalDeleteMeterAndMeterReadingsService,
}
