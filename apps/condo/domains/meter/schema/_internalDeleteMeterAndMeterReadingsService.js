/**
 * Generated by `createservice meter._internalDeleteMeterAndMeterReadingsService --type mutations`
 */

const dayjs = require('dayjs')
const chunk = require('lodash/chunk')
const isEmpty = require('lodash/isEmpty')

const { getLogger } = require('@open-condo/keystone/logging')
const { GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/meter/access/_internalDeleteMeterAndMeterReadingsService')
const { METER_DELETE_STATUS } = require('@condo/domains/meter/constants')
const { Meter } = require('@condo/domains/meter/utils/serverSchema')

const logger = getLogger('_internalDeleteMeterAndMeterReadings')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */

const _internalDeleteMeterAndMeterReadingsService = new GQLCustomSchema('_internalDeleteMeterAndMeterReadingsService', {
    schemaDoc: 'Mutation to delete meters and meter readings for property',
    types: [
        {
            access: true,
            type: 'input _internalDeleteMeterAndMeterReadingsInput { dv: Int!, sender: SenderFieldInput!, propertyIds: [String]! }',
        },
        {
            access: true,
            type: 'enum Status { success, error }',
        },
        {
            access: true,
            type: 'type _internalDeleteMeterAndMeterReadingsOutput { status: Status! }',
        },
    ],
    
    mutations: [
        {
            access: access.can_internalDeleteMeterAndMeterReadings,
            schema: '_internalDeleteMeterAndMeterReadings(data: _internalDeleteMeterAndMeterReadingsInput!): _internalDeleteMeterAndMeterReadingsOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { dv, sender, propertyIds } = data

                const meters = await find('Meter', {
                    deletedAt: null,
                    property: {
                        id_in: propertyIds,
                    },
                })

                if (isEmpty(meters)) {
                    logger.warn({ msg: 'Could not find meters by specified property ids', data: { propertyIds } })
                    return
                }
                logger.info({ msg: `Following meters will be deleted: [${meters.map(reading => `'${reading.id}'`).join(', ')}]` })

                const deletedAt = dayjs().toISOString()
                const payload = meters.map(meter => ({ id: meter.id, data: { dv, sender, deletedAt } }))
                const chunks = chunk(payload, 100)

                let deletedMeters = 0
                for (const chunkData of chunks) {
                    const deleted = await Meter.updateMany(context, chunkData)
                    deletedMeters += deleted.length
                }

                const deleteStatus = meters.length === deletedMeters
                    ? METER_DELETE_STATUS.SUCCESS : METER_DELETE_STATUS.ERROR
                logger.info({ msg: `Delete Status: ${deleteStatus}` })

                return { status: deleteStatus }
            },
        },
    ],
    
})

module.exports = {
    _internalDeleteMeterAndMeterReadingsService,
}
