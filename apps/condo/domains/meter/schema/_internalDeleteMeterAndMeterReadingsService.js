/**
 * Generated by `createservice meter._internalDeleteMeterAndMeterReadingsService --type mutations`
 */

const { isEmpty } = require('lodash')

const { getLogger } = require('@open-condo/keystone/logging')
const { GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/meter/access/_internalDeleteMeterAndMeterReadingsService')
const { Meter } = require('@condo/domains/meter/utils/serverSchema')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */

const _internalDeleteMeterAndMeterReadingsService = new GQLCustomSchema('_internalDeleteMeterAndMeterReadingsService', {
    schemaDoc: 'Mutation to delete meters and meter readings for property',
    types: [
        {
            access: true,
            type: 'input _internalDeleteMeterAndMeterReadingsInput { dv: Int!, sender: SenderFieldInput!, propertyIds: [String]! }',
        },
        {
            access: true,
            type: 'type _internalDeleteMeterAndMeterReadingsOutput { status: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.can_internalDeleteMeterAndMeterReadings,
            schema: '_internalDeleteMeterAndMeterReadings(data: _internalDeleteMeterAndMeterReadingsInput!): _internalDeleteMeterAndMeterReadingsOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { dv, sender, propertyIds } = data
                const logger = getLogger('DeleteMeters')

                const meters = await find('Meter', {
                    deletedAt: null,
                    property: {
                        id_in: propertyIds,
                    },
                })

                if (isEmpty(meters)) {
                    logger.warn({ msg: 'Could not find meters by specified property ids', data: { propertyIds } })
                    return
                }
                logger.info({ msg: `Following meters will be deleted: [${meters.map(reading => `'${reading.id}'`).join(', ')}]` })

                const deletedMeters = await Meter.updateMany(context, meters, { dv, sender, deletedAt: 'true' })
                let deletedSuccessfully = meters.length === deletedMeters.length ? 'success' : 'error'
                logger.info({ msg: 'Deleted all Meter records with associated MeterReading' })

                return { status: deletedSuccessfully }
            },
        },
    ],
    
})

module.exports = {
    _internalDeleteMeterAndMeterReadingsService,
}
