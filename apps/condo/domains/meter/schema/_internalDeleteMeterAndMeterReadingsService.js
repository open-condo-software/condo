/**
 * Generated by `createservice meter._internalDeleteMeterAndMeterReadingsService --type mutations`
 */

const { isArray, map } = require('lodash')

const { GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { getLogger } = require('@open-condo/keystone/logging')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, itemsQuery } = require('@open-condo/keystone/schema')

const { DV_VERSION_MISMATCH, WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const { loadListByChunks } = require('@condo/domains/common/utils/serverSchema')
const access = require('@condo/domains/meter/access/_internalDeleteMeterAndMeterReadingsService')
const { METER_DELETE_STATUS } = require('@condo/domains/meter/constants')
const { Meter } = require('@condo/domains/meter/utils/serverSchema')


const logger = getLogger('_internalDeleteMeterAndMeterReadings')

const ERRORS = {
    DV_VERSION_MISMATCH: {
        query: '_internalDeleteMeterReadingsService',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
    },
    WRONG_SENDER_FORMAT: {
        query: '_internalDeleteMeterReadingsService',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value',
        correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
    },
}

const _internalDeleteMeterAndMeterReadingsService = new GQLCustomSchema('_internalDeleteMeterAndMeterReadingsService', {
    schemaDoc: 'Mutation to delete meters and meter readings for property',
    types: [
        {
            access: true,
            type: 'input _internalDeleteMeterAndMeterReadingsInput { dv: Int!, sender: SenderFieldInput!, propertyIds: [ID], organizationId: ID! }',
        },
        {
            access: true,
            type: 'enum Status { success, error }',
        },
        {
            access: true,
            type: 'type _internalDeleteMeterAndMeterReadingsOutput { status: Status!, metersToDelete: Int!, deletedMeters: Int! }',
        },
    ],
    
    mutations: [
        {
            access: access.can_internalDeleteMeterAndMeterReadings,
            schema: '_internalDeleteMeterAndMeterReadings(data: _internalDeleteMeterAndMeterReadingsInput!): _internalDeleteMeterAndMeterReadingsOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { dv, sender, propertyIds, organizationId } = data

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                const metersWhere = {
                    deletedAt: null,
                    organization: { id: organizationId },
                    ...(isArray(propertyIds) ? { property: { id_in: propertyIds } } : undefined),
                }

                const { count: metersCount } = await itemsQuery('Meter', {
                    where: metersWhere,
                }, { meta: true })

                logger.info({
                    msg: `${metersCount} meters found to delete`,
                    meterReadingsWhere: JSON.stringify(metersWhere),
                    sender: JSON.stringify(sender),
                })

                if (!metersCount) {
                    logger.info({ msg: 'Readings not found', sender: JSON.stringify(sender) })
                    return { status: METER_DELETE_STATUS.SUCCESS, metersToDelete: 0, deletedMeters: 0 }
                }

                const meterIdsToDeleteByChunk = []

                await loadListByChunks({
                    context,
                    list: Meter,
                    where: metersWhere,
                    sortBy: ['createdAt_ASC'],
                    chunkSize: 100,
                    limit: 200_000,
                    chunkProcessor: async (chunk) => {
                        const meterIdsToDelete = map(chunk, 'id')
                        // Why not delete objects immediately in "chunkProcessor"?
                        // Then at each iteration i > 0, objects that have not yet been deleted will be skipped (i * chunkSize)
                        meterIdsToDeleteByChunk.push(meterIdsToDelete)
                        return []
                    },
                })

                let deletedMeters = 0
                let processing = 0
                for (const meterIdsToDelete of meterIdsToDeleteByChunk) {
                    logger.info({
                        msg: `Process of deleting readings (${processing}-${processing += meterIdsToDelete.length}/${metersCount})`,
                        meterIdsToDelete,
                        sender: JSON.stringify(sender),
                    })

                    try {
                        const deleted = await Meter.softDeleteMany(context, meterIdsToDelete, { dv, sender })
                        deletedMeters += deleted.length
                    } catch (error) {
                        logger.error({
                            msg: 'Failed to delete a meters',
                            error,
                            meterIds: meterIdsToDelete,
                            sender: JSON.stringify(sender),
                        })
                    }

                }

                const deleteStatus = metersCount === deletedMeters
                    ? METER_DELETE_STATUS.SUCCESS : METER_DELETE_STATUS.ERROR
                logger.info({
                    msg: 'Deleting meters completed',
                    status: deleteStatus,
                    metersToDelete: metersCount,
                    deletedMeters,
                    sender: JSON.stringify(sender),
                })

                return { status: deleteStatus, metersToDelete: metersCount, deletedMeters }
            },
        },
    ],
    
})

module.exports = {
    _internalDeleteMeterAndMeterReadingsService,
}
