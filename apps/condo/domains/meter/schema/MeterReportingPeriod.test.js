/**
 * Generated by `createschema meter.MeterReportingPeriod 'organization:Relationship:Organization:CASCADE; property:Relationship:Property:CASCADE; meter:Relationship:Meter:CASCADE; startingDate:DateTimeUtc; deadline:DateTimeUtc;'`
 */

const { faker } = require('@faker-js/faker')

const {
    UUID_RE,
    makeLoggedInAdminClient,
    makeClient,
    expectValuesOfCommonFields,
    expectToThrowUniqueConstraintViolationError,
    expectToThrowAccessDeniedErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { makeContextWithOrganizationAndIntegrationAsAdmin, createTestBillingProperty, createTestBillingAccount } = require('@condo/domains/billing/utils/testSchema')
const { COLD_WATER_METER_RESOURCE_ID, HOT_WATER_METER_RESOURCE_ID } = require('@condo/domains/meter/constants/constants')
const {
    MeterReportingPeriod,
    createTestMeterReportingPeriod,
    updateTestMeterReportingPeriod,
    createTestMeter,
} = require('@condo/domains/meter/utils/testSchema')
const { SERVICE_PROVIDER_TYPE } = require('@condo/domains/organization/constants/common')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    createTestOrganizationWithAccessToAnotherOrganization,
    makeEmployeeUserClientWithAbilities,
    makeClientWithRegisteredOrganization,
    updateTestOrganizationEmployeeRole,
    registerNewOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { buildingMapJson } = require('@condo/domains/property/constants/property')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { buildFakeAddressAndMeta } = require('@condo/domains/property/utils/testSchema/factories')
const { createTestResident, createTestServiceConsumer } = require('@condo/domains/resident/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')

const { ERRORS } = require( './MeterReportingPeriod')


describe('MeterReportingPeriod', () => {
    let admin, anonymous, commonOrganization, commonProperty, commonMeterReportingPeriod, commonClientWithPermission, commonClientWithoutPermission
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        anonymous = await makeClient();
        [commonOrganization] = await createTestOrganization(admin);
        [commonProperty] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson });
        [commonMeterReportingPeriod] = await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: commonProperty.id } } })

        commonClientWithPermission = await makeClientWithNewRegisteredAndLoggedInUser()
        commonClientWithoutPermission = await makeClientWithNewRegisteredAndLoggedInUser()
        const [roleWithPermission] = await createTestOrganizationEmployeeRole(admin, commonOrganization, {
            canManageMeters: true,
        })
        const [roleWithoutPermission] = await createTestOrganizationEmployeeRole(admin, commonOrganization, {
            canManageMeters: false,
        })
        await createTestOrganizationEmployee(admin, commonOrganization, commonClientWithPermission.user, roleWithPermission)
        await createTestOrganizationEmployee(admin, commonOrganization, commonClientWithoutPermission.user, roleWithoutPermission)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                const [obj, attrs] = await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })
                expectValuesOfCommonFields(obj, attrs, admin)
            })

            test('user can', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                const [obj, attrs] = await createTestMeterReportingPeriod(commonClientWithPermission, commonOrganization, { property: { connect: { id: property.id } } })

                expectValuesOfCommonFields(obj, attrs, commonClientWithPermission)
            })

            test('user cannot without canManageMeters', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeterReportingPeriod(commonClientWithoutPermission, commonOrganization)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestMeterReportingPeriod(anonymous, { id: 'id' })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [obj, attrs] = await updateTestMeterReportingPeriod(admin, commonMeterReportingPeriod.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            })

            test('user can', async () => {
                const [obj, attrs] = await updateTestMeterReportingPeriod(commonClientWithPermission, commonMeterReportingPeriod.id)

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: commonClientWithPermission.user.id }))
            })

            test('user cannot without canManageMeters', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeterReportingPeriod(commonClientWithoutPermission, commonMeterReportingPeriod.id)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestMeterReportingPeriod(anonymous, 'id')
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReportingPeriod.delete(admin, commonMeterReportingPeriod.id)
                })
            })

            test('user can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReportingPeriod.delete(commonClientWithPermission, commonMeterReportingPeriod.id)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReportingPeriod.delete(anonymous, 'id')
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                const [obj] = await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })

                const objs = await MeterReportingPeriod.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('Staff user can', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                const [obj] = await createTestMeterReportingPeriod(commonClientWithPermission, commonOrganization, { property: { connect: { id: property.id } } })
                const objs = await MeterReportingPeriod.getAll(commonClientWithPermission, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs[0]).toMatchObject({
                    id: obj.id,
                })
            })

            test('Staff user can read default period', async () => {
                const defaultMeterReportingPeriod = await MeterReportingPeriod.create(admin, {
                    dv: 1,
                    sender: { dv: 1, fingerprint: 'initDefaultPeriod' },
                })
                const objs = await MeterReportingPeriod.getAll(commonClientWithPermission, { organization_is_null: true }, { sortBy: ['updatedAt_DESC'] })

                await MeterReportingPeriod.softDelete(admin, defaultMeterReportingPeriod.id)

                expect(objs[0]).toMatchObject({
                    id: defaultMeterReportingPeriod.id,
                })
            })

            test('Resident can read MeterReportingPeriods from any organizations on his address', async () => {
                const orgManager = await makeClientWithRegisteredOrganization()
                const anotherOrgManager = await makeClientWithNewRegisteredAndLoggedInUser()
                const [anotherOrg] = await registerNewOrganization(anotherOrgManager, { type: SERVICE_PROVIDER_TYPE })

                const [property] = await createTestProperty(orgManager, orgManager.organization)
                const [anotherProperty] = await createTestProperty(anotherOrgManager, anotherOrg, {
                    address: property.address,
                    addressMeta: property.addressMeta,
                })

                expect(property.addressKey).not.toBeNull()
                expect(anotherProperty).toHaveProperty('addressKey', property.addressKey)

                const residentClient = await makeClientWithResidentUser()
                const [resident] = await createTestResident(admin, residentClient.user, property)

                expect(resident).toHaveProperty('addressKey', property.addressKey)

                const [meter] = await createTestMeter(orgManager, orgManager.organization, property, { id: COLD_WATER_METER_RESOURCE_ID })
                const [anotherMeter] = await createTestMeter(anotherOrgManager, anotherOrg, anotherProperty, { id: HOT_WATER_METER_RESOURCE_ID })
                expect(meter).toHaveProperty('id')
                expect(anotherMeter).toHaveProperty('id')

                const [globalOrgPeriod] = await createTestMeterReportingPeriod(orgManager, orgManager.organization)
                const [anotherGlobalOrgPeriod] = await createTestMeterReportingPeriod(anotherOrgManager, anotherOrg)
                const [localOrgPeriod] = await createTestMeterReportingPeriod(orgManager, orgManager.organization, {
                    property: { connect: { id: property.id } },
                })
                const [anotherLocalOrgPeriod] = await createTestMeterReportingPeriod(anotherOrgManager, anotherOrg, {
                    property: { connect: { id: anotherProperty.id } },
                })

                const allPeriods = await MeterReportingPeriod.getAll(residentClient, {
                    organization: { id_in: [orgManager.organization.id, anotherOrg.id] },
                })

                expect(allPeriods).toHaveLength(4)
                expect(allPeriods).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: globalOrgPeriod.id }),
                    expect.objectContaining({ id: anotherGlobalOrgPeriod.id }),
                    expect.objectContaining({ id: localOrgPeriod.id }),
                    expect.objectContaining({ id: anotherLocalOrgPeriod.id }),
                ]))
            })

            test('Resident cannot read MeterReportingPeriods from another property', async () => {
                const orgManager = await makeClientWithRegisteredOrganization()

                const [property] = await createTestProperty(orgManager, orgManager.organization)
                expect(property.addressKey).not.toBeNull()

                const residentClient = await makeClientWithResidentUser()
                const { address, addressMeta } = buildFakeAddressAndMeta(false, {})
                const [resident] = await createTestResident(admin, residentClient.user, null, {
                    address,
                    addressMeta,
                })

                expect(resident.addressKey).not.toEqual(property.addressKey)

                const [meter] = await createTestMeter(orgManager, orgManager.organization, property, { id: COLD_WATER_METER_RESOURCE_ID })
                expect(meter).toHaveProperty('id')

                const [globalOrgPeriod] = await createTestMeterReportingPeriod(orgManager, orgManager.organization)
                const [localOrgPeriod] = await createTestMeterReportingPeriod(orgManager, orgManager.organization, {
                    property: { connect: { id: property.id } },
                })

                const allPeriods = await MeterReportingPeriod.getAll(residentClient, {
                    organization: { id: orgManager.organization.id },
                })

                expect(allPeriods).toHaveLength(0)
            })

            test('Resident can read default MeterReportingPeriod', async () => {
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(admin, organization)
                await createTestResident(admin, client.user, property, {
                    unitName,
                })
                const defaultMeterReportingPeriod = await MeterReportingPeriod.create(admin, {
                    dv: 1,
                    sender: { dv: 1, fingerprint: 'initDefaultPeriod' },
                })

                const [period] = await MeterReportingPeriod.getAll(client, {
                    organization_is_null: true,
                }, { sortBy: ['updatedAt_DESC'] })

                await MeterReportingPeriod.softDelete(admin, defaultMeterReportingPeriod.id)

                expect(period.id).toEqual(defaultMeterReportingPeriod.id)
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await MeterReportingPeriod.getAll(anonymous, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('Bulk-operations', () => {
        describe('create', () => {
            test('employee cannot', async () => {
                const client = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })

                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
                    const payload = [client.organization, client.organization].map(org => ({
                        data: {
                            dv: 1,
                            sender,
                            organization: { connect: { id: org.id } },
                        },
                    }))
                    await MeterReportingPeriod.createMany(client, payload)
                })
            })
        })

        describe('update', () => {
            test('employee can if items are from own organizations and have permission "canManageMeters"', async () => {
                const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                const client2 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                await createTestOrganizationEmployee(admin, client2.organization, client1.user, client2.role)

                const [item1] = await createTestMeterReportingPeriod(client1, client1.organization, {
                    property: { connect: { id: client1.property.id } },
                })
                expect(item1.organization.id).toBe(client1.organization.id)

                const [item2] = await createTestMeterReportingPeriod(client1, client2.organization, {
                    property: { connect: { id: client2.property.id } },
                })
                expect(item2.organization.id).toBe(client2.organization.id)

                const [item3] = await createTestMeterReportingPeriod(client1, client2.organization)
                expect(item3.organization.id).toBe(client2.organization.id)

                // case 1 (items from different organizations)
                const payload1 = [item1, item2, item3].map(item => ({
                    id: item.id,
                    data: {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    },
                }))
                const updated1 = await MeterReportingPeriod.updateMany(client1, payload1)

                expect(updated1).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({ id: item1.id }),
                        expect.objectContaining({ id: item2.id }),
                        expect.objectContaining({ id: item3.id }),
                    ])
                )

                // case 2 (items from one organization)
                const payload2 = [item2, item3].map(item => ({
                    id: item.id,
                    data: {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    },
                }))
                const updated2 = await MeterReportingPeriod.updateMany(client1, payload2)

                expect(updated2).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({ id: item2.id }),
                        expect.objectContaining({ id: item3.id }),
                    ])
                )
            })

            test('employee can if items are from related organization or own organization and have permission "canManageMeters" in each organizations', async () => {
                const {
                    clientFrom, organizationFrom, propertyFrom, organizationTo, propertyTo,
                } = await createTestOrganizationWithAccessToAnotherOrganization({
                    canManageMeters: true,
                })

                const [item1] = await createTestMeterReportingPeriod(clientFrom, organizationFrom, {
                    property: { connect: { id: propertyFrom.id } },
                })
                expect(item1.organization.id).toBe(organizationFrom.id)

                const [item2] = await createTestMeterReportingPeriod(clientFrom, organizationTo, {
                    property: { connect: { id: propertyTo.id } },
                })
                expect(item2.organization.id).toBe(organizationTo.id)

                const payload = [item1, item2].map(item => ({
                    id: item.id,
                    data: {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    },
                }))
                const updated = await MeterReportingPeriod.updateMany(clientFrom, payload)

                expect(updated).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({ id: item1.id }),
                        expect.objectContaining({ id: item2.id }),
                    ])
                )
            })

            test('employee cannot if items are not from his organizations', async () => {
                const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                const client2 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })

                const [item1] = await createTestMeterReportingPeriod(client1, client1.organization, {
                    property: { connect: { id: client1.property.id } },
                })
                expect(item1.organization.id).toBe(client1.organization.id)

                const [item2] = await createTestMeterReportingPeriod(client2, client2.organization, {
                    property: { connect: { id: client2.property.id } },
                })
                expect(item2.organization.id).toBe(client2.organization.id)

                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    const payload = [item1, item2].map(item => ({
                        id: item.id,
                        data: {
                            dv: 1,
                            sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                        },
                    }))
                    await MeterReportingPeriod.updateMany(client1, payload)
                })
            })

            test('employee cannot if items are from related or own organization but he have not permission "canManageMeters" in each organizations', async () => {
                const {
                    clientFrom, organizationTo, propertyTo, roleFrom,
                } = await createTestOrganizationWithAccessToAnotherOrganization({
                    canManageMeters: true,
                })
                const anotherClient = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                await createTestOrganizationEmployee(admin, anotherClient.organization, clientFrom.user, anotherClient.role)

                const [item1] = await createTestMeterReportingPeriod(clientFrom, organizationTo, {
                    property: { connect: { id: propertyTo.id } },
                })
                expect(item1.organization.id).toBe(organizationTo.id)

                const [item2] = await createTestMeterReportingPeriod(clientFrom, anotherClient.organization, {
                    property: { connect: { id: anotherClient.property.id } },
                })
                expect(item2.organization.id).toBe(anotherClient.organization.id)

                const payload = [item1, item2].map(item => ({
                    id: item.id,
                    data: {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    },
                }))

                // case 1 (no permission in holding organization)
                await updateTestOrganizationEmployeeRole(admin, roleFrom.id, { canManageMeters: false })
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await MeterReportingPeriod.updateMany(clientFrom, payload)
                })

                // case 2 (no permission in own organization)
                await updateTestOrganizationEmployeeRole(admin, roleFrom.id, { canManageMeters: true })
                await updateTestOrganizationEmployeeRole(admin, anotherClient.role.id, { canManageMeters: false })
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await MeterReportingPeriod.updateMany(clientFrom, payload)
                })

                // case 3 (no permission anywhere)
                await updateTestOrganizationEmployeeRole(admin, roleFrom.id, { canManageMeters: false })
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await MeterReportingPeriod.updateMany(clientFrom, payload)
                })
            })
        })
    })

    describe('Validation tests', () => {
        describe('Constraints', () => {
            test('The uniqueness of the period common to the entire organization', async () => {
                await createTestMeterReportingPeriod(admin, commonOrganization)

                await expectToThrowUniqueConstraintViolationError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization)
                }, 'meterreportingperiod_unique_organization')

            })

            test('The uniqueness of the period for property', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })

                await expectToThrowUniqueConstraintViolationError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })
                }, 'meterreportingperiod_unique_organization_property')
            })
        })
        describe('Hooks', () => {
            test('Organization is required', async () => {
                const defaultMeterReportingPeriod = await MeterReportingPeriod.create(admin, {
                    dv: 1,
                    sender: { dv: 1, fingerprint: 'initDefaultPeriod' },
                })

                await expectToThrowGQLError(async () => {
                    await MeterReportingPeriod.create(admin, {
                        dv: 1,
                        sender: { dv: 1, fingerprint: 'initDefaultPeriod' },
                    })
                }, ERRORS.ORGANIZATION_IS_REQUIRED)
                await MeterReportingPeriod.softDelete(admin, defaultMeterReportingPeriod.id)
            })

            describe('property field validation', () => {
                test('should be create and update item if property from organization', async () => {
                    const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })

                    // can create
                    const [item] = await createTestMeterReportingPeriod(client1, client1.organization, {
                        property: { connect: { id: client1.property.id } },
                    })
                    expect(item.property.id).toBe(client1.property.id)

                    // can reset
                    const [updatedItem1] = await updateTestMeterReportingPeriod(client1, item.id, {
                        property: { disconnectAll: true },
                    })
                    expect(updatedItem1.property).toBeNull()

                    // can update
                    const [updatedItem2] = await updateTestMeterReportingPeriod(client1, item.id, {
                        property: { connect: { id: client1.property.id } },
                    })
                    expect(updatedItem2.property.id).toBe(client1.property.id)
                })

                test('should not be create and update item if property from another organization', async () => {
                    const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                    const client2 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                    await createTestOrganizationEmployee(admin, client2.organization, client1.user, client2.role)

                    // cannot create
                    await expectToThrowGQLError(async () => {
                        await createTestMeterReportingPeriod(client1, client1.organization, {
                            property: { connect: { id: client2.property.id } },
                        })
                    }, ERRORS.PROPERTY_NOT_FOUND)

                    // cannot create
                    const [item] = await createTestMeterReportingPeriod(client1, client2.organization, {
                        property: { connect: { id: client2.property.id } },
                    })
                    await expectToThrowGQLError(async () => {
                        await updateTestMeterReportingPeriod(client1, item.id, {
                            property: { connect: { id: client1.property.id } },
                        })
                    }, ERRORS.PROPERTY_NOT_FOUND)

                    // can reset
                    const [updatedItem] = await updateTestMeterReportingPeriod(client1, item.id, {
                        property: { disconnectAll: true },
                    })
                    expect(updatedItem.property).toBeNull()
                })
            })

            test('notifyStartDay field validation', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, {
                        notifyStartDay: 0,
                    })
                }, ERRORS.INVALID_START)
                await expectToThrowGQLError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, {
                        notifyStartDay: 32,
                    })
                }, ERRORS.INVALID_START)
            })

            test('notifyEndDay field validation', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, {
                        notifyEndDay: 0,
                    })
                }, ERRORS.INVALID_FINISH)
                await expectToThrowGQLError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, {
                        notifyEndDay: 32,
                    })
                }, ERRORS.INVALID_FINISH)
            })

            test('The uniqueness of the period for property', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })

                await expectToThrowUniqueConstraintViolationError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })
                }, 'meterreportingperiod_unique_organization_property')
            })
        })
    })
})
