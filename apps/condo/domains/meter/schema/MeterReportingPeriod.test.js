/**
 * Generated by `createschema meter.MeterReportingPeriod 'organization:Relationship:Organization:CASCADE; property:Relationship:Property:CASCADE; meter:Relationship:Meter:CASCADE; startingDate:DateTimeUtc; deadline:DateTimeUtc;'`
 */

const { faker } = require('@faker-js/faker')

const {
    UUID_RE,
    makeLoggedInAdminClient,
    makeClient,
    expectValuesOfCommonFields,
    expectToThrowUniqueConstraintViolationError,
    catchErrorFrom,
    expectToThrowAccessDeniedErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const { makeContextWithOrganizationAndIntegrationAsAdmin, createTestBillingProperty, createTestBillingAccount } = require('@condo/domains/billing/utils/testSchema')
const { MeterReportingPeriod, createTestMeterReportingPeriod, updateTestMeterReportingPeriod } = require('@condo/domains/meter/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
    createTestOrganizationWithAccessToAnotherOrganization,
    makeEmployeeUserClientWithAbilities,
    updateTestOrganizationEmployeeRole,
} = require('@condo/domains/organization/utils/testSchema')
const { buildingMapJson } = require('@condo/domains/property/constants/property')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { createTestResident, createTestServiceConsumer } = require('@condo/domains/resident/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')


describe('MeterReportingPeriod', () => {
    let admin, anonymous, commonOrganization, commonProperty, commonMeterReportingPeriod, commonClientWithPermission, commonClientWithoutPermission
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        anonymous = await makeClient();
        [commonOrganization] = await createTestOrganization(admin);
        [commonProperty] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson });
        [commonMeterReportingPeriod] = await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: commonProperty.id } } })

        commonClientWithPermission = await makeClientWithNewRegisteredAndLoggedInUser()
        commonClientWithoutPermission = await makeClientWithNewRegisteredAndLoggedInUser()
        const [roleWithPermission] = await createTestOrganizationEmployeeRole(admin, commonOrganization, {
            canManageMeters: true,
        })
        const [roleWithoutPermission] = await createTestOrganizationEmployeeRole(admin, commonOrganization, {
            canManageMeters: false,
        })
        await createTestOrganizationEmployee(admin, commonOrganization, commonClientWithPermission.user, roleWithPermission)
        await createTestOrganizationEmployee(admin, commonOrganization, commonClientWithoutPermission.user, roleWithoutPermission)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                const [obj, attrs] = await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })
                expectValuesOfCommonFields(obj, attrs, admin)
            })

            test('user can', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                const [obj, attrs] = await createTestMeterReportingPeriod(commonClientWithPermission, commonOrganization, { property: { connect: { id: property.id } } })

                expectValuesOfCommonFields(obj, attrs, commonClientWithPermission)
            })

            test('user cannot without canManageMeters', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeterReportingPeriod(commonClientWithoutPermission, commonOrganization)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestMeterReportingPeriod(anonymous, { id: 'id' })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [obj, attrs] = await updateTestMeterReportingPeriod(admin, commonMeterReportingPeriod.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            })

            test('user can', async () => {
                const [obj, attrs] = await updateTestMeterReportingPeriod(commonClientWithPermission, commonMeterReportingPeriod.id)

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: commonClientWithPermission.user.id }))
            })

            test('user cannot without canManageMeters', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeterReportingPeriod(commonClientWithoutPermission, commonMeterReportingPeriod.id)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestMeterReportingPeriod(anonymous, 'id')
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReportingPeriod.delete(admin, commonMeterReportingPeriod.id)
                })
            })

            test('user can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReportingPeriod.delete(commonClientWithPermission, commonMeterReportingPeriod.id)
                })
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReportingPeriod.delete(anonymous, 'id')
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                const [obj] = await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })

                const objs = await MeterReportingPeriod.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('user can', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                const [obj] = await createTestMeterReportingPeriod(commonClientWithPermission, commonOrganization, { property: { connect: { id: property.id } } })
                const objs = await MeterReportingPeriod.getAll(commonClientWithPermission, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs[0]).toMatchObject({
                    id: obj.id,
                })
            })

            test('user can read default period', async () => {
                const defaultMeterReportingPeriod = await MeterReportingPeriod.create(admin, {
                    dv: 1,
                    sender: { dv: 1, fingerprint: 'initDefaultPeriod' },
                })
                const objs = await MeterReportingPeriod.getAll(commonClientWithPermission, { organization_is_null: true }, { sortBy: ['updatedAt_DESC'] })

                await MeterReportingPeriod.softDelete(admin, defaultMeterReportingPeriod.id)

                expect(objs[0]).toMatchObject({
                    id: defaultMeterReportingPeriod.id,
                })
            })

            test('resident can read his MeterReportingPeriods by property', async () => {
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(admin, organization)
                const [billingProperty] = await createTestBillingProperty(admin, context)
                const [billingAccount] = await createTestBillingAccount(admin, context, billingProperty)
                const [resident] = await createTestResident(admin, client.user, property, {
                    unitName,
                })
                await createTestServiceConsumer(admin, resident, organization, {
                    accountNumber: billingAccount.number,
                })
                const [obj] = await createTestMeterReportingPeriod(admin, organization, { property: { connect: { id: property.id } } })

                const [period] = await MeterReportingPeriod.getAll(client, {
                    property: { id: property.id },
                }, { sortBy: ['updatedAt_DESC'] })

                expect(period.id).toEqual(obj.id)
            })

            test('resident cannot read MeterReportingPeriods from another property', async () => {
                const client = await makeClientWithResidentUser()
                const client2 = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(admin, organization)
                const [property2] = await createTestProperty(admin, organization)
                const [billingProperty] = await createTestBillingProperty(admin, context)
                const [billingAccount] = await createTestBillingAccount(admin, context, billingProperty)
                const [resident] = await createTestResident(admin, client.user, property, {
                    unitName,
                })
                await createTestServiceConsumer(admin, resident, organization, {
                    accountNumber: billingAccount.number,
                })
                const [resident2] = await createTestResident(admin, client2.user, property2, {
                    unitName,
                })
                await createTestServiceConsumer(admin, resident2, organization, {
                    accountNumber: billingAccount.number,
                })
                await createTestMeterReportingPeriod(admin, organization, { property: { connect: { id: property.id } } })

                const objs = await MeterReportingPeriod.getAll(client2, {
                    property: { id: property.id },
                }, { sortBy: ['updatedAt_DESC'] })

                expect(objs).toHaveLength(0)
            })

            test('resident can read default MeterReportingPeriod', async () => {
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(admin, organization)
                await createTestResident(admin, client.user, property, {
                    unitName,
                })
                const defaultMeterReportingPeriod = await MeterReportingPeriod.create(admin, {
                    dv: 1,
                    sender: { dv: 1, fingerprint: 'initDefaultPeriod' },
                })

                const [period] = await MeterReportingPeriod.getAll(client, {
                    organization_is_null: true,
                }, { sortBy: ['updatedAt_DESC'] })

                await MeterReportingPeriod.softDelete(admin, defaultMeterReportingPeriod.id)

                expect(period.id).toEqual(defaultMeterReportingPeriod.id)
            })

            test('anonymous can\'t', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await MeterReportingPeriod.getAll(anonymous, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('Bulk-operations', () => {
        describe('create', () => {
            test('employee cannot', async () => {
                const client = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })

                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
                    const payload = [client.organization, client.organization].map(org => ({
                        data: {
                            dv: 1,
                            sender,
                            organization: { connect: { id: org.id } },
                        },
                    }))
                    await MeterReportingPeriod.createMany(client, payload)
                })
            })
        })

        describe('update', () => {
            test('employee can if items are from own organizations and have permission "canManageMeters"', async () => {
                const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                const client2 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                await createTestOrganizationEmployee(admin, client2.organization, client1.user, client2.role)

                const [item1] = await createTestMeterReportingPeriod(client1, client1.organization, {
                    property: { connect: { id: client1.property.id } },
                })
                expect(item1.organization.id).toBe(client1.organization.id)

                const [item2] = await createTestMeterReportingPeriod(client1, client2.organization, {
                    property: { connect: { id: client2.property.id } },
                })
                expect(item2.organization.id).toBe(client2.organization.id)

                const [item3] = await createTestMeterReportingPeriod(client1, client2.organization)
                expect(item3.organization.id).toBe(client2.organization.id)

                // case 1 (items from different organizations)
                const payload1 = [item1, item2, item3].map(item => ({
                    id: item.id,
                    data: {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    },
                }))
                const updated1 = await MeterReportingPeriod.updateMany(client1, payload1)

                expect(updated1).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({ id: item1.id }),
                        expect.objectContaining({ id: item2.id }),
                        expect.objectContaining({ id: item3.id }),
                    ])
                )

                // case 2 (items from one organization)
                const payload2 = [item2, item3].map(item => ({
                    id: item.id,
                    data: {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    },
                }))
                const updated2 = await MeterReportingPeriod.updateMany(client1, payload2)

                expect(updated2).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({ id: item2.id }),
                        expect.objectContaining({ id: item3.id }),
                    ])
                )
            })

            test('employee can if items are from related organization or own organization and have permission "canManageMeters" in each organizations', async () => {
                const {
                    clientFrom, organizationFrom, propertyFrom, organizationTo, propertyTo,
                } = await createTestOrganizationWithAccessToAnotherOrganization({
                    canManageMeters: true,
                })

                const [item1] = await createTestMeterReportingPeriod(clientFrom, organizationFrom, {
                    property: { connect: { id: propertyFrom.id } },
                })
                expect(item1.organization.id).toBe(organizationFrom.id)

                const [item2] = await createTestMeterReportingPeriod(clientFrom, organizationTo, {
                    property: { connect: { id: propertyTo.id } },
                })
                expect(item2.organization.id).toBe(organizationTo.id)

                const payload = [item1, item2].map(item => ({
                    id: item.id,
                    data: {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    },
                }))
                const updated = await MeterReportingPeriod.updateMany(clientFrom, payload)

                expect(updated).toEqual(
                    expect.arrayContaining([
                        expect.objectContaining({ id: item1.id }),
                        expect.objectContaining({ id: item2.id }),
                    ])
                )
            })

            test('employee cannot if items are not from his organizations', async () => {
                const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                const client2 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })

                const [item1] = await createTestMeterReportingPeriod(client1, client1.organization, {
                    property: { connect: { id: client1.property.id } },
                })
                expect(item1.organization.id).toBe(client1.organization.id)

                const [item2] = await createTestMeterReportingPeriod(client2, client2.organization, {
                    property: { connect: { id: client2.property.id } },
                })
                expect(item2.organization.id).toBe(client2.organization.id)

                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    const payload = [item1, item2].map(item => ({
                        id: item.id,
                        data: {
                            dv: 1,
                            sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                        },
                    }))
                    await MeterReportingPeriod.updateMany(client1, payload)
                })
            })

            test('employee cannot if items are from related or own organization but he have not permission "canManageMeters" in each organizations', async () => {
                const {
                    clientFrom, organizationTo, propertyTo, roleFrom,
                } = await createTestOrganizationWithAccessToAnotherOrganization({
                    canManageMeters: true,
                })
                const anotherClient = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
                await createTestOrganizationEmployee(admin, anotherClient.organization, clientFrom.user, anotherClient.role)

                const [item1] = await createTestMeterReportingPeriod(clientFrom, organizationTo, {
                    property: { connect: { id: propertyTo.id } },
                })
                expect(item1.organization.id).toBe(organizationTo.id)

                const [item2] = await createTestMeterReportingPeriod(clientFrom, anotherClient.organization, {
                    property: { connect: { id: anotherClient.property.id } },
                })
                expect(item2.organization.id).toBe(anotherClient.organization.id)

                const payload = [item1, item2].map(item => ({
                    id: item.id,
                    data: {
                        dv: 1,
                        sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    },
                }))

                // case 1 (no permission in holding organization)
                await updateTestOrganizationEmployeeRole(admin, roleFrom.id, { canManageMeters: false })
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await MeterReportingPeriod.updateMany(clientFrom, payload)
                })

                // case 2 (no permission in own organization)
                await updateTestOrganizationEmployeeRole(admin, roleFrom.id, { canManageMeters: true })
                await updateTestOrganizationEmployeeRole(admin, anotherClient.role.id, { canManageMeters: false })
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await MeterReportingPeriod.updateMany(clientFrom, payload)
                })

                // case 3 (no permission anywhere)
                await updateTestOrganizationEmployeeRole(admin, roleFrom.id, { canManageMeters: false })
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await MeterReportingPeriod.updateMany(clientFrom, payload)
                })
            })
        })
    })

    describe('Validation tests', () => {
        describe('Constraints', () => {
            test('The uniqueness of the period common to the entire organization', async () => {
                await createTestMeterReportingPeriod(admin, commonOrganization)

                await expectToThrowUniqueConstraintViolationError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization)
                }, 'meterreportingperiod_unique_organization')

            })

            test('The uniqueness of the period for property', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })

                await expectToThrowUniqueConstraintViolationError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })
                }, 'meterreportingperiod_unique_organization_property')
            })
        })
        describe('Hooks', () => {
            test('Organization is required', async () => {
                const defaultMeterReportingPeriod = await MeterReportingPeriod.create(admin, {
                    dv: 1,
                    sender: { dv: 1, fingerprint: 'initDefaultPeriod' },
                })

                await catchErrorFrom(async () => {
                    await MeterReportingPeriod.create(admin, {
                        dv: 1,
                        sender: { dv: 1, fingerprint: 'initDefaultPeriod' },
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('The organization is required to create')
                    expect(data).toEqual({ 'obj': null })
                })
                await MeterReportingPeriod.softDelete(admin, defaultMeterReportingPeriod.id)
            })

            test('notifyStartDay field validation', async () => {
                await catchErrorFrom(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, {
                        notifyStartDay: 0,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('The "notifyStartDay" field can take values in the range from 1 to 31')
                    expect(data).toEqual({ 'obj': null })
                })
                await catchErrorFrom(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, {
                        notifyStartDay: 32,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('The "notifyStartDay" field can take values in the range from 1 to 31')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            test('notifyEndDay field validation', async () => {
                await catchErrorFrom(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, {
                        notifyEndDay: 0,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('The "notifyEndDay" field can take values in the range from 1 to 31')
                    expect(data).toEqual({ 'obj': null })
                })
                await catchErrorFrom(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, {
                        notifyEndDay: 32,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('The "notifyEndDay" field can take values in the range from 1 to 31')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            test('The uniqueness of the period for property', async () => {
                const [property] = await createTestProperty(admin, commonOrganization, { map: buildingMapJson })

                await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })

                await expectToThrowUniqueConstraintViolationError(async () => {
                    await createTestMeterReportingPeriod(admin, commonOrganization, { property: { connect: { id: property.id } } })
                }, 'meterreportingperiod_unique_organization_property')
            })
        })
    })
})
