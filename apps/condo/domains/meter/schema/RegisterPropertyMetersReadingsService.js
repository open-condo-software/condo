/**
 * Generated by `createservice meter.RegisterPropertyMetersReadingsService --type mutations`
 */
const dayjs = require('dayjs')
const customParseFormat = require('dayjs/plugin/customParseFormat')
const utc = require('dayjs/plugin/utc')
const get = require('lodash/get')
const isEmpty = require('lodash/isEmpty')
const isNil = require('lodash/isNil')
const uniq = require('lodash/uniq')

const conf = require('@open-condo/config')
const { GQLError } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find, getById } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')

const { PropertyResolver } = require('@condo/domains/billing/schema/resolvers')
const access = require('@condo/domains/meter/access/RegisterPropertyMetersReadingsService')
const { OTHER_METER_READING_SOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { READINGS_LIMIT } = require('@condo/domains/meter/constants/registerMetersReadingsService')
const { shouldUpdateMeter, meterReadingAsResult } = require('@condo/domains/meter/utils/meter.utils')
const { PropertyMeter, PropertyMeterReading } = require('@condo/domains/meter/utils/serverSchema')
const {
    ERRORS,
    getValues, getMeterDates, getMeterFields, getReadingFields,
    getFieldsToUpdate,
    getValuesList,
    getMeterReadingByDate,
    tryToISO,
    getDateStrValidationError,
    transformToPlainObject,
    getAddressesKeys, getResolvedAddresses,
} = require('@condo/domains/meter/utils/serverSchema/registerHelpers')
dayjs.extend(customParseFormat)
dayjs.extend(utc)


const RegisterPropertyMetersReadingsService = new GQLCustomSchema('RegisterPropertyMetersReadingsService', {
    types: [
        {
            access: true,
            type: 'input RegisterPropertyMetersReadingsMeterMetaInput {' +
                'numberOfTariffs: Int,' +
                'verificationDate: String,' +
                'nextVerificationDate: String,' +
                'installationDate: String,' +
                'commissioningDate: String,' +
                'sealingDate: String,' +
                'controlReadingsDate: String,' +
                'isAutomatic: Boolean,' +
                'archiveDate: String' +
                '}',
        },
        {
            access: true,
            type: 'input RegisterPropertyMetersReadingsReadingAddressInfoInput { globalId: String }',
        },
        {
            access: true,
            type: 'input RegisterPropertyMetersReadingsReadingInput {' +
                'address: String!,' +
                'addressInfo: RegisterPropertyMetersReadingsReadingAddressInfoInput,' +
                'meterNumber: String!,' +
                'meterResource: MeterResourceWhereUniqueInput!,' +
                'date: String!,' +
                'value1: String!,' +
                'value2: String,' +
                'value3: String,' +
                'value4: String,' +
                'meterMeta: RegisterPropertyMetersReadingsMeterMetaInput,' +
                'readingSource: MeterReadingSourceWhereUniqueInput,' +
                'billingStatus: MeterReadingBillingStatusType,' +
                'billingStatusText: String' +
                '}',
        },
        {
            access: true,
            type: 'input RegisterPropertyMetersReadingsInput { dv: Int!, sender: SenderFieldInput!, organization: OrganizationWhereUniqueInput!, readings: [RegisterPropertyMetersReadingsReadingInput!]! }',
        },
        {
            access: true,
            type: 'type RegisterPropertyMetersReadingsMeterPropertyOutput { id: ID!, address: String!, addressKey: String! }',
        },
        {
            access: true,
            type: 'type RegisterPropertyMetersReadingsMeterOutput { id: ID!, property: RegisterPropertyMetersReadingsMeterPropertyOutput!, number: String! }',
        },
        {
            access: true,
            type: 'type RegisterPropertyMetersReadingsOutput { id: ID!, meter: RegisterPropertyMetersReadingsMeterOutput! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterPropertyMetersReadings,
            doc: {
                summary: 'Create property meter readings and, if not exists, property meters.',
                description: 'Use dates in UTC format (YYYY-MM-DDTHH:mm:ss.SSSZ) or in YYYY-MM-DD. You should prefer UTC.',
                errors: ERRORS,
            },
            schema: 'registerPropertyMetersReadings(data: RegisterPropertyMetersReadingsInput!): [RegisterPropertyMetersReadingsOutput]',
            resolver: async (parent, /**{ data: RegisterPropertyMetersReadingsInput }*/args, context) => {
                const { data: { dv, sender, organization, readings } } = args

                if (readings.length > READINGS_LIMIT) {
                    throw new GQLError({
                        ...ERRORS.TOO_MUCH_READINGS,
                        messageInterpolation: { limit: READINGS_LIMIT, sentCount: readings.length },
                    }, context)
                }

                /** @type Organization */
                const organizationData = await getById('Organization', organization.id)

                if (!organizationData || !!organizationData.deletedAt) {
                    throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)
                }

                const locale = extractReqLocale(context.req) || conf.DEFAULT_LOCALE

                const propertyResolver = new PropertyResolver({ context })
                propertyResolver.tin = organizationData.tin
                propertyResolver.organizationId = organization.id

                const resolvedAddresses = await getResolvedAddresses(propertyResolver, readings)
                const addressesKeys = getAddressesKeys(readings, resolvedAddresses)

                /** @type Property[] */
                const properties = await find('Property', {
                    organization,
                    deletedAt: null,
                    addressKey_in: addressesKeys,
                })

                const resultRows = []

                const meterNumbers = uniq(readings.map(reading => reading.meterNumber.trim()))
                const meters = await find('PropertyMeter', {
                    organization,
                    number_in: meterNumbers,
                    deletedAt: null,
                })

                const meterReadingByDate = await getMeterReadingByDate(readings, meters, properties, 'PropertyMeterReading')

                for (const reading of readings) {
                    const meterNumber = reading.meterNumber.trim()
                    const addressKey = get(resolvedAddresses, [reading.address, 'addressResolve', 'propertyAddress', 'addressKey'])
                    let readingSource = get(reading, 'readingSource')

                    if (isNil(readingSource)) {
                        readingSource = { id: OTHER_METER_READING_SOURCE_ID }
                    }

                    if (isEmpty(meterNumber)) {
                        resultRows.push(new GQLError(ERRORS.INVALID_METER_NUMBER, context))
                        continue
                    }

                    const dateValidationError = getDateStrValidationError(context, locale, reading)
                    if (dateValidationError) {
                        resultRows.push(dateValidationError)
                        continue
                    }

                    const dateISO = tryToISO(reading.date)
                    const startOfDayISO = dateISO ? dayjs(dateISO).startOf('day').toISOString() : undefined
                    const property = properties.find((p) => p.addressKey === addressKey)

                    if (!property) {
                        resultRows.push(new GQLError(ERRORS.PROPERTY_NOT_FOUND, context))
                        continue
                    }

                    let meterId
                    const foundMeters = meters.filter(meter => {
                        return meter.property === property.id &&
                            meter.number === meterNumber &&
                            meter.resource === reading.meterResource.id
                    })

                    if (foundMeters.length > 1) {
                        resultRows.push(new GQLError({
                            ...ERRORS.MULTIPLE_METERS_FOUND,
                            messageInterpolation: { count: foundMeters.length },
                        }, context))
                        continue
                    }

                    const foundMeter = foundMeters[0]

                    const errorValues = {}
                    const values = getValues(reading, errorValues)

                    if (Object.keys(errorValues).length > 0) {
                        const errorValuesKeys = Object.keys(errorValues)
                        const valuesList = getValuesList(errorValuesKeys, errorValues, locale)
                        resultRows.push(new GQLError(
                            { ...ERRORS.INVALID_METER_VALUES, messageInterpolation: { valuesList } },
                            context,
                        ))
                        continue
                    }

                    try {
                        if (foundMeter) {
                            meterId = foundMeter.id
                            const fieldsToUpdate = getFieldsToUpdate(reading, true)
                            if (shouldUpdateMeter(foundMeter, fieldsToUpdate, true)) {
                                const updatedMeter = await PropertyMeter.update(
                                    context,
                                    foundMeter.id,
                                    { dv, sender, ...fieldsToUpdate },
                                    'id property { id } number resource { id }'
                                )
                                const meterIndex = meters.indexOf(meter => meter.id === updatedMeter.id)
                                meters[meterIndex] = transformToPlainObject(updatedMeter)
                            }
                        } else {
                            const propertyMeterFieldsGetter = getMeterFields(true)
                            const createdMeter = await PropertyMeter.create(context, {
                                dv,
                                sender,
                                ...getMeterDates(reading),
                                ...propertyMeterFieldsGetter(organization, property, reading, values, resolvedAddresses),
                            }, 'id property { id } number resource { id }')
                            meterId = createdMeter.id
                            meters.push(transformToPlainObject(createdMeter))
                        }
                    } catch (e) {
                        resultRows.push(e)
                        continue
                    }

                    try {
                        // NOTE: we look for duplicates with the same date, disregarding the time of day
                        const key = `${meterId}-${startOfDayISO}`
                        const duplicateReading = meterReadingByDate[key]

                        if (!duplicateReading) {
                            const propertyMeterReadingFieldsGetter = getReadingFields(true)
                            const createdMeterReading = await PropertyMeterReading.create(context, {
                                dv,
                                sender,
                                ...propertyMeterReadingFieldsGetter(meterId, readingSource, reading, values),
                            }, 'id meter { id number property { id address addressKey } }')

                            meterReadingByDate[key] = createdMeterReading
                            resultRows.push(meterReadingAsResult(createdMeterReading))
                        } else {
                            resultRows.push(meterReadingAsResult(duplicateReading))
                        }
                    } catch (e) {
                        resultRows.push(e)
                    }
                }

                return resultRows
            },
        },
    ],

})

module.exports = {
    RegisterPropertyMetersReadingsService,
}
