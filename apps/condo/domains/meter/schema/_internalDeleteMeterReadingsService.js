/**
 * Generated by `createservice meter.InternalDeleteMeterReadingsService --type mutations`
 */

const dayjs = require('dayjs')
const { isArray, map } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { getLogger } = require('@open-condo/keystone/logging')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, itemsQuery } = require('@open-condo/keystone/schema')

const { DV_VERSION_MISMATCH, WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const { loadListByChunks } = require('@condo/domains/common/utils/serverSchema')
const access = require('@condo/domains/meter/access/_internalDeleteMeterReadingsService')
const { INVALID_START_DATE_TIME, INVALID_END_DATE_TIME, INVALID_PERIOD } = require('@condo/domains/meter/constants/errors')
const { MeterReading } = require('@condo/domains/meter/utils/serverSchema')


const appLogger = getLogger('condo')
const logger = appLogger.child({ module: '_internalDeleteMeterReadingsService' })

const DATE_FORMAT = 'DD.MM.YYYY HH:mm:ss'
const CHUNK_SIZE = 100

const ERRORS = {
    DV_VERSION_MISMATCH: {
        query: '_internalDeleteMeterReadingsService',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
    },
    WRONG_SENDER_FORMAT: {
        query: '_internalDeleteMeterReadingsService',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value',
        correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
    },
    INVALID_START_DATE_TIME: {
        query: '_internalDeleteMeterReadingsService',
        variable: ['data', 'startDateTime'],
        code: BAD_USER_INPUT,
        type: INVALID_START_DATE_TIME,
        message: `Invalid startDateTime. Should be in format ${DATE_FORMAT}`,
    },
    INVALID_END_DATE_TIME: {
        query: '_internalDeleteMeterReadingsService',
        variable: ['data', 'endDateTime'],
        code: BAD_USER_INPUT,
        type: INVALID_END_DATE_TIME,
        message: `invalid endDateTime. Should be in format ${DATE_FORMAT}`,
    },
    INVALID_PERIOD: {
        query: '_internalDeleteMeterReadingsService',
        variable: ['data', 'startDateTime'],
        code: BAD_USER_INPUT,
        type: INVALID_PERIOD,
        message: 'The start date cannot be greater than the end date',
    },
}

const _internalDeleteMeterReadingsService = new GQLCustomSchema('_internalDeleteMeterReadingsService', {
    types: [
        {
            access: true,
            type: 'input _internalDeleteMeterReadingsInput { dv: Int!, sender: SenderFieldInput!, propertyIds: [ID], organizationId: ID!, startDateTime: String!, endDateTime: String! }',
        },
        {
            access: true,
            type: 'enum Status { success, error }',
        },
        {
            access: true,
            type: 'type _internalDeleteMeterReadingsOutput { status: Status!, toDelete: Int!, deleted: Int! }',
        },
    ],
    
    mutations: [
        {
            access: access.canInternalDeleteMeterReadings,
            schema: '_internalDeleteMeterReadings(data: _internalDeleteMeterReadingsInput!): _internalDeleteMeterReadingsOutput',
            doc: {
                summary: 'Deletes readings in specified organization for specified period.',
                description: 'This mutation deletes readings in specified organization for specified period.' +
                    '\n You can also specify properties in which readings need to be deleted.' +
                    '\n The response will return the status of the operation: “success” if all readings for the specified filter were deleted, otherwise “error”.' +
                    '\n Also in the response sender will be returned, with a random fingerprint (which will be different from what was at the input). ' +
                    'If necessary, you can restore data using this value.',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const {
                    dv,
                    sender,
                    propertyIds,
                    organizationId,
                    startDateTime: startDateTimeFromInput,
                    endDateTime: endDateTimeFromInput,
                } = data

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                const startDateTime = dayjs(startDateTimeFromInput, DATE_FORMAT, true)
                if (!startDateTime.isValid()) throw new GQLError(ERRORS.INVALID_START_DATE_TIME, context)

                const endDateTime = dayjs(endDateTimeFromInput, DATE_FORMAT, true)
                if (!endDateTime.isValid()) throw new GQLError(ERRORS.INVALID_END_DATE_TIME, context)

                if (endDateTime.diff(startDateTime) < 0) {
                    throw new GQLError(ERRORS.INVALID_PERIOD, context)
                }

                const meterReadingsWhere = {
                    deletedAt: null,
                    createdAt_gte: dayjs(startDateTime).startOf('s').toISOString(),
                    createdAt_lte: dayjs(endDateTime).endOf('s').toISOString(),
                    meter: {
                        ...(isArray(propertyIds) ? { property: { id_in: propertyIds } } : undefined),
                        organization: { id: organizationId },
                        deletedAt: null,
                    },
                    source: { type: 'import_condo' },
                }

                const { count: meterReadingsCount } = await itemsQuery('MeterReading', {
                    where: meterReadingsWhere,
                }, { meta: true })

                logger.info({
                    msg: `${meterReadingsCount} readings found to delete`,
                    meterReadingsWhere: JSON.stringify(meterReadingsWhere),
                    sender: JSON.stringify(sender),
                })

                if (!meterReadingsCount) {
                    logger.info({ msg: 'Readings not found', sender: JSON.stringify(sender) })
                    return { status: 'success', toDelete: 0, deleted: 0 }
                }

                const meterReadingIdsToDeleteByChunk = []

                await loadListByChunks({
                    context,
                    list: MeterReading,
                    where: meterReadingsWhere,
                    sortBy: ['createdAt_ASC'],
                    chunkSize: CHUNK_SIZE,
                    limit: 200_000,
                    chunkProcessor: async (chunk) => {
                        const meterReadingIdsToDelete = map(chunk, 'id')
                        // Why not delete objects immediately in "chunkProcessor"?
                        // Then at each iteration i > 0, objects that have not yet been deleted will be skipped (i * chunkSize)
                        meterReadingIdsToDeleteByChunk.push(meterReadingIdsToDelete)
                        return []
                    },
                })

                let numberOfDeleted = 0
                let processing = 0

                for (const meterReadingIdsToDelete of meterReadingIdsToDeleteByChunk) {
                    logger.info({
                        msg: `Process of deleting readings (${processing}-${processing += meterReadingIdsToDelete.length}/${meterReadingsCount})`,
                        meterReadingIdsToDelete,
                        sender: JSON.stringify(sender),
                    })

                    try {
                        await MeterReading.softDeleteMany(context, meterReadingIdsToDelete, { dv, sender })
                        numberOfDeleted += meterReadingIdsToDelete.length
                    } catch (error) {
                        logger.error({
                            msg: 'Failed to delete a meter readings',
                            error,
                            meterReadingIds: meterReadingIdsToDelete,
                            sender: JSON.stringify(sender),
                        })
                    }
                }

                const status = meterReadingsCount === numberOfDeleted ? 'success' : 'error'

                logger.info({
                    msg: 'Deleting readings completed',
                    status,
                    toDelete: meterReadingsCount,
                    deleted: numberOfDeleted,
                    sender: JSON.stringify(sender),
                })

                return { status, toDelete: meterReadingsCount, deleted: numberOfDeleted }
            },
        },
    ],
    
})

module.exports = {
    _internalDeleteMeterReadingsService,
    ERRORS,
}
