/**
 * Generated by `createschema meter.MeterReadingSource 'organization:Relationship:Organization:CASCADE; type:Select:call,mobile_app,billing; name:Text;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { makeLoggedInAdminClient, makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { METER_READING_SOURCE_INTERNAL_IMPORT_TYPE } = require('@condo/domains/meter/constants/constants')
const { createTestMeterReadingSource, updateTestMeterReadingSource } = require('@condo/domains/meter/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

const { MeterReadingSource } = require('../utils/testSchema')



describe('MeterReadingSource', () => {
    const createPayload = {
        type: METER_READING_SOURCE_INTERNAL_IMPORT_TYPE,
        name: faker.name.suffix(),
    }
    describe('Create', () => {
        test('admin: can create MeterReadingSource', async () => {
            const admin = await makeLoggedInAdminClient()
            const [source] = await createTestMeterReadingSource(admin, createPayload)
            expect(source).toBeDefined()
            expect(source).toEqual(expect.objectContaining(createPayload))
            expect(source.nameNonLocalized).toEqual(createPayload.name)
        })
        test('support: can create MeterReadingSource', async () => {
            const support = await makeClientWithSupportUser()
            const [source] = await createTestMeterReadingSource(support, createPayload)
            expect(source).toBeDefined()
            expect(source).toEqual(expect.objectContaining(createPayload))
        })
        test('user: cannot create MeterReadingSource', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestMeterReadingSource(client)
            })
        })
        test('anonymous: cannot create MeterReadingSource', async () => {
            const client = await makeClient()

            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestMeterReadingSource(client)
            })
        })
    })
    describe('Update', () => {
        let meterReadingSourceId
        beforeEach(async () => {
            const admin = await makeLoggedInAdminClient()
            const [meterReadingSource] = await createTestMeterReadingSource(admin, createPayload)
            meterReadingSourceId = meterReadingSource.id
        })
        test('admin: can update MeterReadingSource', async () => {
            const admin = await makeLoggedInAdminClient()
            const payload = { name: faker.name.suffix() }
            const [updatedSource] = await updateTestMeterReadingSource(admin, meterReadingSourceId, payload)
            expect(updatedSource).toBeDefined()
            expect(updatedSource).toEqual(expect.objectContaining(payload))
        })
        test('support: can update MeterReadingSource', async () => {
            const support = await makeClientWithSupportUser()
            const payload = { name: faker.name.suffix() }
            const [updatedSource] = await updateTestMeterReadingSource(support, meterReadingSourceId, payload)
            expect(updatedSource).toBeDefined()
            expect(updatedSource).toEqual(expect.objectContaining(payload))
        })
        test('user: cannot update MeterReadingSource', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestMeterReadingSource(client, meterReadingSourceId, {})
            })
        })
        test('anonymous: cannot update MeterReadingSource', async () => {
            const client = await makeClient()

            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestMeterReadingSource(client, meterReadingSourceId, {})
            })
        })
    })
    describe('Soft delete', () => {
        const deletedPayload = { deletedAt: dayjs().toISOString() }
        let meterReadingSourceId
        beforeEach(async () => {
            const admin = await makeLoggedInAdminClient()
            const [meterReadingSource] = await createTestMeterReadingSource(admin, createPayload)
            meterReadingSourceId = meterReadingSource.id
        })
        test('admin: can soft delete MeterReadingSource', async () => {
            const admin = await makeLoggedInAdminClient()
            const [updatedSource] = await updateTestMeterReadingSource(admin, meterReadingSourceId, deletedPayload)
            expect(updatedSource).toBeDefined()
            expect(updatedSource).toHaveProperty('deletedAt')
            expect(updatedSource.deletedAt).not.toBeNull()
        })
        test('support: can soft delete MeterReadingSource', async () => {
            const support = await makeClientWithSupportUser()
            const [updatedSource] = await updateTestMeterReadingSource(support, meterReadingSourceId, deletedPayload)
            expect(updatedSource).toBeDefined()
            expect(updatedSource).toHaveProperty('deletedAt')
            expect(updatedSource.deletedAt).not.toBeNull()
        })
        test('user: cannot soft delete MeterReadingSource', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestMeterReadingSource(client, meterReadingSourceId, deletedPayload)
            })
        })
        test('anonymous: cannot soft delete MeterReadingSource', async () => {
            const client = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestMeterReadingSource(client, meterReadingSourceId, deletedPayload)
            })
        })
    })
    describe('Read', () => {
        let meterReadingSourceId
        beforeAll(async () => {
            const admin = await makeLoggedInAdminClient()
            const [meterReadingSource] = await createTestMeterReadingSource(admin, createPayload)
            meterReadingSourceId = meterReadingSource.id
        })
        test('admin: can read MeterReadingSources', async () => {
            const admin = await makeLoggedInAdminClient()
            const sources = await MeterReadingSource.getAll(admin, {
                id: meterReadingSourceId,
            })
            expect(sources).toBeDefined()
            expect(sources).toHaveLength(1)
        })
        test('support: can read MeterReadingSources', async () => {
            const support = await makeClientWithSupportUser()
            const sources = await MeterReadingSource.getAll(support, {
                id: meterReadingSourceId,
            })
            expect(sources).toBeDefined()
            expect(sources).toHaveLength(1)
        })
        test('user: can read MeterReadingSources', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const sources = await MeterReadingSource.getAll(client, {
                id: meterReadingSourceId,
            })
            expect(sources).toBeDefined()
            expect(sources).toHaveLength(1)
        })
        test('anonymous: cannot read MeterReadingSources', async () => {
            const client = await makeClient()
            await expectToThrowAuthenticationErrorToObjects(async () => {
                await MeterReadingSource.getAll(client, {})
            })
        })
    })
})
