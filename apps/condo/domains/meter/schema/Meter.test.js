/**
 * Generated by `createschema meter.MeterReadingSource 'organization:Relationship:Organization:CASCADE; type:Select:call,mobile_app,billing; name:Text;'`
 */

const { faker } = require('@faker-js/faker')

const { makeClient, UUID_RE, makeLoggedInAdminClient, waitFor, getRandomString, expectToThrowAccessDeniedErrorToObjects } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowValidationFailureError,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    catchErrorFrom,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const {
    createTestBillingAccount,
    createTestBillingProperty,
    makeContextWithOrganizationAndIntegrationAsAdmin,
} = require('@condo/domains/billing/utils/testSchema')
const { COLD_WATER_METER_RESOURCE_ID, HOT_WATER_METER_RESOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { B2C_APP_NOT_AVAILABLE, B2B_APP_NOT_CONNECTED } = require('@condo/domains/meter/constants/errors')
const {
    MeterResource,
    Meter,
    createTestMeter,
    updateTestMeter,
    MeterResourceOwner,
    updateTestMeterResourceOwner,
    createTestMeters,
    updateTestMeters,
} = require('@condo/domains/meter/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2CApp,
    createTestB2CAppProperty,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    createTestOrganization,
    updateTestOrganizationEmployee,
    createTestOrganizationEmployeeRole,
    createTestOrganizationWithAccessToAnotherOrganization,
    makeEmployeeUserClientWithAbilities,
    updateTestOrganization,
    createTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE, PARKING_UNIT_TYPE, COMMERCIAL_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { createTestProperty, Property } = require('@condo/domains/property/utils/testSchema')
const { createTestResident, updateTestServiceConsumer, createTestServiceConsumer } = require('@condo/domains/resident/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')

const { METER_ERRORS } = require('./Meter')

describe('Meter', () => {
    let admin
    let clientFrom
    let clientTo
    let organizationFrom
    let organizationTo
    let propertyFrom
    let propertyTo
    let employeeFrom
    let employeeTo
    let employeeClient,
        organization,
        resource,
        otherEmployeeClient,
        otherOrganization

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        const [testOrganization] = await createTestOrganization(admin)
        organization = testOrganization
        employeeClient = await makeClientWithNewRegisteredAndLoggedInUser()
        const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
            canReadMeters: true,
            canManageMeters: true,
            canManageProperties: true,
        })
        await createTestOrganizationEmployee(admin, organization, employeeClient.user, role)
        const [testResource] = await MeterResource.getAll(employeeClient, { id: COLD_WATER_METER_RESOURCE_ID })
        resource = testResource
        const [testOtherOrganization] = await createTestOrganization(admin)
        otherOrganization = testOtherOrganization
        otherEmployeeClient = await makeClientWithNewRegisteredAndLoggedInUser()
        const [otherRole] = await createTestOrganizationEmployeeRole(admin, otherOrganization, {
            canReadMeters: true,
            canManageMeters: true,
            canManageProperties: true,
        })
        await createTestOrganizationEmployee(admin, otherOrganization, otherEmployeeClient.user, otherRole)

        if (!clientTo) {
            ({
                clientTo,
                clientFrom,
                organizationFrom,
                organizationTo,
                propertyFrom,
                propertyTo,
                employeeFrom,
                employeeTo,
            } = await createTestOrganizationWithAccessToAnotherOrganization())
        }
    })

    describe('CRUD', () => {
        describe('Create', () => {
            test('employee with "canManageMeters" role: can create Meter', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(client, client.organization, client.property, resource, {})

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee with "canManageMeters" role: cannot create Meter with wrong "sender" field', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                await catchErrorFrom(async () => {
                    await createTestMeter(client, client.organization, client.property, resource, {
                        sender: null,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                    expect(errors[0].data.messages[0]).toContain('Required field "sender" is null or undefined.')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            test('employee without "canManageMeters" role: cannot create Meter', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(client, client.organization, client.property, resource, {})
                })
            })

            test('employee with "canManageMeters" role: cannot create Meter if Meter with same accountNumber exist in user organization in other unit', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = getRandomString()
                const unitName1 = getRandomString()
                const unitName2 = getRandomString()

                const [firstMeter] = await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName: unitName1,
                })

                await expectToThrowGQLError(
                    async () => await createTestMeter(client, client.organization, client.property, resource, {
                        accountNumber,
                        unitName: unitName2,
                    }), {
                        ...METER_ERRORS.SAME_ACCOUNT_NUMBER_EXISTS_IN_OTHER_UNIT,
                        messageInterpolation: { unitsCsv: `${firstMeter.unitType} ${firstMeter.unitName}` },
                    }
                )
            })

            test('employee with "canManageMeters" role: cannot create Meter if Meter with same accountNumber exist in user organization in other unit type', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = getRandomString()
                const unitName = getRandomString()

                const [firstMeter] = await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })

                await expectToThrowGQLError(
                    async () => await createTestMeter(client, client.organization, client.property, resource, {
                        accountNumber,
                        unitName,
                        unitType: PARKING_UNIT_TYPE,
                    }), {
                        ...METER_ERRORS.SAME_ACCOUNT_NUMBER_EXISTS_IN_OTHER_UNIT,
                        messageInterpolation: { unitsCsv: `${firstMeter.unitType} ${firstMeter.unitName}` },
                    }
                )
            })

            test('employee with "canManageMeters" role: can create Meter if Meter with same accountNumber exist in user organization in same unit', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = getRandomString()
                const unitName = getRandomString()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                })

                const [meter] = await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                })

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee with "canManageMeters" role: can create Meter if Meter with same accountNumber exist in other organization', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const client2 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = getRandomString()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                })

                const [meter] = await createTestMeter(client2, client2.organization, client2.property, resource, {
                    accountNumber,
                })

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee from another organization with "canManageMeters" role: cannot create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(client, organization, property, resource, {})
                })
            })

            test('employee from "from" related organization with "canManageMeters" role: can create Meter', async () => {
                const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                    canManageMeters: true,
                })

                await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                    role: { connect: { id: role.id } },
                })

                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(clientFrom, organizationTo, propertyTo, resource, {})

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee from "from" related organization without "canManageMeters" role: cannot create Meter', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })

                const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                    canManageMeters: false,
                })
                await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                    role: { connect: { id: role.id } },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(clientFrom, organizationTo, propertyTo, resource, {})
                })
            })

            test('employee from "to" related organization with "canManageMeters" role: cannot create Meter in "from" organization', async () => {
                const [role] = await createTestOrganizationEmployeeRole(admin, organizationTo, {
                    canManageMeters: true,
                })

                await updateTestOrganizationEmployee(admin, employeeTo.id, {
                    role: { connect: { id: role.id } },
                })

                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(clientTo, organizationFrom, propertyFrom, resource, {})
                })
            })

            test('employee with "canManageMeters" role: can create Meter if another Meter with same number and other resource exist in user organization', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource1] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resource2] = await MeterResource.getAll(client, { id: HOT_WATER_METER_RESOURCE_ID })
                const number = faker.random.alphaNumeric(5)

                await createTestMeter(client, client.organization, client.property, resource1, { number })
                const [meter] = await createTestMeter(client, client.organization, client.property, resource2, { number })

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee with "canManageMeters" role: cannot create Meter if another Meter with same number and resource exist in user organization', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const number = faker.random.alphaNumeric(5)

                const [firstMeter] = await createTestMeter(client, client.organization, client.property, resource, { number })

                await expectToThrowGQLError(
                    async () => await createTestMeter(client, client.organization, client.property, resource, { number }),
                    {
                        ...METER_ERRORS.SAME_NUMBER_AND_RESOURCE_EXISTS_IN_ORGANIZATION,
                        messageInterpolation: { accountNumbersCsv: firstMeter.accountNumber },
                    },
                )
            })

            test('resident: cannot create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(adminClient, organization)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })

                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: billingAccount.number,
                })

                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(client, organization, property, resource, {
                        accountNumber: billingAccount.number,
                        unitName,
                    })
                })
            })

            test('user: cannot create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(client, organization, property, resource, {})
                })
            })

            test('anonymous: cannot create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestMeter(client, organization, property, resource, {})
                })
            })

            test('admin: can create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})

                expect(meter.id).toMatch(UUID_RE)
            })

            test('Can not create meter with property in organization where user in not an employee', async () => {
                const [property] = await createTestProperty(otherEmployeeClient, otherOrganization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(employeeClient, organization, property, resource, {})
                })
            })

            test('Can not create meter with property from other user organization', async () => {
                const [otherOrganization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, otherOrganization, {
                    canReadMeters: true,
                    canManageMeters: true,
                    canManageProperties: true,
                })
                await createTestOrganizationEmployee(admin, otherOrganization, employeeClient.user, role)
                const [otherProperty] = await createTestProperty(employeeClient, otherOrganization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(employeeClient, organization, otherProperty, resource, {})
                })
            })
        })
        describe('Update', () => {
            test('employee with "canManageMeters" role: can update Meter', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(client, client.organization, client.property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)
                const [updatedMeter] = await updateTestMeter(client, meter.id, {
                    number: newNumber,
                })

                expect(updatedMeter.number).toEqual(newNumber)
            })

            test('employee with "canManageMeters" role: can update Meter if Meter with same accountNumber exist in user organization in same unit and unitType', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = getRandomString()
                const unitName = getRandomString()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })

                const [meter] = await createTestMeter(client, client.organization, client.property, resource, {
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })

                const [updatedMeter] = await updateTestMeter(client, meter.id, {
                    accountNumber,
                })

                expect(updatedMeter.accountNumber).toEqual(accountNumber)
            })

            test('employee with "canManageMeters" role: cannot update Meter if Meter with same accountNumber exist in organization in other unit', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = getRandomString()

                const [firstMeter] = await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                })

                const [meter] = await createTestMeter(client, client.organization, client.property, resource)

                await expectToThrowGQLError(
                    async () => await updateTestMeter(client, meter.id, {
                        accountNumber,
                    }), {
                        ...METER_ERRORS.SAME_ACCOUNT_NUMBER_EXISTS_IN_OTHER_UNIT,
                        messageInterpolation: { unitsCsv: `${firstMeter.unitType} ${firstMeter.unitName}` },
                    }
                )
            })

            test('employee with "canManageMeters" role: cannot update Meter if Meter with same accountNumber exist in organization in other unit type', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = getRandomString()
                const unitName = getRandomString()

                const [firstMeter] = await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })

                const [meter] = await createTestMeter(client, client.organization, client.property, resource)

                await expectToThrowGQLError(
                    async () => await updateTestMeter(client, meter.id, {
                        accountNumber,
                        unitName,
                        unitType: PARKING_UNIT_TYPE,
                    }), {
                        ...METER_ERRORS.SAME_ACCOUNT_NUMBER_EXISTS_IN_OTHER_UNIT,
                        messageInterpolation: { unitsCsv: `${firstMeter.unitType} ${firstMeter.unitName}` },
                    }
                )
            })

            test('employee without "canManageMeters" role: cannot update Meter', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, client.organization, client.property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(client, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('employee from "from" related organization with "canManageMeters" role: can update Meter', async () => {
                const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                    canManageMeters: true,
                })
                await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                    role: { connect: { id: role.id } },
                })
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(clientFrom, organizationTo, propertyTo, resource, {})
                const newNumber = faker.random.alphaNumeric(8)
                const [updatedMeter] = await updateTestMeter(clientFrom, meter.id, {
                    number: newNumber,
                })

                expect(updatedMeter.number).toEqual(newNumber)
            })

            test('employee from "from" related organization without "canManageMeters" role: cannot update Meter', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organizationTo, propertyTo, resource, {})
                const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                    canManageMeters: false,
                })
                await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                    role: { connect: { id: role.id } },
                })
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(clientFrom, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('employee from "to" related organization with "canManageMeters" role: cannot update Meter from "from" organization', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organizationFrom, propertyFrom, resource, {})
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(clientTo, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('resident: cannot update Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(adminClient, organization)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: billingAccount.number,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: billingAccount.number,
                    unitName,
                })
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(client, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('user: cannot update Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(client, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('anonymous: cannot update Meter', async () => {
                const client = await makeClient()
                const adminClient = await makeLoggedInAdminClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestMeter(client, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('admin: can update Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)
                const [updatedMeter] = await updateTestMeter(adminClient, meter.id, {
                    number: newNumber,
                })

                expect(updatedMeter.number).toEqual(newNumber)
            })

            test('Can update property for meter', async () => {
                const [property] = await createTestProperty(employeeClient, organization)
                const [meter] = await createTestMeter(employeeClient, organization, property, resource, {})

                const [newProperty] = await createTestProperty(employeeClient, organization)
                const [updatedMeter] = await updateTestMeter(employeeClient, meter.id, {
                    property: { connect: { id: newProperty.id } },
                })

                expect(updatedMeter.property.id).toEqual(newProperty.id)
            })

            test('Can not update property to property from other organization where user is not an employee', async () => {
                const [property] = await createTestProperty(employeeClient, organization)
                const [meter] = await createTestMeter(employeeClient, organization, property, resource, {})

                const [newProperty] = await createTestProperty(otherEmployeeClient, otherOrganization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(employeeClient, meter.id, {
                        property: { connect: { id: newProperty.id } },
                    })
                })
            })

            test('Can not update property to property from other user organization', async () => {
                const [property] = await createTestProperty(employeeClient, organization)
                const [meter] = await createTestMeter(employeeClient, organization, property, resource, {})

                const [otherOrganization] = await createTestOrganization(admin)
                const [role] = await createTestOrganizationEmployeeRole(admin, otherOrganization, {
                    canReadMeters: true,
                    canManageMeters: true,
                    canManageProperties: true,
                })
                await createTestOrganizationEmployee(admin, otherOrganization, employeeClient.user, role)
                const [otherProperty] = await createTestProperty(employeeClient, otherOrganization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(employeeClient, meter.id, {
                        property: { connect: { id: otherProperty.id } },
                    })
                })
            })
        })
        describe('Read', () => {
            test('employee: can read Meters', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, client.organization, client.property, resource, {})
                const meters = await Meter.getAll(client, { id: meter.id })

                expect(meters).toHaveLength(1)
            })

            test('employee without "canReadMeters": can not read Meters', async () => {
                const client = await makeEmployeeUserClientWithAbilities({ canReadMeters: false })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, client.organization, client.property, resource, {})
                const readMeter = await Meter.getOne(client, { id: meter.id })

                expect(readMeter).toBeUndefined()
            })

            test('employee from "from" related organization: can read Meters', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organizationTo, propertyTo, resource, {})
                const meters = await Meter.getAll(clientFrom, { id: meter.id })

                expect(meters).toHaveLength(1)
            })

            test('employee from "to" related organization: cannot read Meters from "from" organization', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organizationFrom, propertyFrom, resource, {})
                const meters = await Meter.getAll(clientTo, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            describe('resident: can read his Meters', () => {
                test('Manual meter', async () => {
                    const adminClient = await makeLoggedInAdminClient()
                    const client = await makeClientWithResidentUser()
                    const unitName = faker.random.alphaNumeric(8)
                    const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property] = await createTestProperty(adminClient, organization)
                    const [billingProperty] = await createTestBillingProperty(adminClient, context)
                    const [billingAccount] = await createTestBillingAccount(adminClient, context, billingProperty)
                    const [resident] = await createTestResident(adminClient, client.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(adminClient, resident, organization, {
                        accountNumber: billingAccount.number,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                        accountNumber: billingAccount.number,
                        unitName,
                    })
                    const meters = await Meter.getAll(client, { id: meter.id })

                    expect(meters).toHaveLength(1)
                    expect(meters[0]).toEqual(expect.objectContaining({
                        id: meter.id,
                        isAutomatic: false,
                    }))
                })
                test('Automatic meter', async () => {
                    const adminClient = await makeLoggedInAdminClient()
                    const client = await makeClientWithResidentUser()
                    const unitName = faker.random.alphaNumeric(8)
                    const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property] = await createTestProperty(adminClient, organization)
                    const [billingProperty] = await createTestBillingProperty(adminClient, context)
                    const [billingAccount] = await createTestBillingAccount(adminClient, context, billingProperty)
                    const [resident] = await createTestResident(adminClient, client.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(adminClient, resident, organization, {
                        accountNumber: billingAccount.number,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(adminClient, app, organization)
                    const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                        accountNumber: billingAccount.number,
                        unitName,
                        isAutomatic: true,
                        b2bApp: { connect: { id: app.id } },
                    })
                    const meters = await Meter.getAll(client, { id: meter.id })

                    expect(meters).toHaveLength(1)
                    expect(meters[0]).toEqual(expect.objectContaining({
                        id: meter.id,
                        isAutomatic: true,
                    }))
                })
            })

            test('resident: can read Meters from other organizations if it has resource ownership', async () => {
                const residentClient = await makeClientWithResidentUser()

                const { organization: originalOrganization, context: originalContext } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const { organization: serviceProviderOrganization, context: serviceProviderContext } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [originalProperty] = await createTestProperty(admin, originalOrganization)
                const [serviceProviderProperty] = await createTestProperty(admin, serviceProviderOrganization, {
                    address: originalProperty.address,
                })
                expect(serviceProviderProperty).toHaveProperty('addressKey', originalProperty.addressKey)

                const [originalBillingProperty] = await createTestBillingProperty(admin, originalContext, {
                    address: originalProperty.address,
                })
                expect(originalBillingProperty).toHaveProperty('addressKey', originalProperty.addressKey)

                const [serviceProviderBillingProperty] = await createTestBillingProperty(admin, serviceProviderContext, {
                    address: serviceProviderProperty.address,
                })
                expect(serviceProviderBillingProperty).toHaveProperty('addressKey', serviceProviderProperty.addressKey)

                const [originalBillingAccount] = await createTestBillingAccount(admin, originalContext, originalBillingProperty)
                const [serviceProviderBillingAccount] = await createTestBillingAccount(admin, serviceProviderContext, serviceProviderBillingProperty)

                const unitName = faker.random.alphaNumeric(8)
                const unitType = FLAT_UNIT_TYPE

                const [resident] = await createTestResident(admin, residentClient.user, originalProperty, { unitName, unitType })
                await createTestServiceConsumer(admin, resident, originalOrganization, { accountNumber: originalBillingAccount.number })
                await createTestServiceConsumer(admin, resident, serviceProviderOrganization, { accountNumber: serviceProviderBillingAccount.number })

                const coldWaterResource = await MeterResource.getOne(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const hotWaterResource = await MeterResource.getOne(residentClient, { id: HOT_WATER_METER_RESOURCE_ID })
                const [hotMeter] = await createTestMeter(admin, originalOrganization, originalProperty, hotWaterResource, {
                    accountNumber: originalBillingAccount.number, unitName, unitType,
                })

                await waitFor(async () => {
                    const meterResourceOwner = await MeterResourceOwner.getOne(admin, {
                        address_i: resident.address, resource: { id: HOT_WATER_METER_RESOURCE_ID },
                    })

                    expect(meterResourceOwner).toBeDefined()
                })

                const [coldMeter] = await createTestMeter(admin, originalOrganization, originalProperty, coldWaterResource, {
                    accountNumber: originalBillingAccount.number, unitName, unitType,
                })

                await waitFor(async () => {
                    const meterResourceOwner = await MeterResourceOwner.getOne(admin, {
                        address_i: resident.address, resource: { id: COLD_WATER_METER_RESOURCE_ID },
                    })

                    expect(meterResourceOwner).toBeDefined()
                })

                const meters = await Meter.getAll(residentClient, { id_in: [hotMeter.id, coldMeter.id] })
                expect(meters).toHaveLength(2)

                const coldMeterResourceOwner = await MeterResourceOwner.getOne(admin, {
                    resource: { id: COLD_WATER_METER_RESOURCE_ID }, address_i: resident.address,
                })
                await updateTestMeterResourceOwner(admin, coldMeterResourceOwner.id, {
                    organization: { connect: { id: serviceProviderOrganization.id } },
                })
                const [serviceProviderColdMeter] = await createTestMeter(admin, serviceProviderOrganization, serviceProviderProperty, coldWaterResource, {
                    accountNumber: serviceProviderBillingAccount.number, unitName, unitType,
                })
                expect(serviceProviderColdMeter).toHaveProperty(['property', 'id'], serviceProviderProperty.id)

                const newMeters = await Meter.getAll(residentClient, {}, { sortBy: ['createdAt_DESC'] })

                expect(newMeters).toHaveLength(2)
                expect(newMeters).toHaveProperty(['0', 'id'], serviceProviderColdMeter.id)
                expect(newMeters).toHaveProperty(['1', 'id'], hotMeter.id)

                const newMeter = await Meter.getOne(residentClient, { id: serviceProviderColdMeter.id })
                expect(newMeter).toBeDefined()
                expect(newMeter).toHaveProperty(['accountNumber'], serviceProviderColdMeter.accountNumber)
                expect(newMeter).toHaveProperty(['organization', 'id'], serviceProviderOrganization.id)
                expect(newMeter).toHaveProperty(['resource', 'id'], COLD_WATER_METER_RESOURCE_ID)
            })

            test('resident: cannot read Meters from other organization', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client1 = await makeClientWithResidentUser()
                const client2 = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context: context1, organization: organization1 } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property1] = await createTestProperty(adminClient, organization1)
                const [billingProperty1] = await createTestBillingProperty(adminClient, context1)
                const [billingAccount1] = await createTestBillingAccount(adminClient, context1, billingProperty1)
                const [resident1] = await createTestResident(adminClient, client1.user, property1, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident1, organization1, {
                    accountNumber: billingAccount1.number,
                })
                const { context: context2, organization: organization2 } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property2] = await createTestProperty(adminClient, organization2)
                const [billingProperty2] = await createTestBillingProperty(adminClient, context2)
                const [billingAccount2] = await createTestBillingAccount(adminClient, context2, billingProperty2)
                const [resident2] = await createTestResident(adminClient, client2.user, property2, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident2, organization2, {
                    accountNumber: billingAccount2.number,
                })
                const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization2, property2, resource, {
                    accountNumber: billingAccount2.number,
                    unitName,
                })
                const meters = await Meter.getAll(client1, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters in other property in same organization', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client1 = await makeClientWithResidentUser()
                const client2 = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property1] = await createTestProperty(adminClient, organization)
                const [billingProperty1] = await createTestBillingProperty(adminClient, context)
                const [billingAccount1] = await createTestBillingAccount(adminClient, context, billingProperty1)
                const [resident1] = await createTestResident(adminClient, client1.user, property1, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident1, organization, {
                    accountNumber: billingAccount1.number,
                })
                const [property2] = await createTestProperty(adminClient, organization)
                const [billingProperty2] = await createTestBillingProperty(adminClient, context)
                const [billingAccount2] = await createTestBillingAccount(adminClient, context, billingProperty2)
                const [resident2] = await createTestResident(adminClient, client2.user, property2, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident2, organization, {
                    accountNumber: billingAccount2.number,
                })
                const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property2, resource, {
                    accountNumber: billingAccount2.number,
                    unitName,
                })
                const meters = await Meter.getAll(client1, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: can read Meters in other unit in same property if accountNumber is correct', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client1 = await makeClientWithResidentUser()
                const client2 = await makeClientWithResidentUser()
                const unitName1 = faker.random.alphaNumeric(8)
                const unitName2 = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(adminClient, organization)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount1] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [resident1] = await createTestResident(adminClient, client1.user, property, {
                    unitName: unitName1,
                })
                const [resident2] = await createTestResident(adminClient, client2.user, property, {
                    unitName: unitName2,
                })
                await createTestServiceConsumer(adminClient, resident1, organization, {
                    accountNumber: billingAccount1.number,
                })
                await createTestServiceConsumer(adminClient, resident2, organization, {
                    accountNumber: billingAccount1.number,
                })

                const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: billingAccount1.number,
                    unitName: unitName2,
                })
                const meters1 = await Meter.getAll(client1, { id: meter.id })
                const meters2 = await Meter.getAll(client2, { id: meter.id })
                expect(meters1).toEqual([
                    expect.objectContaining({ id: meter.id }),
                ])
                expect(meters2).toEqual([
                    expect.objectContaining({ id: meter.id }),
                ])
            })

            test('resident: can not read Meters with same unit and different accountNumber', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client1 = await makeClientWithResidentUser()
                const client2 = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(adminClient, organization)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount1] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [billingAccount2] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [resident1] = await createTestResident(adminClient, client1.user, property, {
                    unitName,
                })
                const [resident2] = await createTestResident(adminClient, client2.user, property, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident1, organization, {
                    accountNumber: billingAccount1.number,
                })
                await createTestServiceConsumer(adminClient, resident2, organization, {
                    accountNumber: billingAccount2.number,
                })

                const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: billingAccount1.number,
                    unitName: unitName,
                })
                const meters1 = await Meter.getAll(client1, { id: meter.id })
                const meters2 = await Meter.getAll(client2, { id: meter.id })
                expect(meters1).toEqual([
                    expect.objectContaining({ id: meter.id }),
                ])
                expect(meters2).not.toEqual([
                    expect.objectContaining({ id: meter.id }),
                ])
            })

            test('resident: cannot read Meters with accountNumber, which doesnt present in serviceConsumers', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                const accountNumber1 = faker.random.alphaNumeric(8)
                const accountNumber2 = faker.random.alphaNumeric(8)
                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: accountNumber1,
                })
                await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber1,
                    unitName,
                })
                const [meter2] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber2,
                    unitName,
                })
                const meters = await Meter.getAll(client, { id: meter2.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters with accountNumber, which present in deleted serviceConsumer', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                const accountNumber1 = faker.random.alphaNumeric(8)
                const [serviceConsumer] = await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: accountNumber1,
                })
                await updateTestServiceConsumer(client, serviceConsumer.id, { deletedAt: 'true' })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber1,
                    unitName,
                })
                const meters = await Meter.getAll(client, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters with deleted organization', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                const accountNumber1 = faker.random.alphaNumeric(8)
                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: accountNumber1,
                })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber1,
                    unitName,
                })
                await updateTestOrganization(adminClient, organization.id, { deletedAt: 'true' })
                const meters = await Meter.getAll(client, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters with deleted property', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                const accountNumber1 = faker.random.alphaNumeric(8)
                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: accountNumber1,
                })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber1,
                    unitName,
                })

                await Property.softDelete(adminClient, property.id)

                // Test access before resident connections run in worker
                const metersBeforeResidentReconnects = await Meter.getAll(client, { id: meter.id })
                expect(metersBeforeResidentReconnects).toHaveLength(0)

                // Test access after residents disconnected in worker
                // NOTE: This place is unstable. Because of parallel sub-requests inside Meter.getAll
                // we get different path in error payload, and get either organization or property error
                // in random order from request to request. So we skip testing path/value here.
                // Exception message and error type is enough.
                await waitFor(async () => {
                    const metersAfterResidentReconnects = await Meter.getAll(client, { id: meter.id })

                    expect(metersAfterResidentReconnects).toHaveLength(0)
                })
            })

            test('user: cannot read Meters', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})
                const meters = await Meter.getAll(client, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('anonymous: cannot read Meters', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})

                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Meter.getAll(client, { id: meter.id })
                })
            })
        })
    })
    describe('Validations', () => {
        test('B2B app must have context with organization from meter', async () => {
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
            const [b2bApp] = await createTestB2BApp(admin)
            await expectToThrowValidationFailureError(async () => {
                await createTestMeter(admin, organization, property, resource, {
                    isAutomatic: true,
                    b2bApp: { connect: { id: b2bApp.id } },
                })
            }, B2B_APP_NOT_CONNECTED)
            await createTestB2BAppContext(admin, b2bApp, organization)
            const [meter] = await createTestMeter(admin, organization, property, resource, {
                isAutomatic: true,
                b2bApp: { connect: { id: b2bApp.id } },
            })
            expect(meter).toHaveProperty('id')
            const [anotherApp] = await createTestB2BApp(admin)
            await expectToThrowValidationFailureError(async () => {
                await updateTestMeter(admin, meter.id, {
                    b2bApp: { connect: { id: anotherApp.id } },
                })
            }, B2B_APP_NOT_CONNECTED)
        })
        test('B2C app must be available on meter\'s address', async () => {
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const [anotherProperty] = await createTestProperty(admin, organization)
            const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
            const [b2cApp] = await createTestB2CApp(admin)
            await createTestB2CAppProperty(admin, b2cApp, {
                address: property.address, addressMeta: property.addressMeta,
            })
            const [anotherApp] = await createTestB2CApp(admin)
            await createTestB2CAppProperty(admin, anotherApp, {
                address: anotherProperty.address, addressMeta: anotherProperty.addressMeta,
            })
            await expectToThrowValidationFailureError(async () => {
                await createTestMeter(admin, organization, property, resource, {
                    isAutomatic: false,
                    b2cApp: { connect: { id: anotherApp.id } },
                })
            }, B2C_APP_NOT_AVAILABLE)
            const [meter] = await createTestMeter(admin, organization, property, resource, {
                isAutomatic: false,
                b2cApp: { connect: { id: b2cApp.id } },
            })
            expect(meter).toHaveProperty('id')
            await expectToThrowValidationFailureError(async () => {
                await updateTestMeter(admin, meter.id, {
                    b2cApp: { connect: { id: anotherApp.id } },
                })
            }, B2C_APP_NOT_AVAILABLE)
        })
        describe('fields', () => {
            describe('number', () => {
                test('should trim spaces and throw an invalid value error', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({
                        canManageMeters: true,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                    await catchErrorFrom(async () => {
                        await createTestMeter(client, client.organization, client.property, resource, {
                            number: '     ',
                        })
                    }, ({ errors }) => {
                        expect(errors).toHaveLength(1)
                        expect(errors[0]).toEqual(expect.objectContaining({
                            message: METER_ERRORS.NUMBER_HAVE_INVALID_VALUE.message,
                        }))
                    })
                })

                test('should trim spaces and save meter', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({
                        canManageMeters: true,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter, attrs] = await createTestMeter(client, client.organization, client.property, resource, {
                        number: `   ${faker.random.alphaNumeric(5)}    `,
                    })

                    expect(meter.number).toEqual(String(attrs.number).trim())

                    const [updatedMeter, updatedAttrs] = await updateTestMeter(client, meter.id, {
                        number: `   ${faker.random.alphaNumeric(5)}    `,
                    })

                    expect(updatedMeter.number).toEqual(String(updatedAttrs.number).trim())
                })
            })
            describe('accountNumber', () => {
                test('should trim spaces and throw an invalid value error', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({
                        canManageMeters: true,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                    await catchErrorFrom(async () => {
                        await createTestMeter(client, client.organization, client.property, resource, {
                            accountNumber: '     ',
                        })
                    }, ({ errors }) => {
                        expect(errors).toHaveLength(1)
                        expect(errors[0]).toEqual(expect.objectContaining({
                            message: METER_ERRORS.ACCOUNT_NUMBER_HAVE_INVALID_VALUE.message,
                        }))
                    })
                })
                test('should trim spaces and save meter', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({
                        canManageMeters: true,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter, attrs] = await createTestMeter(client, client.organization, client.property, resource, {
                        accountNumber: `   ${faker.random.alphaNumeric(5)}    `,
                    })

                    expect(meter.accountNumber).toEqual(String(attrs.accountNumber).trim())

                    const [updatedMeter, updatedAttrs] = await updateTestMeter(client, meter.id, {
                        accountNumber: `   ${faker.random.alphaNumeric(5)}    `,
                    })

                    expect(updatedMeter.accountNumber).toEqual(String(updatedAttrs.accountNumber).trim())
                })
            })

            describe('unitType and unitName', () => {
                let client, resource

                beforeAll(async () => {
                    [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                })

                beforeEach(async () => {
                    client = await makeEmployeeUserClientWithAbilities({
                        canManageMeters: true,
                    })
                })

                test('unitType and unitName are required fields', async () => {
                    await expectToThrowValidationFailureError(async () => {
                        await createTestMeter(client, client.organization, client.property, resource, {
                            unitType: null,
                            unitName: faker.random.alphaNumeric(5),
                        })
                    }, 'Required field "unitType" is null or undefined.')

                    await expectToThrowValidationFailureError(async () => {
                        await createTestMeter(client, client.organization, client.property, resource, {
                            unitType: COMMERCIAL_UNIT_TYPE,
                            unitName: null,
                        })
                    }, 'Required field "unitName" is null or undefined.')

                    const [meter] = await createTestMeter(client, client.organization, client.property, resource, {
                        unitType: COMMERCIAL_UNIT_TYPE,
                        unitName: faker.random.alphaNumeric(5),
                    })

                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMeter(client, meter.id, {
                            unitType: null,
                        })
                    }, 'Required field "unitType" is null or undefined.')

                    await expectToThrowValidationFailureError(async () => {
                        await updateTestMeter(client, meter.id, {
                            unitName: null,
                        })
                    }, 'Required field "unitName" is null or undefined.')
                })

                test('unitType must be updatable', async () => {
                    const [meter] = await createTestMeter(client, client.organization, client.property, resource, { unitType: FLAT_UNIT_TYPE })
                    const [updatedMeter] = await updateTestMeter(admin, meter.id, {
                        unitType: COMMERCIAL_UNIT_TYPE,
                    })
                    expect(updatedMeter).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    expect(updatedMeter).toHaveProperty('unitName', meter.unitName)
                })

                test('unitName must be updatable', async () => {
                    const [meter] = await createTestMeter(client, client.organization, client.property, resource, { unitType: COMMERCIAL_UNIT_TYPE })
                    const [updatedMeter, attrs] = await updateTestMeter(admin, meter.id, {
                        unitName: faker.random.alphaNumeric(5),
                    })
                    expect(updatedMeter).toHaveProperty('unitType', COMMERCIAL_UNIT_TYPE)
                    expect(updatedMeter).toHaveProperty('unitName', attrs.unitName)
                })
            })
        })

        test('should restrict creation of the meter with same resource, owned by another organization', async () => {
            const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
            const client2 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true, canManageProperties: true })
            const [property] = await createTestProperty(client2, client2.organization, { address: client1.property.address })
            const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
            const [meter] = await createTestMeter(client1, client1.organization, client1.property, resource, {})

            expect(property).toHaveProperty('address', client1.property.address)
            expect(property).toHaveProperty('addressKey', client1.property.addressKey)
            expect(meter).toHaveProperty(['organization', 'id'], client1.organization.id)
            expect(meter).toHaveProperty(['property', 'id'], client1.property.id)
            expect(meter).toHaveProperty(['resource', 'id'], resource.id)

            await expectToThrowGQLError(async () => {
                await createTestMeter(client2, client2.organization, property, resource, {})
            }, METER_ERRORS.METER_RESOURCE_OWNED_BY_ANOTHER_ORGANIZATION)
        })

        test('should restrict update of the meter with same resource, owned by another organization', async () => {
            const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
            const client2 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true, canManageProperties: true })

            const [property] = await createTestProperty(client2, client2.organization, { address: client1.property.address })
            const [coldResource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
            const [hotResource] = await MeterResource.getAll(client2, { id: HOT_WATER_METER_RESOURCE_ID })
            const [meter1] = await createTestMeter(client1, client1.organization, client1.property, coldResource, {})
            const [meter2] = await createTestMeter(client2, client2.organization, property, hotResource, {})

            await expectToThrowGQLError(async () => {
                await updateTestMeter(client1, meter1.id, {
                    resource: { connect: { id: HOT_WATER_METER_RESOURCE_ID } },
                })
            }, METER_ERRORS.METER_RESOURCE_OWNED_BY_ANOTHER_ORGANIZATION)

            await expectToThrowGQLError(async () => {
                await updateTestMeter(client2, meter2.id, {
                    resource: { connect: { id: COLD_WATER_METER_RESOURCE_ID } },
                })
            }, METER_ERRORS.METER_RESOURCE_OWNED_BY_ANOTHER_ORGANIZATION)
        })

        test('should create MeterResourceOwner after new meter creation', async () => {
            const client = await makeEmployeeUserClientWithAbilities({
                canManageMeters: true,
            })
            const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
            const [meter] = await createTestMeter(client, client.organization, client.property, resource, {})

            await waitFor(async () => {
                const meterResourceOwner = await MeterResourceOwner.getOne(client, {
                    address: meter.property.address,
                    organization: { id: client.organization.id },
                    resource: { id: meter.resource.id },
                })

                expect(meterResourceOwner).toHaveProperty(['organization', 'id'], client.organization.id)
                expect(meterResourceOwner).toHaveProperty(['resource', 'id'], meter.resource.id)
                expect(meterResourceOwner).toHaveProperty('address', meter.property.address)
                expect(meterResourceOwner).toHaveProperty(['sender', 'fingerprint'], meter.sender.fingerprint)
            })
        })

        test('should create MeterResourceOwner after meter update', async () => {
            const client = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
            const [meter] = await createTestMeter(client, client.organization, client.property, { id: COLD_WATER_METER_RESOURCE_ID }, {})

            await waitFor(async () => {
                const meterResourceOwner = await MeterResourceOwner.getOne(client, {
                    addressKey: client.property.addressKey,
                    resource: { id: COLD_WATER_METER_RESOURCE_ID },
                })

                expect(meterResourceOwner).toHaveProperty(['organization', 'id'], client.organization.id)
                expect(meterResourceOwner).toHaveProperty(['resource', 'id'], COLD_WATER_METER_RESOURCE_ID)
                expect(meterResourceOwner).toHaveProperty('addressKey', client.property.addressKey)
            })

            const newNumber = faker.random.alphaNumeric(5)
            const [updatedObj] = await updateTestMeter(client, meter.id, {
                number: newNumber,
            })

            expect(updatedObj).toHaveProperty('number', newNumber)
            const tempMeterResourceOwners = await MeterResourceOwner.getAll(client, {
                addressKey: client.property.addressKey,
            })

            expect(tempMeterResourceOwners).toHaveLength(1)
            expect(tempMeterResourceOwners[0]).toHaveProperty('addressKey', client.property.addressKey)
            expect(tempMeterResourceOwners[0]).toHaveProperty(['resource', 'id'], meter.resource.id)

            const [updatedMeter] = await updateTestMeter(client, meter.id, { resource: { connect: { id: HOT_WATER_METER_RESOURCE_ID } } })

            expect(updatedMeter).toHaveProperty(['resource', 'id'], HOT_WATER_METER_RESOURCE_ID)
            await waitFor(async () => {
                const meterResourceOwners = await MeterResourceOwner.getAll(client, {
                    addressKey: client.property.addressKey,
                })

                expect(meterResourceOwners).toHaveLength(2)
                expect(meterResourceOwners).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        organization: { id: client.organization.id },
                        resource: { id: COLD_WATER_METER_RESOURCE_ID },
                        addressKey: client.property.addressKey,
                    }),
                    expect.objectContaining({
                        organization: { id: client.organization.id },
                        resource: { id: HOT_WATER_METER_RESOURCE_ID },
                        addressKey: client.property.addressKey,
                    }),
                ]))
            })

        })

        test('should allow to softDelete Meter after loose resource ownership', async () => {
            const client = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
            const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
            const [meter] = await createTestMeter(client, client.organization, client.property, resource)

            let meterResourceOwner

            await waitFor(async () => {
                meterResourceOwner = await MeterResourceOwner.getOne(client, {
                    address: meter.property.address,
                    organization: { id: client.organization.id },
                    resource: { id: meter.resource.id },
                })

                expect(meterResourceOwner).toHaveProperty(['organization', 'id'], client.organization.id)
                expect(meterResourceOwner).toHaveProperty(['resource', 'id'], meter.resource.id)
                expect(meterResourceOwner).toHaveProperty('address', meter.property.address)
                expect(meterResourceOwner).toHaveProperty(['sender', 'fingerprint'], meter.sender.fingerprint)
            })

            const [organization] = await createTestOrganization(admin)

            const [newMeterResourceOwner] = await updateTestMeterResourceOwner(admin, meterResourceOwner.id, {
                organization: { connect: { id: organization.id } },
            })

            expect(newMeterResourceOwner).toHaveProperty(['organization', 'id'], organization.id)
            expect(newMeterResourceOwner).toHaveProperty(['addressKey'], client.property.addressKey)
            expect(newMeterResourceOwner).toHaveProperty(['resource', 'id'], COLD_WATER_METER_RESOURCE_ID)

            const [updatedMeter] = await Meter.softDelete(client, meter.id, {})

            expect(updatedMeter.deletedAt).not.toBeNull()
        })

        test('number of tariffs must be from 1 to 4', async () => {
            const client = await makeEmployeeUserClientWithAbilities({
                canManageMeters: true,
            })
            const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
            const errorFields = (value) => ({
                code: 'BAD_USER_INPUT',
                type: 'NUMBER_OF_TARIFFS_NOT_VALID',
                message: 'Provided number of tariffs is not valid. Must be an integer from 1 to 4.',
                messageForUser: 'api.meter.NUMBER_OF_TARIFFS_NOT_VALID',
                messageInterpolation: { value },
                variable: ['data', 'numberOfTariffs'],
            })

            await expectToThrowGQLError(
                async () => createTestMeter(client, client.organization, client.property, resource, { numberOfTariffs: -2 }),
                errorFields(-2),
            )
            await expectToThrowGQLError(
                async () => createTestMeter(client, client.organization, client.property, resource, { numberOfTariffs: 0 }),
                errorFields(0),
            )
            await expectToThrowGQLError(
                async () => createTestMeter(client, client.organization, client.property, resource, { numberOfTariffs: 5 }),
                errorFields(5),
            )
            await expectToThrowGQLError(
                async () => createTestMeter(client, client.organization, client.property, resource, { numberOfTariffs: 100500 }),
                errorFields(100500),
            )
        })
    })
    describe('Bulk requests', () => {
        let property1,
            property2
        beforeEach(async () => {
            const [testProperty1] = await createTestProperty(employeeClient, organization)
            property1 = testProperty1
            const [testProperty2] = await createTestProperty(employeeClient, organization)
            property2 = testProperty2
        })

        test('Can create for organization where user is employee', async () => {
            const unitName1 = faker.random.alphaNumeric(5)
            const unitName2 = faker.random.alphaNumeric(5)

            const meters = await createTestMeters(employeeClient, [
                {
                    organization: { connect: { id: organization.id } },
                    property: { connect: { id: property1.id } },
                    resource: { connect: { id: resource.id } },
                    unitName: unitName1,
                },
                {
                    organization: { connect: { id: organization.id } },
                    property: { connect: { id: property2.id } },
                    resource: { connect: { id: resource.id } },
                    unitName: unitName2,
                },
            ])

            expect(meters).toHaveLength(2)
            expect(meters).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    unitName: unitName1,
                    organization: expect.objectContaining({ id: organization.id }),
                    property: expect.objectContaining({ id: property1.id }),
                }),
                expect.objectContaining({
                    unitName: unitName2,
                    organization: expect.objectContaining({ id: organization.id }),
                    property: expect.objectContaining({ id: property2.id }),
                }),
            ]))
        })

        test('Can not create for organization where user is not employee', async () => {
            const number1 = faker.random.alphaNumeric(8)
            const number2 = faker.random.alphaNumeric(8)

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await createTestMeters(otherEmployeeClient, [
                    {
                        organization: { connect: { id: organization.id } },
                        property: { connect: { id: property1.id } },
                        resource: { connect: { id: resource.id } },
                        number: number1,
                    },
                    {
                        organization: { connect: { id: organization.id } },
                        property: { connect: { id: property2.id } },
                        resource: { connect: { id: resource.id } },
                        number: number2,
                    },
                ])
            })
        })

        test('Can not create with property from other organization', async () => {
            const [otherOrganization] = await createTestOrganization(admin)
            const [otherRole] = await createTestOrganizationEmployeeRole(admin, otherOrganization, {
                canReadMeters: true,
                canManageMeters: true,
                canManageProperties: true,
            })
            await createTestOrganizationEmployee(admin, otherOrganization, employeeClient.user, otherRole)
            const [property] = await createTestProperty(employeeClient, otherOrganization)

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await createTestMeters(employeeClient, [
                    {
                        organization: { connect: { id: organization.id } },
                        property: { connect: { id: property1.id } },
                        resource: { connect: { id: resource.id } },
                    },
                    {
                        organization: { connect: { id: organization.id } },
                        property: { connect: { id: property.id } },
                        resource: { connect: { id: resource.id } },
                    },
                ])
            })
        })

        test('Can update for organization where user is employee', async () => {
            const createdMeters = await createTestMeters(employeeClient, [
                {
                    organization: { connect: { id: organization.id } },
                    property: { connect: { id: property1.id } },
                    resource: { connect: { id: resource.id } },
                },
                {
                    organization: { connect: { id: organization.id } },
                    property: { connect: { id: property2.id } },
                    resource: { connect: { id: resource.id } },
                },
            ])

            const number1 = faker.random.alphaNumeric(8)
            const number2 = faker.random.alphaNumeric(8)
            const [testProperty3] = await createTestProperty(employeeClient, organization)
            const updatedMeters = await updateTestMeters(employeeClient, [
                {
                    id: createdMeters[0].id,
                    data: {
                        number: number1,
                    },
                },
                {
                    id: createdMeters[1].id,
                    data: {
                        number: number2,
                        property: { connect: { id: testProperty3.id } },
                    },
                },
            ])

            expect(updatedMeters).toHaveLength(2)
            expect(updatedMeters).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    number: number1,
                    organization: expect.objectContaining({ id: organization.id }),
                }),
                expect.objectContaining({
                    number: number2,
                    organization: expect.objectContaining({ id: organization.id }),
                    property: expect.objectContaining({ id: testProperty3.id }),
                }),
            ]))
        })

        test('Can not update for organization where user is not employee', async () => {
            const createdMeters = await createTestMeters(employeeClient, [
                {
                    organization: { connect: { id: organization.id } },
                    property: { connect: { id: property1.id } },
                    resource: { connect: { id: resource.id } },
                },
                {
                    organization: { connect: { id: organization.id } },
                    property: { connect: { id: property2.id } },
                    resource: { connect: { id: resource.id } },
                },
            ])

            const number1 = faker.random.alphaNumeric(8)
            const number2 = faker.random.alphaNumeric(8)
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await updateTestMeters(otherEmployeeClient, [
                    {
                        id: createdMeters[0].id,
                        data: {
                            number: number1,
                        },
                    },
                    {
                        id: createdMeters[1].id,
                        data: {
                            number: number2,
                        },
                    },
                ])
            })
        })

        test('Can not update property from other organization', async () => {
            const createdMeters = await createTestMeters(employeeClient, [
                {
                    organization: { connect: { id: organization.id } },
                    property: { connect: { id: property1.id } },
                    resource: { connect: { id: resource.id } },
                },
                {
                    organization: { connect: { id: organization.id } },
                    property: { connect: { id: property2.id } },
                    resource: { connect: { id: resource.id } },
                },
            ])

            const [otherOrganization] = await createTestOrganization(admin)
            const [otherRole] = await createTestOrganizationEmployeeRole(admin, otherOrganization, {
                canReadMeters: true,
                canManageMeters: true,
                canManageProperties: true,
            })
            await createTestOrganizationEmployee(admin, otherOrganization, employeeClient.user, otherRole)
            const [propertyInOtherOrganization] = await createTestProperty(employeeClient, otherOrganization)

            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await updateTestMeters(employeeClient, [
                    {
                        id: createdMeters[0].id,
                        data: {
                            property: { connect: { id: propertyInOtherOrganization.id } },
                        },
                    },
                    {
                        id: createdMeters[1].id,
                        data: {
                            property: { connect: { id: property1.id } },
                        },
                    },
                ])
            })
        })
    })
})
