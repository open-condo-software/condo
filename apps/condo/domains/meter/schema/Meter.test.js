/**
 * Generated by `createschema meter.MeterReadingSource 'organization:Relationship:Organization:CASCADE; type:Select:call,mobile_app,billing; name:Text;'`
 */

const { faker } = require('@faker-js/faker')

const { makeClient, UUID_RE, makeLoggedInAdminClient, waitFor } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowValidationFailureError,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    catchErrorFrom,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const {
    createTestBillingAccount,
    createTestBillingProperty,
    makeContextWithOrganizationAndIntegrationAsAdmin,
} = require('@condo/domains/billing/utils/testSchema')
const { sleep } = require('@condo/domains/common/utils/sleep')
const { COLD_WATER_METER_RESOURCE_ID, HOT_WATER_METER_RESOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { AUTOMATIC_METER_NO_MASTER_APP, B2C_APP_NOT_AVAILABLE, B2B_APP_NOT_CONNECTED } = require('@condo/domains/meter/constants/errors')
const {
    MeterResource,
    Meter,
    createTestMeter,
    updateTestMeter,
    MeterResourceOwner,
    updateTestMeterResourceOwner,
} = require('@condo/domains/meter/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2CApp,
    createTestB2CAppProperty,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    createTestOrganization,
    updateTestOrganizationEmployee,
    createTestOrganizationEmployeeRole,
    createTestOrganizationWithAccessToAnotherOrganization,
    makeEmployeeUserClientWithAbilities,
    updateTestOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE, PARKING_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { createTestProperty, Property } = require('@condo/domains/property/utils/testSchema')
const { createTestResident, updateTestServiceConsumer, createTestServiceConsumer } = require('@condo/domains/resident/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithResidentUser } = require('@condo/domains/user/utils/testSchema')

const { METER_ERRORS } = require('./Meter')


describe('Meter', () => {
    let admin
    let clientFrom
    let clientTo
    let organizationFrom
    let organizationTo
    let propertyFrom
    let propertyTo
    let employeeFrom
    let employeeTo

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()

        if (!clientTo) {
            ({
                clientTo,
                clientFrom,
                organizationFrom,
                organizationTo,
                propertyFrom,
                propertyTo,
                employeeFrom,
                employeeTo,
            } = await createTestOrganizationWithAccessToAnotherOrganization())
        }
    })

    describe('CRUD', () => {
        describe('Create', () => {
            test('employee with "canManageMeters" role: can create Meter', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(client, client.organization, client.property, resource, {})

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee with "canManageMeters" role: cannot create Meter with wrong "sender" field', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                await catchErrorFrom(async () => {
                    await createTestMeter(client, client.organization, client.property, resource, {
                        sender: null,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                    expect(errors[0].data.messages[0]).toContain('Required field "sender" is null or undefined.')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            test('employee without "canManageMeters" role: cannot create Meter', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(client, client.organization, client.property, resource, {})
                })
            })

            test('employee with "canManageMeters" role: cannot create Meter if Meter with same accountNumber exist in user organization in other unit', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = faker.lorem.word()
                const unitName1 = faker.lorem.word()
                const unitName2 = faker.lorem.word()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName: unitName1,
                })

                await catchErrorFrom(async () => {
                    await createTestMeter(client, client.organization, client.property, resource, {
                        accountNumber,
                        unitName: unitName2,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                    expect(errors[0].data.messages[0]).toContain('Meter with same account number exist in current organization')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            test('employee with "canManageMeters" role: cannot create Meter if Meter with same accountNumber exist in user organization in other unit type', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = faker.lorem.word()
                const unitName = faker.lorem.word()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })

                await catchErrorFrom(async () => {
                    await createTestMeter(client, client.organization, client.property, resource, {
                        accountNumber,
                        unitName,
                        unitType: PARKING_UNIT_TYPE,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                    expect(errors[0].data.messages[0]).toContain('Meter with same account number exist in current organization')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            test('employee with "canManageMeters" role: can create Meter if Meter with same accountNumber exist in user organization in same unit', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = faker.lorem.word()
                const unitName = faker.lorem.word()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                })

                const [meter] =  await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                })

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee with "canManageMeters" role: can create Meter if Meter with same accountNumber exist in other organization', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const client2 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = faker.lorem.word()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                })

                const [meter] = await createTestMeter(client2, client2.organization, client2.property, resource, {
                    accountNumber,
                })

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee from another organization with "canManageMeters" role: cannot create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(client, organization, property, resource, {})
                })
            })

            test('employee from "from" related organization with "canManageMeters" role: can create Meter', async () => {
                const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                    canManageMeters: true,
                })

                await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                    role: { connect: { id: role.id } },
                })

                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(clientFrom, organizationTo, propertyTo, resource, {})

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee from "from" related organization without "canManageMeters" role: cannot create Meter', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })

                const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                    canManageMeters: false,
                })
                await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                    role: { connect: { id: role.id } },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(clientFrom, organizationTo, propertyTo, resource, {})
                })
            })

            test('employee from "to" related organization with "canManageMeters" role: cannot create Meter in "from" organization', async () => {
                const [role] = await createTestOrganizationEmployeeRole(admin, organizationTo, {
                    canManageMeters: true,
                })

                await updateTestOrganizationEmployee(admin, employeeTo.id, {
                    role: { connect: { id: role.id } },
                })

                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(clientTo, organizationFrom, propertyFrom, resource, {})
                })
            })

            test('employee with "canManageMeters" role: can create Meter if another Meter with same number and other resource exist in user organization', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource1] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resource2] = await MeterResource.getAll(client, { id: HOT_WATER_METER_RESOURCE_ID })
                const number = faker.random.alphaNumeric(5)

                await createTestMeter(client, client.organization, client.property, resource1, { number })
                const [meter] = await createTestMeter(client, client.organization, client.property, resource2, { number })

                expect(meter.id).toMatch(UUID_RE)
            })

            test('employee with "canManageMeters" role: cannot create Meter if another Meter with same number and resource exist in user organization', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const number = faker.random.alphaNumeric(5)

                await createTestMeter(client, client.organization, client.property, resource, { number })

                await catchErrorFrom(async () => {
                    await createTestMeter(client, client.organization, client.property, resource, { number })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                    expect(errors[0].data.messages[0]).toContain('Meter with same number and resource exist in current organization')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            test('resident: cannot create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(adminClient, organization)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })

                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: billingAccount.number,
                })

                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(client, organization, property, resource, {
                        accountNumber: billingAccount.number,
                        unitName,
                    })
                })
            })

            test('user: cannot create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeter(client, organization, property, resource, {})
                })
            })

            test('anonymous: cannot create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestMeter(client, organization, property, resource, {})
                })
            })

            test('admin: can create Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})

                expect(meter.id).toMatch(UUID_RE)
            })
        })
        describe('Update', () => {
            test('employee with "canManageMeters" role: can update Meter', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(client, client.organization, client.property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)
                const [updatedMeter] = await updateTestMeter(client, meter.id, {
                    number: newNumber,
                })

                expect(updatedMeter.number).toEqual(newNumber)
            })

            test('employee with "canManageMeters" role: can update Meter if Meter with same accountNumber exist in user organization in same unit and unitType', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = faker.lorem.word()
                const unitName = faker.lorem.word()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })

                const [meter] =  await createTestMeter(client, client.organization, client.property, resource, {
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })

                const [updatedMeter] = await updateTestMeter(client, meter.id, {
                    accountNumber,
                })

                expect(updatedMeter.accountNumber).toEqual(accountNumber)
            })

            test('employee with "canManageMeters" role: cannot update Meter if Meter with same accountNumber exist in organization in other unit', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = faker.lorem.word()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                })

                const [meter] = await createTestMeter(client, client.organization, client.property, resource)

                await catchErrorFrom(async () => {
                    await updateTestMeter(client, meter.id, {
                        accountNumber,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                    expect(errors[0].data.messages[0]).toContain('Meter with same account number exist in current organization')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            test('employee with "canManageMeters" role: cannot update Meter if Meter with same accountNumber exist in organization in other unit type', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const accountNumber = faker.lorem.word()
                const unitName = faker.lorem.word()

                await createTestMeter(client, client.organization, client.property, resource, {
                    accountNumber,
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })

                const [meter] = await createTestMeter(client, client.organization, client.property, resource)

                await catchErrorFrom(async () => {
                    await updateTestMeter(client, meter.id, {
                        accountNumber,
                        unitName,
                        unitType: PARKING_UNIT_TYPE,
                    })
                }, ({ errors, data }) => {
                    expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                    expect(errors[0].data.messages[0]).toContain('Meter with same account number exist in current organization')
                    expect(data).toEqual({ 'obj': null })
                })
            })

            test('employee without "canManageMeters" role: cannot update Meter', async () => {
                const client = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, client.organization, client.property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(client, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('employee from "from" related organization with "canManageMeters" role: can update Meter', async () => {
                const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                    canManageMeters: true,
                })
                await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                    role: { connect: { id: role.id } },
                })
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(clientFrom, organizationTo, propertyTo, resource, {})
                const newNumber = faker.random.alphaNumeric(8)
                const [updatedMeter] = await updateTestMeter(clientFrom, meter.id, {
                    number: newNumber,
                })

                expect(updatedMeter.number).toEqual(newNumber)
            })

            test('employee from "from" related organization without "canManageMeters" role: cannot update Meter', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organizationTo, propertyTo, resource, {})
                const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                    canManageMeters: false,
                })
                await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                    role: { connect: { id: role.id } },
                })
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(clientFrom, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('employee from "to" related organization with "canManageMeters" role: cannot update Meter from "from" organization', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organizationFrom, propertyFrom, resource, {})
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(clientTo, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('resident: cannot update Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(adminClient, organization)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: billingAccount.number,
                })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: billingAccount.number,
                    unitName,
                })
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(client, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('user: cannot update Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeter(client, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('anonymous: cannot update Meter', async () => {
                const client = await makeClient()
                const adminClient = await makeLoggedInAdminClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestMeter(client, meter.id, {
                        number: newNumber,
                    })
                })
            })

            test('admin: can update Meter', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})
                const newNumber = faker.random.alphaNumeric(8)
                const [updatedMeter] = await updateTestMeter(adminClient, meter.id, {
                    number: newNumber,
                })

                expect(updatedMeter.number).toEqual(newNumber)
            })
        })
        describe('Read', () => {
            test('employee: can read Meters', async () => {
                const client = await makeEmployeeUserClientWithAbilities()
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, client.organization, client.property, resource, {})
                const meters = await Meter.getAll(client, { id: meter.id })

                expect(meters).toHaveLength(1)
            })

            test('employee without "canReadMeters": can not read Meters', async () => {
                const client = await makeEmployeeUserClientWithAbilities({ canReadMeters: false })
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, client.organization, client.property, resource, {})
                const readMeter = await Meter.getOne(client, { id: meter.id })

                expect(readMeter).toBeUndefined()
            })

            test('employee from "from" related organization: can read Meters', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organizationTo, propertyTo, resource, {})
                const meters = await Meter.getAll(clientFrom, { id: meter.id })

                expect(meters).toHaveLength(1)
            })

            test('employee from "to" related organization: cannot read Meters from "from" organization', async () => {
                const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organizationFrom, propertyFrom, resource, {})
                const meters = await Meter.getAll(clientTo, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            describe('resident: can read his Meters',  () => {
                test('Manual meter', async () => {
                    const adminClient = await makeLoggedInAdminClient()
                    const client = await makeClientWithResidentUser()
                    const unitName = faker.random.alphaNumeric(8)
                    const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property] = await createTestProperty(adminClient, organization)
                    const [billingProperty] = await createTestBillingProperty(adminClient, context)
                    const [billingAccount] = await createTestBillingAccount(adminClient, context, billingProperty)
                    const [resident] = await createTestResident(adminClient, client.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(adminClient, resident, organization, {
                        accountNumber: billingAccount.number,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                        accountNumber: billingAccount.number,
                        unitName,
                    })
                    const meters = await Meter.getAll(client, { id: meter.id })

                    expect(meters).toHaveLength(1)
                    expect(meters[0]).toEqual(expect.objectContaining({
                        id: meter.id,
                        isAutomatic: false,
                    }))
                })
                test('Automatic meter', async () => {
                    const adminClient = await makeLoggedInAdminClient()
                    const client = await makeClientWithResidentUser()
                    const unitName = faker.random.alphaNumeric(8)
                    const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property] = await createTestProperty(adminClient, organization)
                    const [billingProperty] = await createTestBillingProperty(adminClient, context)
                    const [billingAccount] = await createTestBillingAccount(adminClient, context, billingProperty)
                    const [resident] = await createTestResident(adminClient, client.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(adminClient, resident, organization, {
                        accountNumber: billingAccount.number,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [app] = await createTestB2BApp(adminClient)
                    await createTestB2BAppContext(adminClient, app, organization)
                    const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                        accountNumber: billingAccount.number,
                        unitName,
                        isAutomatic: true,
                        b2bApp: { connect: { id: app.id } },
                    })
                    const meters = await Meter.getAll(client, { id: meter.id })

                    expect(meters).toHaveLength(1)
                    expect(meters[0]).toEqual(expect.objectContaining({
                        id: meter.id,
                        isAutomatic: true,
                    }))
                })
            })

            test('resident: cannot read Meters from other organization', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client1 = await makeClientWithResidentUser()
                const client2 = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context: context1, organization: organization1 } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property1] = await createTestProperty(adminClient, organization1)
                const [billingProperty1] = await createTestBillingProperty(adminClient, context1)
                const [billingAccount1] = await createTestBillingAccount(adminClient, context1, billingProperty1)
                const [resident1] = await createTestResident(adminClient, client1.user, property1, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident1, organization1, {
                    accountNumber: billingAccount1.number,
                })
                const { context: context2, organization: organization2 } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property2] = await createTestProperty(adminClient, organization2)
                const [billingProperty2] = await createTestBillingProperty(adminClient, context2)
                const [billingAccount2] = await createTestBillingAccount(adminClient, context2, billingProperty2)
                const [resident2] = await createTestResident(adminClient, client2.user, property2, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident2, organization2, {
                    accountNumber: billingAccount2.number,
                })
                const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization2, property2, resource, {
                    accountNumber: billingAccount2.number,
                    unitName,
                })
                const meters = await Meter.getAll(client1, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters in other property in same organization', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client1 = await makeClientWithResidentUser()
                const client2 = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property1] = await createTestProperty(adminClient, organization)
                const [billingProperty1] = await createTestBillingProperty(adminClient, context)
                const [billingAccount1] = await createTestBillingAccount(adminClient, context, billingProperty1)
                const [resident1] = await createTestResident(adminClient, client1.user, property1, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident1, organization, {
                    accountNumber: billingAccount1.number,
                })
                const [property2] = await createTestProperty(adminClient, organization)
                const [billingProperty2] = await createTestBillingProperty(adminClient, context)
                const [billingAccount2] = await createTestBillingAccount(adminClient, context, billingProperty2)
                const [resident2] = await createTestResident(adminClient, client2.user, property2, {
                    unitName,
                })
                await createTestServiceConsumer(adminClient, resident2, organization, {
                    accountNumber: billingAccount2.number,
                })
                const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property2, resource, {
                    accountNumber: billingAccount2.number,
                    unitName,
                })
                const meters = await Meter.getAll(client1, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters in other unit in same property', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client1 = await makeClientWithResidentUser()
                const client2 = await makeClientWithResidentUser()
                const unitName1 = faker.random.alphaNumeric(8)
                const unitName2 = faker.random.alphaNumeric(8)
                const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                const [property] = await createTestProperty(adminClient, organization)
                const [billingProperty] = await createTestBillingProperty(adminClient, context)
                const [billingAccount1] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [resident1] = await createTestResident(adminClient, client1.user, property, {
                    unitName: unitName1,
                })
                await createTestServiceConsumer(adminClient, resident1, organization, {
                    accountNumber: billingAccount1.number,
                })
                const [billingAccount2] = await createTestBillingAccount(adminClient, context, billingProperty)
                const [resident2] = await createTestResident(adminClient, client2.user, property, {
                    unitName: unitName2,
                })
                await createTestServiceConsumer(adminClient, resident2, organization, {
                    accountNumber: billingAccount2.number,
                })
                const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: billingAccount2.number,
                    unitName: unitName2,
                })
                const meters = await Meter.getAll(client1, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters with accountNumber, which doesnt present in serviceConsumers', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                const accountNumber1 = faker.random.alphaNumeric(8)
                const accountNumber2 = faker.random.alphaNumeric(8)
                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: accountNumber1,
                })
                await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber1,
                    unitName,
                })
                const [meter2] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber2,
                    unitName,
                })
                const meters = await Meter.getAll(client, { id: meter2.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters with accountNumber, which present in deleted serviceConsumer', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                const accountNumber1 = faker.random.alphaNumeric(8)
                const [serviceConsumer] = await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: accountNumber1,
                })
                await updateTestServiceConsumer(client, serviceConsumer.id, { deletedAt: 'true' })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber1,
                    unitName,
                })
                const meters = await Meter.getAll(client, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters with deleted organization', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                const accountNumber1 = faker.random.alphaNumeric(8)
                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: accountNumber1,
                })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber1,
                    unitName,
                })
                await updateTestOrganization(adminClient, organization.id, { deletedAt: 'true' })
                const meters = await Meter.getAll(client, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('resident: cannot read Meters with deleted property', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithResidentUser()
                const unitName = faker.random.alphaNumeric(8)
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                const [resident] = await createTestResident(adminClient, client.user, property, {
                    unitName,
                })
                const accountNumber1 = faker.random.alphaNumeric(8)
                await createTestServiceConsumer(adminClient, resident, organization, {
                    accountNumber: accountNumber1,
                })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {
                    accountNumber: accountNumber1,
                    unitName,
                })

                await Property.softDelete(adminClient, property.id)

                // Test access before resident connections run in worker
                const metersBeforeResidentReconnects = await Meter.getAll(client, { id: meter.id })
                expect(metersBeforeResidentReconnects).toHaveLength(0)

                // NOTE: give worker some time
                await sleep(1000)

                // Test access after residents disconnected in worker
                // NOTE: This place is unstable. Because of parallel sub-requests inside Meter.getAll
                // we get different path in error payload, and get either organization or property error
                // in random order from request to request. So we skip testing path/value here.
                // Exception message and error type is enough.
                const metersAfterResidentReconnects = await Meter.getAll(client, { id: meter.id })

                expect(metersAfterResidentReconnects).toHaveLength(0)
            })

            test('user: cannot read Meters', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})
                const meters = await Meter.getAll(client, { id: meter.id })

                expect(meters).toHaveLength(0)
            })

            test('anonymous: cannot read Meters', async () => {
                const adminClient = await makeLoggedInAdminClient()
                const client = await makeClient()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, organization)
                const [resource] = await MeterResource.getAll(adminClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(adminClient, organization, property, resource, {})

                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await Meter.getAll(client, { id: meter.id })
                })
            })
        })
    })
    describe('Validations', () => {
        test('If automatic must have master-system b2b app', async () => {
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
            await expectToThrowValidationFailureError(async () => {
                await createTestMeter(admin, organization, property, resource, {
                    isAutomatic: true,
                })
            }, AUTOMATIC_METER_NO_MASTER_APP)
            const [b2bApp] = await createTestB2BApp(admin)
            await createTestB2BAppContext(admin, b2bApp, organization)
            const [meter] = await createTestMeter(admin, organization, property, resource, {
                isAutomatic: true,
                b2bApp: { connect: { id: b2bApp.id } },
            })
            expect(meter).toHaveProperty('id')
            await expectToThrowValidationFailureError(async () => {
                await updateTestMeter(admin, meter.id, {
                    b2bApp: { disconnectAll: true },
                })
            }, AUTOMATIC_METER_NO_MASTER_APP)
        })
        test('B2B app must have context with organization from meter', async () => {
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
            const [b2bApp] = await createTestB2BApp(admin)
            await expectToThrowValidationFailureError(async () => {
                await createTestMeter(admin, organization, property, resource, {
                    isAutomatic: true,
                    b2bApp: { connect: { id: b2bApp.id } },
                })
            }, B2B_APP_NOT_CONNECTED)
            await createTestB2BAppContext(admin, b2bApp, organization)
            const [meter] =  await createTestMeter(admin, organization, property, resource, {
                isAutomatic: true,
                b2bApp: { connect: { id: b2bApp.id } },
            })
            expect(meter).toHaveProperty('id')
            const [anotherApp] = await createTestB2BApp(admin)
            await expectToThrowValidationFailureError(async () => {
                await updateTestMeter(admin, meter.id, {
                    b2bApp: { connect: { id: anotherApp.id } },
                })
            }, B2B_APP_NOT_CONNECTED)
        })
        test('B2C app must be available on meter\'s address', async () => {
            const [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization)
            const [anotherProperty] = await createTestProperty(admin, organization)
            const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
            const [b2cApp] = await createTestB2CApp(admin)
            await createTestB2CAppProperty(admin, b2cApp, {
                address: property.address, addressMeta: property.addressMeta,
            })
            const [anotherApp] = await createTestB2CApp(admin)
            await createTestB2CAppProperty(admin, anotherApp, {
                address: anotherProperty.address, addressMeta: anotherProperty.addressMeta,
            })
            await expectToThrowValidationFailureError(async () => {
                await createTestMeter(admin, organization, property, resource, {
                    isAutomatic: false,
                    b2cApp: { connect: { id: anotherApp.id } },
                })
            }, B2C_APP_NOT_AVAILABLE)
            const [meter] = await createTestMeter(admin, organization, property, resource, {
                isAutomatic: false,
                b2cApp: { connect: { id: b2cApp.id } },
            })
            expect(meter).toHaveProperty('id')
            await expectToThrowValidationFailureError(async () => {
                await updateTestMeter(admin, meter.id, {
                    b2cApp: { connect: { id: anotherApp.id } },
                })
            }, B2C_APP_NOT_AVAILABLE)
        })
        describe('fields', () => {
            describe('number', () => {
                test('should trim spaces and throw an invalid value error', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({
                        canManageMeters: true,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                    await catchErrorFrom(async () => {
                        await createTestMeter(client, client.organization, client.property, resource, {
                            number: '     ',
                        })
                    }, ({ errors }) => {
                        expect(errors).toHaveLength(1)
                        expect(errors[0]).toEqual(expect.objectContaining({
                            message: METER_ERRORS.NUMBER_HAVE_INVALID_VALUE.message,
                        }))
                    })
                })

                test('should trim spaces and save meter', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({
                        canManageMeters: true,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter, attrs] = await createTestMeter(client, client.organization, client.property, resource, {
                        number: `   ${faker.random.alphaNumeric(5)}    `,
                    })

                    expect(meter.number).toEqual(String(attrs.number).trim())

                    const [updatedMeter, updatedAttrs] = await updateTestMeter(client, meter.id, {
                        number: `   ${faker.random.alphaNumeric(5)}    `,
                    })

                    expect(updatedMeter.number).toEqual(String(updatedAttrs.number).trim())
                })
            })
            describe('accountNumber', () => {
                test('should trim spaces and throw an invalid value error', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({
                        canManageMeters: true,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })

                    await catchErrorFrom(async () => {
                        await createTestMeter(client, client.organization, client.property, resource, {
                            accountNumber: '     ',
                        })
                    }, ({ errors }) => {
                        expect(errors).toHaveLength(1)
                        expect(errors[0]).toEqual(expect.objectContaining({
                            message: METER_ERRORS.ACCOUNT_NUMBER_HAVE_INVALID_VALUE.message,
                        }))
                    })
                })
                test('should trim spaces and save meter', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({
                        canManageMeters: true,
                    })
                    const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter, attrs] = await createTestMeter(client, client.organization, client.property, resource, {
                        accountNumber: `   ${faker.random.alphaNumeric(5)}    `,
                    })

                    expect(meter.accountNumber).toEqual(String(attrs.accountNumber).trim())

                    const [updatedMeter, updatedAttrs] = await updateTestMeter(client, meter.id, {
                        accountNumber: `   ${faker.random.alphaNumeric(5)}    `,
                    })

                    expect(updatedMeter.accountNumber).toEqual(String(updatedAttrs.accountNumber).trim())
                })
            })
        })

        test('should restrict creation of the meter with same resource, owned by another organization', async () => {
            const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
            const client2 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true, canManageProperties: true })
            const [property] = await createTestProperty(client2, client2.organization, { address: client1.property.address })
            const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
            const [meter] = await createTestMeter(client1, client1.organization, client1.property, resource, {})

            expect(property).toHaveProperty('address', client1.property.address)
            expect(property).toHaveProperty('addressKey', client1.property.addressKey)
            expect(meter).toHaveProperty(['organization', 'id'], client1.organization.id)
            expect(meter).toHaveProperty(['property', 'id'], client1.property.id)
            expect(meter).toHaveProperty(['resource', 'id'], resource.id)

            await expectToThrowGQLError(async () => {
                await createTestMeter(client2, client2.organization, property, resource, {})
            }, METER_ERRORS.METER_RESOURCE_OWNED_BY_ANOTHER_ORGANIZATION)
        })

        test('should restrict update of the meter with same resource, owned by another organization', async () => {
            const client1 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
            const client2 = await makeEmployeeUserClientWithAbilities({ canManageMeters: true, canManageProperties: true })

            const [property] = await createTestProperty(client2, client2.organization, { address: client1.property.address })
            const [coldResource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
            const [hotResource] = await MeterResource.getAll(client2, { id: HOT_WATER_METER_RESOURCE_ID })
            const [meter1] = await createTestMeter(client1, client1.organization, client1.property, coldResource, {})
            const [meter2] = await createTestMeter(client2, client2.organization, property, hotResource, {})

            await expectToThrowGQLError(async () => {
                await updateTestMeter(client1, meter1.id, {
                    resource: { connect: { id: HOT_WATER_METER_RESOURCE_ID } },
                })
            }, METER_ERRORS.METER_RESOURCE_OWNED_BY_ANOTHER_ORGANIZATION)

            await expectToThrowGQLError(async () => {
                await updateTestMeter(client2, meter2.id, {
                    resource: { connect: { id: COLD_WATER_METER_RESOURCE_ID } },
                })
            }, METER_ERRORS.METER_RESOURCE_OWNED_BY_ANOTHER_ORGANIZATION)
        })

        test('should create MeterResourceOwner after new meter creation', async () => {
            const client = await makeEmployeeUserClientWithAbilities({
                canManageMeters: true,
            })
            const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
            const [meter] = await createTestMeter(client, client.organization, client.property, resource, {})

            await waitFor(async () => {
                const meterResourceOwner = await MeterResourceOwner.getOne(client, {
                    address: meter.property.address,
                    organization: { id: client.organization.id },
                    resource: { id: meter.resource.id },
                })

                expect(meterResourceOwner).toHaveProperty(['organization', 'id'], client.organization.id)
                expect(meterResourceOwner).toHaveProperty(['resource', 'id'], meter.resource.id)
                expect(meterResourceOwner).toHaveProperty('address', meter.property.address)
                expect(meterResourceOwner).toHaveProperty(['sender', 'fingerprint'], meter.sender.fingerprint)
            })
        })

        test('should create MeterResourceOwner after meter update', async () => {
            const client = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
            const [meter] = await createTestMeter(client, client.organization, client.property, { id: COLD_WATER_METER_RESOURCE_ID }, {})

            await waitFor(async () => {
                const meterResourceOwner = await MeterResourceOwner.getOne(client, {
                    addressKey: client.property.addressKey,
                    resource: { id: COLD_WATER_METER_RESOURCE_ID },
                })

                expect(meterResourceOwner).toHaveProperty(['organization', 'id'], client.organization.id)
                expect(meterResourceOwner).toHaveProperty(['resource', 'id'], COLD_WATER_METER_RESOURCE_ID)
                expect(meterResourceOwner).toHaveProperty('addressKey', client.property.addressKey)
            })

            const newNumber = faker.random.alphaNumeric(5)
            const [updatedObj] = await updateTestMeter(client, meter.id, {
                number: newNumber,
            })

            expect(updatedObj).toHaveProperty('number', newNumber)
            const tempMeterResourceOwners = await MeterResourceOwner.getAll(client, {
                addressKey: client.property.addressKey,
            })

            expect(tempMeterResourceOwners).toHaveLength(1)
            expect(tempMeterResourceOwners[0]).toHaveProperty('addressKey', client.property.addressKey)
            expect(tempMeterResourceOwners[0]).toHaveProperty(['resource', 'id'], meter.resource.id)

            const [updatedMeter] = await updateTestMeter(client, meter.id, { resource: { connect: { id: HOT_WATER_METER_RESOURCE_ID } } })

            expect(updatedMeter).toHaveProperty(['resource', 'id'], HOT_WATER_METER_RESOURCE_ID)
            await waitFor(async () => {
                const meterResourceOwners = await MeterResourceOwner.getAll(client, {
                    addressKey: client.property.addressKey,
                })

                expect(meterResourceOwners).toHaveLength(2)
                expect(meterResourceOwners).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        organization: { id: client.organization.id },
                        resource: { id: COLD_WATER_METER_RESOURCE_ID },
                        addressKey: client.property.addressKey,
                    }),
                    expect.objectContaining({
                        organization: { id: client.organization.id },
                        resource: { id: HOT_WATER_METER_RESOURCE_ID },
                        addressKey: client.property.addressKey,
                    }),
                ]))
            })

        })

        test('should allow to softDelete Meter after loose resource ownership', async () => {
            const client = await makeEmployeeUserClientWithAbilities({ canManageMeters: true })
            const [resource] = await MeterResource.getAll(client, { id: COLD_WATER_METER_RESOURCE_ID })
            const [meter] = await createTestMeter(client, client.organization, client.property, resource)

            let meterResourceOwner

            await waitFor(async () => {
                meterResourceOwner = await MeterResourceOwner.getOne(client, {
                    address: meter.property.address,
                    organization: { id: client.organization.id },
                    resource: { id: meter.resource.id },
                })

                expect(meterResourceOwner).toHaveProperty(['organization', 'id'], client.organization.id)
                expect(meterResourceOwner).toHaveProperty(['resource', 'id'], meter.resource.id)
                expect(meterResourceOwner).toHaveProperty('address', meter.property.address)
                expect(meterResourceOwner).toHaveProperty(['sender', 'fingerprint'], meter.sender.fingerprint)
            })

            const [organization] = await createTestOrganization(admin)

            const [newMeterResourceOwner] = await updateTestMeterResourceOwner(admin, meterResourceOwner.id, {
                organization: { connect: { id: organization.id } },
            })

            expect(newMeterResourceOwner).toHaveProperty(['organization', 'id'], organization.id)
            expect(newMeterResourceOwner).toHaveProperty(['addressKey'], client.property.addressKey)
            expect(newMeterResourceOwner).toHaveProperty(['resource', 'id'], COLD_WATER_METER_RESOURCE_ID)

            const [updatedMeter] = await Meter.softDelete(client, meter.id, {})

            expect(updatedMeter.deletedAt).not.toBeNull()
        })
    })
})
