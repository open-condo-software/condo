/**
 * Generated by `createschema meter.MeterReadingExportTask 'status:Select:processing,completed,error; format:Select:excel; exportedRecordsCount:Integer; totalRecordsCount:Integer; file?:File; meta?:Json; where:Json; sortBy:Json; locale:Text; timeZone:Text; user:Relationship:User:CASCADE;'`
 */

const dayjs = require('dayjs')
const get = require('lodash/get')

const conf = require('@open-condo/config')
const { canOnlyServerSideWithoutUserRequest } = require('@open-condo/keystone/access')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const FileAdapter = require('@open-condo/keystone/fileAdapter/fileAdapter')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')

const { WRONG_VALUE } = require('@condo/domains/common/constants/errors')
const { COMPLETED, ERROR, EXPORT_STATUS_VALUES, PROCESSING, EXCEL } = require('@condo/domains/common/constants/export')
const { findAllByKey } = require('@condo/domains/common/utils/ecmascript.utils')
const { normalizeTimeZone } = require('@condo/domains/common/utils/timezone')
const access = require('@condo/domains/meter/access/MeterReadingExportTask')
const { EXPORT_METER_READINGS_MONTHS_LIMIT } = require('@condo/domains/meter/constants/constants')
const { exportMeterReadings } = require('@condo/domains/meter/tasks/exportMeterReadings')
const { DEFAULT_ORGANIZATION_TIMEZONE } = require('@condo/domains/organization/constants/common')
const { LOCALES } = require('@condo/domains/user/constants/common')


const { getFileMetaAfterChange } = FileAdapter

const ERRORS = {
    STATUS_IS_ALREADY_COMPLETED: {
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: 'Status is already completed',
        messageForUser: 'api.meterReadingExportTask.STATUS_IS_ALREADY_COMPLETED',
        mutation: 'updateMeterReadingExportTask',
        variable: ['data', 'status'],
    },
    STATUS_IS_ALREADY_ERROR: {
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        message: 'Status is already error',
        messageForUser: 'api.meterReadingExportTask.STATUS_IS_ALREADY_ERROR',
        mutation: 'updateMeterReadingExportTask',
        variable: ['data', 'status'],
    },
}

const METER_READING_EXPORT_TASK_FOLDER_NAME = 'MeterReadingExportTask'
const MeterReadingExportTaskFileAdapter = new FileAdapter(METER_READING_EXPORT_TASK_FOLDER_NAME)
const setFileMetaAfterChange = getFileMetaAfterChange(MeterReadingExportTaskFileAdapter, 'file')


const MeterReadingExportTask = new GQLListSchema('MeterReadingExportTask', {
    schemaDoc: 'Stores requested export format, status of export job, link to exported file and information about progress of export job',
    fields: {
        status: {
            schemaDoc: 'Status of the job. Used at client side progress information component',
            type: 'Select',
            options: EXPORT_STATUS_VALUES,
            defaultValue: PROCESSING,
            isRequired: true,
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: true,
                update: true,
            },
        },

        format: {
            schemaDoc: 'Requested export file format',
            type: 'Select',
            options: [EXCEL],
            isRequired: true,
            access: {
                create: true,
                read: true,
                update: false,
            },
        },

        exportedRecordsCount: {
            schemaDoc: 'How many records at the moment are exported',
            type: 'Integer',
            isRequired: true,
            defaultValue: 0,
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: true,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        totalRecordsCount: {
            schemaDoc: 'Total records to export that will be determined at server side in export operation',
            type: 'Integer',
            isRequired: true,
            defaultValue: 0,
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: true,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        file: {
            schemaDoc: 'Meta information about file, saved outside of database somewhere. Shape of meta information JSON object is specific to file adapter, used by saving a file.',
            type: 'File',
            adapter: MeterReadingExportTaskFileAdapter,
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: true,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        meta: {
            schemaDoc: 'Stores information about query and ids of exported and failed records',
            type: 'Json',
            access: {
                create: canOnlyServerSideWithoutUserRequest,
                read: true,
                update: canOnlyServerSideWithoutUserRequest,
            },
        },

        where: {
            schemaDoc: 'Filtering conditions for records to export',
            type: 'Json',
            graphQLInputType: 'MeterReadingWhereInput',
            isRequired: true,
            access: {
                read: true,
                create: true,
                update: false,
            },
            hooks: {
                resolveInput: ({ resolvedData, fieldPath, operation }) => {
                    if (operation !== 'create') return resolvedData[fieldPath]

                    const baseWhere = resolvedData[fieldPath]

                    const now = dayjs()
                    const dateFrom = now.subtract(EXPORT_METER_READINGS_MONTHS_LIMIT, 'months')

                    const dateLte = get(findAllByKey(baseWhere, 'date_lte'), '0', now.toISOString())
                    let dateGte = get(findAllByKey(baseWhere, 'date_gte'), '0', dateFrom.toISOString())

                    if (dayjs(dateLte).diff(dayjs(dateGte), 'months') > EXPORT_METER_READINGS_MONTHS_LIMIT) {
                        dateGte = dayjs(dateLte).subtract(EXPORT_METER_READINGS_MONTHS_LIMIT, 'months')
                    }

                    return { ...baseWhere, date_gte: dateGte, date_lte: dateLte }
                },
            },
        },
        
        sortBy: {
            schemaDoc: 'Sorting parameters for records to export',
            type: 'Json',
            graphQLInputType: '[SortMeterReadingsBy]',
            graphQLReturnType: '[SortMeterReadingsBy]',
            isRequired: true,
            access: {
                read: true,
                create: true,
                update: false,
            },
        },

        locale: {
            schemaDoc: 'Requested export locale, in that the resulting file will be rendered',
            type: 'Select',
            options: LOCALES,
            isRequired: true,
            hooks: {
                resolveInput: async ({ context, resolvedData, fieldPath }) => {
                    if (resolvedData[fieldPath]) {
                        return resolvedData[fieldPath]
                    }

                    return extractReqLocale(context.req) || conf.DEFAULT_LOCALE
                },
            },
            access: {
                read: true,
                create: true,
                update: false,
            },
        },

        timeZone: {
            schemaDoc: 'To requested timeZone all datetime fields will be converted',
            type: 'Text',
            isRequired: true,
            hooks: {
                resolveInput: async ({ resolvedData }) => {
                    const { timeZone } = resolvedData
                    return normalizeTimeZone(timeZone) || DEFAULT_ORGANIZATION_TIMEZONE
                },
            },
            access: {
                read: true,
                create: true,
                update: false,
            },
        },

        user: {
            schemaDoc: 'User that requested this exporting operation. Will be used for read access checks to display all exported tasks somewhere and to display progress indicator of ongoing exporting task for current user',
            type: 'Relationship',
            ref: 'User',
            isRequired: true,
            knexOptions: { isNotNullable: true },
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
            access: {
                read: true,
                create: true,
                update: false,
            },
        },

    },
    hooks: {
        validateInput: async ({ resolvedData, existingItem, context }) => {
            if (existingItem) {
                if (resolvedData['status'] && existingItem['status'] === COMPLETED) {
                    throw new GQLError(ERRORS.STATUS_IS_ALREADY_COMPLETED, context)
                }
                if (resolvedData['status'] && existingItem['status'] === ERROR) {
                    throw new GQLError(ERRORS.STATUS_IS_ALREADY_ERROR, context)
                }
            }
        },
        afterChange: async (args) => {
            const { updatedItem, operation } = args

            await setFileMetaAfterChange(args)

            if (operation === 'create') {
                await exportMeterReadings.delay(updatedItem.id)
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadMeterReadingExportTasks,
        create: access.canManageMeterReadingExportTasks,
        update: access.canManageMeterReadingExportTasks,
        delete: false,
        auth: true,
    },
})

module.exports = {
    MeterReadingExportTask,
    ERRORS,
}
