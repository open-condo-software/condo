/**
 * Generated by `createschema meter.MeterReading 'organization:Relationship:Organization:CASCADE; property:Relationship:Property:CASCADE; account?:Relationship:BillingAccount:SET_NULL; billingAccountMeter?:Relationship:BillingAccountMeter:SET_NULL; date:DateTimeUtc; meter:Relationship:Meter:CASCADE; value:Integer; source:Relationship:MeterReadingSource:PROTECT'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const conf = require('@open-condo/config')
const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, waitFor, expectToThrowGQLError,
    expectToThrowGraphQLRequestError,
} = require('@open-condo/keystone/test.utils')
const {
    catchErrorFrom,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')
const { i18n } = require('@open-condo/locales/loader')

const {
    createTestBillingProperty,
    createTestBillingAccount,
    makeContextWithOrganizationAndIntegrationAsAdmin,
} = require('@condo/domains/billing/utils/testSchema')
const { Contact, createTestContact } = require('@condo/domains/contact/utils/testSchema')
const {
    CALL_METER_READING_SOURCE_ID,
    COLD_WATER_METER_RESOURCE_ID,
    MOBILE_APP_SOURCE_ID,
    METER_READING_SOURCE_INTERNAL_IMPORT_TYPE,
    METER_READING_SOURCE_EXTERNAL_IMPORT_TYPE,
    HOT_WATER_METER_RESOURCE_ID,
} = require('@condo/domains/meter/constants/constants')
const {
    MeterResource,
    MeterReadingSource,
    MeterReading,
    createTestMeter,
    createTestMeterReading,
    updateTestMeterReading,
    createTestMeterReadingSource,
    updateTestMeter,
    MeterResourceOwner,
    updateTestMeterResourceOwner,
    createTestMeterReportingPeriod, updateTestMeterReportingPeriod,
} = require('@condo/domains/meter/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
} = require('@condo/domains/miniapp/utils/testSchema')
const { createTestB2BAppAccessRightSet, createTestB2BAppAccessRight } = require('@condo/domains/miniapp/utils/testSchema')
const {
    createTestOrganization,
    updateTestOrganizationEmployee,
    createTestOrganizationEmployeeRole,
    createTestOrganizationWithAccessToAnotherOrganization,
    makeEmployeeUserClientWithAbilities,
    updateTestOrganization,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE, PARKING_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const {
    createTestProperty,
    makeClientWithProperty,
    Property,
    makeClientWithResidentAccessAndProperty,
} = require('@condo/domains/property/utils/testSchema')
const {
    createTestResident,
    createTestServiceConsumer,
    updateTestServiceConsumer,
} = require('@condo/domains/resident/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithResidentUser, makeClientWithServiceUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')


describe('MeterReading', () => {
    let admin
    let employeeCanManageReadings
    let employeeCanNotManageReadings
    let residentClient
    let supportClient

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        residentClient = await makeClientWithResidentUser()
        employeeCanManageReadings = await makeEmployeeUserClientWithAbilities({ canManageMeterReadings: true })
        employeeCanNotManageReadings = await makeEmployeeUserClientWithAbilities({ canManageMeterReadings: false })
        supportClient = await makeClientWithSupportUser()
    })

    describe('CRUD', () => {
        describe('Create', () => {
            describe('Admin', () => {
                test('can create MeterReadings', async () => {
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {})

                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    expect(meterReading.id).toMatch(UUID_RE)
                })
            })

            describe('Support', () => {
                test('cannot create MeterReadings', async () => {
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {})

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(supportClient, meter, source)
                    })
                })
            })

            describe('Employee', () => {
                test('employee with "canManageMeterReadings" role: can create MeterReadings', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, {
                        id: COLD_WATER_METER_RESOURCE_ID,
                    })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, {
                        id: CALL_METER_READING_SOURCE_ID,
                    })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                        {}
                    )

                    const [meterReading] = await createTestMeterReading(employeeCanManageReadings, meter, source)

                    expect(meterReading.id).toMatch(UUID_RE)
                    expect(meterReading.organization.id).toMatch(employeeCanManageReadings.organization.id)
                })

                test('employee with "canManageMeterReadings" role: can create MeterReadings with float number value', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                        { numberOfTariffs: 2 }
                    )

                    const numberValue1 = String(faker.datatype.float())
                    const numberValue2 = String(faker.datatype.float())

                    const [meterReading] = await createTestMeterReading(employeeCanManageReadings, meter, source, {
                        value1: numberValue1,
                        value2: numberValue2,
                    })

                    expect(meterReading.id).toMatch(UUID_RE)
                })

                test('employee with "canManageMeterReadings" role: cannot create MeterReadings with string value', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                        { numberOfTariffs: 2 }
                    )

                    const stringValue = faker.random.alphaNumeric(8)

                    await catchErrorFrom(async () => {
                        await createTestMeterReading(employeeCanManageReadings, meter, source, {
                            value1: stringValue,
                            value2: faker.random.alphaNumeric(7),
                        })
                    }, ({ errors, data }) => {
                        expect(errors[0].message).toContain(`invalid input syntax for type numeric: "${stringValue}"`)
                        expect(data).toEqual({ 'obj': null })
                    })
                })

                test('employee with "canManageMeterReadings" role: cannot create MeterReadings with wrong "sender" field', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                        {}
                    )

                    await catchErrorFrom(async () => {
                        await createTestMeterReading(employeeCanManageReadings, meter, source, {
                            sender: null,
                        })
                    }, ({ errors, data }) => {
                        expect(errors[0].message).toMatch('You attempted to perform an invalid mutation')
                        expect(errors[0].data.messages[0]).toContain('Required field "sender" is null or undefined.')
                        expect(data).toEqual({ 'obj': null })
                    })
                })

                test('employee without "canManageMeters" role: cannot create MeterReadings', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanNotManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanNotManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        admin,
                        employeeCanNotManageReadings.organization,
                        employeeCanNotManageReadings.property,
                        resource,
                        {}
                    )

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(employeeCanNotManageReadings, meter, source)
                    })
                })

                test('employee from "from" related organization with "canManageMeterReadings" role: can create MeterReadings', async () => {
                    const { clientFrom, employeeFrom, organizationFrom, organizationTo, propertyTo } = await createTestOrganizationWithAccessToAnotherOrganization()
                    const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                        canManageMeterReadings: true,
                    })
                    await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                        role: { connect: { id: role.id } },
                    })
                    const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(clientFrom, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(clientFrom, organizationTo, propertyTo, resource, {})

                    const [meterReading] = await createTestMeterReading(clientFrom, meter, source)

                    expect(meterReading.id).toMatch(UUID_RE)
                })

                test('employee from "from" related organization without "canManageMeterReadings" role: cannot create MeterReadings', async () => {
                    const { clientFrom, employeeFrom, organizationFrom, organizationTo, propertyTo } = await createTestOrganizationWithAccessToAnotherOrganization()
                    const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(admin, organizationTo, propertyTo, resource, {})

                    const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                        canManageMeterReadings: false,
                    })
                    await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                        role: { connect: { id: role.id } },
                    })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(clientFrom, meter, source)
                    })
                })
            })

            describe('Resident', () => {
                test('can create MeterReadings in his unit', async () => {
                    const userClient = await makeClientWithResidentAccessAndProperty()
                    const unitName = faker.random.alphaNumeric(8)
                    const accountNumber = faker.random.alphaNumeric(8)
                    const [resident] = await createTestResident(admin, userClient.user, userClient.property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident, userClient.organization,  {
                        accountNumber,
                    })
                    const [resource] = await MeterResource.getAll(userClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, userClient.organization, userClient.property, resource, {
                        unitName,
                        accountNumber,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(userClient, meter, source)

                    expect(meterReading.id).toMatch(UUID_RE)
                })

                test('can create MeterReadings based on resource ownership', async () => {
                    const userClient = await makeClientWithResidentAccessAndProperty()
                    const unitName = faker.random.alphaNumeric(8)
                    const accountNumber = faker.random.alphaNumeric(8)
                    const [resident] = await createTestResident(admin, userClient.user, userClient.property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident, userClient.organization, {
                        accountNumber,
                    })
                    const [resource] = await MeterResource.getAll(userClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, userClient.organization, userClient.property, resource, {
                        unitName, accountNumber,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(userClient, meter, source)

                    expect(meterReading.id).toMatch(UUID_RE)
                    const resourceOwner = await MeterResourceOwner.getOne(admin, {
                        addressKey: userClient.property.addressKey, organization: { id: userClient.organization.id }, resource: { id: resource.id } }
                    )

                    expect(resourceOwner).toBeDefined()

                    const { organization: newOrganization } = await makeContextWithOrganizationAndIntegrationAsAdmin()

                    const [property] = await createTestProperty(admin, newOrganization, {
                        address: resourceOwner.address,
                    })

                    expect(property.addressKey).toEqual(resourceOwner.addressKey)
                    await updateTestMeterResourceOwner(admin, resourceOwner.id, {
                        organization: { connect: { id: newOrganization.id } },
                    })
                    await createTestServiceConsumer(admin, resident, newOrganization, {
                        accountNumber,
                    })

                    const [newMeter] = await createTestMeter(admin, newOrganization, property, resource, {
                        unitName, accountNumber,
                    })

                    const [newMeterReading] = await createTestMeterReading(userClient, newMeter, source)

                    expect(newMeterReading).toBeDefined()

                })

                test('client info saved in new reading', async () => {
                    const userClient = await makeClientWithResidentAccessAndProperty()
                    const unitName = faker.random.alphaNumeric(8)
                    const accountNumber = faker.random.alphaNumeric(8)
                    const [resident] = await createTestResident(admin, userClient.user, userClient.property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident, userClient.organization,  {
                        accountNumber,
                    })
                    const [resource] = await MeterResource.getAll(userClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, userClient.organization, userClient.property, resource, {
                        unitName,
                        accountNumber,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(userClient, meter, source)

                    const user = userClient.user
                    const { name, email, phone } = userClient.userAttrs

                    expect(meterReading.client.id).toEqual(user.id)
                    expect(meterReading.clientName).toEqual(name)
                    expect(meterReading.clientPhone).toEqual(phone)
                    expect(meterReading.clientEmail).toEqual(email)
                })

                test('cannot create MetersReadings to Meter with accountNumber, which present in deleted serviceConsumer', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    const accountNumber1 = faker.random.alphaNumeric(8)

                    const [serviceConsumer] = await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber: accountNumber1,
                    })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    await updateTestServiceConsumer(residentClient, serviceConsumer.id, { deletedAt: 'true' })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(residentClient, meter, source)
                    })
                })

                test('cannot create MetersReadings to deleted Meter', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    const accountNumber1 = faker.random.alphaNumeric(8)

                    await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber: accountNumber1,
                    })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })
                    await updateTestMeter(admin, meter.id, { deletedAt: 'true' })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(residentClient, meter, source)
                    })
                })

                test('cannot create MetersReadings to Meter from deleted organization', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    const accountNumber1 = faker.random.alphaNumeric(8)

                    await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber: accountNumber1,
                    })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })
                    await updateTestOrganization(admin, organization.id, { deletedAt: 'true' })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(residentClient, meter, source)
                    })
                })

                test('cannot create MetersReadings to Meter from deleted property', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    const accountNumber1 = faker.random.alphaNumeric(8)

                    await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber: accountNumber1,
                    })

                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })

                    await Property.softDelete(admin, property.id)

                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                    // test access before resident reconnection worker task executes
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(residentClient, meter, source)
                    })

                    // test access after residents reconnection worker task done
                    await waitFor(async () => {
                        await expectToThrowAccessDeniedErrorToObj(async () => {
                            await createTestMeterReading(residentClient, meter, source)
                        })
                    })
                })

                test('cannot create MeterReadings in other organization', async () => {
                    const client1 = await makeClientWithResidentUser()
                    const client2 = await makeClientWithResidentUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const { context: context1, organization: organization1 } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property1] = await createTestProperty(admin, organization1)
                    const [billingProperty1] = await createTestBillingProperty(admin, context1)
                    const [billingAccount1] = await createTestBillingAccount(admin, context1, billingProperty1)
                    const [resident1] = await createTestResident(admin, client1.user, property1, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident1, organization1, {
                        accountNumber: billingAccount1.number,
                    })

                    const { context: context2, organization: organization2 } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property2] = await createTestProperty(admin, organization2)
                    const [billingProperty2] = await createTestBillingProperty(admin, context2)
                    const [billingAccount2] = await createTestBillingAccount(admin, context2, billingProperty2)
                    const [resident2] = await createTestResident(admin, client2.user, property2, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident2, organization2, {
                        accountNumber: billingAccount2.number,
                    })

                    const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization2, property2, resource, {
                        accountNumber: billingAccount2.number,
                        unitName,
                    })

                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(client1, meter, source)
                    })
                })

                test('cannot create MeterReadings in other property in same organization', async () => {
                    const client1 = await makeClientWithResidentUser()
                    const client2 = await makeClientWithResidentUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property1] = await createTestProperty(admin, organization)
                    const [billingProperty1] = await createTestBillingProperty(admin, context)
                    const [billingAccount1] = await createTestBillingAccount(admin, context, billingProperty1)
                    const [resident1] = await createTestResident(admin, client1.user, property1, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident1, organization, {
                        accountNumber: billingAccount1.number,
                    })

                    const [property2] = await createTestProperty(admin, organization)
                    const [billingProperty2] = await createTestBillingProperty(admin, context)
                    const [billingAccount2] = await createTestBillingAccount(admin, context, billingProperty2)
                    const [resident2] = await createTestResident(admin, client2.user, property2, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident2, organization, {
                        accountNumber: billingAccount2.number,
                    })

                    const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property2, resource, {
                        accountNumber: billingAccount2.number,
                        unitName,
                    })

                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(client1, meter, source)
                    })
                })

                test('cannot create MeterReadings in other unit in same property', async () => {
                    const unitName1 = faker.random.alphaNumeric(8)
                    const unitName2 = faker.random.alphaNumeric(8)

                    const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property] = await createTestProperty(admin, organization)
                    const [billingProperty] = await createTestBillingProperty(admin, context)
                    const [billingAccount1] = await createTestBillingAccount(admin, context, billingProperty)
                    const [resident1] = await createTestResident(admin, residentClient.user, property, {
                        unitName: unitName1,
                    })
                    await createTestServiceConsumer(admin, resident1, organization, {
                        accountNumber: billingAccount1.number,
                    })

                    const [billingAccount2] = await createTestBillingAccount(admin, context, billingProperty)
                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: billingAccount2.number,
                        unitName: unitName2,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(residentClient, meter, source)
                    })
                })

                test('cannot create MeterReadings in Meter which account number doesnt present in serviceConsumers', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const accountNumber1 = faker.random.alphaNumeric(8)
                    const accountNumber2 = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)

                    const [resident1] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident1, organization, {
                        accountNumber: accountNumber1,
                    })

                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })
                    const [meter2] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber2,
                        unitName,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(residentClient, meter2, source)
                    })
                })

                test('cannot create MeterReadings in Meter which is automatic', async () => {
                    const userClient = await makeClientWithResidentAccessAndProperty()
                    const unitName = faker.random.alphaNumeric(8)
                    const accountNumber = faker.random.alphaNumeric(8)
                    const [resident] = await createTestResident(admin, userClient.user, userClient.property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident, userClient.organization,  {
                        accountNumber,
                    })
                    const [resource] = await MeterResource.getAll(userClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [b2bApp] = await createTestB2BApp(admin)
                    await createTestB2BAppContext(admin, b2bApp, userClient.organization)
                    const [meter] = await createTestMeter(admin, userClient.organization, userClient.property, resource, {
                        unitName,
                        accountNumber,
                        isAutomatic: true,
                        b2bApp: { connect: { id: b2bApp.id } },
                    })
                    const [source] = await createTestMeterReadingSource(admin, {
                        type: METER_READING_SOURCE_INTERNAL_IMPORT_TYPE,
                        name: faker.name.suffix(),
                    })

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(userClient, meter, source)
                    })
                })
            })

            describe('User', () => {
                test('cannot create MeterReadings', async () => {
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {})

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestMeterReading(client, meter, source)
                    })
                })
            })

            describe('Anonymous', () => {
                test('cannot create MeterReadings', async () => {
                    const client = await makeClient()
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {})

                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await createTestMeterReading(client, meter, source)
                    })
                })
            })

            test('Set billingStatusText to null if billingStatus=`approved`', async () => {
                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organization, property, resource, {})

                const [meterReading] = await createTestMeterReading(admin, meter, source, {
                    billingStatus: 'approved',
                    billingStatusText: faker.lorem.sentence(5),
                })

                expect(meterReading.billingStatus).toBe('approved')
                expect(meterReading.billingStatusText).toBeNull()
            })
        })
        describe('Update', () => {
            describe('Admin', () => {
                test('can update MeterReadings', async () => {
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {})
                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const oldValue = Number(meterReading.value1)
                    const newValue = String(oldValue + 100.1234)
                    const [updatedMeterReading] = await updateTestMeterReading(admin, meterReading.id, {
                        value1: newValue,
                    })

                    expect(updatedMeterReading.id).toMatch(UUID_RE)
                    expect(updatedMeterReading.value1).toEqual(newValue)
                })
            })

            describe('Employee', () => {
                test('employee with "canManageMeterReadings" role: can update MeterReadings', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(employeeCanManageReadings, employeeCanManageReadings.organization, employeeCanManageReadings.property, resource, {})
                    const [meterReading] = await createTestMeterReading(employeeCanManageReadings, meter, source)

                    const oldValue = meterReading.value1
                    const newValue = String(Number(oldValue) + 100.1234)

                    const [updatedMeterReading] = await updateTestMeterReading(employeeCanManageReadings, meterReading.id, {
                        value1: newValue,
                    })
                    expect(updatedMeterReading.id).toMatch(UUID_RE)
                    expect(updatedMeterReading.value1).toEqual(newValue)
                })

                test('employee without "canManageMeterReadings" role: cannot update MeterReadings', async () => {

                    const [resource] = await MeterResource.getAll(employeeCanNotManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanNotManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(admin, employeeCanNotManageReadings.organization, employeeCanNotManageReadings.property, resource, {})
                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const oldValue = meterReading.value1
                    const newValue = oldValue + 100

                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestMeterReading(employeeCanNotManageReadings, meterReading.id, {
                            value1: newValue,
                        })
                    })
                })

                test('employee from "from" related organization: can update MeterReadings', async () => {
                    const { clientFrom, employeeFrom, organizationFrom, organizationTo, propertyTo } = await createTestOrganizationWithAccessToAnotherOrganization()
                    const [role] = await createTestOrganizationEmployeeRole(admin, organizationFrom, {
                        canManageMeterReadings: true,
                    })
                    await updateTestOrganizationEmployee(admin, employeeFrom.id, {
                        role: { connect: { id: role.id } },
                    })
                    const [resource] = await MeterResource.getAll(clientFrom, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(clientFrom, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(clientFrom, organizationTo, propertyTo, resource, {})

                    const [meterReading] = await createTestMeterReading(clientFrom, meter, source)

                    const oldValue = meterReading.value1
                    const newValue = String(Number(oldValue) + 100.1234)

                    const [updatedMeterReading] = await updateTestMeterReading(clientFrom, meterReading.id, {
                        value1: newValue,
                    })
                    expect(updatedMeterReading.id).toMatch(UUID_RE)
                    expect(updatedMeterReading.value1).toEqual(newValue)
                })
            })

            describe('Resident', () => {
                test('cannot update MeterReadings', async () => {
                    const unitName = faker.random.alphaNumeric(8)

                    const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property] = await createTestProperty(admin, organization)
                    const [billingProperty] = await createTestBillingProperty(admin, context)
                    const [billingAccount] = await createTestBillingAccount(admin, context, billingProperty)
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber: billingAccount.number,
                    })

                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        unitName,
                        accountNumber: billingAccount.number,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(residentClient, meter, source)

                    const oldValue = meterReading.value1
                    const newValue = oldValue + 100
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await updateTestMeterReading(residentClient, meterReading.id, {
                            value1: newValue,
                        })
                    })
                })
            })

            describe('User', () => {
                test('can update MeterReadings', async () => {
                    const client = await makeClientWithProperty()
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(admin, client.organization, client.property, resource, {})
                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const oldValue = meterReading.value1
                    const newValue = String(Number(oldValue) + 100.1234)

                    const [updatedMeterReading] = await updateTestMeterReading(client, meterReading.id, {
                        value1: newValue,
                    })
                    expect(updatedMeterReading.id).toMatch(UUID_RE)
                    expect(updatedMeterReading.value1).toEqual(newValue)
                })
            })

            describe('Anonymous', () => {
                test('cannot update MeterReadings', async () => {
                    const client = await makeClient()
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {})
                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const oldValue = meterReading.value1
                    const newValue = oldValue + 100
                    await expectToThrowAuthenticationErrorToObj(async () => {
                        await updateTestMeterReading(client, meterReading.id, {
                            value1: newValue,
                        })
                    })
                })
            })

            test('update organization field when connect other meter', async () => {
                const [organization] = await createTestOrganization(admin)
                const [organization1] = await createTestOrganization(admin)

                const [property] = await createTestProperty(admin, organization)
                const [property1] = await createTestProperty(admin, organization1)

                const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                const [meter] = await createTestMeter(admin, organization, property, resource, {})
                const [meter1] = await createTestMeter(admin, organization1, property1, resource, {})

                const [meterReading] = await createTestMeterReading(admin, meter, source)

                expect(meterReading.organization.id).toEqual(organization.id)

                const [updatedMeterReading] = await updateTestMeterReading(admin, meterReading.id, {
                    meter: { connect: { id: meter1.id } },
                })

                expect(updatedMeterReading.organization.id).toEqual(organization1.id)
            })

            test('Set billingStatusText to null if billingStatus=`approved`', async () => {
                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organization, property, resource, {})
                const [meterReading] = await createTestMeterReading(admin, meter, source)

                const [updatedMeterReading] = await updateTestMeterReading(admin, meterReading.id, {
                    billingStatus: 'approved',
                    billingStatusText: faker.lorem.sentence(5),
                })

                expect(updatedMeterReading.billingStatus).toBe('approved')
                expect(updatedMeterReading.billingStatusText).toBeNull()
            })
        })
        describe('Read', () => {
            describe('Employee', () => {
                test('can read MeterReadings', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({})
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(admin, client.organization, client.property, resource, {})

                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const meterReadings = await MeterReading.getAll(client, { id: meterReading.id })
                    expect(meterReadings).toHaveLength(1)
                })

                test('without "canReadMeters": can not read MeterReadings', async () => {
                    const client = await makeEmployeeUserClientWithAbilities({ canReadMeters: false })
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(admin, client.organization, client.property, resource, {})

                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const readMeterReading = await MeterReading.getOne(client, { id: meterReading.id })
                    expect(readMeterReading).toBeUndefined()
                })

                test('employee from "from" related organization: can read MeterReadings', async () => {
                    const { clientFrom, organizationTo, propertyTo } = await createTestOrganizationWithAccessToAnotherOrganization()
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(admin, organizationTo, propertyTo, resource, {})

                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const meterReadings = await MeterReading.getAll(clientFrom, { id: meterReading.id })
                    expect(meterReadings).toHaveLength(1)
                })

                test('employee from "to" related organization: cannot read MeterReadings from "from" organization', async () => {
                    const { clientTo, organizationFrom, propertyFrom } = await createTestOrganizationWithAccessToAnotherOrganization()
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(admin, organizationFrom, propertyFrom, resource, {})

                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const meterReadings = await MeterReading.getAll(clientTo, { id: meterReading.id })
                    expect(meterReadings).toHaveLength(0)
                })
            })

            describe('Resident', () => {
                test('can read his own MeterReadings', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const accountNumber = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)

                    const [property] = await createTestProperty(admin, organization)
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber,
                    })

                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        unitName,
                        accountNumber,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(residentClient, meter, source)

                    const meterReadings = await MeterReading.getAll(residentClient, {
                        id: meterReading.id,
                        meter: { id: meter.id },
                    })

                    expect(meterReadings).toHaveLength(1)
                })

                test('can read meter reading from automatic meter', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const accountNumber = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)

                    const [property] = await createTestProperty(admin, organization)
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber,
                    })

                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [app] = await createTestB2BApp(admin)
                    await createTestB2BAppContext(admin, app, organization)
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        unitName,
                        accountNumber,
                        isAutomatic: true,
                        b2bApp: { connect: { id: app.id } },
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const meterReadings = await MeterReading.getAll(residentClient, {
                        id: meterReading.id,
                        meter: { id: meter.id },
                    })

                    expect(meterReadings).toHaveLength(1)
                })

                test('cannot read MeterReadings in other organization', async () => {
                    const client1 = await makeClientWithResidentUser()
                    const client2 = await makeClientWithResidentUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const { context: context1, organization: organization1 } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property1] = await createTestProperty(admin, organization1)
                    const [billingProperty1] = await createTestBillingProperty(admin, context1)
                    const [billingAccount1] = await createTestBillingAccount(admin, context1, billingProperty1)
                    const [resident1] = await createTestResident(admin, client1.user, property1, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident1, organization1, {
                        accountNumber: billingAccount1.number,
                    })

                    const { context: context2, organization: organization2 } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property2] = await createTestProperty(admin, organization2)
                    const [billingProperty2] = await createTestBillingProperty(admin, context2)
                    const [billingAccount2] = await createTestBillingAccount(admin, context2, billingProperty2)
                    const [resident2] = await createTestResident(admin, client2.user, property2, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident2, organization2, {
                        accountNumber: billingAccount2.number,
                    })

                    const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization2, property2, resource, {
                        accountNumber: billingAccount2.number,
                        unitName,
                    })

                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(client2, meter, source)

                    const meterReadings = await MeterReading.getAll(client1, {
                        id: meterReading.id,
                    })
                    expect(meterReadings).toHaveLength(0)
                })

                test('cannot read MeterReadings in other property in same organization', async () => {
                    const client1 = await makeClientWithResidentUser()
                    const client2 = await makeClientWithResidentUser()
                    const unitName = faker.random.alphaNumeric(8)

                    const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property1] = await createTestProperty(admin, organization)
                    const [billingProperty1] = await createTestBillingProperty(admin, context)
                    const [billingAccount1] = await createTestBillingAccount(admin, context, billingProperty1)
                    const [resident1] = await createTestResident(admin, client1.user, property1, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident1, organization, {
                        accountNumber: billingAccount1.number,
                    })

                    const [property2] = await createTestProperty(admin, organization)
                    const [billingProperty2] = await createTestBillingProperty(admin, context)
                    const [billingAccount2] = await createTestBillingAccount(admin, context, billingProperty2)
                    const [resident2] = await createTestResident(admin, client2.user, property2, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident2, organization, {
                        accountNumber: billingAccount2.number,
                    })

                    const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property2, resource, {
                        accountNumber: billingAccount2.number,
                        unitName,
                    })

                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(client2, meter, source)

                    const meterReadings = await MeterReading.getAll(client1, {
                        id: meterReading.id,
                    })
                    expect(meterReadings).toHaveLength(0)
                })

                test('cannot read MeterReadings in other unit in same property', async () => {
                    const client1 = await makeClientWithResidentUser()
                    const client2 = await makeClientWithResidentUser()
                    const unitName1 = faker.random.alphaNumeric(8)
                    const unitName2 = faker.random.alphaNumeric(8)

                    const { context, organization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property] = await createTestProperty(admin, organization)
                    const [billingProperty] = await createTestBillingProperty(admin, context)
                    const [billingAccount1] = await createTestBillingAccount(admin, context, billingProperty)
                    const [resident1] = await createTestResident(admin, client1.user, property, {
                        unitName: unitName1,
                    })
                    await createTestServiceConsumer(admin, resident1, organization, {
                        accountNumber: billingAccount1.number,
                    })

                    const [billingAccount2] = await createTestBillingAccount(admin, context, billingProperty)
                    const [resident2] = await createTestResident(admin, client2.user, property, {
                        unitName: unitName2,
                    })
                    await createTestServiceConsumer(admin, resident2, organization, {
                        accountNumber: billingAccount2.number,
                    })

                    const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: billingAccount2.number,
                        unitName: unitName2,
                    })

                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(client2, meter, source)

                    const meterReadings = await MeterReading.getAll(client1, {
                        id: meterReading.id,
                    })

                    expect(meterReadings).toHaveLength(0)
                })

                test('cannot read MeterReadings from Meter which accountNumber doesnt present in resident serviceConsumers', async () => {
                    const client1 = await makeClientWithResidentUser()
                    const client2 = await makeClientWithResidentUser()
                    const unitName = faker.random.alphaNumeric(8)
                    const accountNumber1 = faker.random.alphaNumeric(8)
                    const accountNumber2 = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)

                    const [resident1] = await createTestResident(admin, client1.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident1, organization, {
                        accountNumber: accountNumber1,
                    })
                    const [resident2] = await createTestResident(admin, client2.user, property, {
                        unitName,
                    })
                    await createTestServiceConsumer(admin, resident2, organization, {
                        accountNumber: accountNumber2,
                    })

                    const [resource] = await MeterResource.getAll(client1, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter1] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })
                    const [meter2] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber2,
                        unitName,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                    const [meterReading1] = await createTestMeterReading(client1, meter1, source)
                    const [meterReading2] = await createTestMeterReading(client2, meter2, source)

                    const meterReadingsFromMeter1ByClient1 = await MeterReading.getAll(client1, { id: meterReading1.id })
                    const meterReadingsFromMeter2ByClient2 = await MeterReading.getAll(client2, { id: meterReading2.id })
                    const meterReadingsFromMeter2ByClient1 = await MeterReading.getAll(client1, { id: meterReading2.id })
                    const meterReadingsFromMeter1ByClient2 = await MeterReading.getAll(client2, { id: meterReading1.id })

                    expect(meterReadingsFromMeter1ByClient1).toHaveLength(1)
                    expect(meterReadingsFromMeter2ByClient2).toHaveLength(1)
                    expect(meterReadingsFromMeter2ByClient1).toHaveLength(0)
                    expect(meterReadingsFromMeter1ByClient2).toHaveLength(0)
                })

                test('cannot read MetersReadings from Meter with accountNumber, which present in deleted serviceConsumer', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    const accountNumber1 = faker.random.alphaNumeric(8)

                    const [serviceConsumer] = await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber: accountNumber1,
                    })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(residentClient, meter, source)
                    await updateTestServiceConsumer(residentClient, serviceConsumer.id, { deletedAt: 'true' })
                    const meterReadings = await MeterReading.getAll(residentClient, {
                        id: meterReading.id,
                    })

                    expect(meterReadings).toHaveLength(0)
                })

                test('cannot read MetersReadings from deleted Meter', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    const accountNumber1 = faker.random.alphaNumeric(8)

                    await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber: accountNumber1,
                    })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(residentClient, meter, source)

                    await updateTestMeter(admin, meter.id, { deletedAt: 'true' })
                    const meterReadings = await MeterReading.getAll(residentClient, {
                        id: meterReading.id,
                    })

                    expect(meterReadings).toHaveLength(0)
                })

                test('cannot read MetersReadings from Meter from deleted organization', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    const accountNumber1 = faker.random.alphaNumeric(8)

                    await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber: accountNumber1,
                    })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(residentClient, meter, source)

                    await updateTestOrganization(admin, organization.id, { deletedAt: 'true' })
                    const meterReadings = await MeterReading.getAll(residentClient, {
                        id: meterReading.id,
                    })

                    expect(meterReadings).toHaveLength(0)
                })

                test('cannot read MetersReadings from Meter from deleted property', async () => {
                    const unitName = faker.random.alphaNumeric(8)
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [resident] = await createTestResident(admin, residentClient.user, property, {
                        unitName,
                    })
                    const accountNumber1 = faker.random.alphaNumeric(8)

                    await createTestServiceConsumer(admin, resident, organization, {
                        accountNumber: accountNumber1,
                    })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {
                        accountNumber: accountNumber1,
                        unitName,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [meterReading] = await createTestMeterReading(residentClient, meter, source)

                    await Property.softDelete(admin, property.id)

                    // test access before residents reconnection worker task executes
                    const meterReadingsBeforeReconnect = await MeterReading.getAll(residentClient, {
                        id: meterReading.id,
                    })

                    expect(meterReadingsBeforeReconnect).toHaveLength(0)

                    // test access after residents reconnection worker task done
                    await waitFor(async () => {
                        const meterReadingsAfterReconnect = await MeterReading.getAll(residentClient, {
                            id: meterReading.id,
                        })

                        expect(meterReadingsAfterReconnect).toHaveLength(0)
                    })
                })

                test('can read readings from another organization if it has resource ownership', async () => {
                    const userClient = await makeClientWithResidentAccessAndProperty()
                    const unitName = faker.random.alphaNumeric(8)
                    const accountNumber = faker.random.alphaNumeric(8)
                    const [resident] = await createTestResident(admin, userClient.user, userClient.property, { unitName })
                    await createTestServiceConsumer(admin, resident, userClient.organization, { accountNumber })
                    const [coldWaterResource] = await MeterResource.getAll(userClient, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [hotWaterResource] = await MeterResource.getAll(userClient, { id: HOT_WATER_METER_RESOURCE_ID })
                    const [coldMeter] = await createTestMeter(admin, userClient.organization, userClient.property, coldWaterResource, {
                        unitName, accountNumber,
                    })
                    const [hotMeter] = await createTestMeter(admin, userClient.organization, userClient.property, hotWaterResource, {
                        unitName, accountNumber,
                    })
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })

                    const [coldMeterReading] = await createTestMeterReading(userClient, coldMeter, source)
                    const [hotMeterReading] = await createTestMeterReading(userClient, hotMeter, source)

                    const originalOrganizationReadings = await MeterReading.getAll(userClient, {})

                    expect(originalOrganizationReadings).toHaveLength(2)
                    expect(originalOrganizationReadings).toEqual(
                        expect.arrayContaining([
                            expect.objectContaining(coldMeterReading),
                            expect.objectContaining(hotMeterReading),
                        ])
                    )

                    const { organization: newOrganization } = await makeContextWithOrganizationAndIntegrationAsAdmin()
                    const [property] = await createTestProperty(admin, newOrganization, {
                        address: userClient.property.address,
                    })
                    const newAccountNumber = faker.random.alphaNumeric(8)

                    await createTestServiceConsumer(admin, resident, newOrganization, { accountNumber: newAccountNumber })
                    const meterResourceOwner = await MeterResourceOwner.getOne(admin, {
                        organization: { id: userClient.organization.id },
                        addressKey: property.addressKey,
                        resource: { id: HOT_WATER_METER_RESOURCE_ID },
                    })

                    expect(meterResourceOwner).toBeDefined()

                    await updateTestMeterResourceOwner(admin, meterResourceOwner.id, { organization: { connect: { id: newOrganization.id } } })
                    const tempMeterReadings = await MeterReading.getAll(userClient, {})

                    expect(tempMeterReadings).toHaveLength(1)
                    expect(tempMeterReadings).toEqual(expect.arrayContaining([expect.objectContaining(coldMeterReading)]))

                    const [newHotMeter] = await createTestMeter(admin, newOrganization, property, hotWaterResource, {
                        unitName, accountNumber: newAccountNumber,
                    })

                    const [newHotMeterReading] = await createTestMeterReading(userClient, newHotMeter, source)
                    const meterReadingsByResidentAddress = await MeterReading.getAll(userClient, {})

                    expect(meterReadingsByResidentAddress).toHaveLength(2)
                    expect(meterReadingsByResidentAddress).toEqual(
                        expect.arrayContaining([
                            expect.objectContaining(coldMeterReading),
                            expect.objectContaining(newHotMeterReading),
                        ])
                    )
                })
            })

            describe('User', () => {
                test('cannot read MeterReadings', async () => {
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {})
                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    const meterReadings = await MeterReading.getAll(client, { id: meterReading.id })
                    expect(meterReadings).toHaveLength(0)
                })
            })

            describe('Anonymous', () => {
                test('cannot read MeterReadings', async () => {
                    const client = await makeClient()
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, {})
                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    await expectToThrowAuthenticationErrorToObjects(async () => {
                        await MeterReading.getAll(client, { id: meterReading.id })
                    })
                })
            })
        })
    })
    describe('Validations', () => {
        describe('External integrations', () => {
            test('Can be created without contact / client info', async () => {
                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const [source] = await createTestMeterReadingSource(admin, {
                    name: faker.company.companyName(0),
                    type: METER_READING_SOURCE_EXTERNAL_IMPORT_TYPE,
                })
                const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organization, property, resource, {})

                const [meterReading] = await createTestMeterReading(admin, meter, source, {
                    contact: { disconnectAll: true },
                    client: { disconnectAll: true },
                    clientName: null,
                    clientEmail:  null,
                    clientPhone: null,
                })
                expect(meterReading).toBeDefined()
                expect(meterReading).toHaveProperty('contact', null)
                expect(meterReading).toHaveProperty('client', null)
                expect(meterReading).toHaveProperty('clientName', null)
                expect(meterReading).toHaveProperty('clientEmail', null)
                expect(meterReading).toHaveProperty('clientPhone', null)
            })
        })

        describe('Fields', () => {
            describe('date', () => {
                test('server side set date if it\'s not passed in resolvedData', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                    )

                    const [meterReading] = await createTestMeterReading(employeeCanManageReadings, meter, source, {
                        date: undefined,
                    })

                    expect(meterReading.id).toMatch(UUID_RE)
                    expect(meterReading.date).toMatch(DATETIME_RE)
                })

                test('throw an error if date is from the future and no error if date is from the past or now', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                    )

                    const date = dayjs().add(10, 'seconds').toISOString()

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(employeeCanManageReadings, meter, source, {
                            date,
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'METER_READING_DATE_IN_FUTURE',
                            message: 'Meter reading date can not be from the future',
                            messageForUser: 'api.meter.meterReading.METER_READING_DATE_IN_FUTURE',
                            messageInterpolation: { givenDate: date },
                        }
                    )

                    const date2 = dayjs().add(2, 'days').format('YYYY-MM-DD')

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(employeeCanManageReadings, meter, source, {
                            date: date2,
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'METER_READING_DATE_IN_FUTURE',
                            message: 'Meter reading date can not be from the future',
                            messageForUser: 'api.meter.meterReading.METER_READING_DATE_IN_FUTURE',
                            messageInterpolation: { givenDate: date2 },
                        }
                    )

                    const now = dayjs()
                    const [reading] = await createTestMeterReading(employeeCanManageReadings, meter, source, {
                        date: now.format('YYYY-MM-DD'),
                    })

                    expect(reading.date).toBe(now.utc().hour(0).minute(0).second(0).millisecond(0).toISOString())

                    const past = dayjs().subtract(1, 'day')
                    const [reading2] = await createTestMeterReading(employeeCanManageReadings, meter, source, {
                        date: past.format('YYYY-MM-DD'),
                    })

                    expect(reading2.date).toBe(past.utc().hour(0).minute(0).second(0).millisecond(0).toISOString())
                })
            })

            describe('clientPhone', () => {
                test('can set landline and mobile phone', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                    )
                    const mobilePhone = faker.phone.number('+79#########')
                    const landLinePhone = faker.phone.number('+7343#######')

                    const [meterReading1] = await createTestMeterReading(admin, meter, source, {
                        clientName: faker.name.firstName(),
                        clientPhone: mobilePhone,
                    })
                    expect(meterReading1.clientPhone).toBe(mobilePhone)

                    const [meterReading2] = await createTestMeterReading(admin, meter, source, {
                        clientName: faker.name.firstName(),
                        clientPhone: landLinePhone,
                        value1: meterReading1.value1,
                    })
                    expect(meterReading2.clientPhone).toBe(landLinePhone)
                })
            })

            describe('Values', () => {

                const locale = conf.DEFAULT_LOCALE

                test('Throw an error if values count is less than number of tariffs', async () => {
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, { numberOfTariffs: 3 })

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(admin, meter, source, {
                            value1: undefined,
                            value2: undefined,
                            value3: undefined,
                            value4: undefined,
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'METER_READING_FEW_VALUES',
                            message: 'Wrong values count: few values',
                            messageForUser: 'api.meter.meterReading.METER_READING_FEW_VALUES',
                            messageInterpolation: { meterNumber: meter.number, numberOfTariffs: 3, fieldsNames: ['value1', 'value2', 'value3'].map((field) => i18n(`meter.import.column.${field}`, { locale })).join(', ') },
                        }
                    )

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(admin, meter, source, {
                            value1: String(faker.datatype.number()),
                            value2: undefined,
                            value3: undefined,
                            value4: undefined,
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'METER_READING_FEW_VALUES',
                            message: 'Wrong values count: few values',
                            messageForUser: 'api.meter.meterReading.METER_READING_FEW_VALUES',
                            messageInterpolation: { meterNumber: meter.number, numberOfTariffs: 3, fieldsNames: ['value2', 'value3'].map((field) => i18n(`meter.import.column.${field}`, { locale })).join(', ') },
                        }
                    )

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(admin, meter, source, {
                            value1: String(faker.datatype.number()),
                            value2: String(faker.datatype.number()),
                            value3: undefined,
                            value4: undefined,
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'METER_READING_FEW_VALUES',
                            message: 'Wrong values count: few values',
                            messageForUser: 'api.meter.meterReading.METER_READING_FEW_VALUES',
                            messageInterpolation: { meterNumber: meter.number, numberOfTariffs: 3, fieldsNames: ['value3'].map((field) => i18n(`meter.import.column.${field}`, { locale })).join(', ') },
                        }
                    )

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(admin, meter, source, {
                            value1: undefined,
                            value2: String(faker.datatype.number()),
                            value3: undefined,
                            value4: undefined,
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'METER_READING_FEW_VALUES',
                            message: 'Wrong values count: few values',
                            messageForUser: 'api.meter.meterReading.METER_READING_FEW_VALUES',
                            messageInterpolation: { meterNumber: meter.number, numberOfTariffs: 3, fieldsNames: ['value1', 'value3'].map((field) => i18n(`meter.import.column.${field}`, { locale })).join(', ') },
                        }
                    )
                })

                test('Throw an error if values count is more than number of tariffs', async () => {
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestProperty(admin, organization)
                    const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                    const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [meter] = await createTestMeter(admin, organization, property, resource, { numberOfTariffs: 1 })

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(admin, meter, source, {
                            value1: String(faker.datatype.number()),
                            value2: String(faker.datatype.number()),
                            value3: undefined,
                            value4: undefined,
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'METER_READING_EXTRA_VALUES',
                            message: 'Wrong values count: extra values',
                            messageForUser: 'api.meter.meterReading.METER_READING_EXTRA_VALUES',
                            messageInterpolation: { meterNumber: meter.number, numberOfTariffs: 1, fieldsNames: ['value2'].map((field) => i18n(`meter.import.column.${field}`, { locale })).join(', ') },
                        }
                    )

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(admin, meter, source, {
                            value1: String(faker.datatype.number()),
                            value2: String(faker.datatype.number()),
                            value3: String(faker.datatype.number()),
                            value4: undefined,
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'METER_READING_EXTRA_VALUES',
                            message: 'Wrong values count: extra values',
                            messageForUser: 'api.meter.meterReading.METER_READING_EXTRA_VALUES',
                            messageInterpolation: { meterNumber: meter.number, numberOfTariffs: 1, fieldsNames: ['value2', 'value3'].map((field) => i18n(`meter.import.column.${field}`, { locale })).join(', ') },
                        }
                    )

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(admin, meter, source, {
                            value1: String(faker.datatype.number()),
                            value2: String(faker.datatype.number()),
                            value3: String(faker.datatype.number()),
                            value4: String(faker.datatype.number()),
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'METER_READING_EXTRA_VALUES',
                            message: 'Wrong values count: extra values',
                            messageForUser: 'api.meter.meterReading.METER_READING_EXTRA_VALUES',
                            messageInterpolation: { meterNumber: meter.number, numberOfTariffs: 1, fieldsNames: ['value2', 'value3', 'value4'].map((field) => i18n(`meter.import.column.${field}`, { locale })).join(', ') },
                        }
                    )
                })
            })

            describe('billingStatus & billingStatusText', () => {
                test('can not set billingStatusText without billingStatus', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                    )

                    await expectToThrowGQLError(
                        async () => await createTestMeterReading(admin, meter, source, {
                            billingStatus: null,
                            billingStatusText: faker.lorem.sentence(5),
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'BILLING_STATUS_MESSAGE_WITHOUT_BILLING_STATUS',
                            message: 'Can not set billingStatusText without billingStatus',
                        }
                    )

                    const [meterReading] = await createTestMeterReading(admin, meter, source, {
                        billingStatus: 'declined',
                        billingStatusText: faker.lorem.sentence(5),
                    })

                    await expectToThrowGQLError(
                        async () => await updateTestMeterReading(admin, meterReading.id, {
                            billingStatus: null,
                        }),
                        {
                            code: 'BAD_USER_INPUT',
                            type: 'BILLING_STATUS_MESSAGE_WITHOUT_BILLING_STATUS',
                            message: 'Can not set billingStatusText without billingStatus',
                        }
                    )
                })
            })

            describe('accountNumber', () => {
                test('is filled from related Meter.accountNumber on creation', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                    )
                    const [meterReading] = await createTestMeterReading(admin, meter, source)
                    expect(meterReading.accountNumber).toBe(meter.accountNumber)

                })
                test('cannot be updated', async () => {
                    const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                    const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: CALL_METER_READING_SOURCE_ID })
                    const [meter] = await createTestMeter(
                        employeeCanManageReadings,
                        employeeCanManageReadings.organization,
                        employeeCanManageReadings.property,
                        resource,
                    )
                    const [meterReading] = await createTestMeterReading(admin, meter, source)

                    await expectToThrowGraphQLRequestError(
                        async () => await updateTestMeterReading(admin, meterReading.id, {
                            accountNumber: faker.random.alphaNumeric(),
                        }),
                        'got invalid value',
                    )
                })
            })
        })

        describe('Resolve input', () => {
            it('Create contact if contact does not exist in same property, unitType and unitName', async () => {
                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(8)

                // contact in other unitName
                await createTestContact(admin, organization, property, {
                    phone: residentClient.userAttrs.phone,
                    unitName: faker.random.alphaNumeric(8),
                    unitType: FLAT_UNIT_TYPE,
                })

                // contact in other unitType
                await createTestContact(admin, organization, property, {
                    phone: residentClient.userAttrs.phone,
                    unitName,
                    unitType: PARKING_UNIT_TYPE,
                })

                const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organization, property, resource, {
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })
                const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                const [meterReading] = await createTestMeterReading(admin, meter, source, {
                    clientName: residentClient.userAttrs.name,
                    clientPhone: residentClient.userAttrs.phone,
                })

                const createdContact = await Contact.getOne(admin, {
                    property: { id: property.id },
                    phone: residentClient.userAttrs.phone,
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })
                expect(createdContact).toBeDefined()
                expect(meterReading.contact.id).toEqual(createdContact.id)
            })

            it('Connect contact if he exists in same property, unitType and unitName', async () => {
                const [organization] = await createTestOrganization(admin)
                const [property] = await createTestProperty(admin, organization)
                const unitName = faker.random.alphaNumeric(8)

                const [contact] = await createTestContact(admin, organization, property, {
                    phone: residentClient.userAttrs.phone,
                    unitName,
                    unitType: FLAT_UNIT_TYPE,
                })

                const [resource] = await MeterResource.getAll(residentClient, { id: COLD_WATER_METER_RESOURCE_ID })
                const [meter] = await createTestMeter(admin, organization, property, resource, {
                    unitName,
                })
                const [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
                const [meterReading] = await createTestMeterReading(admin, meter, source, {
                    clientName: residentClient.userAttrs.name,
                    clientPhone: residentClient.userAttrs.phone,
                })

                const connectedContact = meterReading.contact
                expect(connectedContact).toBeDefined()
                expect(connectedContact.id).toEqual(contact.id)
            })

            test('Cannot pass reading if Meter is archived when using the mobile app', async () => {
                const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: MOBILE_APP_SOURCE_ID })
                const [meter] = await createTestMeter(
                    employeeCanManageReadings,
                    employeeCanManageReadings.organization,
                    employeeCanManageReadings.property,
                    resource,
                    { archiveDate: dayjs().toISOString() }
                )

                await expectToThrowGQLError(
                    async () => await createTestMeterReading(employeeCanManageReadings, meter, source, { date: dayjs().format('YYYY-MM-DD') }),
                    {
                        code: 'BAD_USER_INPUT',
                        type: 'METER_ARCHIVED',
                        message: 'Cannot pass meter readings for archived Meter',
                    }
                )
            })

            test('Cannot pass reading if meter verification date is in the past when using the mobile app', async () => {
                const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: MOBILE_APP_SOURCE_ID })
                const [meter] = await createTestMeter(
                    employeeCanManageReadings,
                    employeeCanManageReadings.organization,
                    employeeCanManageReadings.property,
                    resource,
                    { nextVerificationDate: dayjs().subtract(1, 'day').format('YYYY-MM-DD') }
                )

                await expectToThrowGQLError(
                    async () => await createTestMeterReading(employeeCanManageReadings, meter, source, { date: dayjs().format('YYYY-MM-DD') }),
                    {
                        code: 'BAD_USER_INPUT',
                        type: 'METER_VERIFICATION_MISSED',
                        message: 'Cannot pass meter readings for Meter whose next verification date is in the past',
                    }
                )
            })

            test('Allows meter reading if meter is active and next verification date is in the future', async () => {
                const [resource] = await MeterResource.getAll(employeeCanManageReadings, { id: COLD_WATER_METER_RESOURCE_ID })
                const [source] = await MeterReadingSource.getAll(employeeCanManageReadings, { id: MOBILE_APP_SOURCE_ID })
                const [meter] = await createTestMeter(
                    employeeCanManageReadings,
                    employeeCanManageReadings.organization,
                    employeeCanManageReadings.property,
                    resource,
                    { nextVerificationDate: dayjs().add(1, 'month').format('YYYY-MM-DD') }
                )

                const [reading] = await createTestMeterReading(employeeCanManageReadings, meter, source, { date: dayjs().format('YYYY-MM-DD') })
                expect(reading.id).toMatch(UUID_RE)
                expect(reading.date).toMatch(DATETIME_RE)
            })
        })
    })

    describe('billingStatus and billingStatusText fields access', () => {
        let organization, source, meter

        beforeAll(async () => {
            [organization] = await createTestOrganization(admin)
            const [property] = await createTestProperty(admin, organization);
            [source] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
            const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID });
            [meter] = await createTestMeter(admin, organization, property, resource, {})
        })

        test('Service user with b2b access rights can create and update', async () => {
            const serviceUserClient = await makeClientWithServiceUser()
            const [app] = await createTestB2BApp(admin)
            await createTestB2BAppContext(admin, app, organization, { status: 'Finished' })
            const [accessRightSet] = await createTestB2BAppAccessRightSet(admin, app, {
                canExecuteRegisterMetersReadings: true,
                canReadMeters: true,
                canReadMeterReadings: true,
                canManageMeterReadings: true,
                canReadOrganizations: true,
                canReadProperties: true,
            })
            await createTestB2BAppAccessRight(admin, serviceUserClient.user, app, accessRightSet)

            const [meterReading, attrs] = await createTestMeterReading(serviceUserClient, meter, source, {
                billingStatus: 'declined',
                billingStatusText: faker.lorem.sentence(5),
            })

            expect(meterReading.billingStatus).toBe('declined')
            expect(meterReading.billingStatusText).toBe(attrs.billingStatusText)

            const [updatedMeterReading, updatedAttrs] = await updateTestMeterReading(serviceUserClient, meterReading.id, {
                billingStatusText: 'updated billing status text',
            })

            expect(updatedMeterReading.billingStatusText).toBe(updatedAttrs.billingStatusText)
        })

        test('Service user without b2b access rights can\'t create and update', async () => {
            const serviceUserClient = await makeClientWithServiceUser()
            const [app] = await createTestB2BApp(admin)
            await createTestB2BAppContext(admin, app, organization, { status: 'Finished' })

            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await createTestMeterReading(serviceUserClient, meter, source, {
                        billingStatus: 'declined',
                        billingStatusText: faker.lorem.sentence(5),
                    })
                },
                {},
            )
            const [meterReading, attrs] = await createTestMeterReading(admin, meter, source, {
                billingStatus: 'declined',
                billingStatusText: faker.lorem.sentence(5),
            })

            expect(meterReading.billingStatus).toBe('declined')
            expect(meterReading.billingStatusText).toBe(attrs.billingStatusText)

            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await updateTestMeterReading(serviceUserClient, meterReading.id, {
                        billingStatusText: 'updated billing status text',
                    })
                },
                {},
            )
        })

        test('admin can create and update', async () => {
            const [meterReading, attrs] = await createTestMeterReading(admin, meter, source, {
                billingStatus: 'declined',
                billingStatusText: faker.lorem.sentence(5),
            })

            expect(meterReading.billingStatus).toBe('declined')
            expect(meterReading.billingStatusText).toBe(attrs.billingStatusText)

            const [updatedMeterReading, updatedAttrs] = await updateTestMeterReading(admin, meterReading.id, {
                billingStatusText: 'updated billing status text',
            })

            expect(updatedMeterReading.billingStatusText).toBe(updatedAttrs.billingStatusText)
        })

        test('user can\'t create and update', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await createTestMeterReading(client, meter, source, {
                        billingStatus: 'declined',
                        billingStatusText: faker.lorem.sentence(5),
                    })
                },
                {},
            )

            const [meterReading] = await createTestMeterReading(admin, meter, source, {
                billingStatus: 'declined',
                billingStatusText: faker.lorem.sentence(5),
            })

            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await updateTestMeterReading(client, meterReading.id, {
                        billingStatus: 'approved',
                        billingStatusText: faker.lorem.sentence(5),
                    })
                },
                {},
            )
        })

        test('resident can\'t create and update', async () => {
            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await createTestMeterReading(residentClient, meter, source, {
                        billingStatus: 'declined',
                        billingStatusText: faker.lorem.sentence(5),
                    })
                },
                {},
            )

            const [meterReading] = await createTestMeterReading(admin, meter, source, {
                billingStatus: 'declined',
                billingStatusText: faker.lorem.sentence(5),
            })

            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await updateTestMeterReading(residentClient, meterReading.id, {
                        billingStatus: 'approved',
                        billingStatusText: faker.lorem.sentence(5),
                    })
                },
                {},
            )
        })

        test('employee with "canManageMeterReadings" role can\'t create and update', async () => {
            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await createTestMeterReading(employeeCanManageReadings, meter, source, {
                        billingStatus: 'declined',
                        billingStatusText: faker.lorem.sentence(5),
                    })
                },
                {},
            )

            const [meterReading] = await createTestMeterReading(admin, meter, source, {
                billingStatus: 'declined',
                billingStatusText: faker.lorem.sentence(5),
            })

            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await updateTestMeterReading(employeeCanManageReadings, meterReading.id, {
                        billingStatus: 'approved',
                        billingStatusText: faker.lorem.sentence(5),
                    })
                },
                {},
            )
        })

        test('employee without "canManageMeterReadings" role can\'t create and update', async () => {
            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await createTestMeterReading(employeeCanNotManageReadings, meter, source, {
                        billingStatus: 'declined',
                        billingStatusText: faker.lorem.sentence(5),
                    })
                },
                {},
            )

            const [meterReading] = await createTestMeterReading(admin, meter, source, {
                billingStatus: 'declined',
                billingStatusText: faker.lorem.sentence(5),
            })

            await expectToThrowAccessDeniedErrorToObj(
                async () => {
                    await updateTestMeterReading(employeeCanNotManageReadings, meterReading.id, {
                        billingStatus: 'approved',
                        billingStatusText: faker.lorem.sentence(5),
                    })
                },
                {},
            )
        })
    })

    describe('Manipulating readings taking into account MeterReportingPeriod for corresponding property/organization', () => {
        let organization, source

        beforeAll(async () => {
            [organization] = await createTestOrganization(admin);
            [source] = await MeterReadingSource.getAll(admin, { id: MOBILE_APP_SOURCE_ID })
        })

        async function setupTestContext (notifyStartDay, notifyEndDay, restrictionEndDay = null) {
            const [property] = await createTestProperty(admin, organization)
            const [resource] = await MeterResource.getAll(admin, { id: COLD_WATER_METER_RESOURCE_ID })
            const [meter] = await createTestMeter(admin, organization, property, resource)
            const [reportingPeriod] = await createTestMeterReportingPeriod(admin, organization, {
                notifyStartDay,
                notifyEndDay,
                ...restrictionEndDay ? { restrictionEndDay } : {},
                property: { connect: { id: property.id } },
            })
            return { property, meter, reportingPeriod }
        }
        test('rejects reading from mobile app if date is after notifyEndDay in strict period (notifyStartDay < notifyEndDay)', async () => {
            const { meter } = await setupTestContext(20, 25, 31)
            const readingDate = dayjs().subtract(2, 'month').date(26).format('YYYY-MM-DD')
    
            await expectToThrowGQLError(
                async () => await createTestMeterReading(admin, meter, source, { date: readingDate }),
                {
                    code: 'BAD_USER_INPUT',
                    type: 'METER_READING_DATE_AFTER_NOTIFY_END',
                    message: 'Meter reading date cannot be after the end of the MeterReportingPeriod\'s notifyEndDay',
                }
            )
        })
  
        test('allows reading if date is within allowed period in strict period (notifyStartDay < notifyEndDay)', async () => {
            const { meter } = await setupTestContext(20, 25, 31)
            const readingDate = dayjs().subtract(2, 'month').date(24).format('YYYY-MM-DD')
            const [meterReading] = await createTestMeterReading(admin, meter, source, { date: readingDate })
  
            expect(meterReading.id).toMatch(UUID_RE)
            expect(meterReading.date).toMatch(DATETIME_RE)
        })
  
        test('allows reading if strict period has notifyStartDay > notifyEndDay (open window) and restrictionEndDay is default (31)', async () => {
            const { meter } = await setupTestContext(25, 5, 31)
            const readingDate = dayjs().subtract(2, 'month').date(28).format('YYYY-MM-DD')
            const [meterReading] = await createTestMeterReading(admin, meter, source, { date: readingDate })
  
            expect(meterReading.id).toMatch(UUID_RE)
            expect(meterReading.date).toMatch(DATETIME_RE)
        })
  
        test('allows reading for non-strict period even if date is after notifyEndDay', async () => {
            const { meter } = await setupTestContext(20, 25)
            const readingDate = dayjs().subtract(2, 'month').date(28).format('YYYY-MM-DD')
            const [meterReading] = await createTestMeterReading(admin, meter, source, { date: readingDate })
  
            expect(meterReading.id).toMatch(UUID_RE)
            expect(meterReading.date).toMatch(DATETIME_RE)
        })
  
        test('skips MeterReportingPeriod validation if source is not mobile resident app', async () => {
            const { meter } = await setupTestContext(20, 25, 30)
            const [nonMobileSource] = await MeterReadingSource.getAll(admin, { id: CALL_METER_READING_SOURCE_ID })
            const readingDate = dayjs().subtract(2, 'month').date(26).format('YYYY-MM-DD')
            const [meterReading] = await createTestMeterReading(admin, meter, nonMobileSource, { date: readingDate })
  
            expect(meterReading.id).toMatch(UUID_RE)
            expect(meterReading.date).toMatch(DATETIME_RE)
        })

        test('rejects reading if date is in restricted period (notifyStartDay < notifyEndDay)', async () => {
            const { meter } = await setupTestContext(20, 25, 5)
            const restrictedDate = dayjs().subtract(1, 'month').date(2).format('YYYY-MM-DD')

            await expectToThrowGQLError(
                async () => await createTestMeterReading(admin, meter, source, { date: restrictedDate }),
                {
                    code: 'BAD_USER_INPUT',
                    type: 'METER_READING_DATE_AFTER_NOTIFY_END',
                    message: 'Meter reading date cannot be after the end of the MeterReportingPeriod\'s notifyEndDay',
                }
            )
        })

        test('allows reading if date is in allowed period after restriction (notifyStartDay < notifyEndDay)', async () => {
            const { meter } = await setupTestContext(20, 25, 5)
            const allowedDate = dayjs().subtract(2, 'month').date(6).format('YYYY-MM-DD')
            const [meterReading] = await createTestMeterReading(admin, meter, source, { date: allowedDate })

            expect(meterReading.id).toMatch(UUID_RE)
            expect(meterReading.date).toMatch(DATETIME_RE)
        })

        test('rejects reading if date is in restricted period (notifyStartDay > notifyEndDay)', async () => {
            const { meter } = await setupTestContext(25, 5, 8)
            const restrictedDate = dayjs().subtract(2, 'month').date(7).format('YYYY-MM-DD')

            await expectToThrowGQLError(
                async () => await createTestMeterReading(admin, meter, source, { date: restrictedDate }),
                {
                    code: 'BAD_USER_INPUT',
                    type: 'METER_READING_DATE_AFTER_NOTIFY_END',
                    message: 'Meter reading date cannot be after the end of the MeterReportingPeriod\'s notifyEndDay',
                }
            )
        })

        test('allows reading if date is after restricted period (notifyStartDay > notifyEndDay)', async () => {
            const { meter } = await setupTestContext(25, 5, 8)
            const allowedDate = dayjs().subtract(2, 'month').date(9).format('YYYY-MM-DD')
            const [meterReading] = await createTestMeterReading(admin, meter, source, { date: allowedDate })

            expect(meterReading.id).toMatch(UUID_RE)
            expect(meterReading.date).toMatch(DATETIME_RE)
        })

        test('allows reading when restrictionEndDay equals notifyEndDay (no restriction)', async () => {
            const { meter } = await setupTestContext(20, 25, 25)
            const allowedDate = dayjs().subtract(2, 'month').date(26).format('YYYY-MM-DD')
            const [meterReading] = await createTestMeterReading(admin, meter, source, { date: allowedDate })

            expect(meterReading.id).toMatch(UUID_RE)
            expect(meterReading.date).toMatch(DATETIME_RE)
        })

        describe('test all possible cases in one month for strict period that is within one month', () => {
            let allowedDates = [], restrictedDates = [], meter
            const june = dayjs().subtract(1, 'year').month(5)
            for (let i = 5; i <= 25; i++) {
                allowedDates.push(june.date(i).format('YYYY-MM-DD'))
            }
            for (let i = 26; i <= 30; i++) {
                restrictedDates.push(june.date(i).format('YYYY-MM-DD'))
            }
            for (let i = 1; i <= 4; i++) {
                restrictedDates.push(june.date(i).format('YYYY-MM-DD'))
            }


            beforeAll(async () => {
                const { meter: createdMeter } = await setupTestContext(20, 25, 4)
                meter = createdMeter
            })

            test.each(allowedDates)('%p', async (date) => {
                const [meterReading] = await createTestMeterReading(admin, meter, source, { date })

                expect(meterReading.id).toMatch(UUID_RE)
                expect(meterReading.date).toMatch(DATETIME_RE)

            })

            test.each(restrictedDates)('%p', async (date) => {
                await expectToThrowGQLError(
                    async () => await createTestMeterReading(admin, meter, source, { date }),
                    {
                        code: 'BAD_USER_INPUT',
                        type: 'METER_READING_DATE_AFTER_NOTIFY_END',
                        message: 'Meter reading date cannot be after the end of the MeterReportingPeriod\'s notifyEndDay',
                    },
                )
            })
        })

        describe('test all possible cases in one month for strict period that spans into next month', () => {
            let allowedDates = [], restrictedDates = [], meter
            const june = dayjs().subtract(1, 'year').month(5)
            const july = dayjs().subtract(1, 'year').month(6)
            for (let i = 11; i <= 30; i++) {
                allowedDates.push(june.date(i).format('YYYY-MM-DD'))
            }
            for (let i = 1; i <= 5; i++) {
                allowedDates.push(july.date(i).format('YYYY-MM-DD'))
            }
            for (let i = 6; i <= 10; i++) {
                restrictedDates.push(july.date(i).format('YYYY-MM-DD'))
            }

            beforeAll(async () => {
                const { meter: createdMeter } = await setupTestContext(25, 5, 10)
                meter = createdMeter
            })

            test.each(allowedDates)('%p', async (date) => {
                const [meterReading] = await createTestMeterReading(admin, meter, source, { date })

                expect(meterReading.id).toMatch(UUID_RE)
                expect(meterReading.date).toMatch(DATETIME_RE)
            })

            test.each(restrictedDates)('%p', async (date) => {
                await expectToThrowGQLError(
                    async () => await createTestMeterReading(admin, meter, source, { date }),
                    {
                        code: 'BAD_USER_INPUT',
                        type: 'METER_READING_DATE_AFTER_NOTIFY_END',
                        message: 'Meter reading date cannot be after the end of the MeterReportingPeriod\'s notifyEndDay',
                    },
                )
            })
        })
  
        test('prioritizes property reporting period over organization reporting period', async () => {
            const { meter } = await setupTestContext(20, 25, 28)

            await createTestMeterReportingPeriod(admin, organization, {
                notifyStartDay: 20,
                notifyEndDay: 25,
            })

            const readingDate = dayjs().subtract(2, 'month').date(26).format('YYYY-MM-DD')

            await expectToThrowGQLError(
                async () => await createTestMeterReading(admin, meter, source, { date: readingDate }),
                {
                    code: 'BAD_USER_INPUT',
                    type: 'METER_READING_DATE_AFTER_NOTIFY_END',
                    message: 'Meter reading date cannot be after the end of the MeterReportingPeriod\'s notifyEndDay',
                }
            )
        })

        describe('Do not include soft-deleted periods', () => {
            let organization
            
            beforeEach(async () => {
                [organization] = await createTestOrganization(admin)
            })

            test('excludes deleted property-specific reporting period', async () => {
                const { meter, reportingPeriod } = await setupTestContext(20, 25, 28)

                await updateTestMeterReportingPeriod(admin, reportingPeriod.id, { deletedAt: new Date().toISOString() })
                const readingDate = dayjs().subtract(2, 'month').date(26).format('YYYY-MM-DD')

                const [meterReading] = await createTestMeterReading(admin, meter, source, { date: readingDate })

                expect(meterReading.id).toMatch(UUID_RE)
                expect(meterReading.date).toMatch(DATETIME_RE)
            })

            test('excludes deleted organization-specific reporting period', async () => {
                const { meter, reportingPeriod } = await setupTestContext(20, 25, 31)
                const readingDate = dayjs().subtract(2, 'month').date(28).format('YYYY-MM-DD')
                await expectToThrowGQLError(
                    async () => await createTestMeterReading(admin, meter, source, { date: readingDate }),
                    {
                        code: 'BAD_USER_INPUT',
                        type: 'METER_READING_DATE_AFTER_NOTIFY_END',
                    }
                )
                await updateTestMeterReportingPeriod(admin, reportingPeriod.id, { deletedAt: new Date().toISOString() })
                const [meterReading] = await createTestMeterReading(admin, meter, source, { date: readingDate })
                expect(meterReading.id).toMatch(UUID_RE)
                expect(meterReading.date).toMatch(DATETIME_RE)
            })

            test('only checks for non deleted reporting period', async () => {
                // Create periods for organization and for property, soft-delete them
                const { reportingPeriod: oldReportingPeriod } = await setupTestContext(15, 20, 23)

                const [oldReportingPeriod2] = await createTestMeterReportingPeriod(admin, organization, {
                    notifyStartDay: 15,
                    notifyEndDay: 20,
                    restrictionEndDay: 22,
                })

                await updateTestMeterReportingPeriod(admin, oldReportingPeriod.id, { deletedAt: new Date().toISOString() })
                await updateTestMeterReportingPeriod(admin, oldReportingPeriod2.id, { deletedAt: new Date().toISOString() })

                // Create actual periods for organization and for property
                // Period for property should be prioritized (can pass readings starting with 26)
                const { meter } = await setupTestContext(15, 20, 25)
                await createTestMeterReportingPeriod(admin, organization, {
                    notifyStartDay: 15,
                    notifyEndDay: 20,
                    restrictionEndDay: 27,
                })

                const readingDate = dayjs().subtract(2, 'month').date(26).format('YYYY-MM-DD')
                const [meterReading] = await createTestMeterReading(admin, meter, source, { date: readingDate })

                expect(meterReading.id).toMatch(UUID_RE)
                expect(meterReading.date).toMatch(DATETIME_RE)

                const readingDateNotAllowed = dayjs().subtract(2, 'month').date(25).format('YYYY-MM-DD')
                await expectToThrowGQLError(
                    async () => await createTestMeterReading(admin, meter, source, {
                        date: readingDateNotAllowed,
                    }),
                    {
                        code: 'BAD_USER_INPUT',
                        type: 'METER_READING_DATE_AFTER_NOTIFY_END',
                        message: 'Meter reading date cannot be after the end of the MeterReportingPeriod\'s notifyEndDay',
                    }
                )
            })
        })

    })
})
