/**
 * Generated by `createservice propertymeter.RegisterPropertyMetersReadingsService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const flatten = require('lodash/flatten')
const map = require('lodash/map')
const set = require('lodash/set')
const zip = require('lodash/zip')

const { expectToThrowForeignKeyConstraintViolationError } = require('@open-condo/keystone/test.utils')
const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult, expectToThrowGQLError, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const { UUID_REGEXP } = require('@condo/domains/common/constants/regexps')
const {
    ELECTRICITY_METER_RESOURCE_ID,
    HEAT_SUPPLY_METER_RESOURCE_ID,
    GAS_SUPPLY_METER_RESOURCE_ID,
    OTHER_METER_READING_SOURCE_ID,
    REMOTE_SYSTEM_METER_READING_SOURCE_ID,
} = require('@condo/domains/meter/constants/constants')
const { DATE_FIELD_PATHS } = require('@condo/domains/meter/constants/registerMetersReadingsService')
const {
    registerPropertyMetersReadingsByTestClient,
    createTestReadingData,
    PropertyMeter,
    PropertyMeterReading,
} = require('@condo/domains/meter/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRight, createTestB2BAppAccessRightSet,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    createTestOrganization,
    makeEmployeeUserClientWithAbilities,
} = require('@condo/domains/organization/utils/testSchema')
const { createTestPropertyWithMap } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

describe('RegisterPropertyMetersReadingsService', () => {
    let adminClient, supportClient, residentClient, anonymousClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        residentClient = await makeClientWithResidentUser()
        anonymousClient = await makeClient()
    })

    describe('access to execution', () => {

        let organization

        beforeAll(async () => {
            [organization] = await createTestOrganization(adminClient)
        })

        test('admin can', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, organization)
            const readings = [createTestReadingData(property, {}, true)]
            const [data] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                meter: expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    property: expect.objectContaining({
                        id: property.id,
                        address: property.address,
                        addressKey: property.addressKey,
                    }),
                    number: readings[0].meterNumber,
                }),
            })])

            const meters = await PropertyMeter.getAll(adminClient, {
                organization: { id: organization.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
        })

        test('support can', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, organization)
            const readings = [createTestReadingData(property, {}, true)]
            const [data] = await registerPropertyMetersReadingsByTestClient(supportClient, organization, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                meter: expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    property: expect.objectContaining({
                        id: property.id,
                        address: property.address,
                        addressKey: property.addressKey,
                    }),
                    number: readings[0].meterNumber,
                }),
            })])

            const meters = await PropertyMeter.getAll(adminClient, {
                organization: { id: organization.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
        })

        describe('staff', () => {
            test('with permissions can', async () => {
                const staffClient = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                    canManageMeterReadings: true,
                })

                const readings = [createTestReadingData(staffClient.property,  {}, true)]
                const [data] = await registerPropertyMetersReadingsByTestClient(staffClient, staffClient.organization, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    meter: expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        property: expect.objectContaining({
                            id: staffClient.property.id,
                            address: staffClient.property.address,
                            addressKey: staffClient.property.addressKey,
                        }),
                        number: readings[0].meterNumber,
                    }),
                })])

                const meters = await PropertyMeter.getAll(adminClient, {
                    organization: { id: staffClient.organization.id },
                    property: { id: staffClient.property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
            })

            test('without permissions can\'t', async () => {
                const staffClient1 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                    canManageMeterReadings: false,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerPropertyMetersReadingsByTestClient(staffClient1, staffClient1.organization, [])
                })

                const staffClient2 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                    canManageMeterReadings: false,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerPropertyMetersReadingsByTestClient(staffClient2, staffClient2.organization, [])
                })

                const staffClient3 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                    canManageMeterReadings: true,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerPropertyMetersReadingsByTestClient(staffClient3, staffClient3.organization, [])
                })
            })
        })

        describe('service user', () => {
            test('with access rights can', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestPropertyWithMap(adminClient, organization)

                const [app] = await createTestB2BApp(adminClient)
                await createTestB2BAppContext(adminClient, app, organization, { status: 'Finished' })
                const [accessRightSet] = await createTestB2BAppAccessRightSet(adminClient, app, {
                    canExecuteRegisterPropertyMetersReadings: true,
                    canReadMeters: true,
                    canReadMeterReadings: true,
                    canReadOrganizations: true,
                    canReadProperties: true,
                })
                await createTestB2BAppAccessRight(adminClient, serviceClient.user, app, accessRightSet)

                const readings = [createTestReadingData(property, {}, true)]
                const [data] = await registerPropertyMetersReadingsByTestClient(serviceClient, organization, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    meter: expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        property: expect.objectContaining({
                            id: property.id,
                            address: property.address,
                            addressKey: property.addressKey,
                        }),
                        number: readings[0].meterNumber,
                    }),
                })])

                const meters = await PropertyMeter.getAll(adminClient, {
                    organization: { id: organization.id },
                    property: { id: property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
            })

            test('without permissions can\'t', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [organization] = await createTestOrganization(adminClient)

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerPropertyMetersReadingsByTestClient(serviceClient, organization, [])
                })
            })
        })

        test('resident can\'t execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerPropertyMetersReadingsByTestClient(residentClient, organization, [])
            })
        })

        test('anonymous can\'t execute', async () => {
            await expectToThrowAuthenticationError(async () => {
                await registerPropertyMetersReadingsByTestClient(anonymousClient, organization, [])
            }, 'result')
        })
    })

    test('error on too much items', async () => {
        const [organization] = await createTestOrganization(adminClient)
        await expectToThrowGQLError(
            async () => await registerPropertyMetersReadingsByTestClient(
                adminClient,
                organization,
                flatten(Array(501).fill(createTestReadingData({ address: faker.address.streetAddress(true) }, {}, true))),
            ),
            {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MUCH_READINGS',
                message: 'Too much readings. {sentCount} sent, limit is {limit}.',
                messageForUser: 'api.meter.registerMetersReadings.TOO_MUCH_READINGS',
                messageInterpolation: { limit: 500, sentCount: 501 },
            },
            'result',
        )
    })

    test('error if organization not exists', async () => {
        await expectToThrowGQLError(
            async () => await registerPropertyMetersReadingsByTestClient(adminClient, { id: faker.datatype.uuid() }, []),
            {
                code: 'BAD_USER_INPUT',
                type: 'ORGANIZATION_NOT_FOUND',
                message: 'Organization not found',
                messageForUser: 'api.meter.registerMetersReadings.ORGANIZATION_NOT_FOUND',
            },
            'result',
        )
    })

    test('error for row if trying to add property meter reading for property which not added to organization', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, organization)
        const [property2] = await createTestPropertyWithMap(adminClient, organization)

        const readings = [
            createTestReadingData(property1, {}, true),
            createTestReadingData({ address: faker.address.streetAddress(true) }, {}, true),
            createTestReadingData(property2, {}, true),
        ]

        await catchErrorFrom(
            async () => {
                await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property1.id,
                                address: property1.address,
                                addressKey: property1.addressKey,
                            }),
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property2.id,
                                address: property2.address,
                                addressKey: property2.addressKey,
                            }),
                            number: readings[2].meterNumber,
                        }),
                    }),
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Property not found',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'PROPERTY_NOT_FOUND',
                            message: 'Property not found',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid property meter value', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)

        const badReading1 = createTestReadingData(property, {
            meterResource: { id: GAS_SUPPLY_METER_RESOURCE_ID },
            value1: '-100500',
            value2: undefined,
        }, true)

        const badReading2 = createTestReadingData(property, {
            meterResource: { id: ELECTRICITY_METER_RESOURCE_ID },
            value1: 'oops',
            value2: undefined,
        }, true)

        const badReading3 = createTestReadingData(property, {
            meterResource: { id: HEAT_SUPPLY_METER_RESOURCE_ID },
            value1: 'Infinity',
            value2: undefined,
        }, true)

        const readings = [
            createTestReadingData(property, {}, true),
            badReading1,
            badReading2,
            badReading3,
        ]

        await catchErrorFrom(
            async () => {
                await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)
            },
            (err) => {
                const { data: { result }, errors } = err
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property.id,
                                address: property.address,
                                addressKey: property.addressKey,
                            }),
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                    null,
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid meter resource', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, organization)

        const badReading = createTestReadingData(property1, {}, true)
        badReading.meterResource = { id: faker.datatype.uuid() }

        const readings = [
            createTestReadingData(property1, {}, true),
            badReading,
        ]

        await expectToThrowForeignKeyConstraintViolationError(
            async () => await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings),
            'PropertyMeter', 'PropertyMeter_resource_0a48a7b4_fk_MeterResource_id'
        )
    })

    test('error on invalid number of tariffs passed', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, organization)

        const badReading = createTestReadingData(property1, {}, true)
        badReading.meterMeta.numberOfTariffs = 5

        const readings = [
            createTestReadingData(property1, {}, true),
            badReading,
        ]

        await catchErrorFrom(
            async () => {
                await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property1.id,
                                address: property1.address,
                                addressKey: property1.addressKey,
                            }),
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create PropertyMeter internal error',
                        extensions: expect.objectContaining({
                            'code': 'BAD_USER_INPUT',
                            'type': 'NUMBER_OF_TARIFFS_NOT_VALID',
                            'message': 'Provided number of tariffs is not valid. Must be an integer from 1 to 4.',
                            'messageForUserTemplateKey': 'api.meter.NUMBER_OF_TARIFFS_NOT_VALID',
                            'messageInterpolation': {
                                'value': 5,
                            },
                        }),
                    }),
                ])
            },
        )
    })

    test('number of tariffs calculated correctly', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const reading = createTestReadingData(property, {}, true)
        reading.value3 = faker.random.numeric(3)
        reading.meterMeta.numberOfTariffs = undefined

        const [data] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, [reading])

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                number: reading.meterNumber,
            }),
        })])

        const propertyMeters = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(propertyMeters).toEqual([
            expect.objectContaining({ numberOfTariffs: 3 }),
        ])
    })

    test('meterNumber is trimmed correctly', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const reading = createTestReadingData(property, {}, true)
        reading.meterNumber = `\t${reading.meterNumber}  `

        const [data] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, [reading])

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                number: reading.meterNumber.trim(),
            }),
        })])
    })

    test('error on empty meter number', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)

        const readingWithBadMeterNumber1 = createTestReadingData(property, {}, true)
        readingWithBadMeterNumber1.meterNumber = '\t  \n'

        const readingWithBadMeterNumber2 = createTestReadingData(property, {}, true)
        readingWithBadMeterNumber2.meterNumber = ''

        const readings = [
            readingWithBadMeterNumber1,
            readingWithBadMeterNumber2,
        ]

        await catchErrorFrom(
            async () => {
                await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    null,
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid meter number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_METER_NUMBER',
                            message: 'Invalid meter number',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_METER_NUMBER',
                            message: 'Invalid meter number',
                        }),
                    }),
                ])
            },
        )
    })

    describe('Dates parsing', () => {

        describe('valid dates', () => {
            const dates = [
                { input: '2024-06-17', output: dayjs('2024-06-17').toISOString() },
                { input: '2024-06-17T18:44:13.539Z', output: '2024-06-17T18:44:13.539Z' },
                { input: '2021-12-20T00:00:00.000Z', output: '2021-12-20T00:00:00.000Z' },
            ]

            const cases = dates.flatMap(date =>
                DATE_FIELD_PATHS.map(({ path }) => ({
                    input: date.input,
                    output: date.output,
                    path,
                })))

            test.each(cases)('$input in $path should parsed as $output', async ({ input, output, path }) => {
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestPropertyWithMap(adminClient, organization)

                const reading = createTestReadingData(property, {}, true)
                set(reading, path, input)
                const [data] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, [reading])

                expect(data).toHaveLength(1)

                const row = data[0]

                if (path.startsWith('meterMeta')) {
                    path = path.substring('meterMeta.'.length)
                    const propertyMeter = await PropertyMeter.getOne(adminClient, { id: row.meter.id })
                    expect(propertyMeter).toHaveProperty(path, dayjs(output).toISOString())
                } else {
                    const propertyMeterReading = await PropertyMeterReading.getOne(adminClient, { id: row.id })
                    expect(propertyMeterReading).toHaveProperty(path, dayjs(output).toISOString())
                }
            })
        })

        describe('error on invalid dates', () => {
            const invalidDates = [
                '[]',
                '12_23',
                'hello moto',
                '',
                '2024.28.05',
                '2024.05.28 13-13-13',
                '!2024-06-17',
                '2024-06',
                '06-2024',
                '2024.06',
                '06.2024',
                '2024-06-17 18:44',
                '17.06.2024 18:44',
                '2024-06-17 18:44:13',
                '17.06.2024 18:44:13',
                '17/06/2024 18:44:13',
                '2019-03-06T08:00:00+08:00',
                '!2042-06-17',
                '[]17.06.2042',
                '(2042-06',
                'hello06-2042',
                ']2042.06',
                '06.2042',
                '2042-06-17 18:44',
                '17.06.2042 18:44',
                '2042-06-17 18:44:13',
                '17.06.2042 18:44:13',
                '17/06/2042 18:44:13',
                '17/06/2042 18-44-13',
                '17-06-2042 18/44/13',
                '17/06/2042 18/44/13',
                '17-06-2042 18-44-13',
                '2024-09-22T09:03:25',
                '2024-22-09T09:03:25.000Z',
                '2024-22-09',
            ]

            const cases = invalidDates.flatMap((date) =>
                DATE_FIELD_PATHS.map(({ path }) => [date, path])
            )

            test.each(cases)('%p in %p should cause an error', async (invalidDate, dateFieldPath) => {
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestPropertyWithMap(adminClient, organization)

                const reading = createTestReadingData(property, {}, true)
                set(reading, dateFieldPath, invalidDate)

                // TODO(pahaz): DOMA-10348 refactor it to use expectToThrowGQLError (need more deep refactoring) !!
                await catchErrorFrom(
                    async () => await registerPropertyMetersReadingsByTestClient(adminClient, organization, [reading]),
                    ({ data, errors }) => {
                        expect(data).toEqual({ 'result': [null] })
                        expect(errors).toEqual([
                            expect.objectContaining({
                                name: 'GQLError',
                                message: 'Invalid date',
                                path: ['result', 0],
                                extensions: expect.objectContaining({
                                    'code': 'BAD_USER_INPUT',
                                    'type': 'INVALID_DATE',
                                    'message': 'Invalid date',
                                    'messageForUserTemplateKey': 'api.meter.registerMetersReadings.INVALID_DATE',
                                    'messageInterpolation': {
                                        'columnName': expect.any(String),
                                        'format': 'YYYY-MM-DDTHH:mm:ss.SSS[Z]", "YYYY-MM-DD',
                                    },
                                }),
                            }),
                        ])
                    },
                )
            })
        })

    })

    describe('Meter info dates saves as empty on empty input', () => {
        const dateFields = [
            'verificationDate',
            'nextVerificationDate',
            'installationDate',
            'commissioningDate',
            'sealingDate',
            'controlReadingsDate',
            'archiveDate',
        ]

        const emptyValues = [ null, undefined ]

        const cases = zip(dateFields, emptyValues)

        test.each(cases)('%p = %p should be saved as empty date', async (dateField, emptyValue) => {
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, organization)

            const reading = createTestReadingData(property, {}, true)
            reading.meterMeta[dateField] = emptyValue
            const [data] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, [reading])

            expect(data).toHaveLength(1)

            const row = data[0]

            const propertyMeter = await PropertyMeter.getOne(adminClient, { id: row.meter.id })
            expect(propertyMeter).toHaveProperty(dateField, null)
        })
    })

    test('prevent to create readings duplicates', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readings = [createTestReadingData(property, {}, true)]
        const [data] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                number: readings[0].meterNumber,
            }),
        })])

        const propertyMeters = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(propertyMeters).toHaveLength(1)
        expect(propertyMeters[0].number).toBe(readings[0].meterNumber)

        const propertyMeterReadings = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: map(propertyMeters, 'id') } })
        expect(propertyMeterReadings).toHaveLength(1)

        // send same data
        const [data2] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)

        // be sure that we have the same result
        expect(data2).toEqual(data)

        const propertyMeterReadings2 = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: map(propertyMeters, 'id') } })
        expect(propertyMeterReadings2).toHaveLength(1)
        expect(propertyMeterReadings[0].id).toBe(propertyMeterReadings2[0].id)
        expect(data2[0].id).toBe(propertyMeterReadings[0].id)
    })

    test('prevent to create readings duplicates in one input', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readingData = createTestReadingData(property, {}, true)
        const duplicateReadings = [readingData, readingData]

        const [data] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, duplicateReadings)

        expect(data).toHaveLength(2)
        expect(data[0].id).toEqual(data[1].id)
        expect(data).toEqual(expect.arrayContaining([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                number: duplicateReadings[0].meterNumber,
            }),
        })]))

        const propertyMeters = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(propertyMeters).toHaveLength(1)
        expect(propertyMeters[0].number).toBe(duplicateReadings[0].meterNumber)

        const propertyMeterReadings = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: map(propertyMeters, 'id') } })
        expect(propertyMeterReadings).toHaveLength(1)
    })

    test('prevent to create readings duplicates if date is within same day', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readingData = createTestReadingData(property, {}, true)
        const duplicateReadings = [readingData, { ...readingData, date: dayjs(readingData.date).add('1', 's').toISOString() }]

        const [data] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, duplicateReadings)

        expect(data).toHaveLength(2)
        expect(data[0].id).toEqual(data[1].id)
        expect(data).toEqual(expect.arrayContaining([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                number: duplicateReadings[0].meterNumber,
            }),
        })]))

        const propertyMeters = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(propertyMeters).toHaveLength(1)
        expect(propertyMeters[0].number).toBe(duplicateReadings[0].meterNumber)

        const propertyMeterReadings = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: map(propertyMeters, 'id') } })
        expect(propertyMeterReadings).toHaveLength(1)
    })

    test('update meter with data from last reading with same meter', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readingData = createTestReadingData(property, {}, true)

        const duplicateReadings = [readingData, {
            ...readingData,
            meterMeta: {
                numberOfTariffs: 3,
            },
        }]

        await registerPropertyMetersReadingsByTestClient(adminClient, organization, duplicateReadings)

        const propertyMeters = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })

        expect(propertyMeters).toHaveLength(1)
        expect(propertyMeters[0].number).toBe(duplicateReadings[0].meterNumber)
        expect(propertyMeters[0].nextVerificationDate).toBeFalsy()
        expect(propertyMeters[0].numberOfTariffs).toBe(3)
        expect(propertyMeters[0].isAutomatic).toBe(false)
    })

    test('can update existing property meter via this mutation', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const verificationDate1 = dayjs().add(2, 'week').toISOString()
        const readings = [createTestReadingData(property, {
            meterMeta: {
                numberOfTariffs: 2,
                verificationDate: verificationDate1,
            },
        }, true)]
        const [firstAttempt] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)

        // be sure that meter and meter reading was created successfully
        const propertyMeters = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(propertyMeters).toHaveLength(1)
        expect(propertyMeters[0].number).toBe(readings[0].meterNumber)
        expect(propertyMeters[0].nextVerificationDate).toBeFalsy()
        expect(propertyMeters[0].verificationDate).toBe(verificationDate1)
        expect(propertyMeters[0].isAutomatic).toBe(false)

        const propertyMeterReadings = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: map(propertyMeters, 'id') } })
        expect(propertyMeterReadings).toHaveLength(1)
        expect(propertyMeterReadings[0].meter.id).toBe(propertyMeters[0].id)

        // create another reading for same meter and change `verificationDate`, `nextVerificationDate` and `archiveDate` fields values
        const nextVerificationDate = dayjs().add(1, 'week').toISOString()
        const verificationDate2 = dayjs().subtract(1, 'week').toISOString()
        const archiveDate = dayjs().add(2, 'week').toISOString()
        const anotherReadings = [{
            ...readings[0],
            value1: faker.random.numeric(3),
            value2: faker.random.numeric(4),
            meterMeta: {
                ...readings[0].meterMeta,
                verificationDate: verificationDate2,
                nextVerificationDate,
                isAutomatic: true,
                archiveDate,
            },
        }]
        const [secondAttempt] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, anotherReadings)
        expect(firstAttempt[0].meter.id).toBe(secondAttempt[0].meter.id)

        // be sure that meter has changed verificationDate and nextVerificationDate
        const updatedPropertyMeters = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(updatedPropertyMeters).toHaveLength(1)
        expect(updatedPropertyMeters[0].id).toBe(updatedPropertyMeters[0].id)
        expect(updatedPropertyMeters[0].v).toBe(propertyMeters[0].v + 1)
        expect(updatedPropertyMeters[0].number).toBe(readings[0].meterNumber)
        expect(updatedPropertyMeters[0].verificationDate).toBe(verificationDate2)
        expect(updatedPropertyMeters[0].nextVerificationDate).toBeTruthy()
        expect(updatedPropertyMeters[0].archiveDate).toBe(archiveDate)
        expect(updatedPropertyMeters[0].isAutomatic).toBe(true)

        // sent third readings with isAutomatic = false, 'verificationDate' must stay the same
        const thirdReadings = [{
            ...readings[0],
            value1: faker.random.numeric(3),
            value2: faker.random.numeric(4),
            meterMeta: {
                isAutomatic: false,
            },
        }]
        const [thirdAttempt] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, thirdReadings)
        expect(firstAttempt[0].meter.id).toBe(thirdAttempt[0].meter.id)

        const updatedPropertyMeters2 = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(updatedPropertyMeters2).toHaveLength(1)
        expect(updatedPropertyMeters2[0].id).toBe(propertyMeters[0].id)
        expect(updatedPropertyMeters2[0].number).toBe(readings[0].meterNumber)
        expect(updatedPropertyMeters2[0].verificationDate).toBe(verificationDate2)
        expect(updatedPropertyMeters2[0].numberOfTariffs).toBe(2)
        expect(updatedPropertyMeters2[0].nextVerificationDate).toBeTruthy()
        expect(updatedPropertyMeters2[0].isAutomatic).toBe(false)

        // be sure that keep same value from creation
        expect(propertyMeters[0].controlReadingsDate).toBe(updatedPropertyMeters2[0].controlReadingsDate)
    })

    test('property meter not updated if no fields changed', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readings = [createTestReadingData(property, {
            meterMeta: {
                numberOfTariffs: 2,
            },
        }, true)]
        await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)
        const propertyMeters = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })

        // create another reading for same property meter (keep all meter fields as is)
        const anotherReadings = [{
            ...readings[0],
            value1: faker.random.numeric(3),
            value2: faker.random.numeric(4),
            meterMeta: {
                numberOfTariffs: 2, // keep same numberOfTariffs
            },
        }]
        await registerPropertyMetersReadingsByTestClient(adminClient, organization, anotherReadings)

        // be sure that meter has same numberOfTariffs
        const notUpdatedPropertyMeters = await PropertyMeter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(notUpdatedPropertyMeters).toHaveLength(1)
        expect(notUpdatedPropertyMeters[0].id).toBe(propertyMeters[0].id)
        expect(notUpdatedPropertyMeters[0].v).toBe(propertyMeters[0].v)
        expect(notUpdatedPropertyMeters[0].numberOfTariffs).toBe(2)
    })

    test('default reading source if not passed', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readings = [
            createTestReadingData(property, {}, true),
            createTestReadingData(property, { readingSource: { id: REMOTE_SYSTEM_METER_READING_SOURCE_ID } }, true),
        ]
        const [data] = await registerPropertyMetersReadingsByTestClient(adminClient, organization, readings)
        const propertyMeterReadings = await PropertyMeterReading.getAll(adminClient, { meter: { id_in: data.map((row) => row.meter.id) } }, { sortBy: 'createdAt_ASC' })

        expect(propertyMeterReadings).toEqual([
            expect.objectContaining({ source: expect.objectContaining({ id: OTHER_METER_READING_SOURCE_ID }) }),
            expect.objectContaining({ source: expect.objectContaining({ id: REMOTE_SYSTEM_METER_READING_SOURCE_ID }) }),
        ])
    })

})