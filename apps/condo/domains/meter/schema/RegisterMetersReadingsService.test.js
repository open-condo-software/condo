/**
 * Generated by `createservice meter.RegisterMetersReadingsService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { map, flatten } = require('lodash')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult, expectToThrowGQLError, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const { UUID_REGEXP } = require('@condo/domains/common/constants/regexps')
const {
    COLD_WATER_METER_RESOURCE_ID,
    HOT_WATER_METER_RESOURCE_ID,
} = require('@condo/domains/meter/constants/constants')
const { registerMetersReadingsByTestClient, Meter, MeterReading } = require('@condo/domains/meter/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRight, createTestB2BAppAccessRightSet,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    createTestOrganization,
    makeEmployeeUserClientWithAbilities,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

/**
 * @param {Pick<Property, 'address'>} property
 * @param {Partial<RegisterMetersReadingsReadingInput>} extraAttrs
 * @return {RegisterMetersReadingsReadingInput}
 */
const createTestReadingData = (property, extraAttrs = {}) => ({
    address: property.address,
    addressMeta: {
        unitType: FLAT_UNIT_TYPE,
        unitName: faker.random.alphaNumeric(4),
        globalId: faker.datatype.uuid(),
    },
    accountNumber: faker.random.alphaNumeric(12),
    meterNumber: faker.random.numeric(8),
    meterResource: { id: COLD_WATER_METER_RESOURCE_ID },
    date: dayjs().toISOString(),
    value1: faker.random.numeric(3),
    value2: faker.random.numeric(4),
    meterMeta: {
        numberOfTariffs: 1,
    },
    ...extraAttrs,
})

describe('RegisterMetersReadingsService', () => {

    let adminClient, supportClient, residentClient, anonymousClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        residentClient = await makeClientWithResidentUser()
        anonymousClient = await makeClient()
    })

    describe('access to execution', () => {

        let o10n

        beforeAll(async () => {
            [o10n] = await createTestOrganization(adminClient)
        })

        test('admin can', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)
            const readings = [createTestReadingData(property)]
            const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                value1: Number(readings[0].value1).toFixed(4),
                value2: Number(readings[0].value2).toFixed(4),
                value3: null,
                value4: null,
                date: readings[0].date,
                organization: expect.objectContaining({
                    id: o10n.id,
                }),
                meter: expect.objectContaining({
                    number: readings[0].meterNumber,
                    organization: expect.objectContaining({
                        id: o10n.id,
                    }),
                    property: expect.objectContaining({
                        id: property.id,
                    }),
                    resource: expect.objectContaining({
                        id: readings[0].meterResource.id,
                    }),
                }),
            })])

            const meters = await Meter.getAll(adminClient, {
                organization: { id: o10n.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
            expect(metersReadings[0].date).toBe(readings[0].date)
        })

        test('support can', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)
            const readings = [createTestReadingData(property)]
            const [data] = await registerMetersReadingsByTestClient(supportClient, o10n, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                value1: Number(readings[0].value1).toFixed(4),
                value2: Number(readings[0].value2).toFixed(4),
                value3: null,
                value4: null,
                date: readings[0].date,
                organization: expect.objectContaining({
                    id: o10n.id,
                }),
                meter: expect.objectContaining({
                    number: readings[0].meterNumber,
                    organization: expect.objectContaining({
                        id: o10n.id,
                    }),
                    property: expect.objectContaining({
                        id: property.id,
                    }),
                    resource: expect.objectContaining({
                        id: readings[0].meterResource.id,
                    }),
                }),
            })])

            const meters = await Meter.getAll(adminClient, {
                organization: { id: o10n.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
            expect(metersReadings[0].date).toBe(readings[0].date)
        })

        describe('staff', () => {
            test('with permissions can', async () => {
                const staffClient = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                    canManageMeterReadings: true,
                })

                const readings = [createTestReadingData(staffClient.property)]
                const [data] = await registerMetersReadingsByTestClient(staffClient, staffClient.organization, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    value1: Number(readings[0].value1).toFixed(4),
                    value2: Number(readings[0].value2).toFixed(4),
                    value3: null,
                    value4: null,
                    date: readings[0].date,
                    organization: expect.objectContaining({
                        id: staffClient.organization.id,
                    }),
                    meter: expect.objectContaining({
                        number: readings[0].meterNumber,
                        organization: expect.objectContaining({
                            id: staffClient.organization.id,
                        }),
                        property: expect.objectContaining({
                            id: staffClient.property.id,
                        }),
                        resource: expect.objectContaining({
                            id: readings[0].meterResource.id,
                        }),
                    }),
                })])

                const meters = await Meter.getAll(adminClient, {
                    organization: { id: staffClient.organization.id },
                    property: { id: staffClient.property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
                expect(metersReadings[0].date).toBe(readings[0].date)
            })

            test('without permissions can\'t', async () => {
                const staffClient = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                    canManageMeterReadings: false,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient, staffClient.organization, [])
                })
            })
        })

        describe('service user', () => {
            test('with access rights can', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [o10n] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, o10n)

                const [app] = await createTestB2BApp(adminClient)
                await createTestB2BAppContext(adminClient, app, o10n, { status: 'Finished' })
                const [accessRightSet] = await createTestB2BAppAccessRightSet(adminClient, app, {
                    canExecuteRegisterMetersReadings: true,
                    canReadMeters: true,
                    canReadMeterReadings: true,
                    canReadOrganizations: true,
                    canReadProperties: true,
                })
                await createTestB2BAppAccessRight(adminClient, serviceClient.user, app, accessRightSet)

                const readings = [createTestReadingData(property)]
                const [data] = await registerMetersReadingsByTestClient(serviceClient, o10n, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    value1: Number(readings[0].value1).toFixed(4),
                    value2: Number(readings[0].value2).toFixed(4),
                    value3: null,
                    value4: null,
                    date: readings[0].date,
                    organization: expect.objectContaining({
                        id: o10n.id,
                    }),
                    meter: expect.objectContaining({
                        number: readings[0].meterNumber,
                        organization: expect.objectContaining({
                            id: o10n.id,
                        }),
                        property: expect.objectContaining({
                            id: property.id,
                        }),
                        resource: expect.objectContaining({
                            id: readings[0].meterResource.id,
                        }),
                    }),
                })])

                const meters = await Meter.getAll(adminClient, {
                    organization: { id: o10n.id },
                    property: { id: property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
                expect(metersReadings[0].date).toBe(readings[0].date)
            })

            test('without permissions can\'t', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [o10n] = await createTestOrganization(adminClient)

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(serviceClient, o10n, [])
                })
            })
        })

        test('resident can\'t execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerMetersReadingsByTestClient(residentClient, o10n, [])
            })
        })

        test('anonymous can\'t execute', async () => {
            await expectToThrowAuthenticationError(async () => {
                await registerMetersReadingsByTestClient(anonymousClient, o10n, [])
            }, 'result')
        })
    })

    test('error on too much items', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        await expectToThrowGQLError(
            async () => await registerMetersReadingsByTestClient(
                adminClient,
                o10n,
                flatten(Array(501).fill(createTestReadingData({ address: faker.address.streetAddress(true) }))),
            ),
            {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MUCH_READINGS',
                message: 'Too much readings. Maximum is 500.',
                messageForUser: 'api.meter.registerMetersReadings.TOO_MUCH_READINGS',
                messageInterpolation: { limit: 500, sentCount: 501 },
            },
            'result',
        )
    })

    test('Check for Meter model error: cannot create Meter if Meter with same accountNumber exist in user organization in other unit', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestProperty(adminClient, o10n)
        const [property2] = await createTestProperty(adminClient, o10n)

        const accountNumber = faker.random.alphaNumeric(12)

        const readings1 = [createTestReadingData(property1)]
        readings1[0].accountNumber = accountNumber

        await registerMetersReadingsByTestClient(adminClient, o10n, readings1)

        const readings2 = [createTestReadingData(property2)]
        readings2[0].accountNumber = accountNumber

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings2)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([null])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create Meter internal error',
                        originalError: expect.objectContaining({
                            message: '[error] Create Meter internal error',
                            errors: [expect.objectContaining({
                                data: expect.objectContaining({
                                    messages: ['[unique:alreadyExists:accountNumber] Meter with same account number exist in current organization in other unit'],
                                }),
                            })],
                        }),
                    }),
                ])
            },
        )
    })

    test('error if organization not exists', async () => {
        await expectToThrowGQLError(
            async () => await registerMetersReadingsByTestClient(adminClient, { id: faker.datatype.uuid() }, []),
            {
                code: 'BAD_USER_INPUT',
                type: 'ORGANIZATION_NOT_FOUND',
                message: 'Organization not found',
                messageForUser: 'api.meter.registerMetersReadings.ORGANIZATION_NOT_FOUND',
            },
            'result',
        )
    })

    test('error for row if trying to add meter reading for property which not added to organization', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestProperty(adminClient, o10n)
        const [property2] = await createTestProperty(adminClient, o10n)

        const readings = [
            createTestReadingData(property1),
            createTestReadingData({ address: faker.address.streetAddress(true) }),
            createTestReadingData(property2),
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        value1: Number(readings[0].value1).toFixed(4),
                        value2: Number(readings[0].value2).toFixed(4),
                        organization: expect.objectContaining({
                            id: o10n.id,
                        }),
                    }),
                    null,
                    expect.objectContaining({
                        value1: Number(readings[2].value1).toFixed(4),
                        value2: Number(readings[2].value2).toFixed(4),
                        organization: expect.objectContaining({
                            id: o10n.id,
                        }),
                    }),
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Property not found',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'PROPERTY_NOT_FOUND',
                            message: 'Property not found',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid meter value', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, o10n)

        const badReading = createTestReadingData(property, { meterResource: { id: HOT_WATER_METER_RESOURCE_ID } })
        badReading.value1 = '-100500'

        const readings = [
            createTestReadingData(property),
            badReading,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        value1: Number(readings[0].value1).toFixed(4),
                        value2: Number(readings[0].value2).toFixed(4),
                        organization: expect.objectContaining({
                            id: o10n.id,
                        }),
                    }),
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid meter value',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUE',
                            message: 'Invalid meter value',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid meter resource', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestProperty(adminClient, o10n)

        const badReading = createTestReadingData(property1)
        badReading.meterResource = { id: faker.datatype.uuid() }

        const readings = [
            createTestReadingData(property1),
            badReading,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        value1: Number(readings[0].value1).toFixed(4),
                        value2: Number(readings[0].value2).toFixed(4),
                        organization: expect.objectContaining({
                            id: o10n.id,
                        }),
                    }),
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create Meter internal error',
                        originalError: expect.objectContaining({
                            message: '[error] Create Meter internal error',
                            errors: [expect.objectContaining({
                                message: 'Unable to connect a Meter.resource<MeterResource>',
                            })],
                        }),
                    }),
                ])
            },
        )
    })
})
