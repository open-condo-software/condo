/**
 * Generated by `createservice meter.RegisterMetersReadingsService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { get, map, flatten } = require('lodash')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult, expectToThrowGQLError, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const { UUID_REGEXP } = require('@condo/domains/common/constants/regexps')
const {
    COLD_WATER_METER_RESOURCE_ID,
    HOT_WATER_METER_RESOURCE_ID,
    ELECTRICITY_METER_RESOURCE_ID,
    HEAT_SUPPLY_METER_RESOURCE_ID,
    GAS_SUPPLY_METER_RESOURCE_ID,
} = require('@condo/domains/meter/constants/constants')
const { registerMetersReadingsByTestClient, Meter, MeterReading } = require('@condo/domains/meter/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRight, createTestB2BAppAccessRightSet,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    createTestOrganization,
    makeEmployeeUserClientWithAbilities,
} = require('@condo/domains/organization/utils/testSchema')
const { FLAT_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

/**
 * @param {Pick<Property, 'address'>} property
 * @param {Partial<RegisterMetersReadingsReadingInput>} extraAttrs
 * @return {RegisterMetersReadingsReadingInput}
 */
const createTestReadingData = (property, extraAttrs = {}) => ({
    address: property.address,
    addressInfo: {
        unitType: FLAT_UNIT_TYPE,
        unitName: faker.random.alphaNumeric(4),
        globalId: get(property, ['addressMeta', 'data', 'house_fias_id'], faker.datatype.uuid()),
    },
    accountNumber: faker.random.alphaNumeric(12),
    meterNumber: faker.random.numeric(8),
    meterResource: { id: COLD_WATER_METER_RESOURCE_ID },
    date: dayjs().toISOString(),
    value1: faker.random.numeric(3),
    value2: faker.random.numeric(4),
    meterMeta: {
        numberOfTariffs: 2,
    },
    ...extraAttrs,
})

describe('RegisterMetersReadingsService', () => {

    let adminClient, supportClient, residentClient, anonymousClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        residentClient = await makeClientWithResidentUser()
        anonymousClient = await makeClient()
    })

    describe('access to execution', () => {

        let o10n

        beforeAll(async () => {
            [o10n] = await createTestOrganization(adminClient)
        })

        test('admin can', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)
            const readings = [createTestReadingData(property)]
            const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                meter: expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    property: expect.objectContaining({
                        id: property.id,
                        address: property.address,
                        addressKey: property.addressKey,
                    }),
                    unitType: readings[0].addressInfo.unitType,
                    unitName: readings[0].addressInfo.unitName,
                    accountNumber: readings[0].accountNumber,
                    number: readings[0].meterNumber,
                }),
            })])

            const meters = await Meter.getAll(adminClient, {
                organization: { id: o10n.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
            expect(metersReadings[0].date).toBe(readings[0].date)
        })

        test('support can', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestProperty(adminClient, o10n)
            const readings = [createTestReadingData(property)]
            const [data] = await registerMetersReadingsByTestClient(supportClient, o10n, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                meter: expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    property: expect.objectContaining({
                        id: property.id,
                        address: property.address,
                        addressKey: property.addressKey,
                    }),
                    unitType: readings[0].addressInfo.unitType,
                    unitName: readings[0].addressInfo.unitName,
                    accountNumber: readings[0].accountNumber,
                    number: readings[0].meterNumber,
                }),
            })])

            const meters = await Meter.getAll(adminClient, {
                organization: { id: o10n.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
            expect(metersReadings[0].date).toBe(readings[0].date)
        })

        describe('staff', () => {
            test('with permissions can', async () => {
                const staffClient = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                    canManageMeterReadings: true,
                })

                const readings = [createTestReadingData(staffClient.property)]
                const [data] = await registerMetersReadingsByTestClient(staffClient, staffClient.organization, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    meter: expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        property: expect.objectContaining({
                            id: staffClient.property.id,
                            address: staffClient.property.address,
                            addressKey: staffClient.property.addressKey,
                        }),
                        unitType: readings[0].addressInfo.unitType,
                        unitName: readings[0].addressInfo.unitName,
                        accountNumber: readings[0].accountNumber,
                        number: readings[0].meterNumber,
                    }),
                })])

                const meters = await Meter.getAll(adminClient, {
                    organization: { id: staffClient.organization.id },
                    property: { id: staffClient.property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
                expect(metersReadings[0].date).toBe(readings[0].date)
            })

            test('without permissions can\'t', async () => {
                const staffClient1 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                    canManageMeterReadings: false,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient1, staffClient1.organization, [])
                })

                const staffClient2 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                    canManageMeterReadings: false,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient2, staffClient2.organization, [])
                })

                const staffClient3 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                    canManageMeterReadings: true,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient3, staffClient3.organization, [])
                })
            })
        })

        describe('service user', () => {
            test('with access rights can', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [o10n] = await createTestOrganization(adminClient)
                const [property] = await createTestProperty(adminClient, o10n)

                const [app] = await createTestB2BApp(adminClient)
                await createTestB2BAppContext(adminClient, app, o10n, { status: 'Finished' })
                const [accessRightSet] = await createTestB2BAppAccessRightSet(adminClient, app, {
                    canExecuteRegisterMetersReadings: true,
                    canReadMeters: true,
                    canReadMeterReadings: true,
                    canReadOrganizations: true,
                    canReadProperties: true,
                })
                await createTestB2BAppAccessRight(adminClient, serviceClient.user, app, accessRightSet)

                const readings = [createTestReadingData(property)]
                const [data] = await registerMetersReadingsByTestClient(serviceClient, o10n, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    meter: expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        property: expect.objectContaining({
                            id: property.id,
                            address: property.address,
                            addressKey: property.addressKey,
                        }),
                        unitType: readings[0].addressInfo.unitType,
                        unitName: readings[0].addressInfo.unitName,
                        accountNumber: readings[0].accountNumber,
                        number: readings[0].meterNumber,
                    }),
                })])

                const meters = await Meter.getAll(adminClient, {
                    organization: { id: o10n.id },
                    property: { id: property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
                expect(metersReadings[0].date).toBe(readings[0].date)
            })

            test('without permissions can\'t', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [o10n] = await createTestOrganization(adminClient)

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(serviceClient, o10n, [])
                })
            })
        })

        test('resident can\'t execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerMetersReadingsByTestClient(residentClient, o10n, [])
            })
        })

        test('anonymous can\'t execute', async () => {
            await expectToThrowAuthenticationError(async () => {
                await registerMetersReadingsByTestClient(anonymousClient, o10n, [])
            }, 'result')
        })
    })

    test('error on too much items', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        await expectToThrowGQLError(
            async () => await registerMetersReadingsByTestClient(
                adminClient,
                o10n,
                flatten(Array(501).fill(createTestReadingData({ address: faker.address.streetAddress(true) }))),
            ),
            {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MUCH_READINGS',
                message: 'Too much readings. Maximum is 500.',
                messageForUser: 'api.meter.registerMetersReadings.TOO_MUCH_READINGS',
                messageInterpolation: { limit: 500, sentCount: 501 },
            },
            'result',
        )
    })

    test('possible to process 500 meters readings for single address', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, o10n)

        const count = 500
        const readings = []
        for (let i = 0; i < count; i++) {
            readings.push(createTestReadingData(property))
        }

        const [result] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

        expect(result).toHaveLength(count)
    })

    test('possible to process 500 meters readings for different addresses', async () => {
        const [o10n] = await createTestOrganization(adminClient)

        const count = 500
        const readings = []
        for (let i = 0; i < count; i++) {
            const [property] = await createTestProperty(adminClient, o10n)
            readings.push(createTestReadingData(property))
        }

        const [result] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

        expect(result).toHaveLength(count)
    })

    test('Check for Meter model error: cannot create Meter if Meter with same accountNumber exist in user organization in other unit', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestProperty(adminClient, o10n)
        const [property2] = await createTestProperty(adminClient, o10n)

        const accountNumber = faker.random.alphaNumeric(12)

        const readings1 = [createTestReadingData(property1)]
        readings1[0].accountNumber = accountNumber

        await registerMetersReadingsByTestClient(adminClient, o10n, readings1)

        const readings2 = [createTestReadingData(property2)]
        readings2[0].accountNumber = accountNumber

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings2)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([null])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create Meter internal error',
                        originalError: expect.objectContaining({
                            message: '[error] Create Meter internal error',
                            errors: [expect.objectContaining({
                                data: expect.objectContaining({
                                    messages: ['[unique:alreadyExists:accountNumber] Meter with same account number exist in current organization in other unit'],
                                }),
                            })],
                        }),
                    }),
                ])
            },
        )
    })

    test('error if organization not exists', async () => {
        await expectToThrowGQLError(
            async () => await registerMetersReadingsByTestClient(adminClient, { id: faker.datatype.uuid() }, []),
            {
                code: 'BAD_USER_INPUT',
                type: 'ORGANIZATION_NOT_FOUND',
                message: 'Organization not found',
                messageForUser: 'api.meter.registerMetersReadings.ORGANIZATION_NOT_FOUND',
            },
            'result',
        )
    })

    test('error for row if trying to add meter reading for property which not added to organization', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestProperty(adminClient, o10n)
        const [property2] = await createTestProperty(adminClient, o10n)

        const readings = [
            createTestReadingData(property1),
            createTestReadingData({ address: faker.address.streetAddress(true) }),
            createTestReadingData(property2),
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property1.id,
                                address: property1.address,
                                addressKey: property1.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property2.id,
                                address: property2.address,
                                addressKey: property2.addressKey,
                            }),
                            unitType: readings[2].addressInfo.unitType,
                            unitName: readings[2].addressInfo.unitName,
                            accountNumber: readings[2].accountNumber,
                            number: readings[2].meterNumber,
                        }),
                    }),
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Property not found',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'PROPERTY_NOT_FOUND',
                            message: 'Property not found',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid meter value', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, o10n)

        const badReading1 = createTestReadingData(property, {
            meterResource: { id: GAS_SUPPLY_METER_RESOURCE_ID },
            value1: '-100500',
            value2: undefined,
        })

        const badReading2 = createTestReadingData(property, {
            meterResource: { id: ELECTRICITY_METER_RESOURCE_ID },
            value1: 'oops',
            value2: undefined,
        })

        const badReading3 = createTestReadingData(property, {
            meterResource: { id: HEAT_SUPPLY_METER_RESOURCE_ID },
            value1: 'Infinity',
            value2: undefined,
        })

        const readings = [
            createTestReadingData(property),
            badReading1,
            badReading2,
            badReading3,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            (err) => {
                const { data: { result }, errors } = err
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property.id,
                                address: property.address,
                                addressKey: property.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                    null,
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid meter resource', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestProperty(adminClient, o10n)

        const badReading = createTestReadingData(property1)
        badReading.meterResource = { id: faker.datatype.uuid() }

        const readings = [
            createTestReadingData(property1),
            badReading,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property1.id,
                                address: property1.address,
                                addressKey: property1.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create Meter internal error',
                        originalError: expect.objectContaining({
                            message: '[error] Create Meter internal error',
                            errors: [expect.objectContaining({
                                message: 'Unable to connect a Meter.resource<MeterResource>',
                            })],
                        }),
                    }),
                ])
            },
        )
    })

    test('number of tariffs calculated correctly', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestProperty(adminClient, o10n)
        const reading = createTestReadingData(property)
        reading.value3 = faker.random.numeric(3)
        reading.meterMeta.numberOfTariffs = undefined

        const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, [reading])

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                unitType: reading.addressInfo.unitType,
                unitName: reading.addressInfo.unitName,
                accountNumber: reading.accountNumber,
                number: reading.meterNumber,
            }),
        })])

        const meters = await Meter.getAll(adminClient, {
            organization: { id: o10n.id },
            property: { id: property.id },
        })
        expect(meters).toEqual([
            expect.objectContaining({ numberOfTariffs: 3 }),
        ])
    })
})
