/**
 * Generated by `createservice meter.RegisterMetersReadingsService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { map, flatten } = require('lodash')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult, expectToThrowGQLError, catchErrorFrom,
} = require('@open-condo/keystone/test.utils')
const { i18n } = require('@open-condo/locales/loader')

const { UUID_REGEXP } = require('@condo/domains/common/constants/regexps')
const {
    ELECTRICITY_METER_RESOURCE_ID,
    HEAT_SUPPLY_METER_RESOURCE_ID,
    GAS_SUPPLY_METER_RESOURCE_ID,
    OTHER_METER_READING_SOURCE_ID,
    REMOTE_SYSTEM_METER_READING_SOURCE_ID,
} = require('@condo/domains/meter/constants/constants')
const {
    registerMetersReadingsByTestClient,
    Meter,
    MeterReading,
    createTestReadingData,
} = require('@condo/domains/meter/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRight, createTestB2BAppAccessRightSet,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    createTestOrganization,
    makeEmployeeUserClientWithAbilities,
} = require('@condo/domains/organization/utils/testSchema')
const { PARKING_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { createTestPropertyWithMap } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')

describe('RegisterMetersReadingsService', () => {

    let adminClient, supportClient, residentClient, anonymousClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        residentClient = await makeClientWithResidentUser()
        anonymousClient = await makeClient()
    })

    describe('access to execution', () => {

        let o10n

        beforeAll(async () => {
            [o10n] = await createTestOrganization(adminClient)
        })

        test('admin can', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, o10n)
            const readings = [createTestReadingData(property)]
            const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                meter: expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    property: expect.objectContaining({
                        id: property.id,
                        address: property.address,
                        addressKey: property.addressKey,
                    }),
                    unitType: readings[0].addressInfo.unitType,
                    unitName: readings[0].addressInfo.unitName,
                    accountNumber: readings[0].accountNumber,
                    number: readings[0].meterNumber,
                }),
            })])

            const meters = await Meter.getAll(adminClient, {
                organization: { id: o10n.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
        })

        test('support can', async () => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, o10n)
            const readings = [createTestReadingData(property)]
            const [data] = await registerMetersReadingsByTestClient(supportClient, o10n, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                meter: expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    property: expect.objectContaining({
                        id: property.id,
                        address: property.address,
                        addressKey: property.addressKey,
                    }),
                    unitType: readings[0].addressInfo.unitType,
                    unitName: readings[0].addressInfo.unitName,
                    accountNumber: readings[0].accountNumber,
                    number: readings[0].meterNumber,
                }),
            })])

            const meters = await Meter.getAll(adminClient, {
                organization: { id: o10n.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
        })

        describe('staff', () => {
            test('with permissions can', async () => {
                const staffClient = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                    canManageMeterReadings: true,
                })

                const readings = [createTestReadingData(staffClient.property)]
                const [data] = await registerMetersReadingsByTestClient(staffClient, staffClient.organization, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    meter: expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        property: expect.objectContaining({
                            id: staffClient.property.id,
                            address: staffClient.property.address,
                            addressKey: staffClient.property.addressKey,
                        }),
                        unitType: readings[0].addressInfo.unitType,
                        unitName: readings[0].addressInfo.unitName,
                        accountNumber: readings[0].accountNumber,
                        number: readings[0].meterNumber,
                    }),
                })])

                const meters = await Meter.getAll(adminClient, {
                    organization: { id: staffClient.organization.id },
                    property: { id: staffClient.property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
            })

            test('without permissions can\'t', async () => {
                const staffClient1 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                    canManageMeterReadings: false,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient1, staffClient1.organization, [])
                })

                const staffClient2 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                    canManageMeterReadings: false,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient2, staffClient2.organization, [])
                })

                const staffClient3 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                    canManageMeterReadings: true,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient3, staffClient3.organization, [])
                })
            })
        })

        describe('service user', () => {
            test('with access rights can', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [o10n] = await createTestOrganization(adminClient)
                const [property] = await createTestPropertyWithMap(adminClient, o10n)

                const [app] = await createTestB2BApp(adminClient)
                await createTestB2BAppContext(adminClient, app, o10n, { status: 'Finished' })
                const [accessRightSet] = await createTestB2BAppAccessRightSet(adminClient, app, {
                    canExecuteRegisterMetersReadings: true,
                    canReadMeters: true,
                    canReadMeterReadings: true,
                    canReadOrganizations: true,
                    canReadProperties: true,
                })
                await createTestB2BAppAccessRight(adminClient, serviceClient.user, app, accessRightSet)

                const readings = [createTestReadingData(property)]
                const [data] = await registerMetersReadingsByTestClient(serviceClient, o10n, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    meter: expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        property: expect.objectContaining({
                            id: property.id,
                            address: property.address,
                            addressKey: property.addressKey,
                        }),
                        unitType: readings[0].addressInfo.unitType,
                        unitName: readings[0].addressInfo.unitName,
                        accountNumber: readings[0].accountNumber,
                        number: readings[0].meterNumber,
                    }),
                })])

                const meters = await Meter.getAll(adminClient, {
                    organization: { id: o10n.id },
                    property: { id: property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
            })

            test('without permissions can\'t', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [o10n] = await createTestOrganization(adminClient)

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(serviceClient, o10n, [])
                })
            })
        })

        test('resident can\'t execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerMetersReadingsByTestClient(residentClient, o10n, [])
            })
        })

        test('anonymous can\'t execute', async () => {
            await expectToThrowAuthenticationError(async () => {
                await registerMetersReadingsByTestClient(anonymousClient, o10n, [])
            }, 'result')
        })
    })

    test('error on too much items', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        await expectToThrowGQLError(
            async () => await registerMetersReadingsByTestClient(
                adminClient,
                o10n,
                flatten(Array(501).fill(createTestReadingData({ address: faker.address.streetAddress(true) }))),
            ),
            {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MUCH_READINGS',
                message: 'Too much readings. Maximum is 500.',
                messageForUser: 'api.meter.registerMetersReadings.TOO_MUCH_READINGS',
                messageInterpolation: { limit: 500, sentCount: 501 },
            },
            'result',
        )
    })

    test('Check for Meter model error: cannot create Meter if Meter with same accountNumber exist in user organization in other unit', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, o10n)
        const [property2] = await createTestPropertyWithMap(adminClient, o10n)

        const accountNumber = faker.random.alphaNumeric(12)

        const readings1 = [createTestReadingData(property1)]
        readings1[0].accountNumber = accountNumber

        await registerMetersReadingsByTestClient(adminClient, o10n, readings1)

        const readings2 = [createTestReadingData(property2)]
        readings2[0].accountNumber = accountNumber

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings2)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([null])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create Meter internal error',
                        name: 'GraphQLError',
                        originalError: expect.objectContaining({
                            message: '[error] Create Meter internal error',
                            errors: [expect.objectContaining({
                                message: 'Meter with same account number exist in current organization in other unit',
                                name: 'GQLError',
                                extensions: expect.objectContaining({
                                    code: 'BAD_USER_INPUT',
                                    type: 'SAME_ACCOUNT_NUMBER_EXISTS_IN_OTHER_UNIT',
                                    message: 'Meter with same account number exist in current organization in other unit',
                                    messageInterpolation: { unitsCsv: `${readings1[0].addressInfo.unitType} ${readings1[0].addressInfo.unitName}` },
                                }),
                            })],
                        }),
                    }),
                ])
            },
        )
    })

    test('error if organization not exists', async () => {
        await expectToThrowGQLError(
            async () => await registerMetersReadingsByTestClient(adminClient, { id: faker.datatype.uuid() }, []),
            {
                code: 'BAD_USER_INPUT',
                type: 'ORGANIZATION_NOT_FOUND',
                message: 'Organization not found',
                messageForUser: 'api.meter.registerMetersReadings.ORGANIZATION_NOT_FOUND',
            },
            'result',
        )
    })

    test('error for row if trying to add meter reading for property which not added to organization', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, o10n)
        const [property2] = await createTestPropertyWithMap(adminClient, o10n)

        const readings = [
            createTestReadingData(property1),
            createTestReadingData({ address: faker.address.streetAddress(true) }),
            createTestReadingData(property2),
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property1.id,
                                address: property1.address,
                                addressKey: property1.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property2.id,
                                address: property2.address,
                                addressKey: property2.addressKey,
                            }),
                            unitType: readings[2].addressInfo.unitType,
                            unitName: readings[2].addressInfo.unitName,
                            accountNumber: readings[2].accountNumber,
                            number: readings[2].meterNumber,
                        }),
                    }),
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Property not found',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'PROPERTY_NOT_FOUND',
                            message: 'Property not found',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid meter value', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, o10n)

        const badReading1 = createTestReadingData(property, {
            meterResource: { id: GAS_SUPPLY_METER_RESOURCE_ID },
            value1: '-100500',
            value2: undefined,
        })

        const badReading2 = createTestReadingData(property, {
            meterResource: { id: ELECTRICITY_METER_RESOURCE_ID },
            value1: 'oops',
            value2: undefined,
        })

        const badReading3 = createTestReadingData(property, {
            meterResource: { id: HEAT_SUPPLY_METER_RESOURCE_ID },
            value1: 'Infinity',
            value2: undefined,
        })

        const readings = [
            createTestReadingData(property),
            badReading1,
            badReading2,
            badReading3,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            (err) => {
                const { data: { result }, errors } = err
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property.id,
                                address: property.address,
                                addressKey: property.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                    null,
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid meter resource', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, o10n)

        const badReading = createTestReadingData(property1)
        badReading.meterResource = { id: faker.datatype.uuid() }

        const readings = [
            createTestReadingData(property1),
            badReading,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property1.id,
                                address: property1.address,
                                addressKey: property1.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create Meter internal error',
                        originalError: expect.objectContaining({
                            message: '[error] Create Meter internal error',
                            errors: [expect.objectContaining({
                                message: expect.stringContaining('insert or update on table "Meter" violates foreign key constraint'),
                            })],
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid number of tariffs passed', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, o10n)

        const badReading = createTestReadingData(property1)
        badReading.meterMeta.numberOfTariffs = 5

        const readings = [
            createTestReadingData(property1),
            badReading,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property1.id,
                                address: property1.address,
                                addressKey: property1.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create Meter internal error',
                        originalError: expect.objectContaining({
                            message: '[error] Create Meter internal error',
                            errors: [expect.objectContaining({
                                message: 'Provided number of tariffs is not valid. Must be an integer from 1 to 4.',
                            })],
                        }),
                    }),
                ])
            },
        )
    })

    test('number of tariffs calculated correctly', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, o10n)
        const reading = createTestReadingData(property)
        reading.value3 = faker.random.numeric(3)
        reading.meterMeta.numberOfTariffs = undefined

        const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, [reading])

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                unitType: reading.addressInfo.unitType,
                unitName: reading.addressInfo.unitName,
                accountNumber: reading.accountNumber,
                number: reading.meterNumber,
            }),
        })])

        const meters = await Meter.getAll(adminClient, {
            organization: { id: o10n.id },
            property: { id: property.id },
        })
        expect(meters).toEqual([
            expect.objectContaining({ numberOfTariffs: 3 }),
        ])
    })

    test('possible import with un-existing unit', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, o10n)

        const normalReading = createTestReadingData(property1)

        const readingWithBadFlat = createTestReadingData(property1)
        readingWithBadFlat.addressInfo.unitName = faker.datatype.string(4)

        const readingWithBadParking = createTestReadingData(property1)
        readingWithBadParking.addressInfo.unitType = PARKING_UNIT_TYPE
        readingWithBadParking.addressInfo.unitName = faker.datatype.string(4)

        const readings = [
            normalReading,
            readingWithBadFlat,
            readingWithBadParking,
        ]

        const [result] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

        expect(result).toEqual([
            expect.objectContaining({ meter: expect.objectContaining({ unitType: normalReading.addressInfo.unitType, unitName: normalReading.addressInfo.unitName }) }),
            expect.objectContaining({ meter: expect.objectContaining({ unitType: readingWithBadFlat.addressInfo.unitType, unitName: readingWithBadFlat.addressInfo.unitName }) }),
            expect.objectContaining({ meter: expect.objectContaining({ unitType: readingWithBadParking.addressInfo.unitType, unitName: readingWithBadParking.addressInfo.unitName }) }),
        ])
    })

    test('unitType, unitName, meterNumber and accountNumber are trimmed correctly', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, o10n)
        const reading = createTestReadingData(property)
        reading.accountNumber = `  ${reading.accountNumber}\n`
        reading.meterNumber = `\t${reading.meterNumber}  `
        reading.addressInfo.unitType = `${reading.addressInfo.unitType} \t `
        reading.addressInfo.unitName = `\t ${reading.addressInfo.unitName} \n `

        const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, [reading])

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                unitType: reading.addressInfo.unitType.trim(),
                unitName: reading.addressInfo.unitName.trim(),
                accountNumber: reading.accountNumber.trim(),
                number: reading.meterNumber.trim(),
            }),
        })])
    })

    test('error on empty account number', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, o10n)

        const readingWithBadAccountNumber1 = createTestReadingData(property)
        readingWithBadAccountNumber1.accountNumber = '\t  \n'

        const readingWithBadAccountNumber2 = createTestReadingData(property)
        readingWithBadAccountNumber2.accountNumber = ''

        const readings = [
            readingWithBadAccountNumber1,
            readingWithBadAccountNumber2,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    null,
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid account number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_ACCOUNT_NUMBER',
                            message: 'Invalid account number',
                        }),
                        originalError: expect.objectContaining({
                            message: 'Invalid account number',
                            extensions: expect.objectContaining({
                                type: 'INVALID_ACCOUNT_NUMBER',
                                message: 'Invalid account number',
                            }),
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid account number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_ACCOUNT_NUMBER',
                            message: 'Invalid account number',
                        }),
                        originalError: expect.objectContaining({
                            message: 'Invalid account number',
                            extensions: expect.objectContaining({
                                type: 'INVALID_ACCOUNT_NUMBER',
                                message: 'Invalid account number',
                            }),
                        }),
                    }),
                ])
            },
        )
    })

    test('error on empty meter number', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, o10n)

        const readingWithBadMeterNumber1 = createTestReadingData(property)
        readingWithBadMeterNumber1.meterNumber = '\t  \n'

        const readingWithBadMeterNumber2 = createTestReadingData(property)
        readingWithBadMeterNumber2.meterNumber = ''

        const readings = [
            readingWithBadMeterNumber1,
            readingWithBadMeterNumber2,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, o10n, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    null,
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid meter number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_METER_NUMBER',
                            message: 'Invalid meter number',
                        }),
                        originalError: expect.objectContaining({
                            message: 'Invalid meter number',
                            extensions: expect.objectContaining({
                                type: 'INVALID_METER_NUMBER',
                                message: 'Invalid meter number',
                            }),
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_METER_NUMBER',
                            message: 'Invalid meter number',
                        }),
                        originalError: expect.objectContaining({
                            message: 'Invalid meter number',
                            extensions: expect.objectContaining({
                                type: 'INVALID_METER_NUMBER',
                                message: 'Invalid meter number',
                            }),
                        }),
                    }),
                ])
            },
        )
    })

    describe('submission date', () => {
        const cases = [
            { input: '2024-06-17', output: '2024-06-17' },
            { input: '17.06.2024', output: '2024-06-17' },
            { input: '2024-06', output: '2024-06-01' },
            { input: '06-2024', output: '2024-06-01' },
            { input: '2024.06', output: '2024-06-01' },
            { input: '06.2024', output: '2024-06-01' },
            { input: '2024-06-17 18:44', output: '2024-06-17 18:44' },
            { input: '17.06.2024 18:44', output: '2024-06-17 18:44' },
            { input: '2024-06-17 18:44:13', output: '2024-06-17 18:44:13' },
            { input: '17.06.2024 18:44:13', output: '2024-06-17 18:44:13' },
            { input: '17/06/2024 18:44:13', output: '2024-06-17 18:44:13' },
            { input: '17/06/2024 18-44-13', output: '2024-06-17 18:44:13' },
            { input: '17-06-2024 18/44/13', output: '2024-06-17 18:44:13' },
            { input: '17/06/2024 18/44/13', output: '2024-06-17 18:44:13' },
            { input: '17-06-2024 18-44-13', output: '2024-06-17 18:44:13' },
        ]

        test.each(cases)('$input should parsed as $output', async ({ input, output }) => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, o10n)

            const reading = createTestReadingData(property, { date: input })
            const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, [reading])

            expect(data).toHaveLength(1)

            const row = data[0]

            const metersReading = await MeterReading.getOne(adminClient, { id: row.id })
            expect(metersReading.date).toBe(dayjs(output).toISOString())
        })
    })

    describe('error on invalid submission date', () => {
        const cases = ['[]', '12_23', 'hello moto']

        test.each(cases)('%p should cause an error', async (date) => {
            const locale = 'ru'
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, o10n)

            const reading = createTestReadingData(property, { date })

            await catchErrorFrom(
                async () => {
                    await registerMetersReadingsByTestClient(adminClient, o10n, [reading])
                },
                ({ data: { result }, errors }) => {
                    expect(result).toEqual([
                        null,
                    ])
                    expect(errors).toEqual([
                        expect.objectContaining({
                            message: 'Invalid date',
                            extensions: expect.objectContaining({
                                type: 'INVALID_DATE',
                                message: 'Invalid date',
                                messageForUser: i18n('api.meter.registerMetersReadings.INVALID_DATE:', {
                                    locale,
                                    meta: {
                                        columnName: i18n('meter.import.column.meterReadingSubmissionDate', { locale }),
                                        format: ['YYYY-MM-DD', 'DD.MM.YYYY'].join('", "'),
                                    },
                                }),
                            }),
                            originalError: expect.objectContaining({
                                message: 'Invalid date',
                                extensions: expect.objectContaining({
                                    type: 'INVALID_DATE',
                                    message: 'Invalid date',
                                }),
                            }),
                        }),
                    ])
                },
            )
        })
    })

    describe('Meter info dates sanitizing', () => {
        const cases = [
            { input: '!2042-06-17', output: '2042-06-17' },
            { input: '[]17.06.2042', output: '2042-06-17' },
            { input: '(2042-06', output: '2042-06-01' },
            { input: 'hello06-2042', output: '2042-06-01' },
            { input: ']2042.06', output: '2042-06-01' },
            { input: '06.2042', output: '2042-06-01' },
            { input: '2042-06-17 18:44', output: '2042-06-17 18:44' },
            { input: '17.06.2042 18:44', output: '2042-06-17 18:44' },
            { input: '2042-06-17 18:44:13', output: '2042-06-17 18:44:13' },
            { input: '17.06.2042 18:44:13', output: '2042-06-17 18:44:13' },
            { input: '17/06/2042 18:44:13', output: '2042-06-17 18:44:13' },
            { input: '17/06/2042 18-44-13', output: '2042-06-17 18:44:13' },
            { input: '17-06-2042 18/44/13', output: '2042-06-17 18:44:13' },
            { input: '17/06/2042 18/44/13', output: '2042-06-17 18:44:13' },
            { input: '17-06-2042 18-44-13', output: '2042-06-17 18:44:13' },
            { input: '[]', output: null },
        ]

        test.each(cases)('$input should parsed as $output', async ({ input, output }) => {
            const [o10n] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, o10n)

            const reading = createTestReadingData(property)
            reading.meterMeta = {
                ...reading.meterMeta,
                verificationDate: input,
                nextVerificationDate: input,
                installationDate: input,
                commissioningDate: input,
                sealingDate: input,
                controlReadingsDate: input,
            }
            const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, [reading])

            expect(data).toHaveLength(1)

            const row = data[0]

            const meter = await Meter.getOne(adminClient, { id: row.meter.id })
            expect(meter.verificationDate).toBe(output ? dayjs(output).toISOString() : output)
            expect(meter.nextVerificationDate).toBe(output ? dayjs(output).toISOString() : output)
            expect(meter.installationDate).toBe(output ? dayjs(output).toISOString() : output)
            expect(meter.commissioningDate).toBe(output ? dayjs(output).toISOString() : output)
            expect(meter.sealingDate).toBe(output ? dayjs(output).toISOString() : output)
            expect(meter.controlReadingsDate).toBe(output ? dayjs(output).toISOString() : output)
        })
    })

    test('prevent to create readings duplicates', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, o10n)
        const readings = [createTestReadingData(property)]
        const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                unitType: readings[0].addressInfo.unitType,
                unitName: readings[0].addressInfo.unitName,
                accountNumber: readings[0].accountNumber,
                number: readings[0].meterNumber,
            }),
        })])

        const meters = await Meter.getAll(adminClient, {
            organization: { id: o10n.id },
            property: { id: property.id },
        })
        expect(meters).toHaveLength(1)
        expect(meters[0].number).toBe(readings[0].meterNumber)

        const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings).toHaveLength(1)

        // send same data
        const [data2] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

        // be sure that we have the same result
        expect(data2).toEqual(data)

        const metersReadings2 = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings2).toHaveLength(1)
        expect(metersReadings[0].id).toBe(metersReadings2[0].id)
        expect(data2[0].id).toBe(metersReadings[0].id)
    })

    test('can update existing meter via this mutation', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, o10n)
        const readings = [createTestReadingData(property, {
            meterMeta: {
                numberOfTariffs: 2,
                place: 'place1',
            },
        })]
        const [firstAttempt] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

        // be sure that meter and meter reading was created successfully
        const meters = await Meter.getAll(adminClient, {
            organization: { id: o10n.id },
            property: { id: property.id },
        })
        expect(meters).toHaveLength(1)
        expect(meters[0].number).toBe(readings[0].meterNumber)
        expect(meters[0].place).toBe('place1')
        expect(meters[0].nextVerificationDate).toBeFalsy()
        expect(meters[0].isAutomatic).toBe(false)

        const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings).toHaveLength(1)
        expect(metersReadings[0].meter.id).toBe(meters[0].id)

        // create another reading for same meter and change `place` and `nextVerificationDate` fields values
        const nextVerificationDate = dayjs().add(1, 'week').toISOString()
        const anotherReadings = [{
            ...readings[0],
            value1: faker.random.numeric(3),
            value2: faker.random.numeric(4),
            meterMeta: {
                ...readings[0].meterMeta,
                place: 'place2',
                nextVerificationDate,
                isAutomatic: true,
            },
        }]
        const [secondAttempt] = await registerMetersReadingsByTestClient(adminClient, o10n, anotherReadings)
        expect(firstAttempt[0].meter.id).toBe(secondAttempt[0].meter.id)

        // be sure that meter has changed place and nextVerificationDate
        const updatedMeters = await Meter.getAll(adminClient, {
            organization: { id: o10n.id },
            property: { id: property.id },
        })
        expect(updatedMeters).toHaveLength(1)
        expect(updatedMeters[0].id).toBe(meters[0].id)
        expect(updatedMeters[0].v).toBe(meters[0].v + 1)
        expect(updatedMeters[0].number).toBe(readings[0].meterNumber)
        expect(updatedMeters[0].place).toBe('place2')
        expect(updatedMeters[0].nextVerificationDate).toBeTruthy()
        expect(updatedMeters[0].isAutomatic).toBe(true)

        // sent third readings without place - field value must be 'place2'
        const thirdReadings = [{
            ...readings[0],
            value1: faker.random.numeric(3),
            value2: faker.random.numeric(4),
            meterMeta: undefined,
        }]
        const [thirdAttempt] = await registerMetersReadingsByTestClient(adminClient, o10n, thirdReadings)
        expect(firstAttempt[0].meter.id).toBe(thirdAttempt[0].meter.id)

        const updatedMeters2 = await Meter.getAll(adminClient, {
            organization: { id: o10n.id },
            property: { id: property.id },
        })
        expect(updatedMeters2).toHaveLength(1)
        expect(updatedMeters2[0].id).toBe(meters[0].id)
        expect(updatedMeters2[0].number).toBe(readings[0].meterNumber)
        expect(updatedMeters2[0].place).toBe('place2')
        expect(updatedMeters2[0].numberOfTariffs).toBe(2)
        expect(updatedMeters2[0].nextVerificationDate).toBeTruthy()
        expect(updatedMeters2[0].isAutomatic).toBe(true)

        // be sure that keep same value from creation
        expect(meters[0].controlReadingsDate).toBe(updatedMeters2[0].controlReadingsDate)
    })

    test('meter not updated if no fields changed', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, o10n)
        const readings = [createTestReadingData(property, {
            meterMeta: {
                numberOfTariffs: 2,
                place: 'place1',
            },
        })]
        await registerMetersReadingsByTestClient(adminClient, o10n, readings)
        const meters = await Meter.getAll(adminClient, {
            organization: { id: o10n.id },
            property: { id: property.id },
        })

        // create another reading for same meter (keep all meter fields as is)
        const anotherReadings = [{
            ...readings[0],
            value1: faker.random.numeric(3),
            value2: faker.random.numeric(4),
            meterMeta: {
                place: 'place1', // keep same place
            },
        }]
        await registerMetersReadingsByTestClient(adminClient, o10n, anotherReadings)

        // be sure that meter has changed place and nextVerificationDate
        const notUpdatedMeters = await Meter.getAll(adminClient, {
            organization: { id: o10n.id },
            property: { id: property.id },
        })
        expect(notUpdatedMeters).toHaveLength(1)
        expect(notUpdatedMeters[0].id).toBe(meters[0].id)
        expect(notUpdatedMeters[0].v).toBe(meters[0].v)
        expect(notUpdatedMeters[0].place).toBe('place1')
    })

    test('default reading source if not passed', async () => {
        const [o10n] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, o10n)
        const readings = [
            createTestReadingData(property),
            createTestReadingData(property, { readingSource: { id: REMOTE_SYSTEM_METER_READING_SOURCE_ID } }),
        ]
        const [data] = await registerMetersReadingsByTestClient(adminClient, o10n, readings)

        const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: data.map((row) => row.meter.id) } })
        expect(metersReadings).toEqual([
            expect.objectContaining({ source: expect.objectContaining({ id: OTHER_METER_READING_SOURCE_ID }) }),
            expect.objectContaining({ source: expect.objectContaining({ id: REMOTE_SYSTEM_METER_READING_SOURCE_ID }) }),
        ])
    })
})
