/**
 * Generated by `createservice meter.RegisterMetersReadingsService --type mutations`
 */
const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const flatten = require('lodash/flatten')
const map = require('lodash/map')
const set = require('lodash/set')
const zip = require('lodash/zip')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowAuthenticationError,
    expectToThrowAccessDeniedErrorToResult, expectToThrowGQLError, catchErrorFrom,
    expectToThrowForeignKeyConstraintViolationError,
} = require('@open-condo/keystone/test.utils')

const { UUID_REGEXP } = require('@condo/domains/common/constants/regexps')
const {
    ELECTRICITY_METER_RESOURCE_ID,
    HEAT_SUPPLY_METER_RESOURCE_ID,
    GAS_SUPPLY_METER_RESOURCE_ID,
    OTHER_METER_READING_SOURCE_ID,
    REMOTE_SYSTEM_METER_READING_SOURCE_ID,
} = require('@condo/domains/meter/constants/constants')
const { DATE_FIELD_PATHS } = require('@condo/domains/meter/constants/registerMetersReadingsService')
const {
    registerMetersReadingsByTestClient,
    Meter,
    MeterReading,
    createTestReadingData,
} = require('@condo/domains/meter/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRight, createTestB2BAppAccessRightSet,
} = require('@condo/domains/miniapp/utils/testSchema')
const {
    createTestOrganization,
    makeEmployeeUserClientWithAbilities,
} = require('@condo/domains/organization/utils/testSchema')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema/Organization')
const { PARKING_UNIT_TYPE } = require('@condo/domains/property/constants/common')
const { createTestPropertyWithMap } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
    makeClientWithStaffUser,
} = require('@condo/domains/user/utils/testSchema')

describe('RegisterMetersReadingsService', () => {

    let adminClient, supportClient, residentClient, anonymousClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        residentClient = await makeClientWithResidentUser()
        anonymousClient = await makeClient()
    })

    describe('access to execution', () => {

        let organization

        beforeAll(async () => {
            [organization] = await createTestOrganization(adminClient)
        })

        test('admin can', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, organization)
            const readings = [createTestReadingData(property)]
            const [data] = await registerMetersReadingsByTestClient(adminClient, organization, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                meter: expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    property: expect.objectContaining({
                        id: property.id,
                        address: property.address,
                        addressKey: property.addressKey,
                    }),
                    unitType: readings[0].addressInfo.unitType,
                    unitName: readings[0].addressInfo.unitName,
                    accountNumber: readings[0].accountNumber,
                    number: readings[0].meterNumber,
                }),
            })])

            const meters = await Meter.getAll(adminClient, {
                organization: { id: organization.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
        })

        test('support can', async () => {
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, organization)
            const readings = [createTestReadingData(property)]
            const [data] = await registerMetersReadingsByTestClient(supportClient, organization, readings)

            expect(data).toEqual([expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                meter: expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    property: expect.objectContaining({
                        id: property.id,
                        address: property.address,
                        addressKey: property.addressKey,
                    }),
                    unitType: readings[0].addressInfo.unitType,
                    unitName: readings[0].addressInfo.unitName,
                    accountNumber: readings[0].accountNumber,
                    number: readings[0].meterNumber,
                }),
            })])

            const meters = await Meter.getAll(adminClient, {
                organization: { id: organization.id },
                property: { id: property.id },
            })
            expect(meters).toHaveLength(1)
            expect(meters[0].number).toBe(readings[0].meterNumber)

            const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
            expect(metersReadings).toHaveLength(1)
        })

        describe('staff', () => {
            test('with permissions can', async () => {
                const staffClient = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                    canManageMeterReadings: true,
                })

                const readings = [createTestReadingData(staffClient.property)]
                const [data] = await registerMetersReadingsByTestClient(staffClient, staffClient.organization, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    meter: expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        property: expect.objectContaining({
                            id: staffClient.property.id,
                            address: staffClient.property.address,
                            addressKey: staffClient.property.addressKey,
                        }),
                        unitType: readings[0].addressInfo.unitType,
                        unitName: readings[0].addressInfo.unitName,
                        accountNumber: readings[0].accountNumber,
                        number: readings[0].meterNumber,
                    }),
                })])

                const meters = await Meter.getAll(adminClient, {
                    organization: { id: staffClient.organization.id },
                    property: { id: staffClient.property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
            })

            test('without permissions can\'t', async () => {
                const staffClient1 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                    canManageMeterReadings: false,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient1, staffClient1.organization, [])
                })

                const staffClient2 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: true,
                    canManageMeterReadings: false,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient2, staffClient2.organization, [])
                })

                const staffClient3 = await makeEmployeeUserClientWithAbilities({
                    canManageMeters: false,
                    canManageMeterReadings: true,
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(staffClient3, staffClient3.organization, [])
                })
            })
        })

        describe('service user', () => {
            test('with access rights can', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestPropertyWithMap(adminClient, organization)

                const [app] = await createTestB2BApp(adminClient)
                await createTestB2BAppContext(adminClient, app, organization, { status: 'Finished' })
                const [accessRightSet] = await createTestB2BAppAccessRightSet(adminClient, app, {
                    canExecuteRegisterMetersReadings: true,
                    canReadMeters: true,
                    canReadMeterReadings: true,
                    canReadOrganizations: true,
                    canReadProperties: true,
                })
                await createTestB2BAppAccessRight(adminClient, serviceClient.user, app, accessRightSet)

                const readings = [createTestReadingData(property)]
                const [data] = await registerMetersReadingsByTestClient(serviceClient, organization, readings)

                expect(data).toEqual([expect.objectContaining({
                    id: expect.stringMatching(UUID_REGEXP),
                    meter: expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        property: expect.objectContaining({
                            id: property.id,
                            address: property.address,
                            addressKey: property.addressKey,
                        }),
                        unitType: readings[0].addressInfo.unitType,
                        unitName: readings[0].addressInfo.unitName,
                        accountNumber: readings[0].accountNumber,
                        number: readings[0].meterNumber,
                    }),
                })])

                const meters = await Meter.getAll(adminClient, {
                    organization: { id: organization.id },
                    property: { id: property.id },
                })
                expect(meters).toHaveLength(1)
                expect(meters[0].number).toBe(readings[0].meterNumber)

                const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
                expect(metersReadings).toHaveLength(1)
            })

            test('without permissions can\'t', async () => {
                const serviceClient = await makeClientWithServiceUser()
                const [organization] = await createTestOrganization(adminClient)

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerMetersReadingsByTestClient(serviceClient, organization, [])
                })
            })
        })

        test('resident can\'t execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerMetersReadingsByTestClient(residentClient, organization, [])
            })
        })

        test('anonymous can\'t execute', async () => {
            await expectToThrowAuthenticationError(async () => {
                await registerMetersReadingsByTestClient(anonymousClient, organization, [])
            }, 'result')
        })
    })

    test('error on too much items', async () => {
        const [organization] = await createTestOrganization(adminClient)
        await expectToThrowGQLError(
            async () => await registerMetersReadingsByTestClient(
                adminClient,
                organization,
                flatten(Array(501).fill(createTestReadingData({ address: faker.address.streetAddress(true) }))),
            ),
            {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MUCH_READINGS',
                message: 'Too much readings. {sentCount} sent, limit is {limit}.',
                messageForUser: 'api.meter.registerMetersReadings.TOO_MUCH_READINGS',
                messageInterpolation: { limit: 500, sentCount: 501 },
            },
            'result',
        )
    })

    test('Check for Meter model error: cannot create Meter if Meter with same accountNumber exist in user organization in other unit', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, organization)
        const [property2] = await createTestPropertyWithMap(adminClient, organization)

        const accountNumber = faker.random.alphaNumeric(12)

        const readings1 = [createTestReadingData(property1)]
        readings1[0].accountNumber = accountNumber

        await registerMetersReadingsByTestClient(adminClient, organization, readings1)

        const readings2 = [createTestReadingData(property2)]
        readings2[0].accountNumber = accountNumber

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, organization, readings2)
            },
            ({ data, errors }) => {
                expect(data).toEqual({ 'result': [null] })
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create Meter internal error',
                        name: 'GQLError',
                        path: ['result', 0],
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'SAME_ACCOUNT_NUMBER_EXISTS_IN_OTHER_UNIT',
                            message: 'Meter with same account number exist in current organization in other unit',
                            messageForUserTemplateKey: 'api.meter.meter.SAME_ACCOUNT_NUMBER_EXISTS_IN_OTHER_UNIT',
                            messageInterpolation: { unitsCsv: `${readings1[0].addressInfo.unitType} ${readings1[0].addressInfo.unitName}` },
                        }),
                    }),
                ])
            },
        )
    })

    test('error if organization not exists', async () => {
        await expectToThrowGQLError(
            async () => await registerMetersReadingsByTestClient(adminClient, { id: faker.datatype.uuid() }, []),
            {
                code: 'BAD_USER_INPUT',
                type: 'ORGANIZATION_NOT_FOUND',
                message: 'Organization not found',
                messageForUser: 'api.meter.registerMetersReadings.ORGANIZATION_NOT_FOUND',
            },
            'result',
        )
    })

    test('error for row if trying to add meter reading for property which not added to organization', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, organization)
        const [property2] = await createTestPropertyWithMap(adminClient, organization)

        const readings = [
            createTestReadingData(property1),
            createTestReadingData({ address: faker.address.streetAddress(true) }),
            createTestReadingData(property2),
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, organization, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property1.id,
                                address: property1.address,
                                addressKey: property1.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property2.id,
                                address: property2.address,
                                addressKey: property2.addressKey,
                            }),
                            unitType: readings[2].addressInfo.unitType,
                            unitName: readings[2].addressInfo.unitName,
                            accountNumber: readings[2].accountNumber,
                            number: readings[2].meterNumber,
                        }),
                    }),
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Property not found',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'PROPERTY_NOT_FOUND',
                            message: 'Property not found',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid meter value', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)

        const badReading1 = createTestReadingData(property, {
            meterResource: { id: GAS_SUPPLY_METER_RESOURCE_ID },
            value1: '-100500',
            value2: undefined,
        })

        const badReading2 = createTestReadingData(property, {
            meterResource: { id: ELECTRICITY_METER_RESOURCE_ID },
            value1: 'oops',
            value2: undefined,
        })

        const badReading3 = createTestReadingData(property, {
            meterResource: { id: HEAT_SUPPLY_METER_RESOURCE_ID },
            value1: 'Infinity',
            value2: undefined,
        })

        const readings = [
            createTestReadingData(property),
            badReading1,
            badReading2,
            badReading3,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, organization, readings)
            },
            (err) => {
                const { data: { result }, errors } = err
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property.id,
                                address: property.address,
                                addressKey: property.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                    null,
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter values',
                        name: 'GQLError',
                        extensions: expect.objectContaining({
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_METER_VALUES',
                            message: 'Invalid meter values',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on invalid meter resource', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, organization)

        const badReading = createTestReadingData(property1)
        badReading.meterResource = { id: faker.datatype.uuid() }

        const readings = [
            createTestReadingData(property1),
            badReading,
        ]

        await expectToThrowForeignKeyConstraintViolationError(
            async () => await registerMetersReadingsByTestClient(adminClient, organization, readings),
            'Meter', 'Meter_resource_33ab2a27_fk_MeterResource_id'
        )
    })

    test('error on invalid number of tariffs passed', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, organization)

        const badReading = createTestReadingData(property1)
        badReading.meterMeta.numberOfTariffs = 5

        const readings = [
            createTestReadingData(property1),
            badReading,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, organization, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property1.id,
                                address: property1.address,
                                addressKey: property1.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    }),
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: '[error] Create Meter internal error',
                        extensions: expect.objectContaining({
                            'code': 'BAD_USER_INPUT',
                            'type': 'NUMBER_OF_TARIFFS_NOT_VALID',
                            'message': 'Provided number of tariffs is not valid. Must be an integer from 1 to 4.',
                            'messageForUserTemplateKey': 'api.meter.NUMBER_OF_TARIFFS_NOT_VALID',
                            'messageInterpolation': {
                                'value': 5,
                            },
                        }),
                    }),
                ])
            },
        )
    })

    test('number of tariffs calculated correctly', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const reading = createTestReadingData(property)
        reading.value3 = faker.random.numeric(3)
        reading.meterMeta.numberOfTariffs = undefined

        const [data] = await registerMetersReadingsByTestClient(adminClient, organization, [reading])

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                unitType: reading.addressInfo.unitType,
                unitName: reading.addressInfo.unitName,
                accountNumber: reading.accountNumber,
                number: reading.meterNumber,
            }),
        })])

        const meters = await Meter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(meters).toEqual([
            expect.objectContaining({ numberOfTariffs: 3 }),
        ])
    })

    test('possible import with un-existing unit', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property1] = await createTestPropertyWithMap(adminClient, organization)

        const normalReading = createTestReadingData(property1)

        const readingWithBadFlat = createTestReadingData(property1)
        readingWithBadFlat.addressInfo.unitName = faker.datatype.string(4)

        const readingWithBadParking = createTestReadingData(property1)
        readingWithBadParking.addressInfo.unitType = PARKING_UNIT_TYPE
        readingWithBadParking.addressInfo.unitName = faker.datatype.string(4)

        const readings = [
            normalReading,
            readingWithBadFlat,
            readingWithBadParking,
        ]

        const [result] = await registerMetersReadingsByTestClient(adminClient, organization, readings)

        expect(result).toEqual([
            expect.objectContaining({ meter: expect.objectContaining({ unitType: normalReading.addressInfo.unitType, unitName: normalReading.addressInfo.unitName }) }),
            expect.objectContaining({ meter: expect.objectContaining({ unitType: readingWithBadFlat.addressInfo.unitType, unitName: readingWithBadFlat.addressInfo.unitName }) }),
            expect.objectContaining({ meter: expect.objectContaining({ unitType: readingWithBadParking.addressInfo.unitType, unitName: readingWithBadParking.addressInfo.unitName }) }),
        ])
    })

    test('unitType, unitName, meterNumber and accountNumber are trimmed correctly', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const reading = createTestReadingData(property)
        reading.accountNumber = `  ${reading.accountNumber}\n`
        reading.meterNumber = `\t${reading.meterNumber}  `
        reading.addressInfo.unitType = `${reading.addressInfo.unitType} \t `
        reading.addressInfo.unitName = `\t ${reading.addressInfo.unitName} \n `

        const [data] = await registerMetersReadingsByTestClient(adminClient, organization, [reading])

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                unitType: reading.addressInfo.unitType.trim(),
                unitName: reading.addressInfo.unitName.trim(),
                accountNumber: reading.accountNumber.trim(),
                number: reading.meterNumber.trim(),
            }),
        })])
    })

    test('error on empty account number', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)

        const readingWithBadAccountNumber1 = createTestReadingData(property)
        readingWithBadAccountNumber1.accountNumber = '\t  \n'

        const readingWithBadAccountNumber2 = createTestReadingData(property)
        readingWithBadAccountNumber2.accountNumber = ''

        const readings = [
            readingWithBadAccountNumber1,
            readingWithBadAccountNumber2,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, organization, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    null,
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid account number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_ACCOUNT_NUMBER',
                            message: 'Invalid account number',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid account number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_ACCOUNT_NUMBER',
                            message: 'Invalid account number',
                        }),
                    }),
                ])
            },
        )
    })

    test('error on empty meter number', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)

        const readingWithBadMeterNumber1 = createTestReadingData(property)
        readingWithBadMeterNumber1.meterNumber = '\t  \n'

        const readingWithBadMeterNumber2 = createTestReadingData(property)
        readingWithBadMeterNumber2.meterNumber = ''

        const readings = [
            readingWithBadMeterNumber1,
            readingWithBadMeterNumber2,
        ]

        await catchErrorFrom(
            async () => {
                await registerMetersReadingsByTestClient(adminClient, organization, readings)
            },
            ({ data: { result }, errors }) => {
                expect(result).toEqual([
                    null,
                    null,
                ])
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'Invalid meter number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_METER_NUMBER',
                            message: 'Invalid meter number',
                        }),
                    }),
                    expect.objectContaining({
                        message: 'Invalid meter number',
                        extensions: expect.objectContaining({
                            type: 'INVALID_METER_NUMBER',
                            message: 'Invalid meter number',
                        }),
                    }),
                ])
            },
        )
    })

    describe('Dates parsing', () => {

        describe('valid dates', () => {
            const dates = [
                { input: '2024-06-17', output: dayjs('2024-06-17').toISOString() },
                { input: '2024-06-17T18:44:13.539Z', output: '2024-06-17T18:44:13.539Z' },
                { input: '2021-12-20T00:00:00.000Z', output: '2021-12-20T00:00:00.000Z' },
            ]

            const cases = dates.flatMap(date =>
                DATE_FIELD_PATHS.map(({ path }) => ({
                    input: date.input,
                    output: date.output,
                    path,
                })))

            test.each(cases)('$input in $path should parsed as $output', async ({ input, output, path }) => {
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestPropertyWithMap(adminClient, organization)

                const reading = createTestReadingData(property)
                set(reading, path, input)
                const [data] = await registerMetersReadingsByTestClient(adminClient, organization, [reading])

                expect(data).toHaveLength(1)

                const row = data[0]

                if (path.startsWith('meterMeta')) {
                    path = path.substring('meterMeta.'.length)
                    const meter = await Meter.getOne(adminClient, { id: row.meter.id })
                    expect(meter).toHaveProperty(path, dayjs(output).toISOString())
                } else {
                    const metersReading = await MeterReading.getOne(adminClient, { id: row.id })
                    expect(metersReading).toHaveProperty(path, dayjs(output).toISOString())
                }
            })
        })

        describe('error on invalid dates', () => {
            const invalidDates = [
                '[]',
                '12_23',
                'hello moto',
                '',
                '2024.28.05',
                '2024.05.28 13-13-13',
                '!2024-06-17',
                '2024-06',
                '06-2024',
                '2024.06',
                '06.2024',
                '2024-06-17 18:44',
                '17.06.2024 18:44',
                '2024-06-17 18:44:13',
                '17.06.2024 18:44:13',
                '17/06/2024 18:44:13',
                '2019-03-06T08:00:00+08:00',
                '!2042-06-17',
                '[]17.06.2042',
                '(2042-06',
                'hello06-2042',
                ']2042.06',
                '06.2042',
                '2042-06-17 18:44',
                '17.06.2042 18:44',
                '2042-06-17 18:44:13',
                '17.06.2042 18:44:13',
                '17/06/2042 18:44:13',
                '17/06/2042 18-44-13',
                '17-06-2042 18/44/13',
                '17/06/2042 18/44/13',
                '17-06-2042 18-44-13',
                '2024-09-22T09:03:25',
                '2024-22-09T09:03:25.000Z',
                '2024-22-09',
            ]

            const cases = invalidDates.flatMap((date) =>
                DATE_FIELD_PATHS.map(({ path }) => [date, path])
            )

            test.each(cases)('%p in %p should cause an error', async (invalidDate, dateFieldPath) => {
                const [organization] = await createTestOrganization(adminClient)
                const [property] = await createTestPropertyWithMap(adminClient, organization)

                const reading = createTestReadingData(property)
                set(reading, dateFieldPath, invalidDate)

                // TODO(pahaz): DOMA-10348 refactor it to use expectToThrowGQLError (need more deep refactoring) !!
                await catchErrorFrom(
                    async () => await registerMetersReadingsByTestClient(adminClient, organization, [reading]),
                    ({ data, errors }) => {
                        expect(data).toEqual({ 'result': [null] })
                        expect(errors).toEqual([
                            expect.objectContaining({
                                name: 'GQLError',
                                message: 'Invalid date',
                                path: ['result', 0],
                                extensions: expect.objectContaining({
                                    'code': 'BAD_USER_INPUT',
                                    'type': 'INVALID_DATE',
                                    'message': 'Invalid date',
                                    'messageForUserTemplateKey': 'api.meter.registerMetersReadings.INVALID_DATE',
                                    'messageInterpolation': {
                                        'columnName': expect.any(String),
                                        'format': 'YYYY-MM-DDTHH:mm:ss.SSS[Z]", "YYYY-MM-DD',
                                    },
                                }),
                            }),
                        ])
                    },
                )
            })
        })

    })

    describe('Meter info dates saves as empty on empty input', () => {
        const dateFields = [
            'verificationDate',
            'nextVerificationDate',
            'installationDate',
            'commissioningDate',
            'sealingDate',
            'controlReadingsDate',
            'archiveDate',
        ]

        const emptyValues = [ null, undefined ]

        const cases = zip(dateFields, emptyValues)

        test.each(cases)('%p = %p should be saved as empty date', async (dateField, emptyValue) => {
            const [organization] = await createTestOrganization(adminClient)
            const [property] = await createTestPropertyWithMap(adminClient, organization)

            const reading = createTestReadingData(property)
            reading.meterMeta[dateField] = emptyValue
            const [data] = await registerMetersReadingsByTestClient(adminClient, organization, [reading])

            expect(data).toHaveLength(1)

            const row = data[0]

            const meter = await Meter.getOne(adminClient, { id: row.meter.id })
            expect(meter).toHaveProperty(dateField, null)
        })
    })

    test('prevent to create readings duplicates', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readings = [createTestReadingData(property)]
        const [data] = await registerMetersReadingsByTestClient(adminClient, organization, readings)

        expect(data).toEqual([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                unitType: readings[0].addressInfo.unitType,
                unitName: readings[0].addressInfo.unitName,
                accountNumber: readings[0].accountNumber,
                number: readings[0].meterNumber,
            }),
        })])

        const meters = await Meter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(meters).toHaveLength(1)
        expect(meters[0].number).toBe(readings[0].meterNumber)

        const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings).toHaveLength(1)

        // send same data
        const [data2] = await registerMetersReadingsByTestClient(adminClient, organization, readings)

        // be sure that we have the same result
        expect(data2).toEqual(data)

        const metersReadings2 = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings2).toHaveLength(1)
        expect(metersReadings[0].id).toBe(metersReadings2[0].id)
        expect(data2[0].id).toBe(metersReadings[0].id)
    })

    test('prevent to create readings duplicates in one input', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readingData = createTestReadingData(property)
        const duplicateReadings = [readingData, readingData]

        const [data] = await registerMetersReadingsByTestClient(adminClient, organization, duplicateReadings)

        expect(data).toHaveLength(2)
        expect(data[0].id).toEqual(data[1].id)
        expect(data).toEqual(expect.arrayContaining([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                unitType: duplicateReadings[0].addressInfo.unitType,
                unitName: duplicateReadings[0].addressInfo.unitName,
                accountNumber: duplicateReadings[0].accountNumber,
                number: duplicateReadings[0].meterNumber,
            }),
        })]))

        const meters = await Meter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(meters).toHaveLength(1)
        expect(meters[0].number).toBe(duplicateReadings[0].meterNumber)

        const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings).toHaveLength(1)
    })

    test('prevent to create readings duplicates if date is within same day', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readingData = createTestReadingData(property)
        const duplicateReadings = [readingData, { ...readingData, date: dayjs(readingData.date).add('1', 's').toISOString() }]

        const [data] = await registerMetersReadingsByTestClient(adminClient, organization, duplicateReadings)

        expect(data).toHaveLength(2)
        expect(data[0].id).toEqual(data[1].id)
        expect(data).toEqual(expect.arrayContaining([expect.objectContaining({
            id: expect.stringMatching(UUID_REGEXP),
            meter: expect.objectContaining({
                id: expect.stringMatching(UUID_REGEXP),
                property: expect.objectContaining({
                    id: property.id,
                    address: property.address,
                    addressKey: property.addressKey,
                }),
                unitType: duplicateReadings[0].addressInfo.unitType,
                unitName: duplicateReadings[0].addressInfo.unitName,
                accountNumber: duplicateReadings[0].accountNumber,
                number: duplicateReadings[0].meterNumber,
            }),
        })]))

        const meters = await Meter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(meters).toHaveLength(1)
        expect(meters[0].number).toBe(duplicateReadings[0].meterNumber)

        const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings).toHaveLength(1)
    })

    test('update meter with data from last reading with same meter', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readingData = createTestReadingData(property)
        const placeValue = faker.datatype.string(4)

        const duplicateReadings = [readingData, {
            ...readingData,
            meterMeta: {
                numberOfTariffs: 2,
                place: placeValue,
            },
        }]

        await registerMetersReadingsByTestClient(adminClient, organization, duplicateReadings)

        const meters = await Meter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })

        expect(meters).toHaveLength(1)
        expect(meters[0].number).toBe(duplicateReadings[0].meterNumber)
        expect(meters[0].place).toBe(placeValue)
        expect(meters[0].nextVerificationDate).toBeFalsy()
        expect(meters[0].isAutomatic).toBe(false)
    })

    test('can update existing meter via this mutation', async () => {
        const staffClient = await makeClientWithStaffUser()
        const [organization] = await registerNewOrganization(staffClient)
        const [property] = await createTestPropertyWithMap(staffClient, organization)
        const readings = [createTestReadingData(property, {
            meterMeta: {
                numberOfTariffs: 2,
                place: 'place1',
            },
        })]
        const [firstAttempt] = await registerMetersReadingsByTestClient(staffClient, organization, readings)

        // be sure that meter and meter reading was created successfully
        const meters = await Meter.getAll(staffClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(meters).toHaveLength(1)
        expect(meters[0].number).toBe(readings[0].meterNumber)
        expect(meters[0].place).toBe('place1')
        expect(meters[0].nextVerificationDate).toBeFalsy()
        expect(meters[0].isAutomatic).toBe(false)

        const metersReadings = await MeterReading.getAll(staffClient, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings).toHaveLength(1)
        expect(metersReadings[0].meter.id).toBe(meters[0].id)

        // create another reading for same meter and change `place` and `nextVerificationDate` fields values
        const nextVerificationDate = dayjs().add(1, 'week').toISOString()
        const archiveDate = dayjs().add(2, 'week').toISOString()
        const anotherReadings = [{
            ...readings[0],
            value1: faker.random.numeric(3),
            value2: faker.random.numeric(4),
            meterMeta: {
                ...readings[0].meterMeta,
                place: 'place2',
                nextVerificationDate,
                isAutomatic: true,
                archiveDate,
            },
        }]
        const [secondAttempt] = await registerMetersReadingsByTestClient(staffClient, organization, anotherReadings)
        expect(firstAttempt[0].meter.id).toBe(secondAttempt[0].meter.id)

        // be sure that meter has changed place and nextVerificationDate
        const updatedMeters = await Meter.getAll(staffClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(updatedMeters).toHaveLength(1)
        expect(updatedMeters[0].id).toBe(meters[0].id)
        expect(updatedMeters[0].v).toBe(meters[0].v + 1)
        expect(updatedMeters[0].number).toBe(readings[0].meterNumber)
        expect(updatedMeters[0].place).toBe('place2')
        expect(updatedMeters[0].nextVerificationDate).toBeTruthy()
        expect(updatedMeters[0].archiveDate).toBeTruthy()
        expect(updatedMeters[0].isAutomatic).toBe(true)

        // sent third readings without place - field value must be 'place2'
        // and set isAutomatic to false
        const thirdReadings = [{
            ...readings[0],
            value1: faker.random.numeric(3),
            value2: faker.random.numeric(4),
            meterMeta: {
                isAutomatic: false,
                place: '',
            },
        }]
        const [thirdAttempt] = await registerMetersReadingsByTestClient(staffClient, organization, thirdReadings)
        expect(firstAttempt[0].meter.id).toBe(thirdAttempt[0].meter.id)

        const updatedMeters2 = await Meter.getAll(staffClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(updatedMeters2).toHaveLength(1)
        expect(updatedMeters2[0].id).toBe(meters[0].id)
        expect(updatedMeters2[0].number).toBe(readings[0].meterNumber)
        expect(updatedMeters2[0].place).toBe('place2')
        expect(updatedMeters2[0].numberOfTariffs).toBe(2)
        expect(updatedMeters2[0].nextVerificationDate).toBeTruthy()
        expect(updatedMeters2[0].archiveDate).toBeTruthy()
        expect(updatedMeters2[0].isAutomatic).toBe(false)

        // be sure that keep same value from creation
        expect(meters[0].controlReadingsDate).toBe(updatedMeters2[0].controlReadingsDate)

        // Try to change the account number
        const fourReadings = [{
            ...thirdReadings[0],
            accountNumber: faker.random.alphaNumeric(12),
        }]
        const [fourAttempt] = await registerMetersReadingsByTestClient(staffClient, organization, fourReadings)
        expect(firstAttempt[0].meter.id).toBe(fourAttempt[0].meter.id)

        const updatedMeters3 = await Meter.getAll(staffClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(updatedMeters3).toHaveLength(1)
        expect(updatedMeters3[0].id).toBe(meters[0].id)
        expect(updatedMeters3[0].number).toBe(readings[0].meterNumber)
        expect(updatedMeters3[0].place).toBe('place2') // not changed
        expect(updatedMeters3[0].numberOfTariffs).toBe(2)
        expect(updatedMeters3[0].nextVerificationDate).toBeTruthy()
        expect(updatedMeters3[0].archiveDate).toBeTruthy()
        expect(updatedMeters3[0].isAutomatic).toBe(false)
        expect(updatedMeters3[0].accountNumber).toBe(fourReadings[0].accountNumber)
    })

    test('User from other organization can not change meter account number', async () => {
        const staffClient1 = await makeClientWithStaffUser()
        const staffClient2 = await makeClientWithStaffUser()
        const [organization] = await registerNewOrganization(staffClient1)
        const [property] = await createTestPropertyWithMap(staffClient1, organization)
        const readings = [createTestReadingData(property, {
            meterMeta: {
                numberOfTariffs: 2,
                place: 'place1',
            },
        })]
        await registerMetersReadingsByTestClient(staffClient1, organization, readings)

        // be sure that meter and meter reading was created successfully
        const meters = await Meter.getAll(staffClient1, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(meters).toHaveLength(1)
        expect(meters[0].number).toBe(readings[0].meterNumber)
        expect(meters[0].place).toBe('place1')
        expect(meters[0].nextVerificationDate).toBeFalsy()
        expect(meters[0].isAutomatic).toBe(false)

        const metersReadings = await MeterReading.getAll(staffClient1, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings).toHaveLength(1)
        expect(metersReadings[0].meter.id).toBe(meters[0].id)

        // Try to change the account number
        const fourReadings = [{
            ...readings[0],
            accountNumber: faker.random.alphaNumeric(12),
        }]

        await expectToThrowAccessDeniedErrorToResult(async () => {
            await registerMetersReadingsByTestClient(staffClient2, organization, fourReadings)
        })
    })

    test('meter not updated if no fields changed', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readings = [createTestReadingData(property, {
            meterMeta: {
                numberOfTariffs: 2,
                place: 'place1',
            },
        })]
        await registerMetersReadingsByTestClient(adminClient, organization, readings)
        const meters = await Meter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })

        // create another reading for same meter (keep all meter fields as is)
        const anotherReadings = [{
            ...readings[0],
            value1: faker.random.numeric(3),
            value2: faker.random.numeric(4),
            meterMeta: {
                place: 'place1', // keep same place
            },
        }]
        await registerMetersReadingsByTestClient(adminClient, organization, anotherReadings)

        // be sure that meter has changed place and nextVerificationDate
        const notUpdatedMeters = await Meter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(notUpdatedMeters).toHaveLength(1)
        expect(notUpdatedMeters[0].id).toBe(meters[0].id)
        expect(notUpdatedMeters[0].v).toBe(meters[0].v)
        expect(notUpdatedMeters[0].place).toBe('place1')
    })

    test('default reading source if not passed', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readings = [
            createTestReadingData(property),
            createTestReadingData(property, { readingSource: { id: REMOTE_SYSTEM_METER_READING_SOURCE_ID } }),
        ]
        const [data] = await registerMetersReadingsByTestClient(adminClient, organization, readings)
        const metersReadings = await MeterReading.getAll(adminClient, { meter: { id_in: data.map((row) => row.meter.id) } }, { sortBy: 'createdAt_ASC' })

        expect(metersReadings).toEqual([
            expect.objectContaining({ source: expect.objectContaining({ id: OTHER_METER_READING_SOURCE_ID }) }),
            expect.objectContaining({ source: expect.objectContaining({ id: REMOTE_SYSTEM_METER_READING_SOURCE_ID }) }),
        ])
    })

    test('possible re-import readings that were previously deleted', async () => {
        const [organization] = await createTestOrganization(adminClient)
        const [property] = await createTestPropertyWithMap(adminClient, organization)
        const readings = [createTestReadingData(property, {
            meterMeta: {
                numberOfTariffs: 2,
            },
        })]
        const [firstImport] = await registerMetersReadingsByTestClient(adminClient, organization, readings)

        // be sure that meter and meter reading was created successfully
        const meters = await Meter.getAll(adminClient, {
            organization: { id: organization.id },
            property: { id: property.id },
        })
        expect(meters).toHaveLength(1)
        expect(meters[0].number).toBe(readings[0].meterNumber)
        expect(meters[0].nextVerificationDate).toBeFalsy()
        expect(meters[0].isAutomatic).toBe(false)

        const meterReadings = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
        expect(meterReadings).toHaveLength(1)
        expect(meterReadings[0].meter.id).toBe(meters[0].id)

        // soft delete created Meter Reading
        const [deletedReading] = await MeterReading.softDelete(adminClient, meterReadings[0].id)
        expect(deletedReading.id).toBe(meterReadings[0].id)

        // create same reading again
        const [secondImport] = await registerMetersReadingsByTestClient(adminClient, organization, readings)
        expect(firstImport[0].meter.id).toBe(secondImport[0].meter.id)

        const metersReadings2 = await MeterReading.getAll(adminClient, { meter: { id_in: map(meters, 'id') } })
        expect(metersReadings2).toHaveLength(1)
        expect(metersReadings2[0].meter.id).toBe(meters[0].id)

        // ensure that meter reading was created again with all the same fields
        expect(metersReadings2).toHaveLength(1)
        expect(metersReadings2[0].value1).toBe(meterReadings[0].value1)
        expect(metersReadings2[0].value2).toBe(meterReadings[0].value2)
        expect(metersReadings2[0].date).toBe(meterReadings[0].date)
        expect(metersReadings2[0].date).toBe(meterReadings[0].date)
        expect(metersReadings2[0].meter.id).toBe(meterReadings[0].meter.id)
        expect(metersReadings2[0].accountNumber).toBe(meterReadings[0].accountNumber)
        expect(metersReadings2[0].organization.id).toBe(meterReadings[0].organization.id)
        expect(metersReadings2[0].source.id).toBe(meterReadings[0].source.id)

    })

})
