/**
 * Generated by `createservice meter.RegisterMetersReadingsService --type mutations`
 */
const dayjs = require('dayjs')
const customParseFormat = require('dayjs/plugin/customParseFormat')
const { get, isUndefined, isEmpty, isNumber, isString, isNil, pick, set } = require('lodash')
const uniq = require('lodash/uniq')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find, getById } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')
const { i18n } = require('@open-condo/locales/loader')

const { PropertyResolver } = require('@condo/domains/billing/schema/resolvers')
const access = require('@condo/domains/meter/access/RegisterMetersReadingsService')
const { OTHER_METER_READING_SOURCE_ID } = require('@condo/domains/meter/constants/constants')
const {
    TOO_MUCH_READINGS,
    ORGANIZATION_NOT_FOUND,
    PROPERTY_NOT_FOUND,
    INVALID_METER_VALUES,
    MULTIPLE_METERS_FOUND,
    INVALID_ACCOUNT_NUMBER,
    INVALID_METER_NUMBER,
    INVALID_DATE,
} = require('@condo/domains/meter/constants/errors')
const { Meter, MeterReading } = require('@condo/domains/meter/utils/serverSchema')

dayjs.extend(customParseFormat)

const ISO_DATE_FORMAT = 'YYYY-MM-DD'
const EUROPEAN_DATE_FORMAT = 'DD.MM.YYYY'
const DATE_PARSING_FORMATS = [
    'YYYY-MM-DDTHH:mm:ss.SSS[Z]', // The result of dayjs().toISOString()
    `${ISO_DATE_FORMAT} HH:mm:ss`, `${EUROPEAN_DATE_FORMAT} HH:mm:ss`, // Up to seconds
    `${ISO_DATE_FORMAT} HH:mm`, `${EUROPEAN_DATE_FORMAT} HH:mm`, // Up to minutes
    ISO_DATE_FORMAT, EUROPEAN_DATE_FORMAT, // No time
    'YYYY-MM', 'MM-YYYY', 'YYYY.MM', 'MM.YYYY', // Some exotic cases
]
const READINGS_LIMIT = 500

const ERRORS = {
    TOO_MUCH_READINGS: {
        code: BAD_USER_INPUT,
        type: TOO_MUCH_READINGS,
        message: 'Too much readings. {sentCount} sent, limit is {limit}.',
        messageForUser: 'api.meter.registerMetersReadings.TOO_MUCH_READINGS',
        messageInterpolation: {
            limit: READINGS_LIMIT,
            sentCount: '??',  // runtime value
        },
    },
    ORGANIZATION_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: ORGANIZATION_NOT_FOUND,
        message: 'Organization not found',
        messageForUser: 'api.meter.registerMetersReadings.ORGANIZATION_NOT_FOUND',
    },
    PROPERTY_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: PROPERTY_NOT_FOUND,
        message: 'Property not found',
        messageForUser: 'api.meter.registerMetersReadings.PROPERTY_NOT_FOUND',
    },
    INVALID_METER_VALUES: {
        code: BAD_USER_INPUT,
        type: INVALID_METER_VALUES,
        message: 'Invalid meter values',
        messageForUser: 'api.meter.registerMetersReadings.INVALID_METER_VALUES',
    },
    MULTIPLE_METERS_FOUND: {
        code: BAD_USER_INPUT,
        type: MULTIPLE_METERS_FOUND,
        message: 'Multiple meters found',
        messageForUser: 'api.meter.registerMetersReadings.MULTIPLE_METERS_FOUND',
    },
    INVALID_ACCOUNT_NUMBER: {
        code: BAD_USER_INPUT,
        type: INVALID_ACCOUNT_NUMBER,
        message: 'Invalid account number',
        messageForUser: 'api.meter.registerMetersReadings.INVALID_ACCOUNT_NUMBER',
    },
    INVALID_METER_NUMBER: {
        code: BAD_USER_INPUT,
        type: INVALID_METER_NUMBER,
        message: 'Invalid meter number',
        messageForUser: 'api.meter.registerMetersReadings.INVALID_METER_NUMBER',
    },
    INVALID_DATE: {
        code: BAD_USER_INPUT,
        type: INVALID_DATE,
        message: 'Invalid date',
        messageForUser: 'api.meter.registerMetersReadings.INVALID_DATE',
    },
}

const SYMBOLS_TO_CUT_FROM_DATES_REGEXP = /[^-_:.,( )/\d]/g

/**
 * @param {string} dateStr
 * @return {undefined|string}
 */
function sanitizeDateStr (dateStr) {
    if (isEmpty(dateStr) || !isString(dateStr)) {
        return undefined
    }

    const sanitizedDateStr = dateStr.replace(SYMBOLS_TO_CUT_FROM_DATES_REGEXP, '')
    if (isEmpty(sanitizedDateStr)) {
        return undefined
    }

    return sanitizedDateStr
}

/**
 * @param {string} dateStr
 * @return {undefined|string}
 */
function toISO (dateStr) {
    const sanitizedDateStr = sanitizeDateStr(dateStr)

    if (isEmpty(sanitizedDateStr)) {
        return undefined
    }

    return dayjs(sanitizedDateStr, DATE_PARSING_FORMATS).toISOString()
}

/**
 * @param {string} dateStr
 * @return {boolean}
 */
function isDateValid (dateStr) {
    const sanitizedStr = sanitizeDateStr(dateStr)
    return dayjs(sanitizedStr, DATE_PARSING_FORMATS).isValid()
}

/**
 * @param value
 * @return {undefined|string|null}
 */
function normalizeMeterValue (value) {
    if (!(isString(value) || isNumber(value) || isUndefined(value))) return null
    if (isUndefined(value)) return value

    const transformedValue = String(value).trim().replaceAll(',', '.')
    if (isEmpty(transformedValue)) return undefined
    return String(Number(transformedValue))
}

/**
 * @param {string | null | undefined} value
 * @return {boolean}
 */
function validateMeterValue (value) {
    if (!isString(value) && !isUndefined(value)) return false
    if (isUndefined(value)) return true

    return !isEmpty(value) && !isNaN(Number(value)) && isFinite(Number(value)) && Number(value) >= 0
}

/**
 * @param {MeterReading} meterReading
 * @return {Object}
 */
function meterReadingAsResult (meterReading) {
    return {
        id: meterReading.id,
        meter: {
            ...pick(meterReading.meter, ['id', 'unitType', 'unitName', 'accountNumber', 'number']),
            property: pick(meterReading.meter.property, ['id', 'address', 'addressKey']),
        },
    }
}

function transformToPlainObject (input) {
    let result = {}

    for (let key in input) {
        if (typeof input[key] === 'object' && input[key] !== null && input[key].id) {
            result[key] = input[key].id
        } else {
            result[key] = input[key]
        }
    }

    return result
}

/**
 * @param {Meter} meter
 * @param {RegisterMetersReadingsMeterMetaInput} changedFields
 * @return {boolean}
 */
function shouldUpdateMeter (meter, changedFields) {
    const fieldsToUpdate = [
        'accountNumber',
        'numberOfTariffs',
        'place',
        'verificationDate',
        'nextVerificationDate',
        'installationDate',
        'commissioningDate',
        'sealingDate',
        'controlReadingsDate',
    ]

    return fieldsToUpdate.reduce((result, field) => {
        if (result) {
            return result
        }
        return !!get(changedFields, field) && get(changedFields, field) !== get(meter, field)
    }, false)
}

const RegisterMetersReadingsService = new GQLCustomSchema('RegisterMetersReadingsService', {
    types: [
        {
            access: true,
            type: 'input RegisterMetersReadingsMeterMetaInput {' +
                'numberOfTariffs: Int,' +
                'place: String,' +
                'verificationDate: String,' +
                'nextVerificationDate: String,' +
                'installationDate: String,' +
                'commissioningDate: String,' +
                'sealingDate: String,' +
                'controlReadingsDate: String,' +
                'isAutomatic: Boolean' +
                '}',
        },
        {
            access: true,
            type: 'input RegisterMetersReadingsReadingAddressInfoInput { unitType: String, unitName: String, globalId: String }',
        },
        {
            access: true,
            type: 'input RegisterMetersReadingsReadingInput {' +
                'address: String!,' +
                'addressInfo: RegisterMetersReadingsReadingAddressInfoInput!,' +
                'accountNumber: String!,' +
                'meterNumber: String!,' +
                'meterResource: MeterResourceWhereUniqueInput!,' +
                'date: String!,' +
                'value1: String!,' +
                'value2: String,' +
                'value3: String,' +
                'value4: String,' +
                'meterMeta: RegisterMetersReadingsMeterMetaInput,' +
                'readingSource: MeterReadingSourceWhereUniqueInput' +
                '}',
        },
        {
            access: true,
            type: 'input RegisterMetersReadingsInput { dv: Int!, sender: SenderFieldInput!, organization: OrganizationWhereUniqueInput!, readings: [RegisterMetersReadingsReadingInput!]! }',
        },
        {
            access: true,
            type: 'type RegisterMetersReadingsMeterPropertyOutput { id: ID!, address: String!, addressKey: String! }',
        },
        {
            access: true,
            type: 'type RegisterMetersReadingsMeterOutput { id: ID!, property: RegisterMetersReadingsMeterPropertyOutput!, unitType: String!, unitName: String!, accountNumber: String!, number: String! }',
        },
        {
            access: true,
            type: 'type RegisterMetersReadingsOutput { id: ID!, meter: RegisterMetersReadingsMeterOutput! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterMetersReadings,
            schema: 'registerMetersReadings(data: RegisterMetersReadingsInput!): [RegisterMetersReadingsOutput]',
            resolver: async (parent, /**{ data: RegisterMetersReadingsInput }*/args, context) => {
                const { data: { dv, sender, organization, readings } } = args

                if (readings.length > READINGS_LIMIT) {
                    throw new GQLError({
                        ...ERRORS.TOO_MUCH_READINGS,
                        messageInterpolation: { limit: READINGS_LIMIT, sentCount: readings.length },
                    }, context)
                }

                /** @type Organization */
                const organizationData = await getById('Organization', organization.id)

                if (!organizationData || !!organizationData.deletedAt) {
                    throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)
                }

                const locale = extractReqLocale(context.req) || conf.DEFAULT_LOCALE

                const propertyResolver = new PropertyResolver({ context })
                propertyResolver.tin = organizationData.tin
                propertyResolver.organizationId = organization.id

                const resolvedAddresses = await propertyResolver.normalizeAddresses(readings.reduce((res, reading) => ({
                    ...res,
                    [reading.address]: {
                        address: reading.address,
                        addressMeta: reading.addressInfo,
                    },
                }), {}))

                const addressesKeys = uniq(
                    readings
                        .map((reading) => get(resolvedAddresses, [reading.address, 'addressResolve', 'propertyAddress', 'addressKey']))
                        .filter(Boolean)
                )

                /** @type Property[] */
                const properties = await find('Property', {
                    organization,
                    deletedAt: null,
                    addressKey_in: addressesKeys,
                })

                const resultRows = []

                const meterNumbers = uniq(readings.map(reading => reading.meterNumber.trim()))
                const meters = await find('Meter', {
                    organization,
                    number_in: meterNumbers,
                    deletedAt: null,
                })

                const readingsWithValidDates = readings.filter(reading => isDateValid(reading.date))
                const plainMeterReadings = await find('MeterReading', {
                    meter: { id_in: meters.map(meter => meter.id) },
                    date_in: uniq(readingsWithValidDates.map(reading => toISO(reading.date))),
                })
                const propertyByIdMap = properties.reduce((acc, property) => {
                    acc[property.id] = property
                    return acc
                }, {})
                const metersWithPropertyByIdMap = meters.reduce((acc, meter) => {
                    acc[meter.id] = {
                        ...meter,
                        property: propertyByIdMap[meter.property],
                    }
                    return acc
                }, {})
                const meterReadings = plainMeterReadings.map(reading => ({
                    ...reading,
                    meter: metersWithPropertyByIdMap[reading.meter],
                }))
                const meterReadingByDate = meterReadings.reduce((acc, reading) => {
                    const key = `${reading.meter.id}-${reading.date.toISOString()}`
                    acc[key] = reading
                    return acc
                }, {})

                for (const reading of readings) {
                    const meterNumber = reading.meterNumber.trim()
                    const accountNumber = reading.accountNumber.trim()
                    const unitType = get(reading, ['addressInfo', 'unitType'], get(resolvedAddresses, [reading.address, 'addressResolve', 'unitType'], '')).trim() || null
                    const unitName = get(reading, ['addressInfo', 'unitName'], get(resolvedAddresses, [reading.address, 'addressResolve', 'unitName'], '')).trim() || null
                    const addressKey = get(resolvedAddresses, [reading.address, 'addressResolve', 'propertyAddress', 'addressKey'])
                    let readingSource = get(reading, 'readingSource')

                    if (isNil(readingSource)) {
                        readingSource = { id: OTHER_METER_READING_SOURCE_ID }
                    }

                    if (isEmpty(accountNumber)) {
                        resultRows.push(new GQLError(ERRORS.INVALID_ACCOUNT_NUMBER, context))
                        continue
                    }

                    if (isEmpty(meterNumber)) {
                        resultRows.push(new GQLError(ERRORS.INVALID_METER_NUMBER, context))
                        continue
                    }

                    if (!isDateValid(reading.date)) {
                        resultRows.push(new GQLError({
                            ...ERRORS.INVALID_DATE,
                            messageInterpolation: {
                                columnName: i18n('meter.import.column.meterReadingSubmissionDate', { locale }),
                                format: [ISO_DATE_FORMAT, EUROPEAN_DATE_FORMAT].join('", "'),
                            },
                        }, context))
                        continue
                    }

                    const dateISO = toISO(reading.date)
                    const property = properties.find((p) => p.addressKey === addressKey)

                    if (!property) {
                        resultRows.push(new GQLError(ERRORS.PROPERTY_NOT_FOUND, context))
                        continue
                    }

                    let meterId
                    const foundMeters = meters.filter(meter => {
                        return meter.property === property.id &&
                            meter.unitType === unitType &&
                            meter.unitName === unitName &&
                            meter.accountNumber === accountNumber &&
                            meter.number === meterNumber &&
                            meter.resource === reading.meterResource.id
                    })

                    if (foundMeters.length > 1) {
                        resultRows.push(new GQLError({
                            ...ERRORS.MULTIPLE_METERS_FOUND,
                            messageInterpolation: { count: foundMeters.length },
                        }, context))
                        continue
                    }

                    const foundMeter = foundMeters[0]

                    const errorValues = {}
                    const values = ['value1', 'value2', 'value3', 'value4'].reduce((result, currentValue) => {
                        const value = reading[currentValue]
                        const normalizedValue = normalizeMeterValue(value)

                        if (!validateMeterValue(normalizedValue)) {
                            set(errorValues, currentValue, value)
                            return result
                        }

                        return {
                            ...result,
                            [currentValue]: normalizedValue,
                        }
                    }, {})

                    if (Object.keys(errorValues).length > 0) {
                        const errorValuesKeys = Object.keys(errorValues)
                        const valuesList = errorValuesKeys.map((errKey) => {
                            const column = i18n(`meter.import.column.${errKey}`, { locale })
                            return `"${column}"="${errorValues[errKey]}"`
                        }).join(', ')
                        resultRows.push(new GQLError(
                            { ...ERRORS.INVALID_METER_VALUES, messageInterpolation: { valuesList } },
                            context,
                        ))
                        continue
                    }

                    try {
                        if (foundMeter) {
                            meterId = foundMeter.id
                            const fieldsToUpdate = {
                                accountNumber,
                                numberOfTariffs: get(reading, ['meterMeta', 'numberOfTariffs']),
                                place: get(reading, ['meterMeta', 'place']),
                                verificationDate: toISO(get(reading, ['meterMeta', 'verificationDate'])),
                                nextVerificationDate: toISO(get(reading, ['meterMeta', 'nextVerificationDate'])),
                                installationDate: toISO(get(reading, ['meterMeta', 'installationDate'])),
                                commissioningDate: toISO(get(reading, ['meterMeta', 'commissioningDate'])),
                                sealingDate: toISO(get(reading, ['meterMeta', 'sealingDate'])),
                                controlReadingsDate: toISO(get(reading, ['meterMeta', 'controlReadingsDate'])),
                                isAutomatic: get(reading, ['meterMeta', 'isAutomatic']),
                            }
                            if (shouldUpdateMeter(foundMeter, fieldsToUpdate)) {
                                const updatedMeter = await Meter.update(context, foundMeter.id, { dv, sender, ...fieldsToUpdate })
                                const meterIndex = meters.indexOf(meter => meter.id === updatedMeter.id)
                                meters[meterIndex] = transformToPlainObject(updatedMeter)
                            }
                        } else {
                            const rawControlReadingsDate = get(reading, ['meterMeta', 'controlReadingsDate'])
                            const createdMeter = await Meter.create(context, {
                                dv,
                                sender,
                                organization: { connect: organization },
                                property: { connect: { id: property.id } },
                                unitType,
                                unitName,
                                accountNumber,
                                number: meterNumber,
                                resource: { connect: reading.meterResource },
                                numberOfTariffs: get(reading, ['meterMeta', 'numberOfTariffs'], Object.values(values).filter(Boolean).length),
                                place: get(reading, ['meterMeta', 'place']),
                                verificationDate: toISO(get(reading, ['meterMeta', 'verificationDate'])),
                                nextVerificationDate: toISO(get(reading, ['meterMeta', 'nextVerificationDate'])),
                                installationDate: toISO(get(reading, ['meterMeta', 'installationDate'])),
                                commissioningDate: toISO(get(reading, ['meterMeta', 'commissioningDate'])),
                                sealingDate: toISO(get(reading, ['meterMeta', 'sealingDate'])),
                                controlReadingsDate: rawControlReadingsDate ? toISO(rawControlReadingsDate) : dayjs().toISOString(),
                                isAutomatic: get(reading, ['meterMeta', 'isAutomatic']),
                            })
                            meterId = createdMeter.id
                            meters.push(transformToPlainObject(createdMeter))
                        }
                    } catch (e) {
                        resultRows.push(e)
                        continue
                    }

                    try {
                        const key = `${meterId}-${dateISO}`
                        const duplicateReading = meterReadingByDate[key]

                        if (!duplicateReading) {
                            const createdMeterReading = await MeterReading.create(context, {
                                dv,
                                sender,
                                meter: { connect: { id: meterId } },
                                source: { connect: readingSource },
                                date: toISO(reading.date),
                                ...values,
                            })

                            meterReadingByDate[key] = createdMeterReading
                            resultRows.push(meterReadingAsResult(createdMeterReading))
                        } else {
                            resultRows.push(meterReadingAsResult(duplicateReading))
                        }
                    } catch (e) {
                        resultRows.push(e)
                    }
                }

                return resultRows
            },
        },
    ],

})

module.exports = {
    RegisterMetersReadingsService,
}
