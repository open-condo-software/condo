/**
 * Generated by `createservice meter.RegisterMetersReadingsService --type mutations`
 */
const dayjs = require('dayjs')
const { get, isUndefined, isEmpty, isNumber, isString } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find, getByCondition, getById } = require('@open-condo/keystone/schema')

const { PropertyResolver } = require('@condo/domains/billing/schema/resolvers')
const access = require('@condo/domains/meter/access/RegisterMetersReadingsService')
const { IMPORT_CONDO_METER_READING_SOURCE_ID } = require('@condo/domains/meter/constants/constants')
const {
    TOO_MUCH_READINGS,
    ORGANIZATION_NOT_FOUND,
    PROPERTY_NOT_FOUND,
    INVALID_METER_VALUE,
} = require('@condo/domains/meter/constants/errors')
const { Meter, MeterReading } = require('@condo/domains/meter/utils/serverSchema')

const READINGS_LIMIT = 500

const ERRORS = {
    TOO_MUCH_READINGS: (sentCount) => ({
        code: BAD_USER_INPUT,
        type: TOO_MUCH_READINGS,
        message: `Too much readings. Maximum is ${READINGS_LIMIT}.`,
        messageForUser: 'api.meter.registerMetersReadings.TOO_MUCH_READINGS',
        messageInterpolation: { limit: READINGS_LIMIT, sentCount },
    }),
    ORGANIZATION_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: ORGANIZATION_NOT_FOUND,
        message: 'Organization not found',
        messageForUser: 'api.meter.registerMetersReadings.ORGANIZATION_NOT_FOUND',
    },
    PROPERTY_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: PROPERTY_NOT_FOUND,
        message: 'Property not found',
        messageForUser: 'api.meter.registerMetersReadings.PROPERTY_NOT_FOUND',
    },
    INVALID_METER_VALUE: (key, value) => ({
        code: BAD_USER_INPUT,
        type: INVALID_METER_VALUE,
        message: 'Invalid meter value',
        messageForUser: 'api.meter.registerMetersReadings.INVALID_METER_VALUE',
        messageInterpolation: { key, value },
    }),
}

function toISO (str) {
    if (isEmpty(str)) {
        return undefined
    }

    return dayjs(str).toISOString()
}

/**
 * @param value
 * @return {undefined|string|null}
 */
function normalizeMeterValue (value) {
    if (!(isString(value) || isNumber(value) || isUndefined(value))) return null
    if (isUndefined(value)) return value

    const transformedValue = String(value).trim().replaceAll(',', '.')
    if (isEmpty(transformedValue)) return undefined
    return String(Number(transformedValue))
}

/**
 * @param {string | null | undefined} value
 * @return {boolean}
 */
function validateMeterValue (value) {
    if (!isString(value) && !isUndefined(value)) return false
    if (isUndefined(value)) return true

    return !isEmpty(value) && !isNaN(Number(value)) && isFinite(Number(value)) && Number(value) >= 0
}

const RegisterMetersReadingsService = new GQLCustomSchema('RegisterMetersReadingsService', {
    types: [
        {
            access: true,
            type: 'input RegisterMetersReadingsMeterMetaInput {' +
                'numberOfTariffs: Int,' +
                'place: String,' +
                'verificationDate: String,' +
                'nextVerificationDate: String,' +
                'installationDate: String,' +
                'commissioningDate: String,' +
                'sealingDate: String,' +
                'controlReadingsDate: String' +
                '}',
        },
        {
            access: true,
            type: 'input RegisterMetersReadingsReadingAddressMetaInput { unitType: String!, unitName: String!, globalId: String }',
        },
        {
            access: true,
            type: 'input RegisterMetersReadingsReadingInput {' +
                'address: String!,' +
                'addressMeta: RegisterMetersReadingsReadingAddressMetaInput!,' +
                'accountNumber: String!,' +
                'meterNumber: String!,' +
                'meterResource: MeterResourceWhereUniqueInput!,' +
                'date: String!,' +
                'value1: String!,' +
                'value2: String,' +
                'value3: String,' +
                'value4: String,' +
                'meterMeta: RegisterMetersReadingsMeterMetaInput' +
                '}',
        },
        {
            access: true,
            type: 'input RegisterMetersReadingsInput { dv: Int!, sender: SenderFieldInput!, organization: OrganizationWhereUniqueInput!, readings: [RegisterMetersReadingsReadingInput!]! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterMetersReadings,
            schema: 'registerMetersReadings(data: RegisterMetersReadingsInput!): [MeterReading]',
            resolver: async (parent, /**{ data: RegisterMetersReadingsInput }*/args, context) => {
                const { data: { dv, sender, organization, readings } } = args

                if (readings.length > READINGS_LIMIT) {
                    throw new GQLError(ERRORS.TOO_MUCH_READINGS(readings.length), context)
                }

                /** @type Organization */
                const organizationData = await getById('Organization', organization.id)

                if (!organizationData || !!organizationData.deletedAt) {
                    throw new GQLError(ERRORS.ORGANIZATION_NOT_FOUND, context)
                }

                const propertyResolver = new PropertyResolver({ context })
                propertyResolver.tin = organizationData.tin

                const resolvedAddresses = await propertyResolver.normalizeAddresses(readings.reduce((res, reading, index) => ({
                    ...res,
                    [reading.address]: {
                        address: reading.address,
                        addressMeta: reading.addressMeta,
                    },
                }), {}))

                const propertyOrConditions = []
                for (const reading of readings) {
                    const addressKey = get(resolvedAddresses, [reading.address, 'addressResolve', 'propertyAddress', 'addressKey'])
                    propertyOrConditions.push({ ...addressKey ? { OR: [{ address_i: reading.address }, { addressKey }] } : { address_i: reading.address } })
                }

                /** @type Property[] */
                const properties = await find('Property', {
                    organization,
                    deletedAt: null,
                    OR: propertyOrConditions,
                })

                const resultRows = []

                for (const reading of readings) {
                    const addressKey = get(resolvedAddresses, [reading.address, 'addressResolve', 'propertyAddress', 'addressKey'])

                    const property = properties.find((p) => {
                        return p.address === reading.address || p.addressKey === addressKey
                    })

                    if (!property) {
                        resultRows.push(new GQLError(ERRORS.PROPERTY_NOT_FOUND, context))
                        continue
                    }

                    let meterId
                    const foundMeter = await getByCondition('Meter', {
                        organization,
                        property: { id: property.id },
                        unitType: reading.addressMeta.unitType,
                        unitName: reading.addressMeta.unitName,
                        accountNumber: reading.accountNumber,
                        number: reading.meterNumber,
                    })

                    const values = ['value1', 'value2', 'value3', 'value4'].reduce((result, currentValue) => {
                        const value = reading[currentValue]
                        const normalizedValue = normalizeMeterValue(value)

                        if (!validateMeterValue(normalizedValue)) {
                            throw new GQLError(ERRORS.INVALID_METER_VALUE(currentValue, value), context)
                        }

                        return {
                            ...result,
                            [currentValue]: normalizedValue,
                        }
                    }, {})

                    if (foundMeter) {
                        meterId = foundMeter.id
                    } else {
                        try {
                            const rawControlReadingsDate = get(reading, ['meterMeta', 'controlReadingsDate'])
                            const createdMeter = await Meter.create(context, {
                                dv,
                                sender,
                                organization: { connect: organization },
                                property: { connect: { id: property.id } },
                                unitType: reading.addressMeta.unitType,
                                unitName: reading.addressMeta.unitName,
                                accountNumber: reading.accountNumber,
                                number: reading.meterNumber,
                                resource: { connect: reading.meterResource },
                                numberOfTariffs: get(reading, ['meterMeta', 'numberOfTariffs'], Object.values(values).filter(Boolean).length),
                                place: get(reading, ['meterMeta', 'place']),
                                verificationDate: toISO(get(reading, ['meterMeta', 'verificationDate'])),
                                nextVerificationDate: toISO(get(reading, ['meterMeta', 'nextVerificationDate'])),
                                installationDate: toISO(get(reading, ['meterMeta', 'installationDate'])),
                                commissioningDate: toISO(get(reading, ['meterMeta', 'commissioningDate'])),
                                sealingDate: toISO(get(reading, ['meterMeta', 'sealingDate'])),
                                controlReadingsDate: rawControlReadingsDate ? toISO(rawControlReadingsDate) : dayjs().toISOString(),
                            })
                            meterId = createdMeter.id
                        } catch (e) {
                            resultRows.push(e)
                            continue
                        }
                    }

                    try {
                        const createdMeterReading = await MeterReading.create(context, {
                            dv,
                            sender,
                            meter: { connect: { id: meterId } },
                            source: { connect: { id: IMPORT_CONDO_METER_READING_SOURCE_ID } },
                            date: toISO(reading.date),
                            ...values,
                        })

                        resultRows.push(createdMeterReading)
                    } catch (e) {
                        resultRows.push(e)
                    }
                }

                const metersReadings = await find('MeterReading', { id_in: resultRows.map((row) => get(row, 'id')).filter(Boolean) })
                const metersReadingsIndex = Object.fromEntries(metersReadings.map(meterReading => ([meterReading.id, meterReading])))

                return resultRows.map((row) => (!!row.id && !!metersReadingsIndex[row.id]) ? Promise.resolve(get(metersReadingsIndex, row.id)) : Promise.reject(row))
            },
        },
    ],

})

module.exports = {
    RegisterMetersReadingsService,
}
