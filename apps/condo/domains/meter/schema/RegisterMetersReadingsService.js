/**
 * Generated by `createservice meter.RegisterMetersReadingsService --type mutations`
 */

const dayjs = require('dayjs')
const { get, set } = require('lodash')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, getByCondition, getById } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')
const { i18n } = require('@open-condo/locales/loader')

const { PropertyResolver } = require('@condo/domains/billing/schema/resolvers')
const access = require('@condo/domains/meter/access/RegisterMetersReadingsService')
const { IMPORT_CONDO_METER_READING_SOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { TOO_MUCH_ITEMS } = require('@condo/domains/meter/constants/errors')
const { Meter, MeterReading } = require('@condo/domains/meter/utils/serverSchema')

const MAX_ITEMS = 500

const ERRORS = {
    TOO_MUCH_ITEMS: {
        code: BAD_USER_INPUT,
        type: TOO_MUCH_ITEMS,
        message: `Too much items. Maximum is ${MAX_ITEMS}.`,
    },
}

function toISO (str) {
    return dayjs(str).toISOString()
}

const RegisterMetersReadingsService = new GQLCustomSchema('RegisterMetersReadingsService', {
    types: [
        // IN
        {
            access: true,
            type: 'input RegisterMetersMeterReadingInput { date: String!, v1: String!, v2: String, v3: String, v4: String }',
        },
        {
            access: true,
            type: 'input RegisterMetersMeterDatesInput { verificationDate: String, nextVerificationDate: String, installationDate: String, commissioningDate: String, sealingDate: String, controlReadingsDate: String }',
        },
        {
            access: true,
            type: 'input RegisterMetersMeterInput { number: String!, resourceTypeId: ID, numberOfTariffs: Int, place: String, readings: [RegisterMetersMeterReadingInput!], dates: RegisterMetersMeterDatesInput }',
        },
        {
            access: true,
            type: 'input RegisterMetersItemAddressMetaInput { unitType: String, unitName: String, globalId: String }',
        },
        {
            access: true,
            type: 'input RegisterMetersItemAccountMetaInput { globalId: String, clientName: String }',
        },
        {
            access: true,
            type: 'input RegisterMetersItemInput { address: String!, addressMeta: RegisterMetersItemAddressMetaInput, accountNumber: String!, accountMeta: RegisterMetersItemAccountMetaInput, meters: [RegisterMetersMeterInput!]! }',
        },
        {
            access: true,
            type: 'input RegisterMetersReadingsInput { dv: Int!, sender: JSON!, organization: OrganizationWhereUniqueInput!, items: [RegisterMetersItemInput!]! }',
        },

        // OUT
        {
            access: true,
            type: 'type RegisterMetersMeterReadingResultSuccessOutput { id: ID! }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterReadingResultErroneousOutput { message: String! }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterReadingResultOutput { error: RegisterMetersMeterReadingResultErroneousOutput, data: RegisterMetersMeterReadingResultSuccessOutput }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterReadingOutput { v1: String!, v2: String, v3: String, v4: String, result: RegisterMetersMeterReadingResultOutput }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterResultSuccessOutput { id: ID!, readings: [RegisterMetersMeterReadingOutput!]! }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterResultErroneousOutput { message: String! }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterResultOutput { error: RegisterMetersMeterResultErroneousOutput, data: RegisterMetersMeterResultSuccessOutput }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterOutput { number: String!, result: RegisterMetersMeterResultOutput! }',
        },
        {
            access: true,
            type: 'type RegisterMetersItemResultSuccessOutput { propertyId: ID!, meters: [RegisterMetersMeterOutput!]! }',
        },
        {
            access: true,
            type: 'type RegisterMetersItemResultErroneousOutput { message: String! }',
        },
        {
            access: true,
            type: 'type RegisterMetersItemResultOutput { error: RegisterMetersItemResultErroneousOutput, data: RegisterMetersItemResultSuccessOutput }',
        },
        {
            access: true,
            type: 'type RegisterMetersItemOutput { address: String!, accountNumber: String!, result: RegisterMetersItemResultOutput! }',
        },
        {
            access: true,
            type: 'type RegisterMetersReadingsOutput { items: [RegisterMetersItemOutput!]! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterMetersReadings,
            schema: 'registerMetersReadings(data: RegisterMetersReadingsInput!): RegisterMetersReadingsOutput',
            resolver: async (parent, /**{ data: RegisterMetersReadingsInput }*/args, context) => {
                const { data: { dv, sender, organization, items } } = args

                if (items.length > MAX_ITEMS) {
                    throw new GQLError(ERRORS.TOO_MUCH_ITEMS, context)
                }

                const locale = extractReqLocale(context.req) || conf.DEFAULT_LOCALE

                const organizationData = await getById('Organization', organization.id)

                const propertyResolver = new PropertyResolver({ context })
                propertyResolver.tin = organizationData.tin

                /** @type RegisterMetersItemOutput[] */
                const itemsResult = []

                for (const item of items) {
                    /** @type RegisterMetersItemOutput */
                    const itemResult = {
                        address: item.address,
                        accountNumber: item.accountNumber,
                        result: {
                            error: { message: i18n('common.errors.serverError', { locale }) },
                        },
                    }

                    const resolvedAddress = await propertyResolver.normalizeAddresses({
                        [item.address]: {
                            address: item.address,
                            addressMeta: item.addressMeta,
                        },
                    })

                    const addressKey = get(resolvedAddress, [item.address, 'addressResolve', 'propertyAddress', 'addressKey'])
                    const property = await getByCondition('Property', {
                        organization,
                        ...addressKey ? { OR: [{ address_i: item.address }, { addressKey }] } : { address_i: item.address },
                    })

                    if (!property) {
                        set(itemResult, 'result', {
                            error: { message: i18n('field.Address.notFound', { locale }) },
                        })
                    } else {
                        set(itemResult, 'result', {
                            data: {
                                propertyId: property.id,
                                meters: [],
                            },
                        })

                        const itemResultMeters = []
                        for (const meterData of item.meters) {
                            /** @type RegisterMetersMeterResultOutput */
                            const meterResult = {
                                error: { message: i18n('common.errors.serverError', { locale }) },
                            }
                            let meterId
                            const foundMeter = await getByCondition('Meter', {
                                organization,
                                property: { id: property.id },
                                unitType: item.addressMeta.unitType,
                                unitName: item.addressMeta.unitName,
                                accountNumber: item.accountNumber,
                                number: meterData.number,
                            })

                            try {
                                const meterDatesData = get(meterData, 'dates', {})
                                const meterDates = Object.keys(meterDatesData).reduce((result, field) => {
                                    return {
                                        ...result,
                                        [field]: toISO(get(meterDatesData, field)),
                                    }
                                }, {})

                                if (!meterDates.controlReadingsDate) {
                                    meterDates.controlReadingsDate = dayjs().toISOString()
                                }

                                if (foundMeter) {
                                    meterId = foundMeter.id
                                    await Meter.update(context, foundMeter.id, {
                                        dv,
                                        sender,
                                        resource: { connect: { id: meterData.resourceTypeId } },
                                        numberOfTariffs: meterData.numberOfTariffs,
                                        place: meterData.place,
                                        ...meterDates,
                                    })
                                } else {
                                    const createdMeter = await Meter.create(context, {
                                        dv,
                                        sender,
                                        organization: { connect: organization },
                                        property: { connect: { id: property.id } },
                                        unitType: String(item.addressMeta.unitType),
                                        unitName: String(item.addressMeta.unitName),
                                        accountNumber: item.accountNumber,
                                        number: meterData.number,
                                        resource: { connect: { id: meterData.resourceTypeId } },
                                        numberOfTariffs: meterData.numberOfTariffs,
                                        place: meterData.place,
                                        ...meterDates,
                                    })
                                    meterId = createdMeter.id
                                }

                                meterResult.error = undefined
                                meterResult.data = { id: meterId, readings: [] }

                                const meterReadingsResults = []
                                for (const /**RegisterMetersMeterReading*/readingData of get(meterData, 'readings', [])) {
                                    const meterReadingResult = {
                                        error: { message: i18n('common.errors.serverError', { locale }) },
                                    }
                                    try {
                                        const meterReadingModel = await MeterReading.create(context, {
                                            dv,
                                            sender,
                                            meter: { connect: { id: meterId } },
                                            source: { connect: { id: IMPORT_CONDO_METER_READING_SOURCE_ID } },
                                            value1: readingData.v1,
                                            value2: readingData.v2,
                                            value3: readingData.v3,
                                            value4: readingData.v4,
                                            date: toISO(readingData.date),
                                        })
                                        meterReadingResult.error = undefined
                                        meterReadingResult.data = { id: meterReadingModel.id }
                                    } catch (err) {
                                        meterReadingResult.error = {
                                            message: get(
                                                err,
                                                ['errors', 0, 'originalError', 'data', 'messages', 0],
                                                get(err,
                                                    ['graphQLErrors', 0, 'extensions', 'messageForUser'],
                                                    err.message,
                                                ),
                                            ),
                                        }
                                        meterReadingResult.data = undefined
                                    }
                                    meterReadingsResults.push({
                                        v1: readingData.v1,
                                        v2: readingData.v2,
                                        v3: readingData.v3,
                                        v4: readingData.v4,
                                        result: meterReadingResult,
                                    })
                                }

                                set(meterResult, ['data', 'readings'], meterReadingsResults)
                            } catch (err) {
                                meterResult.error = {
                                    message: get(
                                        err,
                                        ['errors', 0, 'originalError', 'data', 'messages', 0],
                                        get(err,
                                            ['graphQLErrors', 0, 'extensions', 'messageForUser'],
                                            err.message,
                                        ),
                                    ),
                                }
                                meterResult.data = undefined
                            }

                            itemResultMeters.push({ number: meterData.number, result: meterResult })
                        }
                        set(itemResult, ['result', 'data', 'meters'], itemResultMeters)
                    }

                    itemsResult.push(itemResult)
                }

                return { items: itemsResult }
            },
        },
    ],

})

module.exports = {
    RegisterMetersReadingsService,
}
