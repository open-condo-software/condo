/**
 * Generated by `createschema meter.MeterReadingExportTask 'status:Select:processing,completed,error; format:Select:excel; exportedRecordsCount:Integer; totalRecordsCount:Integer; file?:File; meta?:Json; where:Json; sortBy:Json; locale:Text; timeZone:Text; user:Relationship:User:CASCADE;'`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const get = require('lodash/get')
const uniqBy = require('lodash/uniqBy')

const conf = require('@open-condo/config')
const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, waitFor,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')
const { i18n } = require('@open-condo/locales/loader')

const { CANCELLED } = require('@condo/domains/common/constants/export')
const { COMPLETED } = require('@condo/domains/common/constants/export')
const { EXCEL } = require('@condo/domains/common/constants/export')
const { getTmpFile, downloadFile, readXlsx, expectDataFormat } = require('@condo/domains/common/utils/testSchema/file')
const { COLD_WATER_METER_RESOURCE_ID, CALL_METER_READING_SOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { ERRORS } = require('@condo/domains/meter/schema/MeterReadingExportTask')
const { MeterReadingExportTask, updateTestMeterReadingExportTask, MeterReading } = require('@condo/domains/meter/utils/testSchema')
const { createTestMeterReadingExportTask, MeterResource, MeterReadingSource, createTestMeter, createTestMeterReading } = require('@condo/domains/meter/utils/testSchema')
const {
    createTestOrganization,
    createTestOrganizationEmployee,
    makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee, createTestOrganizationEmployeeRole,
} = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

const DATE_FORMAT = 'DD.MM.YYYY'

const formatDate = (date, timeZone, format = DATE_FORMAT) => {
    return dayjs(date).tz(timeZone).format(format)
}

describe('MeterReadingExportTask', () => {
    let admin, support, anonymous

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        anonymous = await makeClient()
    })

    describe('Accesses', () => {
        describe('Admin', () => {
            let task, taskAttrs, organization, employeeClient
            beforeAll(async () => {
                const { organization: createdOrg, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                    canReadMeters: true,
                })
                employeeClient = userClient
                organization = createdOrg

                const [createdAdminTask, adminAttrs] = await createTestMeterReadingExportTask(admin, employeeClient.user, {
                    where: {
                        organization: {
                            id: organization.id,
                        },
                    },
                })
                task = createdAdminTask
                taskAttrs = adminAttrs
            })

            test('can create for any user', async () => {
                expect(task.id).toMatch(UUID_RE)
                expect(task.v).toEqual(1)
                expect(task.deletedAt).toEqual(null)
                expect(task.createdBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(task.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(task.createdAt).toMatch(DATETIME_RE)
                expect(task.updatedAt).toMatch(DATETIME_RE)
                expect(task.user.id).toEqual(employeeClient.user.id)
                expect(task.format).toEqual(EXCEL)
            })

            test('can read any tasks', async () => {
                const tasks = await MeterReadingExportTask.getAll(admin, {
                    id_in: [task.id],
                })

                expect(tasks).toHaveLength(1)
                expect(tasks.map(item => item.id)).toEqual((expect.arrayContaining([task.id])))
            })

            test('can update any tasks', async () => {
                const [createdAdminTask] = await createTestMeterReadingExportTask(admin, employeeClient.user, {
                    where: {
                        organization: {
                            id: organization.id,
                        },
                    },
                })

                // NOTE: we cannot guarantee that the task has been cancelled
                // because the task completion may happen very quickly before we send the task cancellation request
                await waitFor(async () => {
                    const foundedTask = await MeterReadingExportTask.getOne(admin, { id: createdAdminTask.id })
                    expect(foundedTask).toHaveProperty('status', COMPLETED)
                })
                await expectToThrowGQLError(async () => {
                    await updateTestMeterReadingExportTask(admin, createdAdminTask.id, {
                        status: CANCELLED,
                    })
                }, ERRORS.STATUS_IS_ALREADY_COMPLETED)
            })

            test('cannot delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReadingExportTask.delete(admin, task.id)
                })
            })

            test('can soft-delete any tasks', async () => {
                const [deletedAdminTask] = await MeterReadingExportTask.softDelete(admin, task.id)
                expect(deletedAdminTask.id).toEqual(task.id)
                expect(deletedAdminTask.deletedAt).not.toBeNull()
                expect(deletedAdminTask.deletedAt).toMatch(DATETIME_RE)
            })
        })

        describe('Support', () => {
            let adminTask, organization, employeeClient

            beforeAll(async () => {
                const { organization: createdOrg, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                    canManageMeterReadings: true,
                    canReadMeters: true,
                    canManageMeters: true,
                })
                employeeClient = userClient
                organization = createdOrg

                const [createdAdminTask] = await createTestMeterReadingExportTask(admin, employeeClient.user, {
                    where: {
                        organization: {
                            id: organization.id,
                        },
                    },
                })
                adminTask = createdAdminTask
            })

            test('cannot create for other user task', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeterReadingExportTask(support, employeeClient.user, {
                        where: {
                            organization: {
                                id: organization.id,
                            },
                        },
                    })
                })
            })

            test('cannot read for other user task', async () => {
                const tasks = await MeterReadingExportTask.getAll(support, {
                    id: adminTask.id,
                })
                expect(tasks).toHaveLength(0)
            })

            test('cannot update task for other user', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeterReadingExportTask(support, adminTask.id, {
                        status: CANCELLED,
                    })
                })
            })

            test('cannot delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReadingExportTask.delete(support, adminTask.id)
                })
            })

            test('cannot soft-delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReadingExportTask.softDelete(support, adminTask.id)
                })
            })
        })

        describe('User', () => {
            let task, taskAttrs, employeeClient1, employeeClient2, organization1, organization2

            beforeAll(async () => {
                const { userClient: employee1, organization, role } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                    canReadMeters: true,
                })
                employeeClient1 = employee1
                organization1 = organization

                const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                await createTestOrganizationEmployee(admin, organization, userClient.user, role)
                employeeClient2 = userClient

                const [otherOrganization] = await createTestOrganization(admin)
                organization2 = otherOrganization

                const [createdTask, attrs] = await createTestMeterReadingExportTask(employeeClient1, employeeClient1.user, {
                    where: {
                        organization: {
                            id: organization1.id,
                        },
                    },
                })
                task = createdTask
                taskAttrs = attrs
            })

            test('can create for self', async () => {
                expect(task.id).toMatch(UUID_RE)
                expect(task.v).toEqual(1)
                expect(task.deletedAt).toEqual(null)
                expect(task.createdBy).toEqual(expect.objectContaining({ id: employeeClient1.user.id }))
                expect(task.updatedBy).toEqual(expect.objectContaining({ id: employeeClient1.user.id }))
                expect(task.createdAt).toMatch(DATETIME_RE)
                expect(task.updatedAt).toMatch(DATETIME_RE)
                expect(task.user.id).toEqual(employeeClient1.user.id)
            })

            test('cannot create for other user', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeterReadingExportTask(employeeClient1, employeeClient2.user, {
                        where: {
                            organization: {
                                id: organization1.id,
                            },
                        },
                    })
                })
            })

            test('cannot create with filter by other organizations', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeterReadingExportTask(employeeClient1, employeeClient1.user, {
                        where: {
                            organization: {
                                id: organization2.id,
                            },
                        },
                    })
                })
            })

            test('cannot create if employee has canReadMeters: false', async () => {
                const employeeClient = await makeClientWithNewRegisteredAndLoggedInUser()
                const [role] = await createTestOrganizationEmployeeRole(admin, organization1, {
                    canReadMeters: false,
                })
                await createTestOrganizationEmployee(admin, organization1, employeeClient.user, role)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestMeterReadingExportTask(employeeClient, employeeClient.user, {
                        where: {
                            organization: {
                                id: organization1.id,
                            },
                        },
                    })
                })
            })

            test('can read its task', async () => {
                const [obj] = await MeterReadingExportTask.getAll(employeeClient1, {
                    id: task.id,
                })
                expect(obj.id).toEqual(task.id)
            })

            test('cannot read other user\'s task', async () => {
                const [createdTask] = await createTestMeterReadingExportTask(employeeClient2, employeeClient2.user, {
                    where: {
                        organization: {
                            id: organization1.id,
                        },
                    },
                })

                const result = await MeterReadingExportTask.getAll(employeeClient1, {
                    id: createdTask.id,
                })
                expect(result).toHaveLength(0)
            })

            test('can update its task', async () => {
                const [createdTask] = await createTestMeterReadingExportTask(employeeClient1, employeeClient1.user, {
                    where: {
                        organization: {
                            id: organization1.id,
                        },
                    },
                })

                // NOTE: we cannot guarantee that the task has been cancelled
                // because the task completion may happen very quickly before we send the task cancellation request
                await waitFor(async () => {
                    const foundedTask = await MeterReadingExportTask.getOne(employeeClient1, { id: createdTask.id })
                    expect(foundedTask).toHaveProperty('status', COMPLETED)
                })
                await expectToThrowGQLError(async () => {
                    await updateTestMeterReadingExportTask(employeeClient1, createdTask.id, {
                        status: CANCELLED,
                    })
                }, ERRORS.STATUS_IS_ALREADY_COMPLETED)
            })

            test('cannot update other user\'s task', async () => {
                const [createdTask] = await createTestMeterReadingExportTask(employeeClient2, employeeClient2.user, {
                    where: {
                        organization: {
                            id: organization1.id,
                        },
                    },
                })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestMeterReadingExportTask(employeeClient1, createdTask.id)
                })
            })

            test('cannot delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReadingExportTask.delete(employeeClient1, task.id)
                })
            })

            test('cannot soft-delete its task', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReadingExportTask.softDelete(employeeClient1, task.id)
                })
            })
        })

        describe('Anonymous', () => {
            let adminTask, employeeClient

            beforeAll(async () => {
                const { organization, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                    canManageMeterReadings: true,
                    canReadMeters: true,
                    canManageMeters: true,
                })
                employeeClient = userClient

                const [createdAdminTask] = await createTestMeterReadingExportTask(admin, employeeClient.user, {
                    where: {
                        organization: {
                            id: organization.id,
                        },
                    },
                })
                adminTask = createdAdminTask
            })
            test('cannot create', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestMeterReadingExportTask(anonymous, employeeClient.user)
                })
            })

            test('cannot read', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await MeterReadingExportTask.getAll(anonymous, {
                        id: adminTask.id,
                    })
                })
            })

            test('cannot update', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestMeterReadingExportTask(anonymous, adminTask.id)
                })
            })

            test('cannot delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await MeterReadingExportTask.delete(anonymous, adminTask.id)
                })
            })

            test('cannot soft-delete', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await MeterReadingExportTask.softDelete(anonymous, adminTask.id)
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('should throw validation error if you trying to change status of already completed task', async () => {
            const { organization, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
                canReadMeters: true,
                canManageMeters: true,
                canManageMeterReadings: true,
            })
            const [task] = await createTestMeterReadingExportTask(userClient, userClient.user, {
                where: {
                    organization: {
                        id: organization.id,
                    },
                },
            })

            await waitFor(async () => {
                const updatedTask = await MeterReadingExportTask.getOne(userClient, {
                    id: task.id,
                })
                expect(updatedTask.status).toEqual(COMPLETED)
            })

            await expectToThrowGQLError(async () => {
                await updateTestMeterReadingExportTask(userClient, task.id, { status: CANCELLED })
            }, ERRORS.STATUS_IS_ALREADY_COMPLETED)
        })
    })
})

describe('exportMeterReadings', () => {
    it('should create `MeterReadingExportTask` and create xlsx file', async () => {
        const { organization, userClient } = await makeAdminClientWithRegisteredOrganizationWithRoleWithEmployee({
            canManageProperties: true,
            canManageMeters: true,
            canManageMeterReadings: true,
            canReadMeters: true,
        })

        const [property] = await createTestProperty(userClient, organization)

        const [resource] = await MeterResource.getAll(userClient, { id: COLD_WATER_METER_RESOURCE_ID })
        const [source] = await MeterReadingSource.getAll(userClient, { id: CALL_METER_READING_SOURCE_ID })

        const metersCount = 5
        const meterReadingsOnEachMeter = 10

        for (let i = 0; i < metersCount; i++) {
            const [meter] = await createTestMeter(userClient, organization, property, resource, {
                nextVerificationDate: i % 2 ? faker.date.future() : null,
                archiveDate: i % 3 ? faker.date.recent() : null,
            })

            for (let j = 0; j < meterReadingsOnEachMeter; j++) {
                await createTestMeterReading(userClient, meter, source)
            }
        }

        const exportWhere = {
            organization: {
                id: organization.id,
            },
        }
        const exportSortBy = 'createdAt_ASC'

        const meterReadings = await MeterReading.getAll(userClient, exportWhere, {
            sortBy: exportSortBy,
        })
        const lastReadingsByMeter = uniqBy(meterReadings.sort((a, b) => (a.date < b.date ? 1 : -1)), (reading => get(reading, 'meter.id')))

        const [task] = await createTestMeterReadingExportTask(userClient, userClient.user, {
            where: exportWhere,
            sortBy: exportSortBy,
        })

        const { timeZone, locale } = task

        await waitFor(async () => {
            const updatedTask = await MeterReadingExportTask.getOne(userClient, { id: task.id })

            expect(updatedTask.file).toBeDefined()
            expect(updatedTask.file.publicUrl.length).toBeGreaterThan(1)
            expect(updatedTask).toHaveProperty('exportedRecordsCount', lastReadingsByMeter.length)
            expect(updatedTask).toHaveProperty('totalRecordsCount', lastReadingsByMeter.length)
            expect(updatedTask).toHaveProperty('v', 3)
            expect(updatedTask).toHaveProperty('status', COMPLETED)
        })

        const updatedTask = await MeterReadingExportTask.getOne(userClient, { id: task.id })
        const url = updatedTask.file.publicUrl.replace(conf.SERVER_URL, userClient.serverUrl)
        const filename = getTmpFile('xlsx')
        await downloadFile(url, filename)
        const data = await readXlsx(filename)

        const expectedData = [
            [
                i18n('excelExport.headers.meters.date', { locale }),
                i18n('excelExport.headers.meters.address', { locale }),
                i18n('excelExport.headers.meters.unitName', { locale }),
                i18n('excelExport.headers.meters.unitType', { locale }),
                i18n('excelExport.headers.meters.accountNumber', { locale }),
                i18n('excelExport.headers.meters.resource', { locale }),
                i18n('excelExport.headers.meters.number', { locale }),
                i18n('excelExport.headers.meters.place', { locale }),
                i18n('excelExport.headers.meters.value1', { locale }),
                i18n('excelExport.headers.meters.value2', { locale }),
                i18n('excelExport.headers.meters.value3', { locale }),
                i18n('excelExport.headers.meters.value4', { locale }),
                i18n('excelExport.headers.meters.clientName', { locale }),
                i18n('excelExport.headers.meters.source', { locale }),
                i18n('excelExport.headers.meters.nextVerificationDate', { locale }),
                i18n('excelExport.headers.meters.status', { locale }),
            ],
            ...(lastReadingsByMeter.map(meterReading => [
                formatDate(meterReading.date, timeZone),
                meterReading.meter.property.address,
                meterReading.meter.unitName,
                i18n(`field.UnitType.${meterReading.meter.unitType}`, { locale }),
                meterReading.meter.accountNumber,
                i18n('meterResource.ColdWater.name', { locale }),
                meterReading.meter.number,
                meterReading.meter.place || '',
                meterReading.value1 || '',
                meterReading.value2 || '',
                meterReading.value3 || '',
                meterReading.value4 || '',
                meterReading.clientName || '',
                i18n('meterReadingSource.Call.name', { locale }),
                meterReading.meter.nextVerificationDate ? formatDate(meterReading.meter.nextVerificationDate, timeZone) : '',
                i18n(`pages.condo.meter.Meter.${meterReading.meter.archiveDate ? 'outOfOrder' : 'isActive'}`, { locale }),
            ])),
        ]

        expectDataFormat(data, expectedData)
    })
})