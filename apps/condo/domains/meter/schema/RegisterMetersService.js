/**
 * Generated by `createservice meter.RegisterMetersService --type mutations`
 */

const dayjs = require('dayjs')
const { get, set } = require('lodash')

const { createInstance: createAddressServiceClient } = require('@open-condo/clients/address-service-client')
const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, getByCondition, getById } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')
const { i18n } = require('@open-condo/locales/loader')

const { PropertyResolver } = require('@condo/domains/billing/schema/resolvers')
const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/meter/access/RegisterMetersService')
const { IMPORT_CONDO_METER_READING_SOURCE_ID } = require('@condo/domains/meter/constants/constants')
const { Meter, MeterReading } = require('@condo/domains/meter/utils/serverSchema')

const ERRORS = {
    NAME_OF_ERROR_FOR_USAGE_INSIDE_THIS_MODULE_ONLY: {
        mutation: 'registerMeters',
        variable: ['data', 'someVar'], // TODO(codegen): Provide path to a query/mutation variable, whose value caused this error. Remove this property, if variables are not relevant to this error
        code: BAD_USER_INPUT, // TODO(codegen): use one of the basic codes, declared in '@open-condo/keystone/errors'
        type: NOT_FOUND, // TODO(codegen): use value from `constants/errors.js` either from 'common' or current domain
        message: 'Describe what happened for developer',
        messageForUser: 'api.user.registerMeters.NAME_OF_ERROR_FOR_USAGE_INSIDE_THIS_MODULE_ONLY', // TODO(codegen): localized message for user, use translation files
    },
}

function toISO (str) {
    return dayjs(str).toISOString()
}

const RegisterMetersService = new GQLCustomSchema('RegisterMetersService', {
    types: [
        // IN
        {
            access: true,
            type: 'input RegisterMetersMeterReading { date: String!, v1: String!, v2: String, v3: String, v4: String }',
        },
        {
            access: true,
            type: 'input RegisterMetersMeterDates { verificationDate: String, nextVerificationDate: String, installationDate: String, commissioningDate: String, sealingDate: String, controlReadingsDate: String }',
        },
        {
            access: true,
            type: 'input RegisterMetersMeterInput { number: String!, resourceTypeId: ID, numberOfTariffs: Int, place: String, readings: [RegisterMetersMeterReading!], dates: RegisterMetersMeterDates }',
        },
        {
            access: true,
            type: 'input RegisterMetersItemInput { address: String!, accountNumber: String!, addressMeta: RegisterBillingReceiptAddressMetaInput, unitType: String, unitName: String, meters: [RegisterMetersMeterInput!]! }',
        },
        {
            access: true,
            type: 'input RegisterMetersInput { dv: Int!, sender: JSON!, organization: OrganizationWhereUniqueInput!, items: [RegisterMetersItemInput!]! }',
        },

        // OUT
        {
            access: true,
            type: 'type RegisterMetersMeterReadingResultSuccessOutput { id: ID! }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterReadingResultErroneousOutput { error: String! }',
        },
        {
            access: true,
            type: 'union RegisterMetersMeterReadingResultDataUnion = RegisterMetersMeterReadingResultSuccessOutput | RegisterMetersMeterReadingResultErroneousOutput',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterReadingResultOutput { err: Boolean!, data: RegisterMetersMeterReadingResultDataUnion! }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterReadingOutput { v1: String!, v2: String, v3: String, v4: String, result: RegisterMetersMeterReadingResultOutput }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterResultSuccessOutput { id: ID!, readings: [RegisterMetersMeterReadingOutput!]! }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterResultErroneousOutput { error: String! }',
        },
        {
            access: true,
            type: 'union RegisterMetersMeterResultDataUnion = RegisterMetersMeterResultSuccessOutput | RegisterMetersMeterResultErroneousOutput',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterResultOutput { err: Boolean!, data: RegisterMetersMeterResultDataUnion! }',
        },
        {
            access: true,
            type: 'type RegisterMetersMeterOutput { number: String!, result: RegisterMetersMeterResultOutput! }',
        },
        {
            access: true,
            type: 'type RegisterMetersItemResultSuccessOutput { propertyId: ID!, meters: [RegisterMetersMeterOutput!]! }',
        },
        {
            access: true,
            type: 'type RegisterMetersItemResultErroneousOutput { error: String! }',
        },
        {
            access: true,
            type: 'union RegisterMetersItemResultDataUnion = RegisterMetersItemResultSuccessOutput | RegisterMetersItemResultErroneousOutput',
        },
        {
            access: true,
            type: 'type RegisterMetersItemResultOutput { err: Boolean!, data: RegisterMetersItemResultDataUnion! }',
        },
        {
            access: true,
            type: 'type RegisterMetersItemOutput { address: String!, accountNumber: String!, result: RegisterMetersItemResultOutput! }',
        },
        {
            access: true,
            type: 'type RegisterMetersOutput { items: [RegisterMetersItemOutput!]! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterMeters,
            schema: 'registerMeters(data: RegisterMetersInput!): RegisterMetersOutput',
            resolver: async (parent, /**{ data: RegisterMetersInput }*/args, context, info, extra = {}) => {
                const { data: { dv, sender, organization, items } } = args
                const locale = extractReqLocale(context.req) || conf.DEFAULT_LOCALE

                const organizationData = await getById('Organization', organization.id)

                const propertyResolver = new PropertyResolver({ context })
                propertyResolver.tin = organizationData.tin

                /** @type RegisterMetersItemOutput[] */
                const itemsResult = []

                for (const item of items) {
                    /** @type RegisterMetersItemOutput */
                    const itemResult = {
                        address: item.address,
                        accountNumber: item.accountNumber,
                        result: {
                            err: true,
                            data: {
                                __typename: 'RegisterMetersItemResultErroneousOutput',
                                error: i18n('common.errors.serverError', { locale }),
                            },
                        },
                    }

                    const resolvedAddress = await propertyResolver.normalizeAddresses({
                        [item.address]: {
                            address: item.address,
                            addressMeta: item.addressMeta,
                        },
                    })

                    const addressKey = get(resolvedAddress, [item.address, 'addressResolve', 'propertyAddress', 'addressKey'])
                    const property = await getByCondition('Property', {
                        organization,
                        ...addressKey ? { OR: [{ address_i: item.address }, { addressKey }] } : { address_i: item.address },
                    })

                    if (!property) {
                        set(itemResult, 'result', {
                            err: true,
                            data: {
                                __typename: 'RegisterMetersItemResultErroneousOutput',
                                error: i18n('field.Address.notFound', { locale }),
                            },
                        })
                    } else {
                        set(itemResult, ['result', 'err'], false)
                        set(itemResult, ['result', 'data'], {
                            __typename: 'RegisterMetersItemResultSuccessOutput',
                            propertyId: property.id,
                            meters: [],
                        })

                        const itemResultMeters = []
                        for (const meterData of item.meters) {
                            /** @type RegisterMetersMeterResultOutput */
                            const meterResult = {
                                err: true,
                                data: {
                                    __typename: 'RegisterMetersMeterResultErroneousOutput',
                                    error: i18n('common.errors.serverError', { locale }),
                                },
                            }
                            let meterId
                            const foundMeter = await getByCondition('Meter', {
                                organization,
                                property: { id: property.id },
                                unitType: item.unitType,
                                unitName: item.unitName,
                                accountNumber: item.accountNumber,
                                number: meterData.number,
                            })

                            try {
                                const meterDatesData = get(meterData, 'dates', {})
                                const meterDates = Object.keys(meterDatesData).reduce((result, field) => {
                                    return {
                                        ...result,
                                        [field]: toISO(get(meterDatesData, field)),
                                    }
                                }, {})

                                if (!meterDates.controlReadingsDate) {
                                    meterDates.controlReadingsDate = dayjs().toISOString()
                                }

                                if (foundMeter) {
                                    meterId = foundMeter.id
                                    await Meter.update(context, foundMeter.id, {
                                        dv,
                                        sender,
                                        resource: { connect: { id: meterData.resourceTypeId } },
                                        numberOfTariffs: meterData.numberOfTariffs,
                                        place: meterData.place,
                                        ...meterDates,
                                    })
                                } else {
                                    const createdMeter = await Meter.create(context, {
                                        dv,
                                        sender,
                                        organization: { connect: organization },
                                        property: { connect: { id: property.id } },
                                        unitType: String(item.unitType), // TODO
                                        unitName: String(item.unitName),
                                        accountNumber: item.accountNumber,
                                        number: meterData.number,
                                        resource: { connect: { id: meterData.resourceTypeId } },
                                        numberOfTariffs: meterData.numberOfTariffs,
                                        place: meterData.place,
                                        ...meterDates,
                                    })
                                    meterId = createdMeter.id
                                }

                                set(meterResult, 'err', false)
                                set(meterResult, 'data', {
                                    __typename: 'RegisterMetersMeterResultSuccessOutput',
                                    id: meterId,
                                })

                                const meterReadingsResults = []
                                for (const readingData of get(meterData, 'readings', [])) {
                                    const meterReadingResult = {
                                        err: true,
                                        data: {
                                            __typename: 'RegisterMetersMeterReadingResultErroneousOutput',
                                            error: i18n('common.errors.serverError', { locale }),
                                        },
                                    }
                                    try {
                                        const meterReadingModel = await MeterReading.create(context, {
                                            dv,
                                            sender,
                                            meter: { connect: { id: meterId } },
                                            source: { connect: { id: IMPORT_CONDO_METER_READING_SOURCE_ID } },
                                            value1: readingData.v1,
                                            value2: readingData.v2,
                                            value3: readingData.v3,
                                            value4: readingData.v4,
                                            date: toISO(readingData.date),
                                        })
                                        set(meterReadingResult, 'err', false)
                                        set(meterReadingResult, 'data', {
                                            __typename: 'RegisterMetersMeterReadingResultSuccessOutput',
                                            id: meterReadingModel.id,
                                        })
                                    } catch (err) {
                                        set(meterReadingResult, 'err', true)
                                        set(meterReadingResult, 'data', {
                                            __typename: 'RegisterMetersMeterReadingResultErroneousOutput',
                                            error: get(err, ['graphQLErrors', 0, 'extensions', 'messageForUser'], err.message),
                                        })
                                    }
                                    meterReadingsResults.push({
                                        v1: readingData.v1,
                                        v2: readingData.v2,
                                        v3: readingData.v3,
                                        v4: readingData.v4,
                                        result: meterReadingResult,
                                    })
                                }

                                set(meterResult, ['data', 'readings'], meterReadingsResults)
                            } catch (err) {
                                set(meterResult, 'err', true)
                                set(meterResult, 'data', {
                                    __typename: 'RegisterMetersMeterResultErroneousOutput',
                                    error: get(err, ['graphQLErrors', 0, 'extensions', 'messageForUser'], err.message),
                                })
                            }

                            itemResultMeters.push({ number: meterData.number, result: meterResult })
                        }
                        set(itemResult, ['result', 'data', 'meters'], itemResultMeters)
                    }

                    itemsResult.push(itemResult)
                }

                return { items: itemsResult }
            },
        },
    ],

})

module.exports = {
    RegisterMetersService,
}
