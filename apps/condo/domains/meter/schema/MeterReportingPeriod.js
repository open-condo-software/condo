/**
 * Generated by `createschema meter.MeterReportingPeriod 'organization:Relationship:Organization:CASCADE; property:Relationship:Property:CASCADE; meter:Relationship:Meter:CASCADE; startingDate:DateTimeUtc; deadline:DateTimeUtc;'`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getByCondition } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/meter/access/MeterReportingPeriod')
const { MeterReportingPeriod: MeterReportingPeriodAPI } = require('@condo/domains/meter/utils/serverSchema/index')
const { Property } = require('@condo/domains/property/utils/serverSchema')


const ERRORS = {
    INVALID_FINISH: {
        code: BAD_USER_INPUT,
        variable: ['data', 'notifyEndDay'],
        type: 'INVALID_FINISH',
        message: 'The "notifyEndDay" field can take values in the range from 1 to 31',
        messageForUser: 'api.meter.meterReportingPeriod.INVALID_FINISH',
    },
    INVALID_START: {
        code: BAD_USER_INPUT,
        variable: ['data', 'notifyStartDay'],
        type: 'INVALID_START',
        message: 'The "notifyStartDay" field can take values in the range from 1 to 31',
        messageForUser: 'api.meter.meterReportingPeriod.INVALID_START',
    },
    ORGANIZATION_IS_REQUIRED: {
        code: BAD_USER_INPUT,
        variable: ['data', 'organization'],
        type: 'ORGANIZATION_IS_REQUIRED',
        message: 'The organization is required to create',
        messageForUser: 'api.meter.meterReportingPeriod.ORGANIZATION_IS_REQUIRED',
    },
    PROPERTY_NOT_FOUND: {
        code: BAD_USER_INPUT,
        variable: ['data', 'property'],
        type: 'PROPERTY_NOT_FOUND',
        message: 'There is no such property in the specified organization',
        messageForUser: 'api.meter.meterReportingPeriod.PROPERTY_NOT_FOUND',
    },
    INVALID_RESTRICTION_END_DAY: {
        code: BAD_USER_INPUT,
        variable: ['data', 'restrictionEndDay'],
        type: 'INVALID_RESTRICTION_END_DAY',
        message: 'The "restrictionEndDay" field can take values in the range from 1 to 31',
        messageForUser: 'api.meter.meterReportingPeriod.INVALID_RESTRICTION_END_DAY',
    },
}


const MeterReportingPeriod = new GQLListSchema('MeterReportingPeriod', {
    schemaDoc: 'Settings for the meter reading report period. ' +
        'Readings can be transferred at any time. ' +
        'The scheme is needed for notifications on the client side',
    fields: {
        organization: {
            schemaDoc: 'Ref to the organization. Will be null if the instance is the default installation for all users',
            type: 'Relationship',
            ref: 'Organization',
            isRequired: false,
            knexOptions: { isNotNullable: false }, // Relationship only!
            kmigratorOptions: { null: true, on_delete: 'models.CASCADE' },
            access: {
                read: true,
                create: true,
                update: false,
            },
        },

        property: {
            schemaDoc: 'Ref to the property. Will be null if the instance is an installation for all users in the organization',
            type: 'Relationship',
            ref: 'Property',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.CASCADE' },
            hooks: {
                validateInput: async ({ resolvedData, fieldPath, existingItem, context }) => {
                    const newItem = { ...existingItem, ...resolvedData }
                    const propertyId = newItem[fieldPath]
                    const organizationId = newItem.organization

                    if (propertyId) {
                        const property = await getByCondition('Property', {
                            id: propertyId,
                            deletedAt: null,
                        })

                        if (organizationId !== property.organization) {
                            throw new GQLError(ERRORS.PROPERTY_NOT_FOUND, context)
                        }
                    }
                },
            },
        },

        notifyStartDay: {
            schemaDoc: 'Starting day of the month for sending a push about the need to submit meter readings',
            type: 'Integer',
            defaultValue: 20,
            isRequired: true,
            hooks: {
                validateInput: async ({ context, operation, resolvedData, fieldPath }) => {
                    if (operation === 'create' || operation === 'update') {
                        if (resolvedData[fieldPath] > 31 || resolvedData[fieldPath] < 1) {
                            throw new GQLError(ERRORS.INVALID_START, context)
                        }
                    }
                },
            },
        },

        notifyEndDay: {
            schemaDoc: 'Finish day of the month for sending a push about the need to submit meter readings',
            type: 'Integer',
            defaultValue: 25,
            isRequired: true,
            hooks: {
                validateInput: async ({ context, operation, resolvedData, fieldPath }) => {
                    if (operation === 'create' || operation === 'update') {
                        if (resolvedData[fieldPath] > 31 || resolvedData[fieldPath] < 1) {
                            throw new GQLError(ERRORS.INVALID_FINISH, context)
                        } 
                    }
                },
            },
        },

        restrictionEndDay: {
            schemaDoc: `Indicates the last day when mobile app users cannot pass readings. By default it is set to null, which means that the period is not strict and readings can be passed any day.
            If it is not null, then the allowed period starts the next day after restrictionEndDay and lasts until notifyEndDay. Can be from 1 to 31. `,
            type: 'Integer',
            hooks: {
                validateInput: async ({ context, operation, resolvedData, fieldPath }) => {
                    if (operation === 'create' || operation === 'update') {
                        if (resolvedData[fieldPath] !== null && (resolvedData[fieldPath] > 31 || resolvedData[fieldPath] < 1)) {
                            throw new GQLError(ERRORS.INVALID_RESTRICTION_END_DAY, context)
                        }
                    }
                },
            },
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['organization', 'property'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'meterreportingperiod_unique_organization_property',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['organization'],
                condition:
                    'Q(deletedAt__isnull=True) &' +
                    'Q(property__isnull=True)',
                name: 'meterreportingperiod_unique_organization',
            },
        ],
    },
    hooks: {
        resolveInput: async ({ context, operation, resolvedData }) => {
            if (operation === 'create') {
                if (!resolvedData.organization && resolvedData.property) {
                    const property = await Property.getOne(context, { id: resolvedData.property }, 'id organization { id }')

                    resolvedData.organization = property.organization
                }
            }

            return resolvedData
        },
        validateInput: async ({ operation, resolvedData, context }) => {
            if (operation === 'create') {
                const foundDefaultPeriod = await MeterReportingPeriodAPI.getAll(context, {
                    organization_is_null: true,
                    deletedAt: null,
                })

                if (!resolvedData.organization && foundDefaultPeriod.length > 0) {
                    throw new GQLError(ERRORS.ORGANIZATION_IS_REQUIRED, context)
                }
            }
        },
    },
    plugins: [
        uuided(),
        versioned(),
        tracked(),
        softDeleted(),
        dvAndSender(),
        historical(),
        analytical(),
    ],
    access: {
        read: access.canReadMeterReportingPeriods,
        create: access.canManageMeterReportingPeriods,
        update: access.canManageMeterReportingPeriods,
        delete: false,
        auth: true,
    },
})

module.exports = {
    MeterReportingPeriod,
    ERRORS,
}
