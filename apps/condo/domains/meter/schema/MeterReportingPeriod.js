/**
 * Generated by `createschema meter.MeterReportingPeriod 'organization:Relationship:Organization:CASCADE; property:Relationship:Property:CASCADE; meter:Relationship:Meter:CASCADE; startingDate:DateTimeUtc; deadline:DateTimeUtc;'`
 */

const { Text, Relationship, Integer, Select, Checkbox, DateTimeUtc, CalendarDay, Decimal, Password, File, Url } = require('@keystonejs/fields')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/meter/access/MeterReportingPeriod')
const { MeterReportingPeriod: MeterReportingPeriodAPI } = require('@condo/domains/meter/utils/serverSchema/index')
const { Property } = require('@condo/domains/property/utils/serverSchema')


const ERRORS = {
    INVALID_FINISH: {
        code: BAD_USER_INPUT,
        variable: ['data', 'notifyEndDay'],
        type: 'INVALID_FINISH',
        message: 'The "notifyEndDay" field can take values in the range from 1 to 31',
        messageForUser: 'api.meter.MeterReportingPeriod.INVALID_FINISH',
    },
    INVALID_START: {
        code: BAD_USER_INPUT,
        variable: ['data', 'notifyStartDay'],
        type: 'INVALID_START',
        message: 'The "notifyStartDay" field can take values in the range from 1 to 31',
        messageForUser: 'api.meter.MeterReportingPeriod.INVALID_START',
    },
    ORGANIZATION_IS_REQUIRED: {
        code: BAD_USER_INPUT,
        variable: ['data', 'organization'],
        type: 'ORGANIZATION_IS_REQUIRED',
        message: 'The organization is required to create',
        messageForUser: 'api.meter.MeterReportingPeriod.ORGANIZATION_IS_REQUIRED',
    },
}


const MeterReportingPeriod = new GQLListSchema('MeterReportingPeriod', {
    schemaDoc: 'Settings for the meter reading report period. ' +
        'Readings can be transferred at any time. ' +
        'The scheme is needed for notifications on the client side',
    fields: {
        organization: {
            schemaDoc: 'Ref to the organization. Will be null if the instance is the default installation for all users',
            type: Relationship,
            ref: 'Organization',
            isRequired: false,
            knexOptions: { isNotNullable: false }, // Relationship only!
            kmigratorOptions: { null: true, on_delete: 'models.CASCADE' },
            access: {
                read: true,
                create: true,
                update: false,
            },
        },

        property: {
            schemaDoc: 'Ref to the property. Will be null if the instance is an installation for all users in the organization',
            type: Relationship,
            ref: 'Property',
            isRequired: false,
            knexOptions: { isNotNullable: false },
            kmigratorOptions: { null: true, on_delete: 'models.CASCADE' },
        },

        notifyStartDay: {
            schemaDoc: 'Starting day of the month for sending a push about the need to submit meter readings',
            type: Integer,
            defaultValue: 20,
            isRequired: true,
            hooks: {
                validateInput: async ({ context, operation, resolvedData }) => {
                    if (operation === 'create' || operation === 'update') {
                        if (resolvedData.notifyStartDay > 31 || resolvedData.notifyStartDay < 1) {
                            throw new GQLError(ERRORS.INVALID_START, context)
                        }
                    }
                },
            },
        },

        notifyEndDay: {
            schemaDoc: 'Finish day of the month for sending a push about the need to submit meter readings',
            type: Integer,
            defaultValue: 25,
            isRequired: true,
            hooks: {
                validateInput: async ({ context, operation, resolvedData }) => {
                    if (operation === 'create' || operation === 'update') {
                        if (resolvedData.notifyEndDay > 31 || resolvedData.notifyEndDay < 1) {
                            throw new GQLError(ERRORS.INVALID_FINISH, context)
                        } 
                    }
                },
            },
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['organization', 'property'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'meterreportingperiod_unique_organization_property',
            },
            {
                type: 'models.UniqueConstraint',
                fields: ['organization'],
                condition:
                    'Q(deletedAt__isnull=True) &' +
                    'Q(property__isnull=True)',
                name: 'meterreportingperiod_unique_organization',
            },
        ],
    },
    hooks: {
        resolveInput: async ({ context, operation, existingItem, resolvedData }) => {
            if (operation === 'create') {
                if (!resolvedData.organization && resolvedData.property) {
                    const property = await Property.getOne(context, { id: resolvedData.property })

                    resolvedData.organization = property.organization
                }
            }

            return resolvedData
        },
        validateInput: async ({ operation, resolvedData, context }) => {
            if (operation === 'create') {
                const foundDefaultPeriod = await MeterReportingPeriodAPI.getAll(context, {
                    organization_is_null: true,
                    deletedAt: null,
                })

                if (!resolvedData.organization && foundDefaultPeriod.length > 0) {
                    throw new GQLError(ERRORS.ORGANIZATION_IS_REQUIRED, context)
                }
            }
        },
    },
    plugins: [
        uuided(),
        versioned(),
        tracked(),
        softDeleted(),
        dvAndSender(),
        historical(),
    ],
    access: {
        read: access.canReadMeterReportingPeriods,
        create: access.canManageMeterReportingPeriods,
        update: access.canManageMeterReportingPeriods,
        delete: false,
        auth: true,
    },
})

module.exports = {
    MeterReportingPeriod,
}
