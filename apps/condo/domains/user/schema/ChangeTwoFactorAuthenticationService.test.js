/**
 * Generated by `createservice user.ChangeTwoFactorAuthenticationService --type mutations`
 */

const { faker } = require('@faker-js/faker')

const { generateGqlQueries } = require('@open-condo/codegen/generate.gql')
const { generateGQLTestUtils } = require('@open-condo/codegen/generate.test.utils')
const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowGQLErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { STAFF } = require('@condo/domains/user/constants/common')
const {
    changeTwoFactorAuthenticationByTestClient,
    makeClientWithStaffUser,
    generateSudoTokenByTestClient,
    updateTestUser,
    UserSudoToken,
    createTestConfirmPhoneAction,
} = require('@condo/domains/user/utils/testSchema')
const { generateToken, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


const UserWith2FA = generateGQLTestUtils(generateGqlQueries('User', '{ id isTwoFactorAuthenticationEnabled }'))

function getCaptcha () {
    return faker.random.alphaNumeric(32)
}

describe('ChangeTwoFactorAuthenticationService', () => {
    let adminClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
    })

    describe('Accesses', () => {
        describe('User', () => {
            test('Can execute', async () => {
                const staffClient = await makeClientWithStaffUser()
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })
                const [result] = await changeTwoFactorAuthenticationByTestClient(staffClient, {
                    token: sudoToken.token,
                    isEnabled: false,
                })
                expect(result).toHaveProperty('status', 'ok')
            })

            test('Soft-deleted user cannot execute', async () => {
                const staffClient = await makeClientWithStaffUser()
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })
                const [deletedUser] = await updateTestUser(adminClient, staffClient.user.id, {
                    deletedAt: new Date().toISOString(),
                })
                expect(deletedUser.deletedAt).not.toBeNull()
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await changeTwoFactorAuthenticationByTestClient(staffClient, {
                        token: sudoToken.token,
                        isEnabled: false,
                    })
                })
            })
        })

        describe('Anonymous', () => {
            test('Cannot execute', async () => {
                const staffClient = await makeClientWithStaffUser()
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })
                const anonymousClient = await makeClient()
                await expectToThrowAuthenticationErrorToResult(async () => {
                    await changeTwoFactorAuthenticationByTestClient(anonymousClient, {
                        token: sudoToken.token,
                        isEnabled: false,
                    })
                })
            })
        })
    })

    describe('Basic logic', () => {
        const cases = [
            { from: false, to: false },
            { from: false, to: true },
            { from: true, to: false },
            { from: true, to: true },
        ]
        describe('Should change "isTwoFactorAuthenticationEnabled" for current user if sufficient authentication factors (min 3)', () => {
            test.each(cases)('$from -> $to', async ({ from, to }) => {
                const staffClient = await makeClientWithStaffUser({
                    isEmailVerified: true,
                    isTwoFactorAuthenticationEnabled: from,
                })
                const [{ token: confirmPhoneToken }] = await createTestConfirmPhoneAction(adminClient, {
                    phone: staffClient.userAttrs.phone, isPhoneVerified: true,
                })
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password, confirmPhoneToken },
                })
                const [result] = await changeTwoFactorAuthenticationByTestClient(staffClient, {
                    token: sudoToken.token,
                    isEnabled: to,
                })
                expect(result).toHaveProperty('status', 'ok')

                const updatedUser = await UserWith2FA.getOne(adminClient, { id: staffClient.user.id })
                expect(updatedUser).toHaveProperty('isTwoFactorAuthenticationEnabled', to)
            })
        })

        test('Should be marked sudo token as used after operation', async () => {
            const staffClient = await makeClientWithStaffUser()
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })
            const [result] = await changeTwoFactorAuthenticationByTestClient(staffClient, {
                token: sudoToken.token,
                isEnabled: false,
            })
            expect(result).toHaveProperty('status', 'ok')

            const updatedSudoToken = await UserSudoToken.getOne(adminClient, {
                token: sudoToken.token,
            })
            expect(updatedSudoToken).toHaveProperty('remainingUses', 0)
        })

        test('Throw error if try enable 2FA when insufficient authentication factors (less then 3)', async () => {
            // Staff has only password and verified phone
            const staffClient = await makeClientWithStaffUser({
                isEmailVerified: false,
                email: null,
            })
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })
            await expectToThrowGQLErrorToResult(async () => {
                await changeTwoFactorAuthenticationByTestClient(staffClient, {
                    token: sudoToken.token,
                    isEnabled: true,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INSUFFICIENT_AUTHENTICATION_FACTORS',
                message: 'Insufficient authentication factors. At least three must be specified. For example, password, verified phone and verified email.',
            })

            // Staff without password
            const staffClient2 = await makeClientWithStaffUser({
                isEmailVerified: true,
                password: null,
            })
            const [{ token: confirmPhoneToken }] = await createTestConfirmPhoneAction(adminClient, {
                phone: staffClient2.userAttrs.phone, isPhoneVerified: true,
            })
            const [sudoToken2] = await generateSudoTokenByTestClient(staffClient2, {
                captcha: getCaptcha(),
                user: { phone: staffClient2.userAttrs.phone, userType: STAFF },
                authFactors: { confirmPhoneToken },
            })
            await expectToThrowGQLErrorToResult(async () => {
                await changeTwoFactorAuthenticationByTestClient(staffClient2, {
                    token: sudoToken2.token,
                    isEnabled: true,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INSUFFICIENT_AUTHENTICATION_FACTORS',
                message: 'Insufficient authentication factors. At least three must be specified. For example, password, verified phone and verified email.',
            })
        })

        test('Throw error if unsupported token', async () => {
            const staffClient = await makeClientWithStaffUser()
            await expectToThrowGQLErrorToResult(async () => {
                await changeTwoFactorAuthenticationByTestClient(staffClient, {
                    token: generateToken(TOKEN_TYPES.CONFIRM_EMAIL),
                    isEnabled: false,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'UNSUPPORTED_TOKEN',
                message: 'Unsupported token',
            })
        })

        test('Throw error if invalid token', async () => {
            const staffClient = await makeClientWithStaffUser()
            await expectToThrowGQLErrorToResult(async () => {
                await changeTwoFactorAuthenticationByTestClient(staffClient, {
                    token: faker.random.alphaNumeric(8),
                    isEnabled: false,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INVALID_TOKEN',
                message: 'Invalid token',
            })
        })

        test('Throw error if token is not exists', async () => {
            const staffClient = await makeClientWithStaffUser()
            await expectToThrowGQLErrorToResult(async () => {
                await changeTwoFactorAuthenticationByTestClient(staffClient, {
                    token: generateToken(TOKEN_TYPES.SUDO),
                    isEnabled: false,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOKEN_NOT_FOUND',
                message: 'Unable to find non-expired UserSudoToken by specified token',
            })
        })

        test('Throw error if sudo token from other user', async () => {
            const staffClient = await makeClientWithStaffUser()
            const staffClient2 = await makeClientWithStaffUser()
            const [sudoToken2] = await generateSudoTokenByTestClient(staffClient2, {
                captcha: getCaptcha(),
                user: { phone: staffClient2.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient2.userAttrs.password },
            })
            await expectToThrowGQLErrorToResult(async () => {
                await changeTwoFactorAuthenticationByTestClient(staffClient, {
                    token: sudoToken2.token,
                    isEnabled: false,
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'OPERATION_FAILED',
                message: 'The operation failed',
            })
        })
    })
})
