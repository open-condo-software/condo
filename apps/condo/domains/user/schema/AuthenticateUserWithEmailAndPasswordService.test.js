/**
 * Generated by `createservice user.AuthenticateUserWithEmailAndPasswordService --type mutations`
 */

const { faker } = require('@faker-js/faker')

const {
    expectToThrowGQLErrorToResult,
    expectToThrowGraphQLRequestError,
    makeLoggedInAdminClient,
    makeClient,
} = require('@open-condo/keystone/test.utils')

const {
    STAFF,
    SERVICE,
    RESIDENT,
    USER_TYPES,
} = require('@condo/domains/user/constants/common')
const { AUTH_COUNTER_LIMIT_TYPE } = require('@condo/domains/user/constants/limits')
const { AUTHENTICATE_USER_WITH_EMAIL_AND_PASSWORD_MUTATION } = require('@condo/domains/user/gql')
const {
    createTestUser,
    User,
    createTestEmail,
    createTestResetUserLimitAction,
    resetUserByTestClient,
    authenticateUserWithEmailAndPasswordByTestClient,
} = require('@condo/domains/user/utils/testSchema')


describe('Auth by email and password', () => {
    let admin

    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
    })

    describe('Accesses', () => {
        test('Anonymous (anyone)', async () => {
            const [user, userAttrs] = await createTestUser(admin, {
                isEmailVerified: true,
            })

            const [res] = await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                email: userAttrs.email,
                password: userAttrs.password,
                userType: STAFF,
            })
            expect(res.item.id).toBe(user.id)
            expect(res.token).not.toBeNull()
        })
    })

    describe('Basic logic', () => {

        describe.each(USER_TYPES)('For user type %p', (userType) => {
            test('should throw error if user email is not verified', async () => {
                const [, userAttrs] = await createTestUser(admin, {
                    type: userType,
                    isEmailVerified: false,
                })

                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                        email: userAttrs.email,
                        password: userAttrs.password,
                        userType: userAttrs.type,
                    })
                }, {
                    mutation: 'authenticateUserWithEmailAndPassword',
                    code: 'BAD_USER_INPUT',
                    type: 'WRONG_CREDENTIALS',
                })
            })

            test('should throw error if user was soft deleted', async () => {
                const [user, userAttrs] = await createTestUser(admin, {
                    type: userType,
                    isEmailVerified: true,
                })
                const [deletedUser] = await User.softDelete(admin, user.id)
                expect(deletedUser.deletedAt).not.toBeNull()
                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                        email: userAttrs.email,
                        password: userAttrs.password,
                        userType: userAttrs.type,
                    })
                }, {
                    mutation: 'authenticateUserWithEmailAndPassword',
                    code: 'BAD_USER_INPUT',
                    type: 'WRONG_CREDENTIALS',
                })
            })

            test('should throw error if user was reset (or user not registered with same email)', async () => {
                const [user, userAttrs] = await createTestUser(admin, {
                    type: userType,
                    isEmailVerified: true,
                })
                await resetUserByTestClient(admin, { user: { id: user.id } })
                const users = await User.getAll(admin, { email: userAttrs.email })
                expect(users).toHaveLength(0)

                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                        email: userAttrs.email,
                        password: userAttrs.password,
                        userType: userAttrs.type,
                    })
                }, {
                    mutation: 'authenticateUserWithEmailAndPassword',
                    code: 'BAD_USER_INPUT',
                    type: 'WRONG_CREDENTIALS',
                })
            })

            test('should throw error if user has not password', async () => {
                const [, userAttrs] = await createTestUser(admin, {
                    password: undefined,
                    type: userType,
                    isEmailVerified: true,
                })

                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                        email: userAttrs.email,
                        password: '',
                        userType: userAttrs.type,
                    })
                }, {
                    mutation: 'authenticateUserWithEmailAndPassword',
                    code: 'BAD_USER_INPUT',
                    type: 'WRONG_CREDENTIALS',
                })
            })

            test('should throw error if password is incorrect', async () => {
                const [, userAttrs] = await createTestUser(admin, {
                    type: userType,
                    isEmailVerified: true,
                })

                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                        email: userAttrs.email,
                        password: userAttrs.password + faker.random.alphaNumeric(8),
                        userType: userAttrs.type,
                    })
                }, {
                    mutation: 'authenticateUserWithEmailAndPassword',
                    code: 'BAD_USER_INPUT',
                    type: 'WRONG_CREDENTIALS',
                })
            })

            test('should throw error if email is not valid', async () => {
                const [, userAttrs] = await createTestUser(admin, {
                    type: userType,
                    isEmailVerified: true,
                })

                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                        email: 'not-email' + faker.random.alphaNumeric(8),
                        password: userAttrs.password,
                        userType: userAttrs.type,
                    })
                }, {
                    mutation: 'authenticateUserWithEmailAndPassword',
                    code: 'BAD_USER_INPUT',
                    type: 'WRONG_EMAIL_VALUE',
                })
            })

            test('should authorize user and return token if password and email number are correct', async () => {
                const [user, userAttrs] = await createTestUser(admin, {
                    type: userType,
                    isEmailVerified: true,
                })
                const anonymousClient = await makeClient()

                const [result] = await authenticateUserWithEmailAndPasswordByTestClient(anonymousClient, {
                    email: userAttrs.email,
                    password: userAttrs.password,
                    userType: userAttrs.type,
                })

                expect(result.item.id).toBe(user.id)
                expect(result.token).not.toBeNull()
            })
        })

        test('should throw error if dv or sender not valid', async () => {
            const [, userAttrs] = await createTestUser(admin, {
                type: STAFF,
                isEmailVerified: true,
            })

            await expectToThrowGQLErrorToResult(async () => {
                await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                    email: userAttrs.email + 'not-email' + faker.random.alphaNumeric(8),
                    password: userAttrs.password,
                    userType: userAttrs.type,
                    dv: 123,
                })
            }, {
                mutation: 'authenticateUserWithEmailAndPassword',
                variable: ['data', 'dv'],
                code: 'BAD_USER_INPUT',
                type: 'DV_VERSION_MISMATCH',
            })

            await expectToThrowGQLErrorToResult(async () => {
                await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                    email: userAttrs.email + 'not-email' + faker.random.alphaNumeric(8),
                    password: userAttrs.password,
                    userType: userAttrs.type,
                    sender: { dv: 1, fingerprint: '-' },
                })
            }, {
                mutation: 'authenticateUserWithEmailAndPassword',
                variable: ['data', 'sender'],
                code: 'BAD_USER_INPUT',
                type: 'WRONG_FORMAT',
            })
        })

        test('should throw error if userType is not valid', async () => {
            const [, userAttrs] = await createTestUser(admin, {
                type: STAFF,
                isEmailVerified: true,
            })

            await expectToThrowGraphQLRequestError(async () => {
                await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                    email: userAttrs.email + 'not-email' + faker.random.alphaNumeric(8),
                    password: userAttrs.password,
                    userType: 'not-valid-user-type',
                })
            }, 'Value "not-valid-user-type" does not exist in "UserTypeType" enum')
        })

        test('should authorize user with with the specified type', async () => {
            const [staff, userAttrs] = await createTestUser(admin, { type: STAFF, isEmailVerified: true })
            const [resident] = await createTestUser(admin, { type: RESIDENT, email: userAttrs.email, password: userAttrs.password, isEmailVerified: true })
            const [service] = await createTestUser(admin, { type: SERVICE, email: userAttrs.email, password: userAttrs.password, isEmailVerified: true })

            const [authedStaff] = await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                email: userAttrs.email,
                password: userAttrs.password,
                userType: STAFF,
            })
            expect(authedStaff.item.id).toBe(staff.id)

            const [authedResident] = await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                email: userAttrs.email,
                password: userAttrs.password,
                userType: RESIDENT,
            })
            expect(authedResident.item.id).toBe(resident.id)

            const [authedService] = await authenticateUserWithEmailAndPasswordByTestClient(await makeClient(), {
                email: userAttrs.email,
                password: userAttrs.password,
                userType: SERVICE,
            })
            expect(authedService.item.id).toBe(service.id)
        })
    })

    describe('Guards', () => {
        const GUARD_WINDOW_LIMIT = 10

        describe('by ip', () => {
            test('works fine', async () => {
                const client = await makeClient()

                for await (const i of Array.from(Array(GUARD_WINDOW_LIMIT).keys())) {
                    const email = createTestEmail()
                    const password = faker.datatype.string(42)
                    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

                    const { errors } = await client.mutate(AUTHENTICATE_USER_WITH_EMAIL_AND_PASSWORD_MUTATION, {
                        data: {
                            email,
                            password,
                            dv: 1,
                            sender,
                            userType: STAFF,
                        },
                    })

                    if (i === GUARD_WINDOW_LIMIT) {
                        expect(errors).toHaveLength(1)
                        expect(errors[0]).toMatchObject(expect.objectContaining({
                            message: expect.stringMatching(/You have to wait \d{1,4} min. to be able to send request again/),
                            extensions: expect.objectContaining({
                                type: 'TOO_MANY_REQUESTS',
                                messageForUserTemplateKey: 'api.user.TOO_MANY_REQUESTS',
                            }),
                        }))
                    } else {
                        expect(errors).toHaveLength(1)
                        expect(errors[0]).toMatchObject(expect.objectContaining({
                            message: 'Wrong email or password',
                            extensions: expect.objectContaining({
                                type: 'WRONG_CREDENTIALS',
                                messageForUserTemplateKey: 'api.user.authenticateUserWithEmailAndPassword.WRONG_CREDENTIALS',
                            }),
                        }))
                    }
                }
            })

            test('should be resettable', async () => {
                const client = await makeClient()
                const fakeIp = faker.internet.ip()
                client.setHeaders({ 'x-forwarded-for': fakeIp })
                const admin = await makeLoggedInAdminClient()

                // Reach the lock
                let lockErrors
                for (let i = 0; i <= GUARD_WINDOW_LIMIT; i++) {
                    const email = createTestEmail()
                    const password = faker.datatype.string(42)
                    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

                    const { errors } = await client.mutate(AUTHENTICATE_USER_WITH_EMAIL_AND_PASSWORD_MUTATION, {
                        data: {
                            email,
                            password,
                            dv: 1,
                            sender,
                            userType: STAFF,
                        },
                    })
                    lockErrors = errors
                }

                // Ensure that lock works fine
                expect(lockErrors).toHaveLength(1)
                expect(lockErrors[0]).toMatchObject(expect.objectContaining({
                    message: expect.stringMatching(/You have to wait \d{1,4} min. to be able to send request again/),
                    extensions: expect.objectContaining({
                        type: 'TOO_MANY_REQUESTS',
                        messageForUserTemplateKey: 'api.user.TOO_MANY_REQUESTS',
                    }),
                }))

                // Reset lock
                await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, fakeIp)

                // Ensure that no more lock
                const email = createTestEmail()
                const password = faker.datatype.string(42)
                const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
                const { errors } = await client.mutate(AUTHENTICATE_USER_WITH_EMAIL_AND_PASSWORD_MUTATION, {
                    data: {
                        email,
                        password,
                        dv: 1,
                        sender,
                        userType: STAFF,
                    },
                })
                expect(errors).toHaveLength(1)
                expect(errors[0]).toMatchObject(expect.objectContaining({
                    message: 'Wrong email or password',
                    extensions: expect.objectContaining({
                        type: 'WRONG_CREDENTIALS',
                        messageForUserTemplateKey: 'api.user.authenticateUserWithEmailAndPassword.WRONG_CREDENTIALS',
                    }),
                }))
            })
        })

        describe('by email', () => {
            test('works fine', async () => {
                const email = createTestEmail()

                for await (const i of Array.from(Array(GUARD_WINDOW_LIMIT).keys())) {
                    const client = await makeClient()
                    const password = faker.datatype.string(42)
                    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

                    const { errors } = await client.mutate(AUTHENTICATE_USER_WITH_EMAIL_AND_PASSWORD_MUTATION, {
                        data: {
                            email,
                            password,
                            dv: 1,
                            sender,
                            userType: STAFF,
                        },
                    })

                    if (i === GUARD_WINDOW_LIMIT) {
                        expect(errors).toHaveLength(1)
                        expect(errors[0]).toMatchObject(expect.objectContaining({
                            message: expect.stringMatching(/You have to wait \d{1,4} min. to be able to send request again/),
                            extensions: expect.objectContaining({
                                type: 'TOO_MANY_REQUESTS',
                                messageForUserTemplateKey: 'api.user.TOO_MANY_REQUESTS',
                            }),
                        }))
                    } else {
                        expect(errors).toHaveLength(1)
                        expect(errors[0]).toMatchObject(expect.objectContaining({
                            message: 'Wrong email or password',
                            extensions: expect.objectContaining({
                                type: 'WRONG_CREDENTIALS',
                                messageForUserTemplateKey: 'api.user.authenticateUserWithEmailAndPassword.WRONG_CREDENTIALS',
                            }),
                        }))
                    }
                }
            })

            test('should be resettable', async () => {
                const email = createTestEmail()
                const admin = await makeLoggedInAdminClient()

                // Reach the lock
                let lockErrors
                for (let i = 0; i <= GUARD_WINDOW_LIMIT; i++) {
                    const client = await makeClient()
                    const password = faker.datatype.string(42)
                    const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }

                    const { errors } = await client.mutate(AUTHENTICATE_USER_WITH_EMAIL_AND_PASSWORD_MUTATION, {
                        data: {
                            email,
                            password,
                            dv: 1,
                            sender,
                            userType: STAFF,
                        },
                    })
                    lockErrors = errors
                }

                // Ensure that lock works fine
                expect(lockErrors).toHaveLength(1)
                expect(lockErrors[0]).toMatchObject(expect.objectContaining({
                    message: expect.stringMatching(/You have to wait \d{1,4} min. to be able to send request again/),
                    extensions: expect.objectContaining({
                        type: 'TOO_MANY_REQUESTS',
                        messageForUserTemplateKey: 'api.user.TOO_MANY_REQUESTS',
                    }),
                }))

                // Reset lock
                await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, email)

                // Ensure that no more lock
                const client = await makeClient()
                const password = faker.datatype.string(42)
                const sender = { dv: 1, fingerprint: faker.random.alphaNumeric(8) }
                const { errors } = await client.mutate(AUTHENTICATE_USER_WITH_EMAIL_AND_PASSWORD_MUTATION, {
                    data: {
                        email,
                        password,
                        dv: 1,
                        sender,
                        userType: STAFF,
                    },
                })
                expect(errors).toHaveLength(1)
                expect(errors[0]).toMatchObject(expect.objectContaining({
                    message: 'Wrong email or password',
                    extensions: expect.objectContaining({
                        type: 'WRONG_CREDENTIALS',
                        messageForUserTemplateKey: 'api.user.authenticateUserWithEmailAndPassword.WRONG_CREDENTIALS',
                    }),
                }))
            })
        })
    })
})
