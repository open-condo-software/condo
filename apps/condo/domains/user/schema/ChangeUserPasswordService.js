/**
 * Generated by `createservice user.ChangeUserPasswordService --type mutations`
 */

const { pick, mapValues } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, getByCondition } = require('@open-condo/keystone/schema')

const { COMMON_ERRORS } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/user/access/ChangeUserPasswordService')
const {
    GQL_ERRORS: USER_ERRORS,
    TOKEN_NOT_FOUND,
    USER_NOT_FOUND,
} = require('@condo/domains/user/constants/errors')
const { UserSudoToken, User } = require('@condo/domains/user/utils/serverSchema')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')
const { detectTokenTypeSafely, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')

const { INVALID_TOKEN, UNSUPPORTED_TOKEN } = require('../constants/errors')


/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    ...mapValues(pick(USER_ERRORS, [
        'WRONG_PASSWORD_FORMAT',
        'INVALID_PASSWORD_LENGTH',
        'PASSWORD_CONTAINS_EMAIL',
        'PASSWORD_CONTAINS_PHONE',
        'PASSWORD_IS_FREQUENTLY_USED',
        'PASSWORD_CONSISTS_OF_SMALL_SET_OF_CHARACTERS',
    ]), (errorDescription) => ({ ...errorDescription, mutation: 'changeUserPassword' })),
    DV_VERSION_MISMATCH: {
        ...COMMON_ERRORS.DV_VERSION_MISMATCH,
        mutation: 'changeUserPassword',
    },
    WRONG_SENDER_FORMAT: {
        ...COMMON_ERRORS.WRONG_SENDER_FORMAT,
        mutation: 'changeUserPassword',
    },
    INVALID_TOKEN: {
        mutation: 'changeUserPassword',
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: INVALID_TOKEN,
        message: 'Invalid token',
        messageForUser: 'api.user.changeUserPassword.INVALID_TOKEN',
    },
    UNSUPPORTED_TOKEN: {
        mutation: 'changeUserPassword',
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: UNSUPPORTED_TOKEN,
        message: 'Unsupported token',
        messageForUser: 'api.user.changeUserPassword.UNSUPPORTED_TOKEN',
    },
    TOKEN_NOT_FOUND: {
        mutation: 'changeUserPassword',
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: TOKEN_NOT_FOUND,
        message: 'Unable to find non-expired SudoUserToken by specified token',
        messageForUser: 'api.user.changeUserPassword.TOKEN_NOT_FOUND',
    },
    USER_NOT_FOUND: {
        mutation: 'changeUserPassword',
        code: BAD_USER_INPUT,
        type: USER_NOT_FOUND,
        message: 'User not found',
        messageForUser: 'api.user.changeUserPassword.USER_NOT_FOUND',
    },
    OPERATION_FAILED: {
        mutation: 'changeUserPassword',
        code: BAD_USER_INPUT,
        type: 'OPERATION_FAILED',
        message: 'Failed to complete the operation',
        messageForUser: 'api.user.changeUserPassword.OPERATION_FAILED',
    },
}

const USER_ERROR_MAPPING = {
    '[password:minLength:User:password]': ERRORS.INVALID_PASSWORD_LENGTH,
    '[password:rejectCommon:User:password]': ERRORS.PASSWORD_IS_FREQUENTLY_USED,
    [ERRORS.INVALID_PASSWORD_LENGTH.message]: ERRORS.INVALID_PASSWORD_LENGTH,
    [ERRORS.PASSWORD_CONSISTS_OF_SMALL_SET_OF_CHARACTERS.message]: ERRORS.PASSWORD_CONSISTS_OF_SMALL_SET_OF_CHARACTERS,
    [ERRORS.PASSWORD_CONTAINS_EMAIL.message]: ERRORS.PASSWORD_CONTAINS_EMAIL,
    [ERRORS.PASSWORD_CONTAINS_PHONE.message]: ERRORS.PASSWORD_CONTAINS_PHONE,
}

const DAY_IN_SEC = 60 * 60 * 24
const HOUR_IN_SEC = 60 * 60

const redisGuard = new RedisGuard()

async function changeUserPasswordGuard (context) {
    const ip = context.req.ip

    const guards = [{
        key: ['changeUserPassword', 'daily', 'ip', ip].join(':'),
        windowLimit: 30,
        windowSizeInSec: DAY_IN_SEC,
    }, {
        key: ['changeUserPassword', 'hourly', 'ip', ip].join(':'),
        windowLimit: 10,
        windowSizeInSec: HOUR_IN_SEC,
    }]

    await redisGuard.checkMultipleCustomLimitCounters(guards, context)
}

const ChangeUserPasswordService = new GQLCustomSchema('ChangeUserPasswordService', {
    types: [
        {
            access: true,
            type: 'input ChangeUserPasswordInput { dv: Int!, sender: SenderFieldInput!, token: String!, newPassword: String! }',
        },
        {
            access: true,
            type: 'type ChangeUserPasswordOutput { status: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canChangeUserPassword,
            schema: 'changeUserPassword(data: ChangeUserPasswordInput!): ChangeUserPasswordOutput',
            doc: {
                summary: 'Changes password this action via correct token, that should correspond to UserSudoToken',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { token, newPassword, sender } = data

                await changeUserPasswordGuard(context)

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                if (!newPassword) {
                    throw new GQLError({ ...ERRORS.INVALID_PASSWORD_LENGTH, mutation: 'changeUserPassword' }, context)
                }

                const { error: tokenError, tokenType } = detectTokenTypeSafely(token)
                if (tokenError) {
                    throw new GQLError({ ...ERRORS.INVALID_TOKEN, data: { error: tokenError } }, context)
                }

                if (tokenType !== TOKEN_TYPES.SUDO) {
                    throw new GQLError(ERRORS.UNSUPPORTED_TOKEN, context)
                }

                const sudoToken = await getByCondition('UserSudoToken', {
                    token,
                    expiresAt_gte: new Date().toISOString(),
                    remainingUses_gt: 0,
                    deletedAt: null,
                })

                if (!sudoToken) throw new GQLError(ERRORS.TOKEN_NOT_FOUND, context)

                const authedItemId = context?.authedItem?.id || null
                if (authedItemId && authedItemId !== sudoToken.user) {
                    throw new GQLError(ERRORS.OPERATION_FAILED, context)
                }

                const user = await getByCondition('User', {
                    id: sudoToken.user,
                    deletedAt: null,
                })

                if (!user) throw new GQLError(ERRORS.USER_NOT_FOUND, context)

                await User.update(
                    context,
                    user.id,
                    { dv: 1, sender, password: newPassword },
                    'id',
                    { errorMapping: USER_ERROR_MAPPING }
                )

                await UserSudoToken.update(context, sudoToken.id, {
                    dv: 1, sender,
                    remainingUses: sudoToken.remainingUses - 1,
                })

                return {
                    status: 'ok',
                }
            },
        },
    ],

})

module.exports = {
    ChangeUserPasswordService,
}
