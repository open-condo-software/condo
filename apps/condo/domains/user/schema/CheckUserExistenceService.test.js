/**
 * Generated by `createservice user.CheckUserExistenceService --type queries`
 */

const { faker } = require('@faker-js/faker')

const {
    makeLoggedInAdminClient,
    makeClient,
    makeLoggedInClient,
    expectToThrowGQLErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { RESIDENT, USER_TYPES } = require('@condo/domains/user/constants/common')
const {
    createTestConfirmPhoneAction,
    createTestConfirmEmailAction,
    createTestUser,
    createTestPhone,
    resetUserByTestClient,
    updateTestUser,
    ConfirmPhoneAction,
    ConfirmEmailAction,
    checkUserExistenceByTestClient,
} = require('@condo/domains/user/utils/testSchema')
const { TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


describe('CheckUserExistenceService', () => {
    let adminClient, anonymousClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
    })

    beforeEach(async () => {
        anonymousClient = await makeClient()
    })

    describe('Accesses', () => {
        describe('User', () => {
            test('can execute', async () => {
                const userClient = await makeLoggedInClient()
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await checkUserExistenceByTestClient(userClient, {
                    token: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
                expect(result).toEqual({
                    isUserExists: false,
                    isNameSet: false,
                    isEmailSet: false,
                    isPhoneSet: false,
                    isPasswordSet: false,
                })
            })
        })

        describe('Anonymous (anyone)', () => {
            test('can execute', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                    token: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
                expect(result).toEqual({
                    isUserExists: false,
                    isNameSet: false,
                    isEmailSet: false,
                    isPhoneSet: false,
                    isPasswordSet: false,
                })
            })
        })
    })

    describe('Base logic', () => {
        describe('should correct work different token types', () => {
            describe('confirmPhoneAction', () => {
                describe.each(USER_TYPES)('should return valid value for userType: %p', (userType) => {
                    const cases = [
                        {
                            userData: {
                                name: faker.name.fullName(),
                                email: faker.internet.email(),
                                phone: createTestPhone(),
                                password: faker.internet.password(),
                            },
                            expectedResult: {
                                isUserExists: true,
                                isNameSet: true,
                                isEmailSet: true,
                                isPhoneSet: true,
                                isPasswordSet: true,
                            },
                        },
                        {
                            userData: {
                                name: null,
                                email: faker.internet.email(),
                                phone: createTestPhone(),
                                password: faker.internet.password(),
                            },
                            expectedResult: {
                                isUserExists: true,
                                isNameSet: false,
                                isEmailSet: true,
                                isPhoneSet: true,
                                isPasswordSet: true,
                            },
                        },
                        {
                            userData: {
                                name: faker.name.fullName(),
                                email: null,
                                phone: createTestPhone(),
                                password: faker.internet.password(),
                            },
                            expectedResult: {
                                isUserExists: true,
                                isNameSet: true,
                                isEmailSet: false,
                                isPhoneSet: true,
                                isPasswordSet: true,
                            },
                        },
                        {
                            userData: {
                                name: faker.name.fullName(),
                                email: faker.internet.email(),
                                phone: createTestPhone(),
                                password: null,
                            },
                            expectedResult: {
                                isUserExists: true,
                                isNameSet: true,
                                isEmailSet: true,
                                isPhoneSet: true,
                                isPasswordSet: false,
                            },
                        },
                    ]

                    test.each(cases)('if user is exist (case: %#)', async ({ userData, expectedResult }) => {
                        const [, userAttrs] = await createTestUser(adminClient, {
                            type: userType,
                            ...userData,
                        })
                        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                            isPhoneVerified: true,
                            phone: userAttrs.phone,
                        })
                        const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmPhoneAction.token,
                            userType: userType,
                        })
                        expect(result).toEqual(expectedResult)
                    })

                    test('if user is not exist', async () => {
                        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                        const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmPhoneAction.token,
                            userType: userType,
                        })
                        expect(result).toEqual({
                            isUserExists: false,
                            isNameSet: false,
                            isEmailSet: false,
                            isPhoneSet: false,
                            isPasswordSet: false,
                        })
                    })

                    test('if user was reset', async () => {
                        const [resetUser, resetUserAttrs] = await createTestUser(adminClient, {
                            type: userType,
                        })
                        await resetUserByTestClient(adminClient, { user: { id: resetUser.id } })
                        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                            isPhoneVerified: true,
                            phone: resetUserAttrs.phone,
                        })
                        const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmPhoneAction.token,
                            userType: resetUserAttrs.type,
                        })
                        expect(result).toEqual({
                            isUserExists: false,
                            isNameSet: false,
                            isEmailSet: false,
                            isPhoneSet: false,
                            isPasswordSet: false,
                        })
                    })

                    test('if user was soft deleted', async () => {
                        const [deletedUser, deletedUserAttrs] = await createTestUser(adminClient, {
                            type: userType,
                        })
                        await updateTestUser(adminClient, deletedUser.id, {
                            deletedAt: new Date().toDateString(),
                        })
                        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                            isPhoneVerified: true,
                            phone: deletedUserAttrs.phone,
                        })
                        const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmPhoneAction.token,
                            userType: deletedUserAttrs.type,
                        })
                        expect(result).toEqual({
                            isUserExists: false,
                            isNameSet: false,
                            isEmailSet: false,
                            isPhoneSet: false,
                            isPasswordSet: false,
                        })
                    })
                })

                test('confirmPhoneAction should not be marked as used after checkUserExistence has been executed', async () => {
                    const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                    const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: RESIDENT,
                    })
                    expect(result).toBeDefined()
                    const confirmPhoneAction2 = await ConfirmPhoneAction.getOne(adminClient, { token: confirmPhoneAction.token })
                    expect(confirmPhoneAction2).toEqual(confirmPhoneAction)
                    expect(confirmPhoneAction2.completedAt).toBeNull()
                })

                test('should throw error if phone token is expired', async () => {
                    const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, expiresAt: new Date().toISOString(),
                    })
                    await expectToThrowGQLErrorToResult(async () => {
                        await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmPhoneAction.token,
                            userType: RESIDENT,
                        })
                    }, {
                        query: 'checkUserExistence',
                        variable: ['data', 'token'],
                        code: 'NOT_FOUND',
                        type: 'TOKEN_NOT_FOUND',
                        message: 'Token not found',
                    })
                })

                test('should throw error if phone token is used', async () => {
                    const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, completedAt: new Date().toISOString(),
                    })
                    await expectToThrowGQLErrorToResult(async () => {
                        await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmPhoneAction.token,
                            userType: RESIDENT,
                        })
                    }, {
                        query: 'checkUserExistence',
                        variable: ['data', 'token'],
                        code: 'NOT_FOUND',
                        type: 'TOKEN_NOT_FOUND',
                        message: 'Token not found',
                    })
                })

                test('should throw error if phone token is not confirmed', async () => {
                    const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: false })
                    await expectToThrowGQLErrorToResult(async () => {
                        await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmPhoneAction.token,
                            userType: RESIDENT,
                        })
                    }, {
                        query: 'checkUserExistence',
                        variable: ['data', 'token'],
                        code: 'NOT_FOUND',
                        type: 'TOKEN_NOT_FOUND',
                        message: 'Token not found',
                    })
                })

                describe('should throw error if invalid token', () => {
                    const cases = [
                        [TOKEN_TYPES.CONFIRM_PHONE, faker.datatype.uuid()].join('_'),
                        ['unsupportedType', faker.datatype.uuid()].join(':'),
                    ]

                    test.each(cases)('%p', async (invalidToken) => {
                        await expectToThrowGQLErrorToResult(async () => {
                            await checkUserExistenceByTestClient(anonymousClient, {
                                token: invalidToken,
                                userType: RESIDENT,
                            })
                        }, {
                            query: 'checkUserExistence',
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_TOKEN',
                            message: 'Invalid token',
                        })
                    })
                })
            })

            describe('confirmEmailAction', () => {
                describe.each(USER_TYPES)('should return valid value for userType: %p', (userType) => {
                    const cases = [
                        {
                            userData: {
                                name: faker.name.fullName(),
                                email: faker.internet.email(),
                                phone: createTestPhone(),
                                password: faker.internet.password(),
                            },
                            expectedResult: {
                                isUserExists: true,
                                isNameSet: true,
                                isEmailSet: true,
                                isPhoneSet: true,
                                isPasswordSet: true,
                            },
                        },
                        {
                            userData: {
                                name: null,
                                email: faker.internet.email(),
                                phone: createTestPhone(),
                                password: faker.internet.password(),
                            },
                            expectedResult: {
                                isUserExists: true,
                                isNameSet: false,
                                isEmailSet: true,
                                isPhoneSet: true,
                                isPasswordSet: true,
                            },
                        },
                        {
                            userData: {
                                name: faker.name.fullName(),
                                email: faker.internet.email(),
                                phone: undefined,
                                password: faker.internet.password(),
                            },
                            expectedResult: {
                                isUserExists: true,
                                isNameSet: true,
                                isEmailSet: true,
                                isPhoneSet: false,
                                isPasswordSet: true,
                            },
                        },
                        {
                            userData: {
                                name: faker.name.fullName(),
                                email: faker.internet.email(),
                                phone: createTestPhone(),
                                password: null,
                            },
                            expectedResult: {
                                isUserExists: true,
                                isNameSet: true,
                                isEmailSet: true,
                                isPhoneSet: true,
                                isPasswordSet: false,
                            },
                        },
                    ]

                    test.each(cases)('if user is exist (case: %#)', async ({ userData, expectedResult }) => {
                        const [, userAttrs] = await createTestUser(adminClient, {
                            type: userType,
                            isEmailVerified: true,
                            ...userData,
                        })
                        const [confirmPhoneAction] = await createTestConfirmEmailAction(adminClient, {
                            isEmailVerified: true,
                            email: userAttrs.email,
                        })
                        const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmPhoneAction.token,
                            userType: userType,
                        })
                        expect(result).toEqual(expectedResult)
                    })

                    test('if user is not exist', async () => {
                        const [confirmEmailAction] = await createTestConfirmEmailAction(adminClient, { isEmailVerified: true })
                        const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmEmailAction.token,
                            userType: userType,
                        })
                        expect(result).toEqual({
                            isUserExists: false,
                            isNameSet: false,
                            isEmailSet: false,
                            isPhoneSet: false,
                            isPasswordSet: false,
                        })
                    })

                    test('if user was reset', async () => {
                        const [resetUser, resetUserAttrs] = await createTestUser(adminClient, {
                            type: userType,
                            isEmailVerified: true,
                        })
                        await resetUserByTestClient(adminClient, { user: { id: resetUser.id } })
                        const [confirmEmailAction] = await createTestConfirmEmailAction(adminClient, {
                            isEmailVerified: true,
                            email: resetUserAttrs.email,
                        })
                        const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmEmailAction.token,
                            userType: resetUserAttrs.type,
                        })
                        expect(result).toEqual({
                            isUserExists: false,
                            isNameSet: false,
                            isEmailSet: false,
                            isPhoneSet: false,
                            isPasswordSet: false,
                        })
                    })

                    test('if user was soft deleted', async () => {
                        const [deletedUser, deletedUserAttrs] = await createTestUser(adminClient, {
                            isEmailVerified: true,
                            type: userType,
                        })
                        await updateTestUser(adminClient, deletedUser.id, {
                            deletedAt: new Date().toDateString(),
                        })
                        const [confirmEmailAction] = await createTestConfirmEmailAction(adminClient, {
                            isEmailVerified: true,
                            email: deletedUserAttrs.email,
                        })
                        const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmEmailAction.token,
                            userType: deletedUserAttrs.type,
                        })
                        expect(result).toEqual({
                            isUserExists: false,
                            isNameSet: false,
                            isEmailSet: false,
                            isPhoneSet: false,
                            isPasswordSet: false,
                        })
                    })
                })

                test('confirmEmailAction should not be marked as used after checkUserExistence has been executed', async () => {
                    const [confirmEmailAction] = await createTestConfirmEmailAction(adminClient, { isEmailVerified: true })
                    const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                        token: confirmEmailAction.token,
                        userType: RESIDENT,
                    })
                    expect(result).toBeDefined()
                    const confirmEmailAction2 = await ConfirmEmailAction.getOne(adminClient, { token: confirmEmailAction.token })
                    expect(confirmEmailAction2).toEqual(confirmEmailAction)
                    expect(confirmEmailAction2.completedAt).toBeNull()
                })

                test('should throw error if email token is expired', async () => {
                    const [confirmEmailAction] = await createTestConfirmEmailAction(adminClient, {
                        isEmailVerified: true, expiresAt: new Date().toISOString(),
                    })
                    await expectToThrowGQLErrorToResult(async () => {
                        await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmEmailAction.token,
                            userType: RESIDENT,
                        })
                    }, {
                        query: 'checkUserExistence',
                        variable: ['data', 'token'],
                        code: 'NOT_FOUND',
                        type: 'TOKEN_NOT_FOUND',
                        message: 'Token not found',
                    })
                })

                test('should throw error if email token is used', async () => {
                    const [confirmEmailAction] = await createTestConfirmEmailAction(adminClient, {
                        isEmailVerified: true, completedAt: new Date().toISOString(),
                    })
                    await expectToThrowGQLErrorToResult(async () => {
                        await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmEmailAction.token,
                            userType: RESIDENT,
                        })
                    }, {
                        query: 'checkUserExistence',
                        variable: ['data', 'token'],
                        code: 'NOT_FOUND',
                        type: 'TOKEN_NOT_FOUND',
                        message: 'Token not found',
                    })
                })

                test('should throw error if email token is not confirmed', async () => {
                    const [confirmEmailAction] = await createTestConfirmEmailAction(adminClient, { isEmailVerified: false })
                    await expectToThrowGQLErrorToResult(async () => {
                        await checkUserExistenceByTestClient(anonymousClient, {
                            token: confirmEmailAction.token,
                            userType: RESIDENT,
                        })
                    }, {
                        query: 'checkUserExistence',
                        variable: ['data', 'token'],
                        code: 'NOT_FOUND',
                        type: 'TOKEN_NOT_FOUND',
                        message: 'Token not found',
                    })
                })

                describe('should throw error if invalid token', () => {
                    const cases = [
                        [TOKEN_TYPES.CONFIRM_PHONE, faker.datatype.uuid()].join('_'),
                        ['unsupportedType', faker.datatype.uuid()].join(':'),
                    ]

                    test.each(cases)('%p', async (invalidToken) => {
                        await expectToThrowGQLErrorToResult(async () => {
                            await checkUserExistenceByTestClient(anonymousClient, {
                                token: invalidToken,
                                userType: RESIDENT,
                            })
                        }, {
                            query: 'checkUserExistence',
                            code: 'BAD_USER_INPUT',
                            type: 'INVALID_TOKEN',
                            message: 'Invalid token',
                        })
                    })
                })
            })
        })

        describe('request limits', () => {
            test('should throw error if there are a lot of requests for one phone number per day', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                for (let i = 0; i < 10; i++) {
                    const client = await makeClient()
                    await checkUserExistenceByTestClient(client, {
                        token: confirmPhoneAction.token,
                        userType: RESIDENT,
                    })
                }
                const client = await makeClient()
                await expectToThrowGQLErrorToResult(async () => {
                    await checkUserExistenceByTestClient(client, {
                        token: confirmPhoneAction.token,
                        userType: RESIDENT,
                    })
                }, {
                    code: 'BAD_USER_INPUT',
                    type: 'DAILY_REQUEST_LIMIT_FOR_PHONE_REACHED',
                    message: 'Too many requests with this phone. Try again later',
                    messageForUser: 'api.user.DAILY_REQUEST_LIMIT_FOR_PHONE_REACHED',
                })
            })

            test('should throw error if there are a lot of requests by ip per day', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                for (let i = 0; i < 10; i++) {
                    await checkUserExistenceByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: RESIDENT,
                    })
                }
                await expectToThrowGQLErrorToResult(async () => {
                    await checkUserExistenceByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: RESIDENT,
                    })
                }, {
                    code: 'BAD_USER_INPUT',
                    type: 'DAILY_REQUEST_LIMIT_FOR_IP_REACHED',
                    message: 'Too many requests from this ip address. Try again later',
                    messageForUser: 'api.user.DAILY_REQUEST_LIMIT_FOR_IP_REACHED',
                })
            })
        })
    })
})
