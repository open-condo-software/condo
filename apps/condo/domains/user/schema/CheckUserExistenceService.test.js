/**
 * Generated by `createservice user.CheckUserExistenceService --type queries`
 */

const { faker } = require('@faker-js/faker')

const {
    makeLoggedInAdminClient,
    makeClient,
    makeLoggedInClient,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { RESIDENT, USER_TYPES } = require('@condo/domains/user/constants/common')
const { GQL_ERRORS: USER_ERRORS } = require('@condo/domains/user/constants/errors')
const {
    createTestConfirmPhoneAction,
    createTestUser,
    createTestPhone,
    resetUserByTestClient,
    updateTestUser,
    ConfirmPhoneAction,
    checkUserExistenceByTestClient,
} = require('@condo/domains/user/utils/testSchema')

const { ERRORS } = require('./CheckUserExistenceService')


describe('CheckUserExistenceService', () => {
    let adminClient, anonymousClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
    })

    beforeEach(async () => {
        anonymousClient = await makeClient()
    })

    describe('Accesses', () => {
        describe('User', () => {
            test('can execute', async () => {
                const userClient = await makeLoggedInClient()
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await checkUserExistenceByTestClient(userClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
                expect(result).toEqual({
                    userExists: false,
                    nameSet: false,
                    emailSet: false,
                    phoneSet: false,
                    passwordSet: false,
                })
            })
        })

        describe('Anonymous (anyone)', () => {
            test('can execute', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
                expect(result).toEqual({
                    userExists: false,
                    nameSet: false,
                    emailSet: false,
                    phoneSet: false,
                    passwordSet: false,
                })
            })
        })
    })

    describe('Base logic', () => {
        describe.each(USER_TYPES)('should return valid value for userType: %p', (userType) => {
            const cases = [
                {
                    userData: {
                        name: faker.name.fullName(),
                        email: faker.internet.email(),
                        phone: createTestPhone(),
                        password: faker.internet.password(),
                    },
                    expectedResult: {
                        userExists: true,
                        nameSet: true,
                        emailSet: true,
                        phoneSet: true,
                        passwordSet: true,
                    },
                },
                {
                    userData: {
                        name: null,
                        email: faker.internet.email(),
                        phone: createTestPhone(),
                        password: faker.internet.password(),
                    },
                    expectedResult: {
                        userExists: true,
                        nameSet: false,
                        emailSet: true,
                        phoneSet: true,
                        passwordSet: true,
                    },
                },
                {
                    userData: {
                        name: faker.name.fullName(),
                        email: null,
                        phone: createTestPhone(),
                        password: faker.internet.password(),
                    },
                    expectedResult: {
                        userExists: true,
                        nameSet: true,
                        emailSet: false,
                        phoneSet: true,
                        passwordSet: true,
                    },
                },
                {
                    userData: {
                        name: faker.name.fullName(),
                        email: faker.internet.email(),
                        phone: createTestPhone(),
                        password: null,
                    },
                    expectedResult: {
                        userExists: true,
                        nameSet: true,
                        emailSet: true,
                        phoneSet: true,
                        passwordSet: false,
                    },
                },
            ]

            test.each(cases)('if user is exist (case: %#)', async ({ userData, expectedResult }) => {
                const [, userAttrs] = await createTestUser(adminClient, {
                    type: userType,
                    ...userData,
                })
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                    isPhoneVerified: true,
                    phone: userAttrs.phone,
                })
                const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: userType,
                })
                expect(result).toEqual(expectedResult)
            })

            test('if user is not exist', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: userType,
                })
                expect(result).toEqual({
                    userExists: false,
                    nameSet: false,
                    emailSet: false,
                    phoneSet: false,
                    passwordSet: false,
                })
            })

            test('if user was reset', async () => {
                const [resetUser, resetUserAttrs] = await createTestUser(adminClient, {
                    type: userType,
                })
                await resetUserByTestClient(adminClient, { user: { id: resetUser.id } })
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                    isPhoneVerified: true,
                    phone: resetUserAttrs.phone,
                })
                const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: resetUserAttrs.type,
                })
                expect(result).toEqual({
                    userExists: false,
                    nameSet: false,
                    emailSet: false,
                    phoneSet: false,
                    passwordSet: false,
                })
            })

            test('if user was soft deleted', async () => {
                const [deletedUser, deletedUserAttrs] = await createTestUser(adminClient, {
                    type: userType,
                })
                await updateTestUser(adminClient, deletedUser.id, {
                    deletedAt: new Date().toDateString(),
                })
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                    isPhoneVerified: true,
                    phone: deletedUserAttrs.phone,
                })
                const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: deletedUserAttrs.type,
                })
                expect(result).toEqual({
                    userExists: false,
                    nameSet: false,
                    emailSet: false,
                    phoneSet: false,
                    passwordSet: false,
                })
            })
        })

        test('confirmPhoneAction should not be marked as used after checkUserExistence has been executed', async () => {
            const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
            const [result] = await checkUserExistenceByTestClient(anonymousClient, {
                confirmActionToken: confirmPhoneAction.token,
                userType: RESIDENT,
            })
            expect(result).toBeDefined()
            const confirmPhoneAction2 = await ConfirmPhoneAction.getOne(adminClient, { token: confirmPhoneAction.token })
            expect(confirmPhoneAction2).toEqual(confirmPhoneAction)
            expect(confirmPhoneAction2.completedAt).toBeNull()
        })

        test('should throw error if phone token is expired', async () => {
            const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                isPhoneVerified: true, expiresAt: new Date().toISOString(),
            })
            await expectToThrowGQLError(async () => {
                await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
            }, ERRORS.TOKEN_NOT_FOUND, 'result')
        })

        test('should throw error if phone token is used', async () => {
            const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                isPhoneVerified: true, completedAt: new Date().toISOString(),
            })
            await expectToThrowGQLError(async () => {
                await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
            }, ERRORS.TOKEN_NOT_FOUND, 'result')
        })

        test('should throw error if phone token is not confirmed', async () => {
            const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: false })
            await expectToThrowGQLError(async () => {
                await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
            }, ERRORS.TOKEN_NOT_FOUND, 'result')
        })

        test('should throw error if there are a lot of requests for one phone number per day', async () => {
            const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
            for (let i = 0; i < 10; i++) {
                const client = await makeClient()
                await checkUserExistenceByTestClient(client, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
            }
            const client = await makeClient()
            await expectToThrowGQLError(async () => {
                await checkUserExistenceByTestClient(client, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
            }, USER_ERRORS.DAILY_REQUEST_LIMIT_FOR_PHONE_REACHED, 'result')
        })

        test('should throw error if there are a lot of requests by ip per day', async () => {
            const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
            for (let i = 0; i < 10; i++) {
                await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
            }
            await expectToThrowGQLError(async () => {
                await checkUserExistenceByTestClient(anonymousClient, {
                    confirmActionToken: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
            }, USER_ERRORS.DAILY_REQUEST_LIMIT_FOR_IP_REACHED, 'result')
        })
    })
})
