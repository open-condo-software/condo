/**
 * Generated by `createschema user.User name:Text; password?:Password; isAdmin?:Checkbox; email?:Text; isEmailVerified?:Checkbox; phone?:Text; isPhoneVerified?:Checkbox; avatar?:File; meta:Json; importId:Text;`
 */

const { faker } = require('@faker-js/faker')

const { generateGqlQueries } = require('@open-condo/codegen/generate.gql')
const { generateGQLTestUtils } = require('@open-condo/codegen/generate.test.utils')
const {
    getRandomString,
    makeLoggedInAdminClient,
    makeClient,
    DEFAULT_TEST_ADMIN_IDENTITY,
    DEFAULT_TEST_USER_IDENTITY,
    DEFAULT_TEST_USER_SECRET,
    UUID_RE,
    expectToThrowGraphQLRequestError,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAccessDeniedErrorToObjects,
    expectToThrowAccessDeniedErrorToCount,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedError,
    expectToThrowGQLError,
    catchErrorFrom,
    expectToThrowAccessDeniedToManageFieldError,
    expectToThrowAccessDeniedToFieldError,
} = require('@open-condo/keystone/test.utils')

const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { createTestB2BApp, B2BApp } = require('@condo/domains/miniapp/utils/testSchema')
const {
    MIN_PASSWORD_LENGTH,
    MAX_PASSWORD_LENGTH,
    STAFF,
    RESIDENT,
    SERVICE,
} = require('@condo/domains/user/constants/common')
const { USER_TYPES } = require('@condo/domains/user/constants/common')
const {
    WRONG_EMAIL_ERROR, WRONG_PASSWORD_ERROR, EMPTY_PASSWORD_ERROR, GQL_ERRORS: ERRORS,
} = require('@condo/domains/user/constants/errors')
const { GET_MY_USERINFO, SIGNIN_MUTATION } = require('@condo/domains/user/gql')
const {
    User,
    UserAdmin,
    createTestUser,
    updateTestUser,
    createTestUserRightsSet,
    makeClientWithNewRegisteredAndLoggedInUser,
    makeClientWithServiceUser,
    makeLoggedInClient,
    createTestLandlineNumber,
    createTestPhone,
    createTestEmail,
    makeClientWithResidentUser,
    makeClientWithSupportUser,
    registerNewUser,
} = require('@condo/domains/user/utils/testSchema')


const USER_FIELDS = '_label_'
const UserLabelGQL = generateGqlQueries('User', `{ ${USER_FIELDS} }`)
const UserLabel = generateGQLTestUtils(UserLabelGQL)

describe('SIGNIN', () => {
    test('anonymous: SIGNIN_MUTATION', async () => {
        const client = await makeClient()
        const { data, errors } = await client.mutate(SIGNIN_MUTATION, {
            'identity': DEFAULT_TEST_USER_IDENTITY,
            'secret': DEFAULT_TEST_USER_SECRET,
        })
        expect(errors).toEqual(undefined)
        expect(data.obj.item.id).toMatch(/[a-zA-Z0-9-_]+/)
    })

    test('anonymous: GET_MY_USERINFO', async () => {
        const client = await makeClient()
        const { data, errors } = await client.query(GET_MY_USERINFO)
        expect(errors).toEqual(undefined)
        expect(data).toEqual({ 'user': null })
    })

    test('user: GET_MY_USERINFO', async () => {
        const client = await makeLoggedInClient()
        const { data, errors } = await client.query(GET_MY_USERINFO)
        expect(errors).toEqual(undefined)
        expect(data.user).toEqual(expect.objectContaining({ id: client.user.id }))
    })

    test('anonymous: SIGNIN_MUTATION by wrong password', async () => {
        const client = await makeClient()
        const { data, errors } = await client.mutate(SIGNIN_MUTATION, {
            'identity': DEFAULT_TEST_USER_IDENTITY,
            'secret': 'wrong password',
        })
        expect(data).toEqual({ 'obj': null })
        expect(JSON.stringify(errors)).toMatch((WRONG_PASSWORD_ERROR))
    })

    test('anonymous: SIGNIN_MUTATION by wrong email', async () => {
        const client = await makeClient()
        const { data, errors } = await client.mutate(SIGNIN_MUTATION, {
            'identity': 'some3571592131usermail@example.com',
            'secret': 'wrong password',
        })
        expect(data).toEqual({ 'obj': null })
        expect(JSON.stringify(errors)).toMatch(WRONG_EMAIL_ERROR)
    })

    test('check auth by empty password', async () => {
        const admin = await makeLoggedInAdminClient()
        const [, userAttrs] = await createTestUser(admin, { password: '' })
        const checkAuthByEmptyPassword = async () => {
            await makeLoggedInClient({ email: userAttrs.email, password: '' })
        }
        await expect(checkAuthByEmptyPassword).rejects.toThrow(EMPTY_PASSWORD_ERROR)
    })

    test('soft deleted user cannot be authorized', async () => {
        const admin = await makeLoggedInAdminClient()
        const [user, userAttrs] = await createTestUser(admin)
        const { email, password } = userAttrs
        const [deletedUser] = await User.softDelete(admin, user.id)
        expect(deletedUser.deletedAt).not.toBeNull()
        const client = await makeClient()
        const res = await client.mutate(SIGNIN_MUTATION, { identity: email, secret: password })
        expect(res.data.obj).toBeNull()
        expect(res.errors[0].message).toEqual(expect.stringContaining('[passwordAuth:identity:notFound]'))
    })

    test('should authorize resident user', async () => {
        const admin = await makeLoggedInAdminClient()
        const [user, userAttrs] = await createTestUser(admin, { type: RESIDENT })
        const client = await makeClient()
        const res = await client.mutate(SIGNIN_MUTATION, { identity: userAttrs.email, secret: userAttrs.password })
        expect(res.errors).toEqual(undefined)
        expect(res.data.obj.item.id).toBe(user.id)
    })

    test('should authorize staff user', async () => {
        const admin = await makeLoggedInAdminClient()
        const [user, userAttrs] = await createTestUser(admin, { type: STAFF })
        const client = await makeClient()
        const res = await client.mutate(SIGNIN_MUTATION, { identity: userAttrs.email, secret: userAttrs.password })
        expect(res.errors).toEqual(undefined)
        expect(res.data.obj.item.id).toBe(user.id)
    })

    test('should authorize service user', async () => {
        const admin = await makeLoggedInAdminClient()
        const [user, userAttrs] = await createTestUser(admin, { type: SERVICE })
        const client = await makeClient()
        const res = await client.mutate(SIGNIN_MUTATION, { identity: userAttrs.email, secret: userAttrs.password })
        expect(res.errors).toEqual(undefined)
        expect(res.data.obj.item.id).toBe(user.id)
    })

    test('should throw error if service and staff users have one email', async () => {
        const admin = await makeLoggedInAdminClient()
        const email = createTestEmail()
        const [, staffUserAttrs] = await createTestUser(admin, { type: STAFF, email })
        const [, serviceUserAttrs] = await createTestUser(admin, { type: SERVICE, email })
        const client = await makeClient()

        const staffRes = await client.mutate(SIGNIN_MUTATION, { identity: staffUserAttrs.email, secret: staffUserAttrs.password })
        expect(staffRes.data.obj).toBeNull()
        expect(staffRes.errors[0].message).toEqual(expect.stringContaining('[passwordAuth:identity:multipleFound]'))

        const serviceRes = await client.mutate(SIGNIN_MUTATION, { identity: serviceUserAttrs.email, secret: serviceUserAttrs.password })
        expect(serviceRes.data.obj).toBeNull()
        expect(serviceRes.errors[0].message).toEqual(expect.stringContaining('[passwordAuth:identity:multipleFound]'))
    })
})

describe('User', () => {
    test('user: create User', async () => {
        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await createTestUser(client)
        })
    })

    test('anonymous: create User', async () => {
        const client = await makeClient()
        await expectToThrowAuthenticationErrorToObj(async () => {
            await createTestUser(client)
        })
    })

    test('user: read User', async () => {
        const admin = await makeLoggedInAdminClient()
        const [anotherUser] = await createTestUser(admin)

        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const { data } = await UserAdmin.getAll(client, {}, { raw: true, sortBy: ['updatedAt_DESC'] })
        expect(data.objs).toEqual(
            expect.arrayContaining([
                expect.objectContaining({
                    id: client.user.id,
                    email: client.userAttrs.email,
                    phone: client.userAttrs.phone,
                }),
                expect.objectContaining({ id: anotherUser.id, email: null, phone: null }),
            ]),
        )
        expect(data.objs.length >= 1).toBeTruthy()
    })

    test('anonymous: read User', async () => {
        const client = await makeClient()
        await expectToThrowAuthenticationErrorToObjects(async () => {
            await User.getAll(client)
        })
    })

    test('user: update self User', async () => {
        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const payload = {}
        const [obj, attrs] = await updateTestUser(client, client.user.id, payload)
        expect(obj.updatedBy).toMatchObject({ id: client.user.id })
        expect(obj.sender).toMatchObject(attrs.sender)
        expect(obj.v).toBeGreaterThan(client.user.v)
    })

    test('user: update self User phone should fail', async () => {
        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const payload = { phone: createTestPhone() }
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestUser(client, client.user.id, payload)
        })
    })

    // TODO(pahaz): !!! remove this test in the FUTURE
    test('user: update self resident phone should ok', async () => {
        const client = await makeClientWithResidentUser()
        const payload = { phone: client.userAttrs.phone }
        await updateTestUser(client, client.user.id, payload)

        const objs = await UserAdmin.getAll(client, { id: client.user.id })
        expect(objs[0]).toEqual(expect.objectContaining({ phone: client.userAttrs.phone }))
    })

    // TODO(pahaz): !!! unskip!
    test.skip('user: update self User email should fail', async () => {
        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const payload = { email: createTestEmail() }
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestUser(client, client.user.id, payload)
        })
    })

    test('user: update self User name', async () => {
        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const payload = { name: createTestEmail() }
        const [obj] = await updateTestUser(client, client.user.id, payload)
        expect(obj.name).toEqual(payload.name)
    })

    test('user: update self User isAdmin should fail', async () => {
        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const payload = { isAdmin: true }
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestUser(client, client.user.id, payload)
        })
    })

    test('user: update self User password should fail', async () => {
        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const password = getRandomString()
        const payload = { password }
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestUser(client, client.user.id, payload)
        })
    })

    test('user: update another User should fail', async () => {
        const admin = await makeLoggedInAdminClient()
        const [objCreated] = await createTestUser(admin)

        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const payload = {}
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestUser(client, objCreated.id, payload)
        })
    })

    test('anonymous: update User', async () => {
        const admin = await makeLoggedInAdminClient()
        const [objCreated] = await createTestUser(admin)

        const client = await makeClient()
        const payload = {}
        await expectToThrowAuthenticationErrorToObj(async () => {
            await updateTestUser(client, objCreated.id, payload)
        })
    })

    test('user: delete User', async () => {
        const admin = await makeLoggedInAdminClient()
        const [objCreated] = await createTestUser(admin)

        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await User.delete(client, objCreated.id)
        })
    })

    test('anonymous: delete User', async () => {
        const admin = await makeLoggedInAdminClient()
        const [objCreated] = await createTestUser(admin)

        const client = await makeClient()
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await User.delete(client, objCreated.id)
        })
    })

    test('anonymous: count', async () => {
        const client = await makeClient()
        const { data, errors } = await User.count(client, {}, { raw: true })
        expect(data).toEqual({ meta: { count: null } })
        expect(errors[0]).toMatchObject({
            'message': 'No or incorrect authentication credentials',
            'name': 'AuthenticationError',
            'path': ['meta', 'count'],
        })
    })

    test('user: count', async () => {
        const admin = await makeLoggedInAdminClient()
        const [, userAttrs] = await createTestUser(admin)
        const client = await makeLoggedInClient(userAttrs)
        const count = await User.count(client)
        expect(count).toBeGreaterThanOrEqual(2)
    })
})

describe('User utils', () => {
    test('createUser()', async () => {
        const admin = await makeLoggedInAdminClient()
        const [user, userAttrs] = await createTestUser(admin)
        expect(user.id).toMatch(/^[A-Za-z0-9-]+$/g)
        expect(userAttrs.email).toBeTruthy()
        expect(userAttrs.password).toBeTruthy()
    })

    test('createUser() with dv/sender cookies', async () => {
        const admin = await makeLoggedInAdminClient()
        const newCookie = `${admin.getCookie()}; sender=%7B%22fingerprint%22%3A%22xY1byOxr6wCu%22%2C%22dv%22%3A1%7D; dv=1`
        admin.setHeaders({
            Cookie: newCookie,
        })
        const [user, attrs] = await createTestUser(admin, { dv: undefined, sender: undefined })
        expect(attrs.dv).toBeUndefined()
        expect(attrs.sender).toBeUndefined()
        expect(user.id).toMatch(UUID_RE)
    })

    test('createUser() with wrong dv', async () => {
        const admin = await makeLoggedInAdminClient()
        await expectToThrowGQLError(async () => await createTestUser(admin, { dv: 7 }), {
            'code': 'BAD_USER_INPUT',
            'type': 'DV_VERSION_MISMATCH',
            'message': 'Wrong value for data version number',
            'mutation': 'createUser',
            'variable': ['data', 'dv'],
        })
    })

    test('createUser() with wrong sender dv', async () => {
        const admin = await makeLoggedInAdminClient()
        await expectToThrowGQLError(async () => await createTestUser(admin, {
            sender: {
                dv: 2,
                fingerprint: '<errrr>',
            },
        }), {
            'code': 'BAD_USER_INPUT',
            'type': 'WRONG_FORMAT',
            'message': 'Invalid format of "sender" field value. {details}',
            'correctExample': '{ "dv": 1, "fingerprint": "uniq-device-or-container-id" }',
            'mutation': 'createUser',
            'messageInterpolation': { 'details': 'fingerprint: \'Fingerprint is invalid\', dv: \'Dv must be equal to 1\'' },
            'variable': ['data', 'sender'],
        })
    })

    test('createUser() with wrong sender fingerprint', async () => {
        const admin = await makeLoggedInAdminClient()
        await expectToThrowGQLError(async () => await createTestUser(admin, {
            sender: {
                dv: 1,
                fingerprint: '<errrr>',
            },
        }), {
            'code': 'BAD_USER_INPUT',
            'type': 'WRONG_FORMAT',
            'correctExample': '{ "dv": 1, "fingerprint": "uniq-device-or-container-id" }',
            'message': 'Invalid format of "sender" field value. {details}',
            'mutation': 'createUser',
            'messageInterpolation': { 'details': 'fingerprint: \'Fingerprint is invalid\'' },
            'variable': ['data', 'sender'],
        })
    })

    test('createUser() with landline phone number', async () => {
        const admin = await makeLoggedInAdminClient()
        const phone = createTestLandlineNumber()

        const { data, errors } = await createTestUser(admin, { phone }, { raw: true })

        expect(data).toEqual({ 'obj': null })
        expect(errors).toMatchObject([{
            message: 'You attempted to perform an invalid mutation',
            name: 'ValidationFailureError',
            path: ['obj'],
            data: {
                messages: ['[format:phone] invalid format'],
            },
        }])
    })

    test('makeLoggedInClient() without arguments', async () => {
        const admin = await makeLoggedInAdminClient()
        const client = await makeLoggedInClient()
        const userObj = await UserAdmin.getOne(admin, { id: client.user.id })
        expect(userObj).toMatchObject({
            email: DEFAULT_TEST_USER_IDENTITY,
            isAdmin: false,
            isSupport: false,
            type: 'staff',
        })
        const adminObj = await UserAdmin.getOne(admin, { id: admin.user.id })
        expect(adminObj).toMatchObject({
            email: DEFAULT_TEST_ADMIN_IDENTITY,
            isAdmin: true,
            isSupport: false,
            type: 'staff',
        })
    })
})

describe('User fields', () => {
    test('Convert email to lower case', async () => {
        const admin = await makeLoggedInAdminClient()
        const email = 'XXX' + getRandomString() + '@example.com'
        const [user, userAttrs] = await createTestUser(admin, { email })

        const objs = await UserAdmin.getAll(admin, { id: user.id })
        expect(objs[0]).toEqual(expect.objectContaining({ email: email.toLowerCase(), id: user.id }))

        const client2 = await makeLoggedInClient({ password: userAttrs.password, email: email.toLowerCase() })
        expect(client2.user.id).toEqual(user.id)

        // TODO(pahaz): fix in a future (it's no OK if you can't logged in by upper case email)
        const checkAuthByUpperCaseEmail = async () => {
            await makeLoggedInClient(userAttrs)
        }
        await expect(checkAuthByUpperCaseEmail).rejects.toThrow(WRONG_EMAIL_ERROR)
    })

    test('should auto-set "showGlobalHints" to true if value is not passed explicitly', async () => {
        const admin = await makeLoggedInAdminClient()
        const [user] = await createTestUser(admin)

        expect(user.showGlobalHints).toBeTruthy()
    })

    describe('name', () => {
        describe('Inside list queries (allUsers, User)', () => {
            test('Can be seen only by admin / support / direct accessed users', async () => {
                const admin = await makeLoggedInAdminClient()
                const support = await makeClientWithSupportUser()

                const [rightsSet] = await createTestUserRightsSet(admin, {
                    canReadUsers: true,
                })
                const directAccessedClient = await makeClientWithNewRegisteredAndLoggedInUser({
                    rightsSet: { connect: { id: rightsSet.id } },
                })

                const defaultClient = await makeClientWithNewRegisteredAndLoggedInUser()

                expect(admin.user.name).not.toBeNull()
                expect(support.user.name).not.toBeNull()
                expect(directAccessedClient.user.name).not.toBeNull()
                expect(defaultClient.user.name).not.toBeNull()

                const where = {
                    id_in: [support.user.id, directAccessedClient.user.id, defaultClient.user.id],
                }

                for (const client of [admin, support, directAccessedClient]) {
                    const users = await User.getAll(client, where)
                    expect(users).toHaveLength(3)
                    expect(users).toEqual(expect.arrayContaining([
                        expect.objectContaining({ id: support.user.id, name: support.user.name }),
                        expect.objectContaining({ id: directAccessedClient.user.id, name: directAccessedClient.user.name }),
                        expect.objectContaining({ id: defaultClient.user.id, name: defaultClient.user.name }),
                    ]))

                    const user = await User.getOne(client, { id: defaultClient.user.id })
                    expect(user).toEqual(expect.objectContaining({
                        name: defaultClient.user.name,
                    }))
                }

                const { data, errors } = await User.getAll(defaultClient, where, { raw: true })
                expect(data).toHaveProperty('objs')
                expect(data.objs).toHaveLength(3)
                expect(data.objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({ id: support.user.id, name: null }),
                    expect.objectContaining({ id: directAccessedClient.user.id, name: null }),
                    expect.objectContaining({ id: defaultClient.user.id, name: defaultClient.user.name }),
                ]))

                const nonSelfIndexes = data.objs
                    .map((_, idx) => idx)
                    .filter(idx => data.objs[idx].id !== defaultClient.user.id)

                expect(nonSelfIndexes).toHaveLength(2)

                expect(errors).toEqual(expect.arrayContaining(nonSelfIndexes.map(idx =>
                    expect.objectContaining({
                        name: 'AccessDeniedError',
                        path: ['objs', idx, 'name'],
                    })
                )))
            })
        })
        describe('Outside list queries (allUsers, User)', () => {
            describe('Can be seen according to regular access',  () => {
                test('List example', async () => {
                    const support = await makeClientWithSupportUser()
                    const [app] = await createTestB2BApp(support)
                    expect(support).toHaveProperty(['user', 'name'])

                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()

                    const apps = await B2BApp.getAll(userClient, { id: app.id })
                    expect(apps).toHaveLength(1)

                    expect(apps[0]).toHaveProperty(['createdBy', 'name'], support.user.name)
                })
                test('Unauthorized query returning User', async () => {
                    const client = await makeClient()
                    const name = faker.name.firstName()
                    const [user] = await registerNewUser(client, { name })

                    expect(user).toHaveProperty('name', name)
                })
            })
        })
    })

    describe('type', ()=> {
        let user
        let admin
        let support
        let client

        beforeAll(async () => {
            admin = await makeLoggedInAdminClient()
            support = await makeClientWithSupportUser()
            client = await makeClientWithServiceUser();

            [user] = await createTestUser(admin)
        })

        test.each(USER_TYPES)('Client type cannot be manually set to %p', async (type) => {
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestUser(client, user.id, { type: type })
            })
        })

        test.each(USER_TYPES)('Support type cannot be manually set to %p', async (type) => {
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestUser(support, user.id, { type: type })
            })
        })

        test.each(USER_TYPES)('Admin can be manually set to %p', async (type) => {
            const [updatedUser] = await updateTestUser(admin, user.id, { type: type })

            expect(updatedUser.type).toEqual(type)
        })
    })

    describe('hasMarketingConsent', () => {
        let admin
        beforeAll(async () => {
            admin = await makeLoggedInAdminClient()
        })

        test('cannot be updated by support', async () => {
            const support = await makeClientWithSupportUser()
            const [user] = await createTestUser(admin)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestUser(support, user.id, { hasMarketingConsent: true })
            })
        })

        test('can be updated by user himself', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()

            const [updatedUser] = await updateTestUser(client, client.user.id, { hasMarketingConsent: true })
            expect(updatedUser.hasMarketingConsent).toBe(true)
        })

        test('can be updated by user with "canManageUserHasMarketingConsentField" set in rights set', async () => {
            const userWithPermissions = await makeClientWithNewRegisteredAndLoggedInUser()
            const [canManageUserHasMarketingConsentField] = await createTestUserRightsSet(admin, {
                canManageUserHasMarketingConsentField: true,
            })

            const [updatedUserWithPermissions] = await updateTestUser(admin, userWithPermissions.user.id, { rightsSet: { connect: { id: canManageUserHasMarketingConsentField.id } } })
            expect(updatedUserWithPermissions.rightsSet.id).toEqual(canManageUserHasMarketingConsentField.id)

            const [user] = await createTestUser(admin)
            const [updatedUser] = await updateTestUser(userWithPermissions, user.id, { hasMarketingConsent: true })
            expect(updatedUser.hasMarketingConsent).toBe(true)
        })
    })

    describe('rightsSet', () => {
        let admin
        beforeAll(async () => {
            admin = await makeLoggedInAdminClient()
        })

        test('Admin and user with rightsSet for manage User.rightsSet field can add to user some rightsSet', async () => {
            const userWithPermissions = await makeClientWithNewRegisteredAndLoggedInUser()
            const [canManageUserRightsSetField] = await createTestUserRightsSet(admin, {
                canManageUserRightsSetField: true,
            })

            const [updatedUserWithPermissionsByAdmin] = await updateTestUser(admin, userWithPermissions.user.id, { rightsSet: { connect: { id: canManageUserRightsSetField.id } } })
            expect(updatedUserWithPermissionsByAdmin.rightsSet.id).toEqual(canManageUserRightsSetField.id)
            // NOTE: We can do it!
            const [user] = await createTestUser(admin)
            const [updatedUser] = await updateTestUser(userWithPermissions, user.id, { rightsSet: { connect: { id: canManageUserRightsSetField.id } } })
            expect(updatedUser.rightsSet.id).toEqual(canManageUserRightsSetField.id)
        })

        test('Support cannot add to user some rightsSet', async () => {
            const [user] = await createTestUser(admin)
            const support = await makeClientWithSupportUser()
            const [canManageUserHasMarketingConsentField] = await createTestUserRightsSet(admin, {
                canManageUserHasMarketingConsentField: true,
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestUser(support, user.id, { rightsSet: { connect: { id: canManageUserHasMarketingConsentField.id } } })
            })
        })
    })

    describe('email', () => {
        let admin
        let UserWithEmail
        beforeAll(async () => {
            admin = await makeLoggedInAdminClient()
            UserWithEmail = generateGQLTestUtils(generateGqlQueries('User', '{ id email deletedAt }'))
        })

        test('cannot be read by support', async () => {
            const [user] = await createTestUser(admin)
            const support = await makeClientWithSupportUser()
            await expectToThrowAccessDeniedError(async () => {
                await UserWithEmail.getOne(support, { id: user.id })
            }, ['objs', 0, 'email'])
        })

        test('can read by user with "canReadUserEmailField" permission in rights set', async () => {
            const [user, userAttrs] = await createTestUser(admin)
            const userWithPermissions = await makeClientWithNewRegisteredAndLoggedInUser()
            const [canReadUserEmailField] = await createTestUserRightsSet(admin, {
                canReadUserEmailField: true,
            })

            const [updatedUserWithPermissions]  = await updateTestUser(admin, userWithPermissions.user.id, { rightsSet: { connect: { id: canReadUserEmailField.id } } })
            expect(updatedUserWithPermissions.rightsSet.id).toEqual(canReadUserEmailField.id)

            const readUser = await UserWithEmail.getOne(userWithPermissions, { id: user.id } )
            expect(readUser.email).toEqual(userAttrs.email)
        })

        test('cannot be updated directly by himself', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()

            await expectToThrowAccessDeniedToManageFieldError(async () => {
                await updateTestUser(client, client.user.id, { email: createTestEmail() })
            }, 'obj', 'email')
        })
    })

    describe('phone', () => {
        let admin
        let UserWithPhone
        beforeAll(async () => {
            admin = await makeLoggedInAdminClient()
            UserWithPhone = generateGQLTestUtils(generateGqlQueries('User', '{ id phone deletedAt }'))
        })

        test('cannot be read by support', async () => {
            const [user] = await createTestUser(admin)
            const support = await makeClientWithSupportUser()
            await expectToThrowAccessDeniedError(async () => {
                await UserWithPhone.getOne(support, { id: user.id })
            }, ['objs', 0, 'phone'])
        })

        test('can read by user with "canReadUserPhoneField" permission in rights set', async () => {
            const [user, userAttrs] = await createTestUser(admin)
            const userWithPermissions = await makeClientWithNewRegisteredAndLoggedInUser()
            const [canReadUserPhoneField] = await createTestUserRightsSet(admin, {
                canReadUserPhoneField: true,
            })

            const [updatedUserWithPermissions] = await updateTestUser(admin, userWithPermissions.user.id, { rightsSet: { connect: { id: canReadUserPhoneField.id } } })
            expect(updatedUserWithPermissions.rightsSet.id).toEqual(canReadUserPhoneField.id)

            const readUser = await UserWithPhone.getOne(userWithPermissions, { id: user.id } )
            expect(readUser.phone).toEqual(userAttrs.phone)
        })
    })

    describe('_label_', () => {

        let admin
        let support
        let user
        beforeAll(async () => {
            admin = await makeLoggedInAdminClient()
            support = await makeClientWithSupportUser()
        })

        beforeEach(async () => {
            const name = faker.name.firstName();
            [user] = await registerNewUser(admin, { name })
        })

        test('Shows "name" -- <id> in "_label_" if requested by admin or support', async () => {
            const userForAdmin = await UserLabel.getOne(admin, { id: user.id })
            expect(userForAdmin).toHaveProperty('_label_', `${user.name} -- <${user.id}>`)

            const userForSupport = await UserLabel.getOne(support, { id: user.id })
            expect(userForSupport).toHaveProperty('_label_', `${user.name} -- <${user.id}>`)
        })

        test('Shows "id" in "_label_" if requested by user with no admin / support rights', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const [rightSet] = await createTestUserRightsSet(admin, { canReadUsers: true })
            await updateTestUser(admin, client.user.id, { rightsSet: { connect: { id: rightSet.id } } })

            const userForClient = await UserLabel.getOne(client, { id: user.id })
            expect(userForClient).toHaveProperty('_label_', user.id)
        })

    })

    describe('external fields', () => {
        const externalFieldsPayload = {
            externalPhone: createTestPhone(),
            externalEmail: createTestEmail(),
            isExternalPhoneVerified: Math.random() > 0.5,
            isExternalEmailVerified: Math.random() > 0.5,
        }
        const actors = {
            admin: null,
            support: null,
        }
        beforeAll(async () => {
            actors.admin = await makeLoggedInAdminClient()
            actors.support = await makeClientWithSupportUser()
        })
        describe.each(Object.keys(externalFieldsPayload))('%p', (fieldName) => {
            describe('Cannot be created via GQL-request',  () => {
                test.each(Object.keys(actors))('Actor: %p', async (actorName) => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestUser(actors[actorName], {
                            [fieldName]: externalFieldsPayload[fieldName],
                        })
                    })
                })

            })
            describe('Cannot be updated via GQL-request',  () => {
                test.each(Object.keys(actors))('Actor: %p', async (actorName) => {
                    const [user] = await createTestUser(actors.admin)
                    await catchErrorFrom(async () => {
                        await updateTestUser(actors[actorName], user.id, {
                            [fieldName]: externalFieldsPayload[fieldName],
                        })
                    }, (error) => {
                        expect(error.errors).toHaveLength(1)
                        expect(error.errors[0].message).toContain(`Field "${fieldName}" is not defined by type "UserUpdateInput"`)
                    })
                })

            })
        })
    })

    describe('isTwoFactorAuthenticationEnabled', () => {
        let adminClient, supportClient
        const UserWith2FA = generateGQLTestUtils(generateGqlQueries('User', '{ id isTwoFactorAuthenticationEnabled }'))

        beforeAll(async () => {
            supportClient = await makeClientWithSupportUser()
            adminClient = await makeLoggedInAdminClient()
        })

        test('Default value is "false"', async () => {
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const user = await UserWith2FA.getOne(adminClient, { id: userClient.user.id })
            expect(user.isTwoFactorAuthenticationEnabled).toBeFalsy()
        })

        describe('Accesses', () => {
            describe('Admin', () => {
                test('can set field when create user', async () => {
                    const [user] = await createTestUser(adminClient, {
                        isTwoFactorAuthenticationEnabled: true,
                    })
                    const createdUser = await UserWith2FA.getOne(adminClient, { id: user.id })
                    expect(createdUser.isTwoFactorAuthenticationEnabled).toBeTruthy()
                })

                test('can update', async () => {
                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const user = await UserWith2FA.getOne(adminClient, { id: userClient.user.id })
                    expect(user.isTwoFactorAuthenticationEnabled).toBeFalsy()
                    await updateTestUser(adminClient, userClient.user.id, {
                        isTwoFactorAuthenticationEnabled: true,
                    })
                    const updatedUser = await UserWith2FA.getOne(adminClient, { id: userClient.user.id })
                    expect(updatedUser.isTwoFactorAuthenticationEnabled).toBeTruthy()
                })

                test('can read', async () => {
                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const user = await UserWith2FA.getOne(adminClient, { id: userClient.user.id })
                    expect(user.isTwoFactorAuthenticationEnabled).toBeDefined()
                    expect(user.isTwoFactorAuthenticationEnabled).toBeFalsy()
                })
            })

            describe('Support', () => {
                test('can not set field when create user', async () => {
                    await expectToThrowAccessDeniedToManageFieldError(async () => {
                        await createTestUser(supportClient, {
                            isTwoFactorAuthenticationEnabled: true,
                        })
                    }, 'obj', 'isTwoFactorAuthenticationEnabled')
                })

                test('can not update', async () => {
                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const user = await UserWith2FA.getOne(adminClient, { id: userClient.user.id })
                    expect(user.isTwoFactorAuthenticationEnabled).toBeFalsy()
                    await expectToThrowAccessDeniedToManageFieldError(async () => {
                        await updateTestUser(supportClient, userClient.user.id, {
                            isTwoFactorAuthenticationEnabled: true,
                        })
                    }, 'obj', 'isTwoFactorAuthenticationEnabled')
                })

                test('can read', async () => {
                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const user = await UserWith2FA.getOne(supportClient, { id: userClient.user.id })
                    expect(user.isTwoFactorAuthenticationEnabled).toBeDefined()
                    expect(user.isTwoFactorAuthenticationEnabled).toBeFalsy()
                })
            })

            describe('User', () => {
                test('can not update', async () => {
                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const userClient2 = await makeClientWithNewRegisteredAndLoggedInUser()
                    const user = await UserWith2FA.getOne(adminClient, { id: userClient.user.id })
                    expect(user.isTwoFactorAuthenticationEnabled).toBeFalsy()
                    await expectToThrowAccessDeniedToManageFieldError(async () => {
                        await updateTestUser(userClient2, userClient.user.id, {
                            isTwoFactorAuthenticationEnabled: true,
                        })
                    }, 'obj', 'isTwoFactorAuthenticationEnabled')
                })

                test('can not update by himself', async () => {
                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const user = await UserWith2FA.getOne(adminClient, { id: userClient.user.id })
                    expect(user.isTwoFactorAuthenticationEnabled).toBeFalsy()
                    await expectToThrowAccessDeniedToManageFieldError(async () => {
                        await updateTestUser(userClient, userClient.user.id, {
                            isTwoFactorAuthenticationEnabled: true,
                        })
                    }, 'obj', 'isTwoFactorAuthenticationEnabled')
                })

                test('can read by himself', async () => {
                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const user = await UserWith2FA.getOne(userClient, { id: userClient.user.id })
                    expect(user.isTwoFactorAuthenticationEnabled).toBeDefined()
                    expect(user.isTwoFactorAuthenticationEnabled).toBeFalsy()
                })

                test('can not read (not himself)', async () => {
                    const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
                    const userClient2 = await makeClientWithNewRegisteredAndLoggedInUser()
                    await expectToThrowAccessDeniedToFieldError(async () => {
                        await UserWith2FA.getOne(userClient2, { id: userClient.user.id })
                    }, 'objs', 'isTwoFactorAuthenticationEnabled')
                })
            })
        })
    })
})

const COMMON_FIELDS = 'id dv sender v deletedAt newId createdBy updatedBy createdAt updatedAt'
const HISTORY_FIELDS = 'history_id history_action history_date'
const USER_HISTORY_FIELDS = `{ ${HISTORY_FIELDS} name avatar meta type isPhoneVerified isEmailVerified ${COMMON_FIELDS} }`
const UserHistoryAdminGQL = generateGqlQueries('UserHistoryRecord', USER_HISTORY_FIELDS)
const UserHistoryAdmin = generateGQLTestUtils(UserHistoryAdminGQL)

describe('UserHistoryRecord', () => {
    test('create/update action generate history records', async () => {
        const admin = await makeLoggedInAdminClient()
        const name = getRandomString()

        const [user] = await createTestUser(admin)
        await User.update(admin, user.id, { name, dv: 1, sender: user.sender })

        const objs = await UserHistoryAdmin.getAll(admin, { history_id: user.id }, { sortBy: ['history_date_ASC'] })
        expect(objs).toMatchObject([
            {
                history_id: user.id,
                history_action: 'c',
                name: user.name,
                avatar: user.avatar,
                meta: user.meta,
                type: user.type,
                isPhoneVerified: user.isPhoneVerified,
                isEmailVerified: user.isEmailVerified,
                dv: 1,
                sender: user.sender,
                v: 1,
                deletedAt: null,
                newId: null,
                createdBy: admin.user.id,
                updatedBy: admin.user.id,
            },
            {
                history_id: user.id,
                history_action: 'u',
                name,
                avatar: user.avatar,
                meta: user.meta,
                type: user.type,
                isPhoneVerified: user.isPhoneVerified,
                isEmailVerified: user.isEmailVerified,
                dv: 1,
                sender: user.sender,
                v: 2,
                deletedAt: null,
                newId: null,
                createdBy: admin.user.id,
                updatedBy: admin.user.id,
            },
        ])
    })
})

describe('Cache tests', () => {
    test('Clients that ask for different set of fields in parallel get different set of fields', async () => {
        const originalClient = await makeClientWithNewRegisteredAndLoggedInUser()

        const originalClientUserId = originalClient.user.id

        const requests = []

        const CLIENTS = [
            { fields: ['id'], result: {} },
            { fields: ['id', 'type'], result: {} },
            { fields: ['id', 'dv'], result: {} },
            { fields: ['id', 'updatedAt'], result: {} },
            { fields: ['id', 'deletedAt'], result: {} },
        ]

        const REQUEST_ID = 'REQ_TEST'

        for (let i = 0; i < CLIENTS.length; ++i) {
            const modifiedClient = await makeClientWithNewRegisteredAndLoggedInUser()
            modifiedClient.setHeaders({ 'X-Request-Id': REQUEST_ID })

            const modifiedGQL = generateGqlQueries('User', `{ ${CLIENTS[i].fields.join(' ')} }`)
            const modifiedAPI = generateGQLTestUtils(modifiedGQL)

            CLIENTS[i].api = modifiedAPI
            CLIENTS[i].client = modifiedClient
        }

        for (let i = 0; i < CLIENTS.length; ++i) {
            const request = async () => {
                CLIENTS[i].result = await CLIENTS[i].api.getAll(CLIENTS[i].client, { id: originalClientUserId })
            }
            requests.push(request())
        }

        await Promise.all(requests)

        for (let i = 0; i < CLIENTS.length; ++i) {

            const fields = CLIENTS[i].fields
            const user = CLIENTS[i].result[0]

            for (let j = 0; j < fields.length; ++j) {
                const property = fields[j]
                expect(user).toHaveProperty(property)
                expect(user[property]).toEqual(originalClient.user[property])
            }
        }
    })
})

describe('Custom access rights', () => {
    it('should grant access to specific field if override rule was provided', async () => {
        const admin = await makeLoggedInAdminClient()

        const [user, userAttrs] = await createTestUser(admin)

        const customAccess = {
            accessRules: [{
                list: 'User',
                fields: [{ field: 'email', read: true }],
            }],
        }

        const [specialUser, specialUserAttrs] = await createTestUser(admin, { customAccess })
        const client = await makeLoggedInClient({ password: specialUserAttrs.password, email: specialUserAttrs.email })
        client.user = specialUser
        const regularClient = await makeLoggedInClient()

        const { data } = await UserAdmin.getAll(client, {
            id: user.id,
        }, { raw: true })

        expect(data.objs[0]).toHaveProperty('email', userAttrs.email)
        expect(data.objs[0]).toHaveProperty('id', user.id)

        const { data: regularData } = await UserAdmin.getAll(regularClient, {
            id: user.id,
        }, { raw: true })

        expect(regularData.objs[0]).toHaveProperty('email', null)
        expect(regularData.objs[0]).toHaveProperty('id', user.id)
    })

    it('should grant access to a list if override rule was provided', async () => {
        const admin = await makeLoggedInAdminClient()

        const customAccess = {
            accessRules: [{
                list: 'User',
                read: true,
                create: true,
                fields: [
                    { field: 'password', create: true },
                    { field: 'email', create: true, read: true },
                    { field: 'phone', create: true, read: true },
                    { field: 'type', create: true, read: true },
                ],
            }],
        }
        const [user, userAttrs] = await createTestUser(admin, { customAccess })

        const client = await makeLoggedInClient({ password: userAttrs.password, email: userAttrs.email })
        client.user = user

        const [createdUser] = await createTestUser(client)

        expect(createdUser).toBeDefined()
        expect(createdUser).toHaveProperty('id')
    })
})

describe('Validations', () => {
    describe('Password', () => {
        test('set to empty password', async () => {
            const admin = await makeLoggedInAdminClient()

            const [user] = await createTestUser(admin, { password: '' })
            expect(user.id).toBeDefined()

            const [user2] = await createTestUser(admin, { password: null })
            expect(user2.id).toBeDefined()
        })

        test('set to weak password', async () => {
            const admin = await makeLoggedInAdminClient()
            const password = '123456789'

            // TODO(pahaz): use ValidationErrorCheck
            await catchErrorFrom(
                async () => await createTestUser(admin, { password }),
                ({ errors }) => {
                    expect(errors).toHaveLength(1)
                    expect(errors[0]).toEqual(expect.objectContaining({
                        message: '[password:rejectCommon:User:password] Common and frequently-used passwords are not allowed.',
                    }))
                },
            )
        })

        test('set to short password', async () => {
            const admin = await makeLoggedInAdminClient()
            const password = faker.internet.password(MIN_PASSWORD_LENGTH - 1)

            await expectToThrowGQLError(
                async () => await createTestUser(admin, { password }),
                ERRORS.INVALID_PASSWORD_LENGTH,
            )
        })

        test('set to password starting or ending with a space', async () => {
            const admin = await makeLoggedInAdminClient()
            const password = '  ' + faker.internet.password() + '  '

            const [user] = await createTestUser(admin, { password })
            expect(user.id).toBeDefined()
        })

        test('set to very long password', async () => {
            const admin = await makeLoggedInAdminClient()
            const password = faker.internet.password(MAX_PASSWORD_LENGTH + 1)

            await expectToThrowGQLError(
                async () => await createTestUser(admin, { password }),
                ERRORS.INVALID_PASSWORD_LENGTH,
            )
        })

        test('set to password containing email', async () => {
            const admin = await makeLoggedInAdminClient()
            const [user, userAttrs] = await createTestUser(admin)
            const password = userAttrs.email + faker.internet.password()

            await expectToThrowGQLError(
                async () => await updateTestUser(admin, user.id, { password }),
                ERRORS.PASSWORD_CONTAINS_EMAIL,
            )
        })

        test('set to password containing phone', async () => {
            const admin = await makeLoggedInAdminClient()
            const [user, userAttrs] = await createTestUser(admin)
            const password = userAttrs.phone + faker.internet.password()

            await expectToThrowGQLError(
                async () => await updateTestUser(admin, user.id, { password }),
                ERRORS.PASSWORD_CONTAINS_PHONE,
            )
        })

        test('set to wrong format password', async () => {
            const admin = await makeLoggedInAdminClient()
            const password = faker.datatype.number()

            await expectToThrowGraphQLRequestError(
                async () => await createTestUser(admin, { password }),
                '"data.password"; String cannot represent a non string value',
            )
        })

        test('set to password that does not containing at least 4 different characters', async () => {
            const admin = await makeLoggedInAdminClient()
            const password = '12331212312123'

            await expectToThrowGQLError(
                async () => await createTestUser(admin, { password }),
                ERRORS.PASSWORD_CONSISTS_OF_SMALL_SET_OF_CHARACTERS,
            )
        })
    })
})

function generateSearchScenarios (field, value) {
    const prefixes = ['', 'contains', 'starts_with', 'ends_with']

    const allStringFields = []
    for (const prefix of prefixes) {
        allStringFields.push([field, prefix].filter(x => x).join('_'))
        allStringFields.push([field, prefix, 'i'].filter(x => x).join('_'))
        allStringFields.push([field, 'not', prefix].filter(x => x).join('_'))
        allStringFields.push([field, 'not', prefix, 'i'].filter(x => x).join('_'))
    }

    return allStringFields.map(field => ({ [field]: value })).concat([
        { [`${field}_in`]: [value] },
        { [`${field}_not_in`]: [value] },
    ])
}

describe('Sensitive data search', () => {
    const testPhone = '+79991234567'
    const testEmail = 'search@email.com'
    const cases = [
        ...generateSearchScenarios('phone', testPhone).map(where => [JSON.stringify(where), where]),
        ...generateSearchScenarios('email', testEmail).map(where => [JSON.stringify(where), where]),
        ['AND / OR combo with phone', {
            OR: [
                { AND: [{ phone: testPhone }] },
                { AND: [{ name: 'User' }] },
            ],
        }],
        ['AND / OR combo with email', {
            OR: [
                { AND: [{ name: 'User' }] },
                { AND: [{ email: testEmail }] },
            ],
        }],
    ]
    describe('Sensitive fields cannot be searched by user', () => {
        let user
        beforeAll(async () => {
            user = await makeClientWithNewRegisteredAndLoggedInUser()
        })
        test.each(cases)('%p', async (_, where) => {
            await expectToThrowAccessDeniedErrorToObjects(async () => {
                await User.getAll(user, where)
            })
            await expectToThrowAccessDeniedErrorToCount(async () => {
                await User.count(user, where)
            })
        })
    })
    test('Email address of service users can be read by another service users with direct access', async () => {
        const admin = await makeLoggedInAdminClient()
        const [rightsSet] = await createTestUserRightsSet(admin, {
            canReadUsers: true,
            canReadUserEmailField: true,
        })
        const firstServiceUser = await makeClientWithServiceUser({
            rightsSet: { connect: { id: rightsSet.id } },
        })
        const secondServiceUser = await makeClientWithServiceUser()
        const nonServiceUser = await makeClientWithNewRegisteredAndLoggedInUser()

        const UserWithEmail = generateGQLTestUtils(generateGqlQueries('User', '{ id email deletedAt }'))

        const readUser = await UserWithEmail.getOne(firstServiceUser, { id: secondServiceUser.user.id })
        expect(readUser).toHaveProperty('id', secondServiceUser.user.id)
        expect(readUser).toHaveProperty('email', normalizeEmail(secondServiceUser.userAttrs.email))
        expect(readUser).toHaveProperty('deletedAt')
        expect(readUser.deletedAt).toBeNull()

        const accessDeniedCases = [
            [secondServiceUser, firstServiceUser],
            [secondServiceUser, nonServiceUser],
            [nonServiceUser, secondServiceUser],
        ]

        for (const [client, target] of accessDeniedCases) {
            await expectToThrowAccessDeniedError(async () => {
                await UserWithEmail.getOne(client, { id: target.user.id })
            }, ['objs', 0, 'email'])
        }
    })
})