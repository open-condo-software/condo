/**
 * Generated by `createservice user.ChangeUserEmailService --type mutations`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, getByCondition } = require('@open-condo/keystone/schema')

const { COMMON_ERRORS } = require('@condo/domains/common/constants/errors')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const access = require('@condo/domains/user/access/ChangeUserEmailService')
const { INVALID_TOKEN, UNSUPPORTED_TOKEN, TOKEN_NOT_FOUND, USER_NOT_FOUND } = require('@condo/domains/user/constants/errors')
const { User, UserSudoToken } = require('@condo/domains/user/utils/serverSchema')
const { changeOrVerifyUserEmailGuard } = require('@condo/domains/user/utils/serverSchema/userEmailGuards')
const { detectTokenTypeSafely, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    DV_VERSION_MISMATCH: {
        ...COMMON_ERRORS.DV_VERSION_MISMATCH,
        mutation: 'changeUserEmail',
    },
    WRONG_SENDER_FORMAT: {
        ...COMMON_ERRORS.WRONG_SENDER_FORMAT,
        mutation: 'changeUserEmail',
    },
    INVALID_TOKEN: {
        mutation: 'changeUserEmail',
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: INVALID_TOKEN,
        message: 'Invalid token',
        messageForUser: 'api.user.changeUserEmail.INVALID_TOKEN',
    },
    UNSUPPORTED_TOKEN: {
        mutation: 'changeUserEmail',
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: UNSUPPORTED_TOKEN,
        message: 'Unsupported token',
        messageForUser: 'api.user.changeUserEmail.UNSUPPORTED_TOKEN',
    },
    TOKEN_NOT_FOUND: {
        mutation: 'changeUserEmail',
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: TOKEN_NOT_FOUND,
        message: 'Unable to find non-expired UserSudoToken by specified token',
        messageForUser: 'api.user.changeUserEmail.TOKEN_NOT_FOUND',
    },
    USER_NOT_FOUND: {
        mutation: 'changeUserEmail',
        code: BAD_USER_INPUT,
        type: USER_NOT_FOUND,
        message: 'User not found',
        messageForUser: 'api.user.changeUserEmail.USER_NOT_FOUND',
    },
    WRONG_EMAIL_FORMAT:  {
        ...COMMON_ERRORS.WRONG_EMAIL_FORMAT,
        variable: ['data', 'newEmail'],
        mutation: 'changeUserEmail',
    },
    OPERATION_FAILED: {
        mutation: 'changeUserEmail',
        code: BAD_USER_INPUT,
        type: 'OPERATION_FAILED',
        message: 'The operation failed',
        messageForUser: 'api.user.changeUserEmail.OPERATION_FAILED',
    },
}

const ChangeUserEmailService = new GQLCustomSchema('ChangeUserEmailService', {
    types: [
        {
            access: true,
            type: 'input ChangeUserEmailInput { dv: Int!, sender: SenderFieldInput!, token: String!, newEmail: String }',
        },
        {
            access: true,
            type: 'type ChangeUserEmailOutput { status: String! }',
        },
    ],

    mutations: [
        {
            access: access.canChangeUserEmail,
            schema: 'changeUserEmail(data: ChangeUserEmailInput!): ChangeUserEmailOutput',
            doc: {
                summary: 'Changes the user\'s email.\n' +
                    'If the new email is not specified, the email is reset.\n' +
                    'When changing the email, verification is reset.\n' +
                    'The email change is confirmed by a sudo token.',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { token, newEmail, sender } = data

                const normalizedEmail = normalizeEmail(newEmail) || null

                await changeOrVerifyUserEmailGuard(context, normalizedEmail)

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                if (newEmail && !normalizedEmail) {
                    throw new GQLError(ERRORS.WRONG_EMAIL_FORMAT, context)
                }

                const { error: tokenError, tokenType } = detectTokenTypeSafely(token)
                if (tokenError) {
                    throw new GQLError({ ...ERRORS.INVALID_TOKEN, data: { error: tokenError } }, context)
                }

                if (tokenType !== TOKEN_TYPES.SUDO) {
                    throw new GQLError(ERRORS.UNSUPPORTED_TOKEN, context)
                }

                const sudoToken = await getByCondition('UserSudoToken', {
                    token,
                    expiresAt_gte: new Date().toISOString(),
                    remainingUses_gt: 0,
                    deletedAt: null,
                })

                if (!sudoToken) throw new GQLError(ERRORS.TOKEN_NOT_FOUND, context)

                const authedItemId = context?.authedItem?.id || null
                if (authedItemId && authedItemId !== sudoToken.user) {
                    throw new GQLError(ERRORS.OPERATION_FAILED, context)
                }

                const user = await getByCondition('User', {
                    id: sudoToken.user,
                    deletedAt: null,
                })

                if (!user) throw new GQLError(ERRORS.USER_NOT_FOUND, context)

                await User.update(context, user.id, {
                    dv: 1, sender,
                    email: normalizedEmail,
                    isEmailVerified: false,
                })

                await UserSudoToken.update(context, sudoToken.id, {
                    dv: 1, sender,
                    remainingUses: sudoToken.remainingUses - 1,
                })

                return {
                    status: 'ok',
                }
            },
        },
    ],

})

module.exports = {
    ChangeUserEmailService,
}
