/**
 * Generated by `createservice user.RegisterNewUserThroughExternalIdentityService`
 */
const faker = require('faker')
const { isNil, isEmpty } = require('lodash')

const { GQLCustomSchema, getSchemaCtx } = require('@open-condo/keystone/schema')
const access = require('@condo/domains/user/access/RegisterNewUserThroughExternalIdentityService')
const { GQLErrorCode: { BAD_USER_INPUT }, GQLError } = require('@open-condo/keystone/errors')
const { DV_VERSION_MISMATCH, WRONG_FORMAT, NOT_UNIQUE } = require('@condo/domains/common/constants/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { normalizePhone } = require('@condo/domains/common/utils/phone')

const { UserExternalIdentity, User, registerUserExternalIdentity } = require('@condo/domains/user/utils/serverSchema')
const { getIdentityIntegration } = require('@condo/domains/user/integration/identity')
const {
    IDENTITY_INTEGRATION_DOES_NOT_SUPPORT_LOGIN_FORM,
    EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR,

} = require('@condo/domains/user/constants/errors')
const { RESIDENT } = require('@condo/domains/user/constants/common')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const errors = {
    DV_VERSION_MISMATCH: {
        mutation: 'registerNewUserThroughExternalIdentity',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Unsupported value for dv',
    },
    WRONG_SENDER_FORMAT: {
        mutation: 'registerNewUserThroughExternalIdentity',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value. {details}',
        correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
    },
    IDENTITY_INTEGRATION_DOES_NOT_SUPPORT_LOGIN_FORM: {
        mutation: 'registerNewUserThroughExternalIdentity',
        variable: ['data', 'identityType'],
        code: BAD_USER_INPUT,
        type: IDENTITY_INTEGRATION_DOES_NOT_SUPPORT_LOGIN_FORM,
        message: 'Identity integration does not support login form',
    },
    EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR: {
        mutation: 'registerNewUserThroughExternalIdentity',
        variable: ['data', 'tokenSet'],
        code: BAD_USER_INPUT,
        type: EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR,
        message: 'External identity already registered',
        messageForUser: 'api.user.registerNewUserThroughExternalIdentity.EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR',
    },
    USER_WITH_SPECIFIED_PHONE_ALREADY_EXISTS: {
        mutation: 'registerNewUserThroughExternalIdentity',
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'User with specified phone already exists',
        messageForUser: 'api.user.registerNewUser.USER_WITH_SPECIFIED_PHONE_ALREADY_EXISTS',
    },
    USER_WITH_SPECIFIED_EMAIL_ALREADY_EXISTS: {
        mutation: 'registerNewUserThroughExternalIdentity',
        code: BAD_USER_INPUT,
        type: NOT_UNIQUE,
        message: 'User with specified email already exists',
        messageForUser: 'api.user.registerNewUser.USER_WITH_SPECIFIED_EMAIL_ALREADY_EXISTS',
    },
}

async function ensureNotExists (context, field, value) {
    const existed = await User.getOne(context, { [field]: value, type: RESIDENT })
    if (existed) {
        throw new GQLError({
            phone: errors.USER_WITH_SPECIFIED_PHONE_ALREADY_EXISTS,
            email: errors.USER_WITH_SPECIFIED_EMAIL_ALREADY_EXISTS,
        }[field], context)
    }
}

const RegisterNewUserThroughExternalIdentityService = new GQLCustomSchema('RegisterNewUserThroughExternalIdentityService', {
    types: [
        {
            access: true,
            type: 'input RegisterNewUserThroughExternalIdentityInput { dv: Int! sender: SenderFieldInput!, identityType: IdentityType!, tokenSet: JSON!, name: String! }',
        },
        {
            access: true,
            type: 'type RegisterNewUserThroughExternalIdentityOutput { item: User!, token: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canRegisterNewUserThroughExternalIdentity,
            schema: 'registerNewUserThroughExternalIdentity(data: RegisterNewUserThroughExternalIdentityInput!): RegisterNewUserThroughExternalIdentityOutput',
            resolver: async (parent, { data }, context) => {
                const { sender, dv, identityType, tokenSet, name } = data
                const password = faker.internet.password()

                // validate dv & sender
                checkDvAndSender(data, errors.DV_VERSION_MISMATCH, errors.WRONG_SENDER_FORMAT, context)

                // get & validate integration
                const integration = getIdentityIntegration(identityType)

                // in some case identityType can not support login form
                if (isNil(integration)) {
                    throw new GQLError(errors.IDENTITY_INTEGRATION_DOES_NOT_SUPPORT_LOGIN_FORM, context)
                }

                // get user info from external service
                const userInfo = await integration.getUserInfo(tokenSet)
                const userIdentities = await UserExternalIdentity.getAll(context, {
                    identityType,
                    identityId: userInfo.id,
                })

                if (userIdentities.length > 0) {
                    throw new GQLError(errors.EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR, context)
                }

                // create a user
                const userData = {
                    name,
                    password,
                    email: normalizeEmail(userInfo.email),
                    phone: normalizePhone(userInfo.phoneNumber),
                    type: RESIDENT,
                    sender,
                    dv,
                }

                // validate that user is not already registered by email, phone
                if (!isEmpty(userData.phone)) {
                    await ensureNotExists(context, 'phone', userData.phone)
                    userData.isPhoneVerified = true
                }
                if (!isEmpty(userData.email)) {
                    await ensureNotExists(context, 'email', userData.email)
                    userData.isEmailVerified = true
                }

                // create user
                const user = await User.create(context, userData)

                // register UserExternalIdentity
                await registerUserExternalIdentity(context, {
                    sender,
                    user: { id: user.id },
                    identityId: userInfo.id,
                    identityType,
                    meta: userInfo,
                })

                // issue a token
                const { keystone } = await getSchemaCtx('User')
                const token = await context.startAuthedSession({ item: user, list: keystone.lists['User'] })

                return {
                    item: user,
                    token,
                }
            },
        },
    ],
    
})

module.exports = {
    RegisterNewUserThroughExternalIdentityService,
}
