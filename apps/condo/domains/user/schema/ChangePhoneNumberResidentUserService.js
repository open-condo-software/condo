/**
 * Generated by `createservice user.ChangePhoneNumberResidentUserService`
 */
const { get } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { NOT_FOUND, DV_VERSION_MISMATCH, WRONG_FORMAT, WRONG_VALUE } = require('@condo/domains/common/constants/errors')
const { normalizePhone } = require('@condo/domains/common/utils/phone')
const access = require('@condo/domains/user/access/ChangePhoneNumberResidentUserService')
const { ConfirmPhoneAction, User, UserExternalIdentity } = require('@condo/domains/user/utils/serverSchema')


/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    DV_VERSION_MISMATCH: {
        mutation: 'changePhoneNumberResidentUser',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
    },
    WRONG_SENDER_FORMAT: {
        mutation: 'changePhoneNumberResidentUser',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value. {details}',
        correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
    },
    UNABLE_TO_FIND_CONFIRM_PHONE_ACTION: {
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        mutation: 'changePhoneNumberResidentUser',
        message: 'Unable to find a non-expired confirm phone action, that corresponds to provided token',
        variable: ['data', 'token'],
        messageForUser: 'api.user.changePhoneNumberResidentUser.UNABLE_TO_FIND_CONFIRM_PHONE_ACTION',
    },
    USER_HAS_CONNECTED_EXTERNAL_IDENTITY_WITH_DIFFERENT_PHONE: {
        code: BAD_USER_INPUT,
        type: WRONG_VALUE,
        mutation: 'changePhoneNumberResidentUser',
        message: 'Unable to change phone number since user has external identity and phone number are different',
        variable: ['data', 'token'],
        messageForUser: 'api.user.changePhoneNumberResidentUser.USER_HAS_CONNECTED_EXTERNAL_IDENTITY_WITH_DIFFERENT_PHONE',
    },
}

const ChangePhoneNumberResidentUserService = new GQLCustomSchema('ChangePhoneNumberResidentUserService', {
    types: [
        {
            access: true,
            type: 'input ChangePhoneNumberResidentUserInput { dv: Int!, sender: SenderFieldInput!, token: String!, removeUserExternalIdentitiesIfPhoneDifferent: Boolean }',
        },
        {
            access: true,
            type: 'type ChangePhoneNumberResidentUserOutput { status: String! }',
        },
    ],

    mutations: [
        {
            access: access.canChangePhoneNumberResidentUser,
            schema: 'changePhoneNumberResidentUser(data: ChangePhoneNumberResidentUserInput!): ChangePhoneNumberResidentUserOutput',
            doc: {
                summary: 'Changes a phone of a resident, that corresponds to confirmed phone number, specified via token',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { token, sender, removeUserExternalIdentitiesIfPhoneDifferent } = data
                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)
                if (!context.authedItem.id) throw new Error('Internal error inside the access check. We assume that the user should exists!')
                const userId = context.authedItem.id
                const action = await ConfirmPhoneAction.getOne(context,
                    {
                        expiresAt_gte: new Date().toISOString(),
                        token,
                        completedAt: null,
                        isPhoneVerified: true,
                    }
                )
                if (!action) {
                    throw new GQLError(ERRORS.UNABLE_TO_FIND_CONFIRM_PHONE_ACTION, context)
                }
                const { phone, isPhoneVerified } = action

                // check that user's external identity pointed to the new phone number
                // otherwise this case should be handled on client side
                const accordingUserExternalIdentity = await UserExternalIdentity.getAll(context, {
                    user: {
                        id: userId,
                    },
                    deletedAt: null,
                })

                for (const externalIdentity of accordingUserExternalIdentity) {
                    const phoneNumber = get(externalIdentity, 'meta.phoneNumber') || get(externalIdentity, 'meta.phone_number')
                    || get(externalIdentity, 'meta.phone') || get(externalIdentity, 'meta.mobile')

                    // if exists, throw exception if number is not equal to the new one
                    if (phoneNumber && normalizePhone(phoneNumber) !== normalizePhone(phone)) {
                        // if we have a flag removeUserExternalIdentitiesIfPhoneDifferent == true
                        // let's remove that UserExternalIdentity
                        if (removeUserExternalIdentitiesIfPhoneDifferent) {
                            await UserExternalIdentity.softDelete(context, externalIdentity.id, { dv: 1, sender })
                        } else {
                            throw new GQLError(ERRORS.USER_HAS_CONNECTED_EXTERNAL_IDENTITY_WITH_DIFFERENT_PHONE, context)
                        }
                    }
                }

                await User.update(context, userId, { sender, phone, isPhoneVerified, type: context.authedItem.type, dv: 1 })
                await ConfirmPhoneAction.update(context, action.id, { completedAt: new Date().toISOString(), sender, dv: 1 })
                return {
                    status: 'ok',
                }
            },
        },
    ],

})

module.exports = {
    ChangePhoneNumberResidentUserService,
}
