/**
 * Generated by `createservice user.ChangeUserPasswordService --type mutations`
 */

const { faker } = require('@faker-js/faker')

const { 
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowGQLErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { STAFF, RESIDENT, SERVICE } = require('@condo/domains/user/constants/common')
const {
    changeUserPasswordByTestClient,
    generateSudoTokenByTestClient,
    authenticateUserWithPhoneAndPasswordByTestClient,
    updateTestUser,
    UserSudoToken,
} = require('@condo/domains/user/utils/testSchema')
const {
    registerNewUser,
    makeClientWithStaffUser,
    makeClientWithResidentUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')
const { TOKEN_TYPES, generateToken } = require('@condo/domains/user/utils/tokens')


function getCaptcha () {
    return faker.random.alphaNumeric(32)
}

describe('ChangeUserPasswordService', () => {
    let adminClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
    })

    describe('Accesses', () => {
        describe('User', () => {
            test('can execute', async () => {
                const staffClient = await makeClientWithStaffUser()
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })

                const newPassword = faker.internet.password(16)
                const [result] = await changeUserPasswordByTestClient(staffClient, {
                    token: sudoToken.token,
                    newPassword,
                })
                expect(result.status).toBe('ok')

                const [authRes] = await authenticateUserWithPhoneAndPasswordByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    userType: STAFF,
                    phone: staffClient.userAttrs.phone,
                    password: newPassword,
                })
                expect(authRes.item.id).toBe(staffClient.user.id)
            })

            test('soft-deleted user cannot execute', async () => {
                const staffClient = await makeClientWithStaffUser()
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })

                await updateTestUser(adminClient, staffClient.user.id, {
                    deletedAt: new Date().toISOString(),
                })

                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await changeUserPasswordByTestClient(staffClient, {
                        token: sudoToken.token,
                        newPassword: faker.internet.password(16),
                    })
                })
            })
        })

        describe('Anonymous', () => {
            test('can execute', async () => {
                const anonymousClient = await makeClient()
                const [registeredUser, userAttrs] = await registerNewUser(await makeClient())
                const [sudoToken] = await generateSudoTokenByTestClient(anonymousClient, {
                    captcha: getCaptcha(),
                    user: { phone: userAttrs.phone, userType: STAFF },
                    authFactors: { password: userAttrs.password },
                })

                const newPassword = faker.internet.password(16)
                const [result] = await changeUserPasswordByTestClient(anonymousClient, {
                    token: sudoToken.token,
                    newPassword,
                })
                expect(result.status).toBe('ok')

                const [authRes] = await authenticateUserWithPhoneAndPasswordByTestClient(anonymousClient, {
                    captcha: getCaptcha(),
                    userType: STAFF,
                    phone: userAttrs.phone,
                    password: newPassword,
                })
                expect(authRes.item.id).toBe(registeredUser.id)
            })
        })
    })

    describe('Basic logic', () => {
        test('should throw error if dv and sender not valid', async () => {
            const staffClient = await makeClientWithStaffUser()
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })

            const newPassword = faker.internet.password(16)
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserPasswordByTestClient(staffClient, {
                    token: sudoToken.token,
                    newPassword,
                    dv: 123,
                })
            }, {
                mutation: 'changeUserPassword',
                variable: ['data', 'dv'],
                code: 'BAD_USER_INPUT',
                type: 'DV_VERSION_MISMATCH',
                message: 'Wrong value for data version number',
            })
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserPasswordByTestClient(staffClient, {
                    token: sudoToken.token,
                    newPassword,
                    sender: { dv: 1, fingerprint: '-' },
                })
            }, {
                mutation: 'changeUserPassword',
                variable: ['data', 'sender'],
                code: 'BAD_USER_INPUT',
                type: 'WRONG_FORMAT',
                message: 'Invalid format of "sender" field value. Please, check the example for details',
                correctExample: '{ "dv": 1, "fingerprint": "uniq-device-or-container-id" }',
            })
        })

        test('should throw error if newPassword is empty', async () => {
            const staffClient = await makeClientWithStaffUser()
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })

            await expectToThrowGQLErrorToResult(async () => {
                await changeUserPasswordByTestClient(staffClient, {
                    token: sudoToken.token,
                    newPassword: '',
                })
            }, {
                mutation: 'changeUserPassword',
                variable: ['data', 'password'],
                code: 'BAD_USER_INPUT',
                type: 'INVALID_PASSWORD_LENGTH',
                message: 'Password length must be between 8 and 128 characters',
            })
        })

        test('should throw error if token is invalid', async () => {
            const staffClient = await makeClientWithStaffUser()

            const newPassword = faker.internet.password(16)
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserPasswordByTestClient(staffClient, {
                    token: ['faker', faker.random.alphaNumeric(8)].join(':'),
                    newPassword,
                })
            }, {
                mutation: 'changeUserPassword',
                code: 'BAD_USER_INPUT',
                type: 'INVALID_TOKEN',
                message: 'Invalid token',
            })
        })

        test('should throw error if token is not supported', async () => {
            const staffClient = await makeClientWithStaffUser()

            const newPassword = faker.internet.password(16)
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserPasswordByTestClient(staffClient, {
                    token: generateToken(TOKEN_TYPES.CONFIRM_PHONE),
                    newPassword,
                })
            }, {
                mutation: 'changeUserPassword',
                code: 'BAD_USER_INPUT',
                type: 'UNSUPPORTED_TOKEN',
                message: 'Unsupported token',
            })
        })

        test('should throw error if token is not exists', async () => {
            const staffClient = await makeClientWithStaffUser()

            const newPassword = faker.internet.password(16)
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserPasswordByTestClient(staffClient, {
                    token: generateToken(TOKEN_TYPES.SUDO),
                    newPassword,
                })
            }, {
                mutation: 'changeUserPassword',
                variable: ['data', 'token'],
                code: 'BAD_USER_INPUT',
                type: 'TOKEN_NOT_FOUND',
                message: 'Unable to find non-expired SudoUserToken by specified token',
            })
        })

        test('should throw error if user is authed and not equal user from sudo-token', async () => {
            const staffClient = await makeClientWithStaffUser()
            const staffClient2 = await makeClientWithStaffUser()
            const [foreignSudoToken] = await generateSudoTokenByTestClient(staffClient2, {
                captcha: getCaptcha(),
                user: { phone: staffClient2.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient2.userAttrs.password },
            })

            const newPassword = faker.internet.password(16)
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserPasswordByTestClient(staffClient, {
                    token: foreignSudoToken.token,
                    newPassword,
                })
            }, {
                mutation: 'changeUserPassword',
                code: 'BAD_USER_INPUT',
                type: 'OPERATION_FAILED',
                message: 'Failed to complete the operation',
            })
        })

        const cases = [
            [STAFF, makeClientWithStaffUser],
            [RESIDENT, makeClientWithResidentUser],
            [SERVICE, makeClientWithServiceUser],
        ]
        test.each(cases)('should change user password (userType: %p)', async (userType, makeClientWithUser) => {
            const staffClient = await makeClientWithUser()
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType },
                authFactors: { password: staffClient.userAttrs.password },
            })

            const newPassword = faker.internet.password(16)
            const [result] = await changeUserPasswordByTestClient(staffClient, {
                token: sudoToken.token,
                newPassword,
            })
            expect(result.status).toBe('ok')

            await expectToThrowGQLErrorToResult(async () => {
                await authenticateUserWithPhoneAndPasswordByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    userType,
                    phone: staffClient.userAttrs.phone,
                    password: staffClient.userAttrs.password, // old password
                })
            }, {
                mutation: 'authenticateUserWithPhoneAndPassword',
                code: 'BAD_USER_INPUT',
                type: 'WRONG_CREDENTIALS',
            })
            const [authRes] = await authenticateUserWithPhoneAndPasswordByTestClient(staffClient, {
                captcha: getCaptcha(),
                userType,
                phone: staffClient.userAttrs.phone,
                password: newPassword,
            })
            expect(authRes.item.id).toBe(staffClient.user.id)
        })

        test('should update UserSudoToken after a password changing', async () => {
            const staffClient = await makeClientWithStaffUser()
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })
            const foundedSudoToken = await UserSudoToken.getOne(adminClient, {
                token: sudoToken.token,
            })
            expect(foundedSudoToken.remainingUses).toBe(1)

            const newPassword = faker.internet.password(16)
            const [result] = await changeUserPasswordByTestClient(staffClient, {
                token: sudoToken.token,
                newPassword,
            })
            expect(result.status).toBe('ok')

            const updatedSudoToken = await UserSudoToken.getOne(adminClient, {
                token: sudoToken.token,
            })
            expect(updatedSudoToken.remainingUses).toBe(0)
        })
    })

    describe('Request limit', () => {
        const REQUEST_LIMIT_PER_HOUR = 10

        test('should throw error if more than 10 requests are sent by ip per hours', async () => {
            const staffClient = await makeClientWithStaffUser()
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })

            for (let i = 0; i < REQUEST_LIMIT_PER_HOUR; i++) {
                await expectToThrowGQLErrorToResult(async () => {
                    await changeUserPasswordByTestClient(staffClient, {
                        token: sudoToken.token,
                        newPassword: '',
                    })
                }, {
                    mutation: 'changeUserPassword',
                    variable: ['data', 'password'],
                    code: 'BAD_USER_INPUT',
                    type: 'INVALID_PASSWORD_LENGTH',
                    message: 'Password length must be between 8 and 128 characters',
                })
            }

            await expectToThrowGQLErrorToResult(async () => {
                await changeUserPasswordByTestClient(staffClient, {
                    token: sudoToken.token,
                    newPassword: '',
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })
        })
    })
})