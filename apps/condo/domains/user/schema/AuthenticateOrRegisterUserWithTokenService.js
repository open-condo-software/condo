/**
 * Generated by `createservice user.AuthenticateOrRegisterUserWithTokenService --type mutations`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, getByCondition, getSchemaCtx } = require('@open-condo/keystone/schema')

const { COMMON_ERRORS } = require('@condo/domains/common/constants/errors')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { normalizePhone } = require('@condo/domains/common/utils/phone')
const access = require('@condo/domains/user/access/AuthenticateOrRegisterUserWithTokenService')
const { RESIDENT, STAFF, SERVICE } = require('@condo/domains/user/constants/common')
const { CAPTCHA_CHECK_FAILED, UNSUPPORTED_TOKEN, INVALID_TOKEN } = require('@condo/domains/user/constants/errors')
const { captchaCheck } = require('@condo/domains/user/utils/hCaptcha')
const { User, ConfirmPhoneAction } = require('@condo/domains/user/utils/serverSchema')
const { validateUserCredentials, authGuards } = require('@condo/domains/user/utils/serverSchema/auth')
const { detectTokenTypeSafely, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    CAPTCHA_CHECK_FAILED: {
        query: 'authenticateOrRegisterUserWithToken',
        variable: ['data', 'captcha'],
        code: BAD_USER_INPUT,
        type: CAPTCHA_CHECK_FAILED,
        message: 'Failed to check CAPTCHA',
        messageForUser: 'api.user.CAPTCHA_CHECK_FAILED',
    },
    DV_VERSION_MISMATCH: {
        ...COMMON_ERRORS.DV_VERSION_MISMATCH,
        query: 'authenticateOrRegisterUserWithToken',
    },
    WRONG_SENDER_FORMAT: {
        ...COMMON_ERRORS.WRONG_SENDER_FORMAT,
        query: 'authenticateOrRegisterUserWithToken',
    },
    INVALID_TOKEN: {
        query: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: INVALID_TOKEN,
        message: 'Invalid token',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.INVALID_TOKEN',
    },
    UNSUPPORTED_TOKEN: {
        query: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: UNSUPPORTED_TOKEN,
        message: 'Unsupported token',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.UNSUPPORTED_TOKEN',
    },
    DIFFERENT_PHONES: {
        mutation: 'authenticateOrRegisterUserWithToken',
        variable: ['data', 'userData', 'phone'],
        code: BAD_USER_INPUT,
        type: 'DIFFERENT_PHONES',
        message: 'The verified phone and the phone from the payload cannot be different',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.DIFFERENT_PHONES',
    },
    // TODO(DOMA-9890): use when added ConfirmEmailToken
    // DIFFERENT_EMAILS: {
    //     mutation: 'authenticateOrRegisterUserWithToken',
    //     variable: ['data', 'userData', 'phone'],
    //     code: BAD_USER_INPUT,
    //     type: 'DIFFERENT_EMAILS',
    //     message: 'The verified email and the email from the payload cannot be different',
    //     messageForUser: 'api.user.authenticateOrRegisterUserWithToken.DIFFERENT_PHONES',
    // },
    OPERATION_FAILED: {
        mutation: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: 'OPERATION_FAILED',
        message: 'The operation failed',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.OPERATION_FAILED',
    },
    REQUIRED_USER_DATA_IS_MISSING: {
        mutation: 'authenticateOrRegisterUserWithToken',
        variable: ['data', 'userData'],
        code: BAD_USER_INPUT,
        type: 'REQUIRED_USER_DATA_IS_MISSING',
        message: 'Some required user data was missing',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.REQUIRED_USER_DATA_IS_MISSING',
    },
    SHOULD_AUTHORIZE_WITH_EMAIL: {
        mutation: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: 'SHOULD_AUTHORIZE_WITH_EMAIL',
        message: 'You should log in to your account using a verified email to be able to log in by phone',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.SHOULD_AUTHORIZE_WITH_EMAIL',
    },
    // TODO(DOMA-9890): use when added ConfirmEmailToken
    // SHOULD_AUTHORIZE_WITH_PHONE: {
    //     mutation: 'authenticateOrRegisterUserWithToken',
    //     code: BAD_USER_INPUT,
    //     type: 'SHOULD_AUTHORIZE_WITH_PHONE',
    //     message: 'You should log in to your account using a verified phone to be able to log in by email',
    //     messageForUser: 'api.user.authenticateOrRegisterUserWithToken.SHOULD_AUTHORIZE_WITH_PHONE',
    // },
    CREDENTIAL_VALIDATION_FAILED: {
        mutation: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: 'CREDENTIAL_VALIDATION_FAILED',
        message: 'User credentials validation failed',
        messageForUser: 'api.user.CREDENTIAL_VALIDATION_FAILED',
    },
    UNAVAILABLE_TOKEN_FOR_REGISTRATION: {
        query: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: 'UNAVAILABLE_TOKEN_FOR_REGISTRATION',
        message: 'It is not possible to register a user with the type {userType} using {identifierType}',
        messageInterpolation: { userType: '?', identifierType: '?' },
    },
}

const SUPPORTED_TOKENS = [
    TOKEN_TYPES.CONFIRM_PHONE,

    // TODO(DOMA-9890): use when added ConfirmEmailToken
    // TOKEN_TYPES.CONFIRM_EMAIL,
]

const REQUIRED_USER_REGISTRATION_FIELDS = {
    [RESIDENT]: ['phone'],
    [STAFF]: ['phone', 'name', 'password'],
    [SERVICE]: [
        'email', 'name',

        // TODO(DOMA-9890): when added ConfirmEmailToken,
        //  It is necessary to check the complexity of the password
        //  so that it is impossible to set an easy password
        //  (at least for the service user)
        'password',
    ],
}

const USER_REGISTRATION_TOKEN_TYPES = {
    [RESIDENT]: [TOKEN_TYPES.CONFIRM_PHONE],
    [STAFF]: [TOKEN_TYPES.CONFIRM_PHONE],
    [SERVICE]: [
        // TODO(DOMA-9890): use when added ConfirmEmailToken
        // TOKEN_TYPES.CONFIRM_EMAIL,
    ],
}

const prepareCreateOrUpdateUserData = (user, userData, dvAndSender) => {
    const payload = {}
    for (const [key, value] of Object.entries(userData))  {
        if (!value) continue
        if (user?.[key]) continue
        payload[key] = value
    }
    if (Object.keys(payload).length > 0) {
        payload.dv = dvAndSender.dv
        payload.sender = dvAndSender.sender
    }
    return payload
}

/**
 * Checks that all required fields are present in a user data.
 * @param {string[]} requiredFields
 * @param {*} userData
 * @return {{missingFields: string[], missingRequiredFields: boolean}}
 */
const checkRequiredUserFields = (requiredFields, userData) => {
    if (!Array.isArray(requiredFields)) throw new Error('"requiredFields" should be an array')

    const missingFields = []
    for (const field of requiredFields) {
        const value = userData?.[field] || null
        if (value === null || value === undefined) missingFields.push(field)
        if (typeof value === 'string' && value.trim().length < 1) missingFields.push(field)
    }
    return { missingRequiredFields: missingFields.length > 0, missingFields }
}

const AuthenticateOrRegisterUserWithTokenService = new GQLCustomSchema('AuthenticateOrRegisterUserWithTokenService', {
    types: [
        {
            access: true,
            type: 'input AuthenticateOrRegisterUserWithTokenUserDataInput { phone: String, name: String, email: String, password: String }',
        },
        {
            access: true,
            type: 'input AuthenticateOrRegisterUserWithTokenInput { dv: Int!, sender: SenderFieldInput!, token: String!, userType: UserTypeType!, captcha: String!, userData: AuthenticateOrRegisterUserWithTokenUserDataInput }',
        },
        {
            access: true,
            type: 'type AuthenticateOrRegisterUserWithTokenOutput { item: User, token: String! }',
        },
    ],

    mutations: [
        {
            access: access.canAuthenticateOrRegisterUserWithToken,
            schema: 'authenticateOrRegisterUserWithToken(data: AuthenticateOrRegisterUserWithTokenInput!): AuthenticateOrRegisterUserWithTokenOutput',
            doc: {
                summary: 'This mutation authorizes the user by token, after confirming the phone number.\n\n' +
                    'If the user is not registered, then he will be created with the data that is passed in the payload (user data).\n\n' +
                    'If the existing user is missing some fields, then these fields will be taken from the payload (user data) and updated.\n\n' +
                    'This mutation is not available for service users!',
                errors: ERRORS,
            },
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data } = args
                const { token, userType, userData, captcha, dv, sender } = data

                await authGuards({ userType }, context)

                // NOTE: CAPTCHA, an acronym for “completely automated public Turing test to tell computers and humans apart”.
                // We assume that a user with the type "service" is not a human.
                // Therefore, we do not need to check for users with this type.
                if (userType !== SERVICE) {
                    const { error: captchaError } = await captchaCheck(context, captcha)
                    if (captchaError) {
                        throw new GQLError({ ...ERRORS.CAPTCHA_CHECK_FAILED, data: { error: captchaError } }, context)
                    }
                }

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                const { error: tokenError, tokenType } = detectTokenTypeSafely(token)
                if (tokenError) {
                    throw new GQLError({ ...ERRORS.INVALID_TOKEN, data: { error: tokenError } }, context)
                }

                if (!SUPPORTED_TOKENS.includes(tokenType)) {
                    throw new GQLError(ERRORS.UNSUPPORTED_TOKEN, context)
                }

                let confirmAction

                if (tokenType === TOKEN_TYPES.CONFIRM_PHONE) {
                    confirmAction = await getByCondition('ConfirmPhoneAction', {
                        token: token,
                        expiresAt_gte: new Date().toISOString(),
                        completedAt: null,
                        isPhoneVerified: true,
                        deletedAt: null,
                    })
                }
                // TODO(DOMA-9890): implement when added ConfirmEmailToken
                // else if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL) {
                //
                // }

                if (!confirmAction) throw new GQLError(ERRORS.INVALID_TOKEN, context)

                const confirmedPhone = tokenType === TOKEN_TYPES.CONFIRM_PHONE ? confirmAction?.phone : null
                // TODO(DOMA-9890): implement when added ConfirmEmailToken
                // const confirmedEmail = tokenType === TOKEN_TYPES.CONFIRM_EMAIL ? confirmAction?.email : null
                const notConfirmedPhone = normalizePhone(userData?.phone || null)
                const notConfirmedEmail = normalizeEmail(userData?.email || null) || null

                if (tokenType === TOKEN_TYPES.CONFIRM_PHONE && notConfirmedPhone && confirmedPhone !== notConfirmedPhone) {
                    throw new GQLError(ERRORS.DIFFERENT_PHONES, context)
                }
                // TODO(DOMA-9890): implement when added ConfirmEmailToken
                // if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL && notConfirmedEmail && confirmedEmail !== notConfirmedEmail) {
                //     throw new GQLError(ERRORS.DIFFERENT_EMAILS, context)
                // }

                const existingUser = await getByCondition('User', {
                    type: userType,
                    phone: confirmedPhone,
                })
                if (existingUser?.deletedAt) throw new GQLError(ERRORS.OPERATION_FAILED, context)

                const normalizedUserData = {
                    ...userData,
                    type: userType,
                    name: String(userData?.name || '').trim() || null,
                    // TODO(DOMA-9890): use when added ConfirmEmailToken
                    // email: confirmedEmail || notConfirmedEmail,
                    // isEmailVerified: !!confirmedEmail,
                    email: notConfirmedEmail,
                    phone: confirmedPhone || notConfirmedPhone,
                    isPhoneVerified: !!confirmedPhone,
                }
                const dvAndSender = { dv, sender }

                const userPayload = prepareCreateOrUpdateUserData(existingUser, normalizedUserData, dvAndSender)

                let actualUser
                if (!existingUser) {
                    if (!USER_REGISTRATION_TOKEN_TYPES[userType].includes(tokenType)) {
                        throw new GQLError({
                            ...ERRORS.UNAVAILABLE_TOKEN_FOR_REGISTRATION,
                            messageInterpolation: {
                                userType,
                                identifierType: tokenType === TOKEN_TYPES.CONFIRM_PHONE ? 'phone' : 'email',
                            },
                        }, context)
                    }

                    const { missingRequiredFields, missingFields } = checkRequiredUserFields(REQUIRED_USER_REGISTRATION_FIELDS[userType], userPayload)
                    if (missingRequiredFields) {
                        throw new GQLError({
                            ...ERRORS.REQUIRED_USER_DATA_IS_MISSING,
                            variable: ['data', 'userData', missingFields[0]],
                            message: `Some required user data was missing: ${missingFields.join(', ')}`,
                        }, context)
                    }

                    actualUser = await User.create(context, userPayload)
                } else {
                    if (tokenType === TOKEN_TYPES.CONFIRM_PHONE && !existingUser.isPhoneVerified && existingUser.isEmailVerified) {
                        throw new GQLError(ERRORS.SHOULD_AUTHORIZE_WITH_EMAIL, context)
                    }
                    // TODO(DOMA-9890): use when added ConfirmEmailToken
                    // if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL && !existingUser.isEmailVerified && existingUser.isPhoneVerified) {
                    //     throw new GQLError(ERRORS.SHOULD_AUTHORIZE_WITH_PHONE, context)
                    // }

                    if (existingUser.isEmailVerified || existingUser.isPhoneVerified) {
                        const authFactors = {}
                        if (tokenType === TOKEN_TYPES.CONFIRM_PHONE) {
                            authFactors.confirmPhoneToken = token
                        }
                        // TODO(DOMA-9890): use when added ConfirmEmailToken
                        // if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL) {
                        //     authFactors.confirmEmailToken = token
                        // }

                        const validation = await validateUserCredentials(
                            { userType: existingUser.type },
                            authFactors,
                        )

                        if (!validation.success) {
                            throw new GQLError(ERRORS.CREDENTIAL_VALIDATION_FAILED, context)
                        }
                    }

                    actualUser = existingUser

                    if (Object.keys(userPayload).some(key => key !== 'dv' && key !== 'sender')) {
                        actualUser = await User.update(context, existingUser.id, userPayload)
                    }
                }

                if (tokenType === TOKEN_TYPES.CONFIRM_PHONE) {
                    await ConfirmPhoneAction.update(context, confirmAction.id, { dv: 1, sender, completedAt: new Date().toISOString() })
                }
                // TODO(DOMA-9890): implement when added ConfirmEmailToken
                // if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL) {
                //
                // }

                const { keystone } = getSchemaCtx('User')
                const sessionToken = await context.startAuthedSession({ item: actualUser, list: keystone.lists['User'] })

                return {
                    item: actualUser,
                    token: sessionToken,
                }
            },
        },
    ],

})

module.exports = {
    AuthenticateOrRegisterUserWithTokenService,
}
