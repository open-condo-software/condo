/**
 * Generated by `createservice user.AuthenticateOrRegisterUserWithTokenService --type mutations`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, getByCondition, getSchemaCtx } = require('@open-condo/keystone/schema')

const { COMMON_ERRORS } = require('@condo/domains/common/constants/errors')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { normalizePhone } = require('@condo/domains/common/utils/phone')
const access = require('@condo/domains/user/access/AuthenticateOrRegisterUserWithTokenService')
const { RESIDENT, STAFF, SERVICE } = require('@condo/domains/user/constants/common')
const { ERRORS: USER_ERRORS } = require('@condo/domains/user/constants/errors')
const {
    CAPTCHA_CHECK_FAILED,
    UNSUPPORTED_TOKEN,
    INVALID_TOKEN,
    EMAIL_ALREADY_REGISTERED_ERROR,
    PHONE_ALREADY_REGISTERED_ERROR,
} = require('@condo/domains/user/constants/errors')
const { captchaCheck } = require('@condo/domains/user/utils/hCaptcha')
const { User, ConfirmPhoneAction, ConfirmEmailAction } = require('@condo/domains/user/utils/serverSchema')
const { validateUserCredentials, authGuards } = require('@condo/domains/user/utils/serverSchema/auth')
const { getIdentificationUserRequiredFields } = require('@condo/domains/user/utils/serverSchema/userHelpers')
const { detectTokenTypeSafely, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    CAPTCHA_CHECK_FAILED: {
        query: 'authenticateOrRegisterUserWithToken',
        variable: ['data', 'captcha'],
        code: BAD_USER_INPUT,
        type: CAPTCHA_CHECK_FAILED,
        message: 'Failed to check CAPTCHA',
        messageForUser: 'api.user.CAPTCHA_CHECK_FAILED',
    },
    DV_VERSION_MISMATCH: {
        ...COMMON_ERRORS.DV_VERSION_MISMATCH,
        query: 'authenticateOrRegisterUserWithToken',
    },
    WRONG_SENDER_FORMAT: {
        ...COMMON_ERRORS.WRONG_SENDER_FORMAT,
        query: 'authenticateOrRegisterUserWithToken',
    },
    INVALID_TOKEN: {
        query: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: INVALID_TOKEN,
        message: 'Invalid token',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.INVALID_TOKEN',
    },
    UNSUPPORTED_TOKEN: {
        query: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: UNSUPPORTED_TOKEN,
        message: 'Unsupported token',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.UNSUPPORTED_TOKEN',
    },
    DIFFERENT_PHONES: {
        mutation: 'authenticateOrRegisterUserWithToken',
        variable: ['data', 'userData', 'phone'],
        code: BAD_USER_INPUT,
        type: 'DIFFERENT_PHONES',
        message: 'The verified phone and the phone from the payload cannot be different',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.DIFFERENT_PHONES',
    },
    DIFFERENT_EMAILS: {
        mutation: 'authenticateOrRegisterUserWithToken',
        variable: ['data', 'userData', 'email'],
        code: BAD_USER_INPUT,
        type: 'DIFFERENT_EMAILS',
        message: 'The verified email and the email from the payload cannot be different',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.DIFFERENT_EMAILS',
    },
    OPERATION_FAILED: {
        mutation: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: 'OPERATION_FAILED',
        message: 'The operation failed',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.OPERATION_FAILED',
    },
    REQUIRED_USER_DATA_IS_MISSING: {
        mutation: 'authenticateOrRegisterUserWithToken',
        variable: ['data', 'userData'],
        code: BAD_USER_INPUT,
        type: 'REQUIRED_USER_DATA_IS_MISSING',
        message: 'Some required user data was missing',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.REQUIRED_USER_DATA_IS_MISSING',
    },
    SHOULD_AUTHORIZE_WITH_EMAIL: {
        mutation: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: 'SHOULD_AUTHORIZE_WITH_EMAIL',
        message: 'You should log in to your account using a verified email to be able to log in by phone',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.SHOULD_AUTHORIZE_WITH_EMAIL',
    },
    SHOULD_AUTHORIZE_WITH_PHONE: {
        mutation: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: 'SHOULD_AUTHORIZE_WITH_PHONE',
        message: 'You should log in to your account using a verified phone to be able to log in by email',
        messageForUser: 'api.user.authenticateOrRegisterUserWithToken.SHOULD_AUTHORIZE_WITH_PHONE',
    },
    CREDENTIAL_VALIDATION_FAILED: {
        mutation: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: 'CREDENTIAL_VALIDATION_FAILED',
        message: 'User credentials validation failed',
        messageForUser: 'api.user.CREDENTIAL_VALIDATION_FAILED',
    },
    UNAVAILABLE_TOKEN_FOR_REGISTRATION: {
        query: 'authenticateOrRegisterUserWithToken',
        code: BAD_USER_INPUT,
        type: 'UNAVAILABLE_TOKEN_FOR_REGISTRATION',
        message: 'It is not possible to register a user with the type {userType} using {identifierType}',
        messageInterpolation: { userType: '?', identifierType: '?' },
    },
    PHONE_ALREADY_REGISTERED_ERROR: {
        query: 'authenticateOrRegisterUserWithToken',
        variable: ['data', 'userData', 'phone'],
        code: BAD_USER_INPUT,
        type: 'PHONE_ALREADY_REGISTERED_ERROR',
        message: 'Phone already registered',
    },
    EMAIL_ALREADY_REGISTERED_ERROR: {
        query: 'authenticateOrRegisterUserWithToken',
        variable: ['data', 'userData', 'email'],
        code: BAD_USER_INPUT,
        type: 'EMAIL_ALREADY_REGISTERED_ERROR',
        message: 'Email already registered',
    },
    INVALID_PASSWORD_LENGTH: {
        ...USER_ERRORS.INVALID_PASSWORD_LENGTH,
        mutation: 'authenticateOrRegisterUserWithToken',
    },
    PASSWORD_IS_FREQUENTLY_USED: {
        ...USER_ERRORS.PASSWORD_IS_FREQUENTLY_USED,
        mutation: 'authenticateOrRegisterUserWithToken',
    },
    PASSWORD_CONSISTS_OF_SMALL_SET_OF_CHARACTERS: {
        ...USER_ERRORS.PASSWORD_CONSISTS_OF_SMALL_SET_OF_CHARACTERS,
        mutation: 'authenticateOrRegisterUserWithToken',
    },
    PASSWORD_CONTAINS_EMAIL: {
        ...USER_ERRORS.PASSWORD_CONTAINS_EMAIL,
        mutation: 'authenticateOrRegisterUserWithToken',
    },
    PASSWORD_CONTAINS_PHONE: {
        ...USER_ERRORS.PASSWORD_CONTAINS_PHONE,
        mutation: 'authenticateOrRegisterUserWithToken',
    },
}

const USER_ERROR_MAPPING = {
    [PHONE_ALREADY_REGISTERED_ERROR]: ERRORS.PHONE_ALREADY_REGISTERED_ERROR,
    [EMAIL_ALREADY_REGISTERED_ERROR]: ERRORS.EMAIL_ALREADY_REGISTERED_ERROR,
    '[password:minLength:User:password]': ERRORS.INVALID_PASSWORD_LENGTH,
    '[password:rejectCommon:User:password]': ERRORS.PASSWORD_IS_FREQUENTLY_USED,
    [ERRORS.INVALID_PASSWORD_LENGTH.message]: ERRORS.INVALID_PASSWORD_LENGTH,
    [ERRORS.PASSWORD_CONSISTS_OF_SMALL_SET_OF_CHARACTERS.message]: ERRORS.PASSWORD_CONSISTS_OF_SMALL_SET_OF_CHARACTERS,
    [ERRORS.PASSWORD_CONTAINS_EMAIL.message]: ERRORS.PASSWORD_CONTAINS_EMAIL,
    [ERRORS.PASSWORD_CONTAINS_PHONE.message]: ERRORS.PASSWORD_CONTAINS_PHONE,
}

const SUPPORTED_TOKENS = [
    TOKEN_TYPES.CONFIRM_PHONE,
    TOKEN_TYPES.CONFIRM_EMAIL,
]


const IDENTIFICATION_USER_REQUIRED_FIELDS = getIdentificationUserRequiredFields()

const REQUIRED_USER_REGISTRATION_FIELDS = {
    [RESIDENT]: [...IDENTIFICATION_USER_REQUIRED_FIELDS.resident],
    [STAFF]: [...IDENTIFICATION_USER_REQUIRED_FIELDS.staff, 'name', 'password'],
    [SERVICE]: [
        ...IDENTIFICATION_USER_REQUIRED_FIELDS.service, // NOTE: Service user registers only by email
        'name',

        // TODO(DOMA-9890): when added ConfirmEmailToken,
        //  It is necessary to check the complexity of the password
        //  so that it is impossible to set an easy password
        //  (at least for the service user)
        'password',
    ],
}

function getTokenTypesByIdentificationUserFields (fields) {
    if (!Array.isArray(fields)) {
        throw new Error('Input fields should be an array!')
    }

    const result = []

    if (fields.includes('phone')) {
        result.push(TOKEN_TYPES.CONFIRM_PHONE)
    }
    if (fields.includes('email')) {
        result.push(TOKEN_TYPES.CONFIRM_EMAIL)
    }

    return result
}

const USER_REGISTRATION_TOKEN_TYPES = {
    [RESIDENT]: [...getTokenTypesByIdentificationUserFields(IDENTIFICATION_USER_REQUIRED_FIELDS.resident)],
    [STAFF]: [...getTokenTypesByIdentificationUserFields(IDENTIFICATION_USER_REQUIRED_FIELDS.staff)],
    [SERVICE]: [...getTokenTypesByIdentificationUserFields(IDENTIFICATION_USER_REQUIRED_FIELDS.service)],
}

const prepareCreateOrUpdateUserData = (user, userData, dvAndSender) => {
    const payload = {}
    for (const [key, value] of Object.entries(userData)) {
        if (!value) continue
        if (user?.[key]) continue
        payload[key] = value
    }
    if (Object.keys(payload).length > 0) {
        payload.dv = dvAndSender.dv
        payload.sender = dvAndSender.sender
    }
    return payload
}

/**
 * Checks that all required fields are present in a user data.
 * @param {string[]} requiredFields
 * @param {*} userData
 * @return {{missingFields: string[], missingRequiredFields: boolean}}
 */
const checkRequiredUserFields = (requiredFields, userData) => {
    if (!Array.isArray(requiredFields)) throw new Error('"requiredFields" should be an array')

    const missingFields = []
    for (const field of requiredFields) {
        const value = userData?.[field] || null
        if (value === null || value === undefined) missingFields.push(field)
        if (typeof value === 'string' && value.trim().length < 1) missingFields.push(field)
    }
    return { missingRequiredFields: missingFields.length > 0, missingFields }
}

const AuthenticateOrRegisterUserWithTokenService = new GQLCustomSchema('AuthenticateOrRegisterUserWithTokenService', {
    types: [
        {
            access: true,
            type: 'input AuthenticateOrRegisterUserWithTokenUserDataInput { phone: String, name: String, email: String, password: String }',
        },
        {
            access: true,
            type: 'input AuthenticateOrRegisterUserWithTokenInput { dv: Int!, sender: SenderFieldInput!, token: String!, userType: UserTypeType!, captcha: String!, userData: AuthenticateOrRegisterUserWithTokenUserDataInput }',
        },
        {
            access: true,
            type: 'type AuthenticateOrRegisterUserWithTokenOutput { item: User, token: String! }',
        },
    ],

    mutations: [
        {
            access: access.canAuthenticateOrRegisterUserWithToken,
            schema: 'authenticateOrRegisterUserWithToken(data: AuthenticateOrRegisterUserWithTokenInput!): AuthenticateOrRegisterUserWithTokenOutput',
            doc: {
                summary: 'This mutation authorizes the user by token, after confirming the phone number.\n\n' +
                    'If the user is not registered, then he will be created with the data that is passed in the payload (user data).\n\n' +
                    'If the existing user is missing some fields, then these fields will be taken from the payload (user data) and updated.\n\n' +
                    'This mutation is not available for service users!',
                errors: ERRORS,
            },
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data } = args
                const { token, userType, userData, captcha, dv, sender } = data

                await authGuards({ userType }, context)

                // NOTE: CAPTCHA, an acronym for “completely automated public Turing test to tell computers and humans apart”.
                // We assume that a user with the type "service" is not a human.
                // Therefore, we do not need to check for users with this type.
                if (userType !== SERVICE) {
                    const { error: captchaError } = await captchaCheck(context, captcha)
                    if (captchaError) {
                        throw new GQLError({ ...ERRORS.CAPTCHA_CHECK_FAILED, data: { error: captchaError } }, context)
                    }
                }

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                const { error: tokenError, tokenType } = detectTokenTypeSafely(token)
                if (tokenError) {
                    throw new GQLError({ ...ERRORS.INVALID_TOKEN, data: { error: tokenError } }, context)
                }

                if (!SUPPORTED_TOKENS.includes(tokenType)) {
                    throw new GQLError(ERRORS.UNSUPPORTED_TOKEN, context)
                }

                let confirmAction

                if (tokenType === TOKEN_TYPES.CONFIRM_PHONE) {
                    confirmAction = await getByCondition('ConfirmPhoneAction', {
                        token: token,
                        expiresAt_gte: new Date().toISOString(),
                        completedAt: null,
                        isPhoneVerified: true,
                        deletedAt: null,
                    })
                } else if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL) {
                    confirmAction = await getByCondition('ConfirmEmailAction', {
                        token: token,
                        expiresAt_gte: new Date().toISOString(),
                        completedAt: null,
                        isEmailVerified: true,
                        deletedAt: null,
                    })
                }

                if (!confirmAction) throw new GQLError(ERRORS.INVALID_TOKEN, context)

                const confirmedPhone = tokenType === TOKEN_TYPES.CONFIRM_PHONE ? confirmAction?.phone : null
                const confirmedEmail = tokenType === TOKEN_TYPES.CONFIRM_EMAIL ? confirmAction?.email : null
                const notConfirmedPhone = normalizePhone(userData?.phone || null)
                const notConfirmedEmail = normalizeEmail(userData?.email || null) || null

                if (tokenType === TOKEN_TYPES.CONFIRM_PHONE && notConfirmedPhone && confirmedPhone !== notConfirmedPhone) {
                    throw new GQLError(ERRORS.DIFFERENT_PHONES, context)
                }
                if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL && notConfirmedEmail && confirmedEmail !== notConfirmedEmail) {
                    throw new GQLError(ERRORS.DIFFERENT_EMAILS, context)
                }

                const existingUser = await getByCondition('User', {
                    type: userType,
                    ...(tokenType === TOKEN_TYPES.CONFIRM_PHONE ? { phone: confirmedPhone } : { email: confirmedEmail }),
                })
                if (existingUser?.deletedAt) throw new GQLError(ERRORS.OPERATION_FAILED, context)

                const normalizedUserData = {
                    ...userData,
                    type: userType,
                    name: String(userData?.name || '').trim() || null,
                    email: confirmedEmail || notConfirmedEmail,
                    isEmailVerified: !!confirmedEmail,
                    phone: confirmedPhone || notConfirmedPhone,
                    isPhoneVerified: !!confirmedPhone,
                }
                const dvAndSender = { dv, sender }

                const userPayload = prepareCreateOrUpdateUserData(existingUser, normalizedUserData, dvAndSender)

                let actualUser
                if (!existingUser) {
                    if (!USER_REGISTRATION_TOKEN_TYPES[userType].includes(tokenType)) {
                        throw new GQLError({
                            ...ERRORS.UNAVAILABLE_TOKEN_FOR_REGISTRATION,
                            messageInterpolation: {
                                userType,
                                identifierType: tokenType === TOKEN_TYPES.CONFIRM_PHONE ? 'phone' : 'email',
                            },
                        }, context)
                    }

                    const {
                        missingRequiredFields,
                        missingFields,
                    } = checkRequiredUserFields(REQUIRED_USER_REGISTRATION_FIELDS[userType], userPayload)
                    if (missingRequiredFields) {
                        throw new GQLError({
                            ...ERRORS.REQUIRED_USER_DATA_IS_MISSING,
                            variable: ['data', 'userData', missingFields[0]],
                            message: `Some required user data was missing: ${missingFields.join(', ')}`,
                        }, context)
                    }

                    actualUser = await User.create(context, userPayload, 'id', {
                        errorMapping: USER_ERROR_MAPPING,
                    })
                } else {
                    if (tokenType === TOKEN_TYPES.CONFIRM_PHONE && !existingUser.isPhoneVerified && existingUser.isEmailVerified) {
                        throw new GQLError(ERRORS.SHOULD_AUTHORIZE_WITH_EMAIL, context)
                    }

                    if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL && !existingUser.isEmailVerified && existingUser.isPhoneVerified) {
                        throw new GQLError(ERRORS.SHOULD_AUTHORIZE_WITH_PHONE, context)
                    }

                    if (existingUser.isEmailVerified || existingUser.isPhoneVerified) {
                        const authFactors = {}
                        if (tokenType === TOKEN_TYPES.CONFIRM_PHONE) {
                            authFactors.confirmPhoneToken = token
                        }

                        if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL) {
                            authFactors.confirmEmailToken = token
                        }

                        const validation = await validateUserCredentials(
                            { userType: existingUser.type },
                            authFactors,
                        )

                        if (!validation.success) {
                            throw new GQLError(ERRORS.CREDENTIAL_VALIDATION_FAILED, context)
                        }
                    }

                    actualUser = existingUser

                    if (Object.keys(userPayload).some(key => key !== 'dv' && key !== 'sender')) {
                        actualUser = await User.update(context, existingUser.id, userPayload, 'id', {
                            errorMapping: USER_ERROR_MAPPING,
                        })
                    }
                }

                if (tokenType === TOKEN_TYPES.CONFIRM_PHONE) {
                    await ConfirmPhoneAction.update(context, confirmAction.id, {
                        dv: 1,
                        sender,
                        completedAt: new Date().toISOString(),
                    })
                }
                if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL) {
                    await ConfirmEmailAction.update(context, confirmAction.id, {
                        dv: 1,
                        sender,
                        completedAt: new Date().toISOString(),
                    })
                }

                const { keystone } = getSchemaCtx('User')
                const sessionToken = await context.startAuthedSession({
                    item: actualUser,
                    list: keystone.lists['User'],
                })

                return {
                    item: actualUser,
                    token: sessionToken,
                }
            },
        },
    ],

})

module.exports = {
    AuthenticateOrRegisterUserWithTokenService,
}
