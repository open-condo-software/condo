/**
 * Generated by `createservice user.RegisterNewServiceUserService`
 */
const crypto = require('crypto')

const conf = require('@open-condo/config')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { SERVICE_USER_CREATED_MESSAGE_TYPE, SERVICE_USER_UPDATED_MESSAGE_TYPE } = require('@condo/domains/notification/constants/constants')
const { sendMessage } = require('@condo/domains/notification/utils/serverSchema')
const access = require('@condo/domains/user/access/RegisterNewServiceUserService')
const { SERVICE } = require('@condo/domains/user/constants/common')
const { User } = require('@condo/domains/user/utils/serverSchema')

const LOWER_LETTERS = 'abcdefghijklmnopqrstuvwxyz'
const UPPER_LETTERS = LOWER_LETTERS.toUpperCase()
const OTHER_CHARS = '01234567890'
const PASS_ALPHABET = LOWER_LETTERS + UPPER_LETTERS + OTHER_CHARS
const PASS_LENGTH = 32

function generateStrongPassword () {
    return [...Array(PASS_LENGTH)]
        .map(() => PASS_ALPHABET[crypto.randomInt(PASS_LENGTH)])
        .join('')
}


const RegisterNewServiceUserService = new GQLCustomSchema('RegisterNewServiceUserService', {
    types: [
        {
            access: true,
            type: 'input RegisterNewServiceUserInput { dv: Int!, sender: SenderFieldInput!, name: String!, email: String!, meta: JSON, password: String }',
        },
        {
            access: true,
            type: 'type RegisterNewServiceUserOutput { id: ID!, email: String!, password: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canRegisterNewServiceUser,
            schema: 'registerNewServiceUser(data: RegisterNewServiceUserInput!): RegisterNewServiceUserOutput',
            resolver: async (parent, args, context) => {
                const { data: { email, password, name, dv, sender } } = args

                const newPassword = password || generateStrongPassword()

                let user = await User.getOne(context, { email, type: SERVICE, deletedAt: null })
                const messageType = user ? SERVICE_USER_UPDATED_MESSAGE_TYPE : SERVICE_USER_CREATED_MESSAGE_TYPE

                if (user) {
                    user = await User.update(context, user.id, {
                        dv,
                        sender,
                        password: newPassword,
                    })
                } else {
                    user = await User.create(context, {
                        dv,
                        sender,
                        type: SERVICE,
                        name,
                        email,
                        password: newPassword,
                    })
                }

                await sendMessage(context, {
                    to: { email: user.email },
                    type: messageType,
                    meta: {
                        dv: 1,
                        data: {
                            password: newPassword,
                            serverUrl: conf['SERVER_URL'],
                        },
                    },
                    sender,
                })

                return { id: user.id, email: user.email, password: newPassword }
            },
        },
    ],
    
})

module.exports = {
    RegisterNewServiceUserService,
}
