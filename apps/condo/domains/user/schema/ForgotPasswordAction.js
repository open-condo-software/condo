/**
 * Generated by `createschema user.ForgotPasswordAction 'user:Relationship:User:CASCADE; token:Text; requestedAt:DateTimeUtc; expiresAt:DateTimeUtc; usedAt?:DateTimeUtc;'`
 */
const { v4: uuid } = require('uuid')
const { Text, Relationship, DateTimeUtc } = require('@keystonejs/fields')
const { GQLListSchema } = require('@core/keystone/schema')
const { historical, versioned, uuided, tracked, softDeleted } = require('@core/keystone/plugins')
const { SENDER_FIELD, DV_FIELD } = require('@condo/domains/common/schema/fields')
const access = require('@condo/domains/user/access/ForgotPasswordAction')
const conf = require('@core/config')
const { WRONG_EMAIL_ERROR, MULTIPLE_ACCOUNTS_MATCHES, RESET_TOKEN_NOT_FOUND, PASSWORD_TOO_SHORT } = require('@condo/domains/user/constants/errors')
const { RESET_PASSWORD_MESSAGE_TYPE } = require('@condo/domains/notification/constants')
const RESET_PASSWORD_TOKEN_EXPIRY = conf.USER__RESET_PASSWORD_TOKEN_EXPIRY || 1000 * 60 * 60 * 24
const { MIN_PASSWORD_LENGTH } = require('../constants/common')
const { GQLCustomSchema } = require('@core/keystone/schema')
const { COUNTRIES, RUSSIA_COUNTRY } = require('@condo/domains/common/constants/countries')
const { sendMessage } = require('@condo/domains/notification/utils/serverSchema')
const { ForgotPasswordAction: ForgotPasswordActionGQL, User } = require('@condo/domains/user/utils/serverSchema')
const isEmpty = require('lodash/isEmpty')


const ForgotPasswordAction = new GQLListSchema('ForgotPasswordAction', {
    schemaDoc: 'Forgot password actions is used for anonymous user password recovery procedure',
    fields: {
        dv: DV_FIELD,
        sender: SENDER_FIELD,
        user: {
            schemaDoc: 'Ref to the user. The object will be deleted if the user ceases to exist',
            type: Relationship,
            ref: 'User',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },
        token: {
            schemaDoc: 'Unique token to complete confirmation',
            type: Text,
            isRequired: true,
        },
        requestedAt: {
            schemaDoc: 'DateTime when confirm phone action was started',
            type: DateTimeUtc,
            isRequired: true,
        },
        expiresAt: {
            schemaDoc: 'When password recovery action becomes invalid',
            type: DateTimeUtc,
            isRequired: true,
        },
        usedAt: {
            schemaDoc: 'When password recovery action was completed',
            type: DateTimeUtc,
            isRequired: false,
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), historical()],
    access: {
        read: access.canReadForgotPasswordAction,
        create: access.canManageForgotPasswordAction,
        update: access.canManageForgotPasswordAction,
        delete: false,
        auth: true,
    },
})

const ForgotPasswordService = new GQLCustomSchema('ForgotPasswordService', {
    types: [
        {
            access: true,
            type: 'input CheckPasswordRecoveryTokenInput { token: String! }',
        },
        {
            access: true,
            type: 'type CheckPasswordRecoveryTokenOutput { status: String! }',
        },
        {
            access: true,
            type: 'input StartPasswordRecoveryInput { email: String!, sender: JSON!, dv: Int! }',
        },
        {
            access: true,
            type: 'type StartPasswordRecoveryOutput { status: String! }',
        },
        {
            access: true,
            type: 'input ChangePasswordWithTokenInput { token: String!, password: String! }',
        },
        {
            access: true,
            type: 'type ChangePasswordWithTokenOutput { status: String! }',
        },

    ],
    queries: [
        {
            access: true,
            schema: 'checkPasswordRecoveryToken(data: CheckPasswordRecoveryTokenInput!): CheckPasswordRecoveryTokenOutput',
            resolver: async (parent, args, context, info, extra) => {
                const { data: { token } } = args
                const now = extra.extraNow || Date.now()
                const actions = await ForgotPasswordActionGQL.getAll(context, {
                    token,
                    expiresAt_gte: new Date(now).toISOString(),
                })
                if (isEmpty(actions)) {
                    throw new Error('[error]: Unable to find valid token')
                }

                return { status: 'ok' }
            },
        },
    ],
    mutations: [
        {
            access: true,
            schema: 'startPasswordRecovery(data: StartPasswordRecoveryInput!): StartPasswordRecoveryOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { email, sender, dv } } = args
                const extraToken = extra.extraToken || uuid()
                const extraTokenExpiration = extra.extraTokenExpiration || parseInt(RESET_PASSWORD_TOKEN_EXPIRY)
                const extraNowTimestamp = extra.extraNowTimestamp || Date.now()

                const requestedAt = new Date(extraNowTimestamp).toISOString()
                const expiresAt = new Date(extraNowTimestamp + extraTokenExpiration).toISOString()

                const users = await User.getAll(context, {
                    email,
                })

                if (isEmpty(users)) {
                    throw new Error(`${WRONG_EMAIL_ERROR}] Unable to find user when trying to start password recovery`)
                }

                if (users.length !== 1) {
                    throw new Error(`${MULTIPLE_ACCOUNTS_MATCHES}] Unable to find exact one user to start password recovery`)
                }

                const userId = users[0].id
                await ForgotPasswordActionGQL.create(context, {
                    dv,
                    sender,
                    user: { connect: { id: userId } },
                    token: extraToken,
                    requestedAt,
                    expiresAt,
                })

                // prepare emit context
                const lang = COUNTRIES[RUSSIA_COUNTRY].locale
                await sendMessage(context, {
                    lang,
                    to: {
                        user: {
                            id: userId,
                        },
                    },
                    type: RESET_PASSWORD_MESSAGE_TYPE,
                    meta: {
                        token: extraToken,
                        dv: 1,
                    },
                    sender: sender,
                })
                return { status: 'ok' }
            },
        },
        {
            access: true,
            schema: 'changePasswordWithToken(data: ChangePasswordWithTokenInput!): ChangePasswordWithTokenOutput',
            resolver: async (parent, args, context, info, extra) => {
                const { data: { token, password } } = args
                const now = extra.extraNow || (new Date(Date.now())).toISOString()

                if (password.length < MIN_PASSWORD_LENGTH) {
                    throw new Error(`${PASSWORD_TOO_SHORT}] Password too short`)
                }
                const forgotPasswordData = await ForgotPasswordActionGQL.getAll(context, {
                    token,
                    expiresAt_gte: now,
                })

                if (isEmpty(forgotPasswordData) || !forgotPasswordData.length) {
                    throw new Error(`${RESET_TOKEN_NOT_FOUND}] Unable to find token`)
                }

                const userId = forgotPasswordData[0].user.id
                const tokenId = forgotPasswordData[0].id

                // mark token as used
                await ForgotPasswordActionGQL.update(context, tokenId, {
                    usedAt: now,
                })

                await User.update(context, userId, {
                    password,
                })

                return { status: 'ok' }
            },
        },
    ],
})


module.exports = {
    ForgotPasswordAction,
    ForgotPasswordService,
}
