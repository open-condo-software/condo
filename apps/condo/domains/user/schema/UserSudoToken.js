/**
 * Generated by `createschema user.UserSudoToken 'token:Text; expiresAt:DateTimeUtc; user:Relationship:User:CASCADE; remainingUses:Integer'`
 */

const { GQLError, GQLErrorCode: { INTERNAL_ERROR, BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/user/access/UserSudoToken')
const { MAX_NUMBER_OF_TOKEN_USES } = require('@condo/domains/user/constants/sudoToken')


const ERRORS = {
    REMAINING_USES_INVALID: {
        variable: ['data', 'remainingUses'],
        code: INTERNAL_ERROR,
        type: 'REMAINING_USES_INVALID',
        message: `"remainingUses" field should not be less than 0 and not be more then ${MAX_NUMBER_OF_TOKEN_USES}`,
    },
    INCREASE_REMAINING_USES_IS_NOT_AVAILABLE: {
        variable: ['data', 'remainingUses'],
        code: BAD_USER_INPUT,
        type: 'INCREASE_REMAINING_USES_IS_NOT_AVAILABLE',
        message: 'Value of "remainingUses" field can only decrease',
    },
}

const UserSudoToken = new GQLListSchema('UserSudoToken', {
    schemaDoc: 'A sudo token that confirms sensitive user actions.',
    fields: {

        token: {
            schemaDoc: 'Unique token value.',
            type: 'Text',
            isUnique: true,
            isRequired: true,
        },

        expiresAt: {
            schemaDoc: 'Timestamp when the sudo token expires.',
            type: 'DateTimeUtc',
            isRequired: true,
        },

        user: {
            schemaDoc: 'User associated with this sudo token.',
            type: 'Relationship',
            ref: 'User',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },

        remainingUses: {
            schemaDoc: 'Number of remaining times the token can be used before it becomes invalid.',
            type: 'Integer',
            isRequired: true,
            hooks: {
                validateInput: ({ resolvedData, fieldPath, context, existingItem }) => {
                    const existingValue = existingItem?.[fieldPath]
                    const newValue = resolvedData[fieldPath]
                    if (typeof existingValue === 'number' && newValue > existingValue) {
                        throw new GQLError(ERRORS.INCREASE_REMAINING_USES_IS_NOT_AVAILABLE, context)
                    }
                    if (newValue < 0) {
                        throw new GQLError(ERRORS.REMAINING_USES_INVALID, context)
                    }
                    if (newValue > MAX_NUMBER_OF_TOKEN_USES) {
                        throw new GQLError(ERRORS.REMAINING_USES_INVALID, context)
                    }
                },
            },
        },

    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadUserSudoTokens,
        create: access.canManageUserSudoTokens,
        update: access.canManageUserSudoTokens,
        delete: false,
        auth: true,
    },
})

module.exports = {
    UserSudoToken,
}
