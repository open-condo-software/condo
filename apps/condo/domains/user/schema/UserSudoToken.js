/**
 * Generated by `createschema user.UserSudoToken 'token:Text; expiresAt:DateTimeUtc; user:Relationship:User:CASCADE; remainingUses:Integer'`
 */

const { GQLError, GQLErrorCode: { INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/user/access/UserSudoToken')


const ERRORS = {
    REMAINING_USES_INVALID: {
        variable: ['data', 'remainingUses'],
        code: INTERNAL_ERROR,
        type: 'REMAINING_USES_INVALID',
        message: '"remainingUses" field should not be less than 0',
    },
}

const UserSudoToken = new GQLListSchema('UserSudoToken', {
    schemaDoc: 'A user\'s sudo token that is used to confirm any sensitive actions with the user.',
    fields: {

        token: {
            schemaDoc: 'Unique token',
            type: 'Text',
            isUnique: true,
            isRequired: true,
        },

        expiresAt: {
            schemaDoc: 'Time when sudo token becomes not valid',
            type: 'DateTimeUtc',
            isRequired: true,
        },

        user: {
            schemaDoc: 'User to whom a sudo token is linked',
            type: 'Relationship',
            ref: 'User',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },

        remainingUses: {
            schemaDoc: 'Number of remaining uses of the token. Once these are used up, the token will be not valid',
            type: 'Integer',
            isRequired: true,
            hooks: {
                validateInput: ({ resolvedData, fieldPath, context }) => {
                    const newValue = resolvedData[fieldPath]
                    if (newValue < 0) {
                        throw new GQLError(ERRORS.REMAINING_USES_INVALID, context)
                    }
                },
            },
        },

    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadUserSudoTokens,
        create: access.canManageUserSudoTokens,
        update: access.canManageUserSudoTokens,
        delete: false,
        auth: true,
    },
})

module.exports = {
    UserSudoToken,
}
