/**
 * Generated by `createservice user.GenerateSudoTokenService --type mutations`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const { gql } = require('graphql-tag')

const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowGQLErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { STAFF, RESIDENT, SERVICE } = require('@condo/domains/user/constants/common')
const {
    registerNewUser,
    generateSudoTokenByTestClient,
    makeClientWithStaffUser,
    updateTestUser,
    User,
    ConfirmPhoneAction,
    ConfirmEmailAction,
    UserSudoToken,
    authenticateUserWithPhoneAndPasswordByTestClient,
    createTestConfirmPhoneAction,
    createTestConfirmEmailAction,
    createTestPhone,
} = require('@condo/domains/user/utils/testSchema')
const { detectTokenType, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


const TOKEN_LIFETIME_IN_MS = 15 * 60 * 1000
const MAX_NUMBER_OF_TOKEN_USES = 1
const REQUESTS_LIMIT = 10

function getCaptcha () {
    return faker.random.alphaNumeric(32)
}

describe('GenerateSudoTokenService', () => {
    let adminClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
    })

    describe('Accesses', () => {
        test('Can execute authorized user', async () => {
            const staffClient = await makeClientWithStaffUser()
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })
            expect(sudoToken).toBeDefined()
            expect(sudoToken.token).toBeDefined()
            expect(detectTokenType(sudoToken.token)).toBe(TOKEN_TYPES.SUDO)
        })

        test('Cannot execute soft-deleted user', async () => {
            const staffClient = await makeClientWithStaffUser()
            await User.softDelete(adminClient, staffClient.user.id)

            await expectToThrowAccessDeniedErrorToResult(async () => {
                await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })
            })
        })

        test('Can execute anonymous', async () => {
            const anonymous = await makeClient()
            const [, userAttrs] = await registerNewUser(await makeClient())
            const [sudoToken] = await generateSudoTokenByTestClient(anonymous, {
                captcha: getCaptcha(),
                user: { phone: userAttrs.phone, userType: STAFF },
                authFactors: { password: userAttrs.password },
            })
            expect(sudoToken).toBeDefined()
            expect(sudoToken.token).toBeDefined()
            expect(detectTokenType(sudoToken.token)).toBe(TOKEN_TYPES.SUDO)
        })
    })

    describe('Basic logic', () => {
        test('should throw error if dv and sender not valid', async () => {
            const staffClient = await makeClientWithStaffUser()
            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                    dv: 123,
                })
            }, {
                mutation: 'generateSudoToken',
                variable: ['data', 'dv'],
                code: 'BAD_USER_INPUT',
                type: 'DV_VERSION_MISMATCH',
                message: 'Wrong value for data version number',
            })
            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                    sender: { dv: 1, fingerprint: '-' },
                })
            }, {
                mutation: 'generateSudoToken',
                variable: ['data', 'sender'],
                code: 'BAD_USER_INPUT',
                type: 'WRONG_FORMAT',
                message: 'Invalid format of "sender" field value. Please, check the example for details',
                correctExample: '{ "dv": 1, "fingerprint": "uniq-device-or-container-id" }',
            })
        })

        test('should throw error if phone and email empty', async () => {
            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(await makeClient(), {
                    captcha: getCaptcha(),
                    user: { userType: STAFF },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                mutation: 'generateSudoToken',
                code: 'BAD_USER_INPUT',
                type: 'CREDENTIAL_VALIDATION_FAILED',
                message: 'User credentials validation failed',
                messageForUser: 'api.user.CREDENTIAL_VALIDATION_FAILED',
            })
        })

        test('should throw error if validation failed', async () => {
            const staffClient = await makeClientWithStaffUser()

            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password + faker.random.alphaNumeric(4) },
                })
            }, {
                mutation: 'generateSudoToken',
                code: 'BAD_USER_INPUT',
                type: 'CREDENTIAL_VALIDATION_FAILED',
                message: 'User credentials validation failed',
                messageForUser: 'api.user.CREDENTIAL_VALIDATION_FAILED',
            })
        })

        test('should throw error if validation successful, but authed user not equal validation user', async () => {
            const staffClient = await makeClientWithStaffUser()
            const staffClient2 = await makeClientWithStaffUser()

            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient2.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient2.userAttrs.password },
                })
            }, {
                mutation: 'generateSudoToken',
                code: 'BAD_USER_INPUT',
                type: 'CREDENTIAL_VALIDATION_FAILED',
                message: 'User credentials validation failed',
                messageForUser: 'api.user.CREDENTIAL_VALIDATION_FAILED',
            })
        })

        // NOTE: All possible cases with validation are checked in tests for the function "validateUserCredentials"
        describe('should create valid sudo token if validation successful', () => {
            test('by authed user with password', async () => {
                const staffClient = await makeClientWithStaffUser()
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })
                expect(sudoToken).toBeDefined()
                expect(sudoToken.token).toBeDefined()
                expect(detectTokenType(sudoToken.token)).toBe(TOKEN_TYPES.SUDO)

                const createdSudoToken = await UserSudoToken.getOne(adminClient, { token: sudoToken.token })
                expect(createdSudoToken).toBeDefined()
                expect(dayjs().diff(createdSudoToken.expiresAt) < TOKEN_LIFETIME_IN_MS).toBeTruthy()
                expect(createdSudoToken.user.id).toBe(staffClient.user.id)
                expect(createdSudoToken.remainingUses).toBe(MAX_NUMBER_OF_TOKEN_USES)
            })

            test('by authed user with confirmPhoneAction', async () => {
                const staffClient = await makeClientWithStaffUser()

                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                    phone: staffClient.userAttrs.phone, isPhoneVerified: true,
                })

                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { confirmPhoneToken: confirmPhoneAction.token },
                })
                expect(sudoToken).toBeDefined()
                expect(sudoToken.token).toBeDefined()
                expect(detectTokenType(sudoToken.token)).toBe(TOKEN_TYPES.SUDO)

                const createdSudoToken = await UserSudoToken.getOne(adminClient, { token: sudoToken.token })
                expect(createdSudoToken).toBeDefined()
                expect(dayjs().diff(createdSudoToken.expiresAt) < TOKEN_LIFETIME_IN_MS).toBeTruthy()
                expect(createdSudoToken.user.id).toBe(staffClient.user.id)
                expect(createdSudoToken.remainingUses).toBe(MAX_NUMBER_OF_TOKEN_USES)
            })

            test('by authed user with confirmEmailAction', async () => {
                const staffClient = await makeClientWithStaffUser({ isEmailVerified: true })

                const [confirmEmailAction] = await createTestConfirmEmailAction(adminClient, {
                    email: staffClient.userAttrs.email, isEmailVerified: true,
                })

                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { email: staffClient.userAttrs.email, userType: STAFF },
                    authFactors: { confirmEmailToken: confirmEmailAction.token },
                })
                expect(sudoToken).toBeDefined()
                expect(sudoToken.token).toBeDefined()
                expect(detectTokenType(sudoToken.token)).toBe(TOKEN_TYPES.SUDO)

                const createdSudoToken = await UserSudoToken.getOne(adminClient, { token: sudoToken.token })
                expect(createdSudoToken).toBeDefined()
                expect(dayjs().diff(createdSudoToken.expiresAt) < TOKEN_LIFETIME_IN_MS).toBeTruthy()
                expect(createdSudoToken.user.id).toBe(staffClient.user.id)
                expect(createdSudoToken.remainingUses).toBe(MAX_NUMBER_OF_TOKEN_USES)
            })

            test('by anonymous with password', async () => {
                const anonymous = await makeClient()
                const [registeredUser, userAttrs] = await registerNewUser(await makeClient())

                const [sudoToken] = await generateSudoTokenByTestClient(anonymous, {
                    captcha: getCaptcha(),
                    user: { phone: userAttrs.phone, userType: STAFF },
                    authFactors: { password: userAttrs.password },
                })
                expect(sudoToken).toBeDefined()
                expect(sudoToken.token).toBeDefined()
                expect(detectTokenType(sudoToken.token)).toBe(TOKEN_TYPES.SUDO)

                const createdSudoToken = await UserSudoToken.getOne(adminClient, { token: sudoToken.token })
                expect(createdSudoToken).toBeDefined()
                expect(dayjs().diff(createdSudoToken.expiresAt) < TOKEN_LIFETIME_IN_MS).toBeTruthy()
                expect(createdSudoToken.user.id).toBe(registeredUser.id)
                expect(createdSudoToken.remainingUses).toBe(MAX_NUMBER_OF_TOKEN_USES)
            })
        })

        test('should complete confirmPhoneAction if validation successful by confirmPhoneAction', async () => {
            const staffClient = await makeClientWithStaffUser()

            const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                phone: staffClient.userAttrs.phone, isPhoneVerified: true,
            })

            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { confirmPhoneToken: confirmPhoneAction.token },
            })
            expect(sudoToken).toBeDefined()
            expect(sudoToken.token).toBeDefined()
            expect(detectTokenType(sudoToken.token)).toBe(TOKEN_TYPES.SUDO)

            const completedConfirmPhoneAction = await ConfirmPhoneAction.getOne(adminClient, { token: confirmPhoneAction.token })
            expect(completedConfirmPhoneAction).toBeDefined()
            expect(completedConfirmPhoneAction.completedAt).not.toBeNull()
        })

        test('should complete confirmEmailAction if validation successful by confirmEmailAction', async () => {
            const staffClient = await makeClientWithStaffUser({ isEmailVerified: true })

            const [confirmEmailAction] = await createTestConfirmEmailAction(adminClient, {
                email: staffClient.userAttrs.email, isEmailVerified: true,
            })

            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { email: staffClient.userAttrs.email, userType: STAFF },
                authFactors: { confirmEmailToken: confirmEmailAction.token },
            })
            expect(sudoToken).toBeDefined()
            expect(sudoToken.token).toBeDefined()
            expect(detectTokenType(sudoToken.token)).toBe(TOKEN_TYPES.SUDO)

            const completedConfirmEmailAction = await ConfirmEmailAction.getOne(adminClient, { token: confirmEmailAction.token })
            expect(completedConfirmEmailAction).toBeDefined()
            expect(completedConfirmEmailAction.completedAt).not.toBeNull()
        })
    })

    describe('Request limit', () => {
        async function expectToThrowErrorCredentialValidationFailed (callback) {
            await expectToThrowGQLErrorToResult(async () => {
                await callback()
            }, {
                mutation: 'generateSudoToken',
                code: 'BAD_USER_INPUT',
                type: 'CREDENTIAL_VALIDATION_FAILED',
                message: 'User credentials validation failed',
                messageForUser: 'api.user.CREDENTIAL_VALIDATION_FAILED',
            })
        }

        test(`should throw error if more than ${REQUESTS_LIMIT} requests are sent by ip per hours`, async () => {
            const anonymous = await makeClient()

            for (let i = 0; i < REQUESTS_LIMIT; i++) {
                await expectToThrowErrorCredentialValidationFailed(async () => {
                    await generateSudoTokenByTestClient(anonymous, {
                        captcha: getCaptcha(),
                        user: { phone: createTestPhone(), userType: STAFF },
                        authFactors: { password: faker.random.alphaNumeric(12) },
                    })
                })
            }

            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(anonymous, {
                    captcha: getCaptcha(),
                    user: { phone: createTestPhone(), userType: STAFF },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })
        })

        test(`should throw error if more than ${REQUESTS_LIMIT} requests are sent by authed user per hours`, async () => {
            const staffClient = await makeClientWithStaffUser()

            for (let i = 0; i < REQUESTS_LIMIT; i++) {
                const client = await makeClient()
                await authenticateUserWithPhoneAndPasswordByTestClient(client, {
                    phone: staffClient.userAttrs.phone,
                    password: staffClient.userAttrs.password,
                })
                await expectToThrowErrorCredentialValidationFailed(async () => {
                    await generateSudoTokenByTestClient(client, {
                        captcha: getCaptcha(),
                        user: { phone: createTestPhone(), userType: STAFF },
                        authFactors: { password: faker.random.alphaNumeric(12) },
                    })
                })
            }

            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: createTestPhone(), userType: STAFF },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })
        })

        test(`should throw error if more than ${REQUESTS_LIMIT} requests are sent by phone + userType per hours`, async () => {
            const [registeredResidentUser, residentUserAttrs] = await registerNewUser(await makeClient())
            await updateTestUser(adminClient, registeredResidentUser.id, { type: RESIDENT })
            const phone = residentUserAttrs.phone
            const [registeredServiceUser] = await registerNewUser(await makeClient(), {
                phone,
                email: residentUserAttrs.email,
            })
            await updateTestUser(adminClient, registeredServiceUser.id, { type: SERVICE })
            await registerNewUser(await makeClient(), {
                phone,
                email: residentUserAttrs.email,
            })

            for (let i = 0; i < REQUESTS_LIMIT; i++) {
                const anonymous = await makeClient()
                await expectToThrowErrorCredentialValidationFailed(async () => {
                    await generateSudoTokenByTestClient(anonymous, {
                        captcha: getCaptcha(),
                        user: { phone, userType: STAFF },
                        authFactors: { password: faker.random.alphaNumeric(12) },
                    })
                })
                await expectToThrowErrorCredentialValidationFailed(async () => {
                    await generateSudoTokenByTestClient(anonymous, {
                        captcha: getCaptcha(),
                        user: { phone, userType: RESIDENT },
                        authFactors: { password: faker.random.alphaNumeric(12) },
                    })
                })
                await expectToThrowErrorCredentialValidationFailed(async () => {
                    await generateSudoTokenByTestClient(anonymous, {
                        captcha: getCaptcha(),
                        user: { phone, userType: SERVICE },
                        authFactors: { password: faker.random.alphaNumeric(12) },
                    })
                })
            }

            const anonymous = await makeClient()
            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(anonymous, {
                    captcha: getCaptcha(),
                    user: { phone, userType: STAFF },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })

            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(anonymous, {
                    captcha: getCaptcha(),
                    user: { phone, userType: RESIDENT },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })

            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(anonymous, {
                    captcha: getCaptcha(),
                    user: { phone, userType: SERVICE },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })
        })

        test(`should throw error if more than ${REQUESTS_LIMIT} requests are sent by email + userType per hours`, async () => {
            const [registeredResidentUser, residentUserAttrs] = await registerNewUser(await makeClient())
            await updateTestUser(adminClient, registeredResidentUser.id, { type: RESIDENT })
            const email = residentUserAttrs.email
            const [registeredServiceUser] = await registerNewUser(await makeClient(), {
                phone: residentUserAttrs.phone,
                email,
            })
            await updateTestUser(adminClient, registeredServiceUser.id, { type: SERVICE })
            await registerNewUser(await makeClient(), {
                phone: residentUserAttrs.phone,
                email,
            })

            for (let i = 0; i < REQUESTS_LIMIT; i++) {
                const anonymous = await makeClient()
                await expectToThrowErrorCredentialValidationFailed(async () => {
                    await generateSudoTokenByTestClient(anonymous, {
                        captcha: getCaptcha(),
                        user: { email, userType: STAFF },
                        authFactors: { password: faker.random.alphaNumeric(12) },
                    })
                })
                await expectToThrowErrorCredentialValidationFailed(async () => {
                    await generateSudoTokenByTestClient(anonymous, {
                        captcha: getCaptcha(),
                        user: { email, userType: RESIDENT },
                        authFactors: { password: faker.random.alphaNumeric(12) },
                    })
                })
                await expectToThrowErrorCredentialValidationFailed(async () => {
                    await generateSudoTokenByTestClient(anonymous, {
                        captcha: getCaptcha(),
                        user: { email, userType: SERVICE },
                        authFactors: { password: faker.random.alphaNumeric(12) },
                    })
                })
            }

            const anonymous = await makeClient()
            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(anonymous, {
                    captcha: getCaptcha(),
                    user: { email, userType: STAFF },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })

            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(anonymous, {
                    captcha: getCaptcha(),
                    user: { email, userType: RESIDENT },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })

            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(anonymous, {
                    captcha: getCaptcha(),
                    user: { email, userType: SERVICE },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
                message: 'You have to wait {minutesRemaining} min. to be able to send request again',
            })
        })

        // NOTE: should increase all guards in request
        test(`should block ip, (phone + userType), (email + userType) and user if more then ${REQUESTS_LIMIT} requests are sent by ip, (phone + userType) and (email + userType) by authed user per hours`, async () => {
            const staffClient = await makeClientWithStaffUser()
            const phone = createTestPhone()
            const email = faker.internet.email()

            for (let i = 0; i < REQUESTS_LIMIT; i++) {
                await expectToThrowErrorCredentialValidationFailed(async () => {
                    await generateSudoTokenByTestClient(staffClient, {
                        captcha: getCaptcha(),
                        user: { phone, email, userType: STAFF },
                        authFactors: { password: faker.random.alphaNumeric(12) },
                    })
                })
            }

            // throw by email
            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(await makeClient(), {
                    captcha: getCaptcha(),
                    user: { email, userType: STAFF },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
            })

            // throw by phone
            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(await makeClient(), {
                    captcha: getCaptcha(),
                    user: { phone, userType: STAFF },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
            })

            // throw by user
            const staffClient2 = await makeClient()
            await authenticateUserWithPhoneAndPasswordByTestClient(staffClient2, {
                phone: staffClient.userAttrs.phone,
                password: staffClient.userAttrs.password,
            })
            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(staffClient2, {
                    captcha: getCaptcha(),
                    user: { phone: createTestPhone(), userType: STAFF },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
            })

            // throw by ip
            await staffClient.mutate(gql`
                mutation unauthenticateUser {
                    obj: unauthenticateUser {
                        success
                    }
                }
            `)
            await expectToThrowGQLErrorToResult(async () => {
                await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: createTestPhone(), userType: STAFF },
                    authFactors: { password: faker.random.alphaNumeric(12) },
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOO_MANY_REQUESTS',
            })
        })
    })
})
