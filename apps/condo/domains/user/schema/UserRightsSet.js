/**
 * Generated by `createschema user.UserRightsSet 'name:Text'`
 */

const chunk = require('lodash/chunk')
const get = require('lodash/get')

const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')
const { find } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/user/access/UserRightsSet')
const { DIRECT_ACCESS_AVAILABLE_SCHEMAS } = require('@condo/domains/user/utils/directAccess/config')
const { generateRightSetFields } = require('@condo/domains/user/utils/directAccess/server.utils')
const { User } = require('@condo/domains/user/utils/serverSchema')

const USER_UPDATE_CHUNK_SIZE = 100

const UserRightsSet = new GQLListSchema('UserRightsSet', {
    schemaDoc:
        'A set of rights that allows one user or a group of users ' +
        'to gain direct access to objects of a particular schema and to perform certain mutations',
    fields: {
        name: {
            schemaDoc:
                'A name that distinguishes this group of rights from others ' +
                'and describes the set of rights that users of this group receive. ' +
                'For example: "Full access to mini-applications", "Level 1 Support", "Read all organizations", etc',
            type: 'Text',
            isRequired: true,
        },
        ...generateRightSetFields(DIRECT_ACCESS_AVAILABLE_SCHEMAS),
    },
    hooks: {
        beforeChange: async ({ resolvedData, existingItem, context }) => {
            const isSoftDelete = Boolean(resolvedData['deletedAt'])
            const itemId = get(existingItem, 'id', resolvedData['id'])
            const sender = resolvedData.sender

            if (isSoftDelete) {
                // Basically implementing SET_NULL policy, to keep consistent behaviour (see Read/User test)
                // NOTE 1: it's important to SET_NULL this field, since in access checks we get flat user record
                // (similar as find/getByConditions returns), so there's no softDeleted filter in it.
                // NOTE 2: Yes, we're checking deletedAt in direct accesses, but the presence of a field "rightsSet" in user record
                // is our sign to check it (do a sub-query).
                // That's why we're clearing this fields now once to avoid extra sub-queries later.
                const relatedUsers = await find('User', { rightsSet: { id: itemId } })
                const updateData = relatedUsers.map(user => ({
                    id: user.id,
                    data: {
                        dv: 1,
                        sender,
                        rightsSet: { disconnectAll: true },
                    },
                }))
                const usersChunks = chunk(updateData, USER_UPDATE_CHUNK_SIZE)
                for (const usersChunk of usersChunks) {
                    await User.updateMany(context, usersChunk)
                }
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), analytical()],
    access: {
        read: access.canReadUserRightsSets,
        create: access.canManageUserRightsSets,
        update: access.canManageUserRightsSets,
        delete: false,
        auth: true,
    },
})

module.exports = {
    UserRightsSet,
}
