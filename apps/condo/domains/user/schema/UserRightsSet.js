/**
 * Generated by `createschema user.UserRightsSet 'name:Text'`
 */

const chunk = require('lodash/chunk')
const get = require('lodash/get')

const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')
const { find } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/user/access/UserRightsSet')
const { DIRECT_ACCESS_AVAILABLE_SCHEMAS } = require('@condo/domains/user/constants/access')
const { generateRightSetFields } = require('@condo/domains/user/utils/directAccess')
const { User } = require('@condo/domains/user/utils/serverSchema')

const USER_UPDATE_CHUNK_SIZE = 100

const UserRightsSet = new GQLListSchema('UserRightsSet', {
    schemaDoc:
        'A set of rights that allows one user or a group of users ' +
        'to gain direct access to objects of a particular schema and to perform certain mutations',
    fields: {
        name: {
            schemaDoc:
                'A name that distinguishes this group of rights from others ' +
                'and describes the set of rights that users of this group receive. ' +
                'For example: "Full access to mini-applications", "Level 1 Support", "Read all organizations", etc',
            type: 'Text',
            isRequired: true,
        },
        ...generateRightSetFields(DIRECT_ACCESS_AVAILABLE_SCHEMAS),
    },
    hooks: {
        beforeChange: async ({ resolvedData, existingItem, context }) => {
            const isSoftDelete = Boolean(resolvedData['deletedAt'])
            const itemId = get(existingItem, 'id', resolvedData['id'])

            if (isSoftDelete) {
                // Basically implementing SET_NULL policy, to keep consistent behaviour (see Read/User test)
                const relatedUsers = await find('User', { rightsSet: { id: itemId } })
                const updateData = relatedUsers.map(user => ({ id: user.id, data: { rightsSet: { disconnectAll: true } } }))
                const usersChunks = chunk(updateData, USER_UPDATE_CHUNK_SIZE)
                for (const usersChunk of usersChunks) {
                    await User.updateMany(context, usersChunk)
                }
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadUserRightsSets,
        create: access.canManageUserRightsSets,
        update: access.canManageUserRightsSets,
        delete: false,
        auth: true,
    },
})

module.exports = {
    UserRightsSet,
}
