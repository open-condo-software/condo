/**
 * Generated by `createschema user.ResetUserLimitAction 'type:Select:auth;identifier:Text;reason:Text'`
 */
const { faker } = require('@faker-js/faker')

const { makeLoggedInAdminClient, makeClient, expectToThrowGQLError } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { AUTH_COUNTER_LIMIT_TYPE } = require('@condo/domains/user/constants/limits')
const { ERRORS } = require('@condo/domains/user/schema/ResetUserLimitAction')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')
const {
    ResetUserLimitAction,
    createTestResetUserLimitAction,
    updateTestResetUserLimitAction,
    createTestPhone,
    makeClientWithSupportUser,
    makeClientWithNewRegisteredAndLoggedInUser,
} = require('@condo/domains/user/utils/testSchema')


const redisGuard = new RedisGuard()
const COUNTER_VALUE_TO_UPDATE = 2

describe('ResetUserLimitAction', () => {
    let admin, support, userWithoutDirectAccess, userWithDirectAccess, anonymous, phone

    beforeAll(async () => {
        anonymous = await makeClient()
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        userWithoutDirectAccess = await makeClientWithNewRegisteredAndLoggedInUser()
        userWithDirectAccess = await makeClientWithNewRegisteredAndLoggedInUser({
            rightsSet: {
                create: {
                    name: faker.lorem.words(3),
                    dv: 1,
                    sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    canReadResetUserLimitActions: true,
                    canManageResetUserLimitActions: true,
                },
            },
        })
    })

    beforeEach(async () => {
        phone = createTestPhone()
        const key = `${AUTH_COUNTER_LIMIT_TYPE}:${phone}`

        for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
            await redisGuard.incrementDayCounter(key)
        }
        const value = await redisGuard.getCounterValue(key)

        expect(Number(value)).toEqual(COUNTER_VALUE_TO_UPDATE)
    })

    describe('Access', () => {
        describe('Create', () => {
            test('admin: can create', async () => {
                const [obj] = await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, phone)

                expect(obj.id).toBeDefined()
            })

            test('support: can create', async () => {
                const [obj] = await createTestResetUserLimitAction(support, AUTH_COUNTER_LIMIT_TYPE, phone)

                expect(obj.id).toBeDefined()
            })

            test('user: can create with access right (canManageResetUserLimitActions)', async () => {
                const [obj] = await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, phone)

                expect(obj.id).toBeDefined()
            })

            test('user: can not create without access right (canManageResetUserLimitActions)', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestResetUserLimitAction(userWithoutDirectAccess, AUTH_COUNTER_LIMIT_TYPE, phone)
                })
            })

            test('anonymous: can not execute', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestResetUserLimitAction(anonymous, AUTH_COUNTER_LIMIT_TYPE, phone)
                })
            })
        })

        describe('Read', () => {
            let resetUserLimitActionToRead

            beforeAll(async () => {
                const phone = createTestPhone()
                await redisGuard.incrementDayCounter(`${AUTH_COUNTER_LIMIT_TYPE}:${phone}`)

                const [createdResetUserLimitAction] = await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, phone)
                resetUserLimitActionToRead = createdResetUserLimitAction
            })

            test('admin: can read', async () => {
                const obj = await ResetUserLimitAction.getOne(admin, { id: resetUserLimitActionToRead.id })

                expect(obj.id).toBeDefined()
            })

            test('support: can read', async () => {
                const obj = await ResetUserLimitAction.getOne(support, { id: resetUserLimitActionToRead.id })

                expect(obj.id).toBeDefined()
            })

            test('user: can read with access right (canReadResetUserLimitActions)', async () => {
                const obj = await ResetUserLimitAction.getOne(userWithDirectAccess, { id: resetUserLimitActionToRead.id })

                expect(obj.id).toBeDefined()
            })

            test('user: can not read without access right (canReadResetUserLimitActions)', async () => {
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await ResetUserLimitAction.getOne(userWithoutDirectAccess, { id: resetUserLimitActionToRead.id })
                })
            })

            test('anonymous: can not read', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestResetUserLimitAction(anonymous, AUTH_COUNTER_LIMIT_TYPE, phone)
                })
            })
        })

        describe('Update', () => {
            let resetUserLimitActionToUpdate

            beforeEach(async () => {
                const phone = createTestPhone()
                await redisGuard.incrementDayCounter(`${AUTH_COUNTER_LIMIT_TYPE}:${phone}`)

                const [createdResetUserLimitAction] = await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, phone)
                resetUserLimitActionToUpdate = createdResetUserLimitAction
            })

            test('admin: can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(admin, resetUserLimitActionToUpdate.id, {})
                })
            })

            test('support: can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(support, resetUserLimitActionToUpdate.id, {})
                })
            })

            test('user with access right (canManageResetUserLimitActions): can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(userWithDirectAccess, resetUserLimitActionToUpdate.id, {})
                })
            })

            test('user without access right (canManageResetUserLimitActions): can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(userWithoutDirectAccess, resetUserLimitActionToUpdate.id, {})
                })
            })

            test('anonymous: can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(anonymous, resetUserLimitActionToUpdate.id, {})
                })
            })
        })

        describe('Delete', () => {
            let resetUserLimitActionToDelete

            beforeEach(async () => {
                const phone = createTestPhone()
                await redisGuard.incrementDayCounter(`${AUTH_COUNTER_LIMIT_TYPE}:${phone}`)

                const [createdResetUserLimitAction] = await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, phone)
                resetUserLimitActionToDelete = createdResetUserLimitAction
            })

            test('admin: can not delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(admin, resetUserLimitActionToDelete.id)
                })
            })

            test('support: can not delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(support, resetUserLimitActionToDelete.id)
                })
            })

            test('user with access right (canManageResetUserLimitActions): can not delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(userWithDirectAccess, resetUserLimitActionToDelete.id)
                })
            })

            test('user without access right (canManageResetUserLimitActions): can not delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(userWithoutDirectAccess, resetUserLimitActionToDelete.id)
                })
            })

            test('anonymous: can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(anonymous, resetUserLimitActionToDelete.id)
                })
            })
        })
    })

    describe('Logic', () => {
        describe('Common', () => {
            test('throws error if key is not exists', async () => {
                const phone = createTestPhone()

                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, phone)
                }, ERRORS.KEY_NOT_FOUND)
            })
        })

        describe(`${AUTH_COUNTER_LIMIT_TYPE} type`, () => {
            test('reset counter by phone number', async () => {
                const key = `${AUTH_COUNTER_LIMIT_TYPE}:${phone}`

                await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, phone)
                const value = await redisGuard.getCounterValue(key)

                expect(value).toBeNull()
            })

            test('reset counter by ip', async () => {
                const ip = faker.internet.ipv4()
                const key = `${AUTH_COUNTER_LIMIT_TYPE}:${ip}`

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(key)
                }
                const beforeReset = await redisGuard.getCounterValue(key)

                expect(Number(beforeReset)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, ip)
                const afterReset = await redisGuard.getCounterValue(key)

                expect(afterReset).toBeNull()
            })

            test('throws error if key is not valid ip or phone', async () => {
                const key = faker.random.alphaNumeric(8)
                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(key)
                }
                const beforeReset = await redisGuard.getCounterValue(key)

                expect(Number(beforeReset)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, key)
                }, ERRORS.INVALID_IDENTIFIER)
            })
        })
    })
})