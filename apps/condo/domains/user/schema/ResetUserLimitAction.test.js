/**
 * Generated by `createschema user.ResetUserLimitAction 'type:Select:auth;identifier:Text;reason:Text'`
 */
const { faker } = require('@faker-js/faker')

const { getKVClient } = require('@open-condo/keystone/kv')
const { ApolloRateLimitingPlugin } = require('@open-condo/keystone/rateLimiting')
const { makeLoggedInAdminClient, makeClient, expectToThrowGQLError } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { USER_TYPES } = require('@condo/domains/user/constants/common')
const {
    SMS_COUNTER_LIMIT_TYPE,
    RATE_LIMIT_TYPE,
    FIND_ORGANIZATION_BY_TIN_TYPE,
    AUTH_COUNTER_LIMIT_TYPE,
} = require('@condo/domains/user/constants/limits')
const { ERRORS } = require('@condo/domains/user/schema/ResetUserLimitAction')
const { buildQuotaKey: buildAuthQuotaKey, buildQuotaKeyByUserType: buildAuthQuotaKeyByUserType } = require('@condo/domains/user/utils/serverSchema/auth')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')
const {
    ResetUserLimitAction,
    createTestResetUserLimitAction,
    updateTestResetUserLimitAction,
    createTestPhone,
    createTestEmail,
    makeClientWithSupportUser,
    makeClientWithNewRegisteredAndLoggedInUser,
} = require('@condo/domains/user/utils/testSchema')


const redisGuard = new RedisGuard()
const COUNTER_VALUE_TO_UPDATE = 2

describe('ResetUserLimitAction', () => {
    let admin, support, userWithoutDirectAccess, userWithDirectAccess, anonymous, phone

    beforeAll(async () => {
        anonymous = await makeClient()
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        userWithoutDirectAccess = await makeClientWithNewRegisteredAndLoggedInUser()
        userWithDirectAccess = await makeClientWithNewRegisteredAndLoggedInUser({
            rightsSet: {
                create: {
                    name: faker.lorem.words(3),
                    dv: 1,
                    sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
                    canReadResetUserLimitActions: true,
                    canManageResetUserLimitActions: true,
                },
            },
        })
    })

    beforeEach(async () => {
        phone = createTestPhone()
        const key = `${SMS_COUNTER_LIMIT_TYPE}:${phone}`

        for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
            await redisGuard.incrementDayCounter(key)
        }
        const value = await redisGuard.getCounterValue(key)

        expect(Number(value)).toEqual(COUNTER_VALUE_TO_UPDATE)
    })

    describe('Access', () => {
        describe('Create', () => {
            test('admin: can create', async () => {
                const [obj] = await createTestResetUserLimitAction(admin, SMS_COUNTER_LIMIT_TYPE, phone)

                expect(obj.id).toBeDefined()
            })

            test('support: can create', async () => {
                const [obj] = await createTestResetUserLimitAction(support, SMS_COUNTER_LIMIT_TYPE, phone)

                expect(obj.id).toBeDefined()
            })

            test('user: can create with access right (canManageResetUserLimitActions)', async () => {
                const [obj] = await createTestResetUserLimitAction(userWithDirectAccess, SMS_COUNTER_LIMIT_TYPE, phone)

                expect(obj.id).toBeDefined()
            })

            test('user: can not create without access right (canManageResetUserLimitActions)', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestResetUserLimitAction(userWithoutDirectAccess, SMS_COUNTER_LIMIT_TYPE, phone)
                })
            })

            test('anonymous: can not execute', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestResetUserLimitAction(anonymous, SMS_COUNTER_LIMIT_TYPE, phone)
                })
            })
        })

        describe('Read', () => {
            let resetUserLimitActionToRead

            beforeAll(async () => {
                const phone = createTestPhone()
                await redisGuard.incrementDayCounter(`${SMS_COUNTER_LIMIT_TYPE}:${phone}`)

                const [createdResetUserLimitAction] = await createTestResetUserLimitAction(admin, SMS_COUNTER_LIMIT_TYPE, phone)
                resetUserLimitActionToRead = createdResetUserLimitAction
            })

            test('admin: can read', async () => {
                const obj = await ResetUserLimitAction.getOne(admin, { id: resetUserLimitActionToRead.id })

                expect(obj.id).toBeDefined()
            })

            test('support: can read', async () => {
                const obj = await ResetUserLimitAction.getOne(support, { id: resetUserLimitActionToRead.id })

                expect(obj.id).toBeDefined()
            })

            test('user: can read with access right (canReadResetUserLimitActions)', async () => {
                const obj = await ResetUserLimitAction.getOne(userWithDirectAccess, { id: resetUserLimitActionToRead.id })

                expect(obj.id).toBeDefined()
            })

            test('user: can not read without access right (canReadResetUserLimitActions)', async () => {
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await ResetUserLimitAction.getOne(userWithoutDirectAccess, { id: resetUserLimitActionToRead.id })
                })
            })

            test('anonymous: can not read', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestResetUserLimitAction(anonymous, SMS_COUNTER_LIMIT_TYPE, phone)
                })
            })
        })

        describe('Update', () => {
            let resetUserLimitActionToUpdate

            beforeEach(async () => {
                const phone = createTestPhone()
                await redisGuard.incrementDayCounter(`${SMS_COUNTER_LIMIT_TYPE}:${phone}`)

                const [createdResetUserLimitAction] = await createTestResetUserLimitAction(admin, SMS_COUNTER_LIMIT_TYPE, phone)
                resetUserLimitActionToUpdate = createdResetUserLimitAction
            })

            test('admin: can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(admin, resetUserLimitActionToUpdate.id, {})
                })
            })

            test('support: can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(support, resetUserLimitActionToUpdate.id, {})
                })
            })

            test('user with access right (canManageResetUserLimitActions): can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(userWithDirectAccess, resetUserLimitActionToUpdate.id, {})
                })
            })

            test('user without access right (canManageResetUserLimitActions): can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(userWithoutDirectAccess, resetUserLimitActionToUpdate.id, {})
                })
            })

            test('anonymous: can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestResetUserLimitAction(anonymous, resetUserLimitActionToUpdate.id, {})
                })
            })
        })

        describe('Delete', () => {
            let resetUserLimitActionToDelete

            beforeEach(async () => {
                const phone = createTestPhone()
                await redisGuard.incrementDayCounter(`${SMS_COUNTER_LIMIT_TYPE}:${phone}`)

                const [createdResetUserLimitAction] = await createTestResetUserLimitAction(admin, SMS_COUNTER_LIMIT_TYPE, phone)
                resetUserLimitActionToDelete = createdResetUserLimitAction
            })

            test('admin: can not delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(admin, resetUserLimitActionToDelete.id)
                })
            })

            test('support: can not delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(support, resetUserLimitActionToDelete.id)
                })
            })

            test('user with access right (canManageResetUserLimitActions): can not delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(userWithDirectAccess, resetUserLimitActionToDelete.id)
                })
            })

            test('user without access right (canManageResetUserLimitActions): can not delete', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(userWithoutDirectAccess, resetUserLimitActionToDelete.id)
                })
            })

            test('anonymous: can not update', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await ResetUserLimitAction.delete(anonymous, resetUserLimitActionToDelete.id)
                })
            })
        })
    })

    describe('Logic', () => {
        describe(`${SMS_COUNTER_LIMIT_TYPE} type`, () => {
            test('throws error if key is not exists', async () => {
                const phone = createTestPhone()

                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, SMS_COUNTER_LIMIT_TYPE, phone)
                }, ERRORS.KEY_NOT_FOUND)
            })

            test('throws error if key is not valid ip or phone', async () => {
                const key = faker.random.alphaNumeric(8)
                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(key)
                }
                const beforeReset = await redisGuard.getCounterValue(key)

                expect(Number(beforeReset)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(userWithDirectAccess, SMS_COUNTER_LIMIT_TYPE, key)
                }, ERRORS.INVALID_IDENTIFIER)
            })

            test('resets counter by phone number', async () => {
                const key = `${SMS_COUNTER_LIMIT_TYPE}:${phone}`

                await createTestResetUserLimitAction(userWithDirectAccess, SMS_COUNTER_LIMIT_TYPE, phone)
                const value = await redisGuard.getCounterValue(key)

                expect(value).toBeNull()
            })

            test('resets counter by ip', async () => {
                const ip = faker.internet.ipv4()
                const key = `${SMS_COUNTER_LIMIT_TYPE}:${ip}`

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(key)
                }
                const beforeReset = await redisGuard.getCounterValue(key)

                expect(Number(beforeReset)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await createTestResetUserLimitAction(userWithDirectAccess, SMS_COUNTER_LIMIT_TYPE, ip)
                const afterReset = await redisGuard.getCounterValue(key)

                expect(afterReset).toBeNull()
            })
        })

        describe(`${RATE_LIMIT_TYPE} type`, () => {
            test('throws error if key is not exists', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, RATE_LIMIT_TYPE, faker.datatype.uuid())
                }, ERRORS.KEY_NOT_FOUND)
            })

            describe('throws error if key is not valid uuid or ip', () => {
                const cases = [
                    createTestPhone(),
                    faker.random.alphaNumeric(10),
                ]
                test.each(cases)('%p', async (key) => {
                    await expectToThrowGQLError(async () => {
                        await createTestResetUserLimitAction(userWithDirectAccess, RATE_LIMIT_TYPE, key)
                    }, ERRORS.INVALID_IDENTIFIER)
                })
            })

            const cases = [
                ['ip', 'ip', faker.internet.ipv4()],
                ['user id', 'user', faker.datatype.uuid()],
            ]

            test.each(cases)('resets rate-limit by %p', async (_, prefix, identifier) => {
                const key = ApolloRateLimitingPlugin.buildQuotaKey(prefix, identifier)

                const redis = getKVClient()
                const result = await redis.set(key, Math.floor(Math.random() * 10_000))
                expect(result).toEqual('OK')

                await createTestResetUserLimitAction(userWithDirectAccess, RATE_LIMIT_TYPE, identifier)
                const value = await redis.get(key)

                expect(value).toBeNull()
            })
        })

        describe(`${FIND_ORGANIZATION_BY_TIN_TYPE} type`, () => {
            test('throws error if key is not exists', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, FIND_ORGANIZATION_BY_TIN_TYPE, createTestPhone())
                }, ERRORS.KEY_NOT_FOUND)

                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, FIND_ORGANIZATION_BY_TIN_TYPE, createTestEmail())
                }, ERRORS.KEY_NOT_FOUND)

                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, FIND_ORGANIZATION_BY_TIN_TYPE, faker.datatype.uuid())
                }, ERRORS.KEY_NOT_FOUND)
            })

            describe('throws error if key is not valid uuid, phone or email', () => {
                const cases = [
                    faker.internet.ipv4(),
                    faker.random.alphaNumeric(10),
                ]
                test.each(cases)('%p', async (key) => {
                    await expectToThrowGQLError(async () => {
                        await createTestResetUserLimitAction(userWithDirectAccess, FIND_ORGANIZATION_BY_TIN_TYPE, key)
                    }, ERRORS.INVALID_IDENTIFIER)
                })
            })

            const cases = [
                ['phone', 'phone', createTestPhone()],
                ['email', 'email', createTestEmail()],
                ['user id', 'userId', faker.datatype.uuid()],
            ]

            test.each(cases)('resets counters by %p if daily and total counters exist', async (_, identifierKey, identifier) => {
                const dailyKey = `${FIND_ORGANIZATION_BY_TIN_TYPE}:${identifierKey}:${identifier}`
                const totalKey = `${FIND_ORGANIZATION_BY_TIN_TYPE}:total:${identifierKey}:${identifier}`

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(dailyKey)
                    await redisGuard.incrementDayCounter(totalKey)
                }
                const beforeResetDaily = await redisGuard.getCounterValue(dailyKey)
                const beforeResetTotal = await redisGuard.getCounterValue(totalKey)

                expect(Number(beforeResetDaily)).toEqual(COUNTER_VALUE_TO_UPDATE)
                expect(Number(beforeResetTotal)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await createTestResetUserLimitAction(userWithDirectAccess, FIND_ORGANIZATION_BY_TIN_TYPE, identifier)
                const afterResetDaily = await redisGuard.getCounterValue(dailyKey)
                const afterResetTotal = await redisGuard.getCounterValue(totalKey)

                expect(afterResetDaily).toBeNull()
                expect(afterResetTotal).toBeNull()
            })

            test.each(cases)('resets counter by %p if daily counter exist only', async (_, identifierKey, identifier) => {
                const dailyKey = `${FIND_ORGANIZATION_BY_TIN_TYPE}:${identifierKey}:${identifier}`

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(dailyKey)
                }
                const beforeResetDaily = await redisGuard.getCounterValue(dailyKey)

                expect(Number(beforeResetDaily)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await createTestResetUserLimitAction(userWithDirectAccess, FIND_ORGANIZATION_BY_TIN_TYPE, identifier)
                const afterResetDaily = await redisGuard.getCounterValue(dailyKey)

                expect(afterResetDaily).toBeNull()
            })

            test.each(cases)('resets counter by %p if total counter exist only', async (_, identifierKey, identifier) => {
                const totalKey = `${FIND_ORGANIZATION_BY_TIN_TYPE}:total:${identifierKey}:${identifier}`

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(totalKey)
                }
                const beforeResetTotal = await redisGuard.getCounterValue(totalKey)

                expect(Number(beforeResetTotal)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await createTestResetUserLimitAction(userWithDirectAccess, FIND_ORGANIZATION_BY_TIN_TYPE, identifier)
                const afterResetTotal = await redisGuard.getCounterValue(totalKey)

                expect(afterResetTotal).toBeNull()
            })
        })

        describe(`${AUTH_COUNTER_LIMIT_TYPE} type`, () => {
            test('throws error if key is not exists', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, faker.internet.ip())
                }, ERRORS.KEY_NOT_FOUND)

                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, faker.datatype.uuid())
                }, ERRORS.KEY_NOT_FOUND)

                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, createTestPhone())
                }, ERRORS.KEY_NOT_FOUND)

                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(admin, AUTH_COUNTER_LIMIT_TYPE, createTestEmail())
                }, ERRORS.KEY_NOT_FOUND)
            })

            test('throws error if key is not valid uuid, ip, email or phone', async () => {
                await expectToThrowGQLError(async () => {
                    await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, faker.random.alphaNumeric(10))
                }, ERRORS.INVALID_IDENTIFIER)
            })

            test('resets counters by ip', async () => {
                const ip = faker.internet.ipv4()
                const key = buildAuthQuotaKey('ip', ip)

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(key)
                }
                const beforeReset = await redisGuard.getCounterValue(key)

                expect(Number(beforeReset)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, ip)
                const afterReset = await redisGuard.getCounterValue(key)

                expect(afterReset).toBeNull()
            })

            test('resets counters by user id', async () => {
                const userId = faker.datatype.uuid()
                const key = buildAuthQuotaKey('user', userId)

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(key)
                }
                const beforeReset = await redisGuard.getCounterValue(key)

                expect(Number(beforeReset)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, userId)
                const afterReset = await redisGuard.getCounterValue(key)

                expect(afterReset).toBeNull()
            })

            test.each(USER_TYPES)('resets counter by phone for %p', async (userType) => {
                const phone = createTestPhone()
                const key = buildAuthQuotaKeyByUserType('phone', phone, userType)

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(key)
                }
                const beforeReset = await redisGuard.getCounterValue(key)

                expect(Number(beforeReset)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, phone)
                const afterReset = await redisGuard.getCounterValue(key)

                expect(afterReset).toBeNull()
            })

            test('resets all counters by phone', async () => {
                const phone = createTestPhone()
                const keys = USER_TYPES.map(userType => buildAuthQuotaKeyByUserType('phone', phone, userType))

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    for (const key of keys) {
                        await redisGuard.incrementDayCounter(key)
                    }
                }

                const beforeResets = await Promise.all(
                    keys.map(key => redisGuard.getCounterValue(key))
                )

                expect(beforeResets).toHaveLength(3)
                expect(beforeResets.every(counterValue => Number(counterValue) === COUNTER_VALUE_TO_UPDATE)).toBeTruthy()

                await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, phone)
                const afterReset = await Promise.all(
                    keys.map(key => redisGuard.getCounterValue(key))
                )

                expect(afterReset).toHaveLength(3)
                expect(afterReset.every(counterValue => counterValue === null)).toBeTruthy()
            })

            test.each(USER_TYPES)('resets counter by email for %p', async (userType) => {
                const email = createTestEmail()
                const key = buildAuthQuotaKeyByUserType('email', email, userType)

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    await redisGuard.incrementDayCounter(key)
                }
                const beforeReset = await redisGuard.getCounterValue(key)

                expect(Number(beforeReset)).toEqual(COUNTER_VALUE_TO_UPDATE)

                await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, email)
                const afterReset = await redisGuard.getCounterValue(key)

                expect(afterReset).toBeNull()
            })

            test('resets all counters by email', async () => {
                const email = createTestEmail()
                const keys = USER_TYPES.map(userType => buildAuthQuotaKeyByUserType('email', email, userType))

                for (let i = 0; i < COUNTER_VALUE_TO_UPDATE; i++)  {
                    for (const key of keys) {
                        await redisGuard.incrementDayCounter(key)
                    }
                }

                const beforeResets = await Promise.all(
                    keys.map(key => redisGuard.getCounterValue(key))
                )

                expect(beforeResets).toHaveLength(3)
                expect(beforeResets.every(counterValue => Number(counterValue) === COUNTER_VALUE_TO_UPDATE)).toBeTruthy()

                await createTestResetUserLimitAction(userWithDirectAccess, AUTH_COUNTER_LIMIT_TYPE, email)
                const afterReset = await Promise.all(
                    keys.map(key => redisGuard.getCounterValue(key))
                )

                expect(afterReset).toHaveLength(3)
                expect(afterReset.every(counterValue => counterValue === null)).toBeTruthy()
            })
        })
    })
})
