/**
 * Generated by `createservice user.GenerateSudoTokenService --type mutations`
 */

const dayjs = require('dayjs')
const { get } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { COMMON_ERRORS } = require('@condo/domains/common/constants/errors')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { normalizePhone } = require('@condo/domains/common/utils/phone')
const access = require('@condo/domains/user/access/GenerateSudoTokenService')
const { SERVICE } = require('@condo/domains/user/constants/common')
const {
    CAPTCHA_CHECK_FAILED,
    CREDENTIAL_VALIDATION_FAILED,
    GENERATE_TOKEN_FAILED,
    USER_IDENTITY_INVALID,
    NOT_ENOUGH_AUTH_FACTORS,
} = require('@condo/domains/user/constants/errors')
const { MAX_NUMBER_OF_TOKEN_USES, TOKEN_LIFETIME_IN_MIN } = require('@condo/domains/user/constants/sudoToken')
const { captchaCheck } = require('@condo/domains/user/utils/hCaptcha')
const { UserSudoToken, ConfirmPhoneAction, ConfirmEmailAction } = require('@condo/domains/user/utils/serverSchema')
const { authGuards, validateUserCredentials, ERROR_TYPES } = require('@condo/domains/user/utils/serverSchema/auth')
const { generateTokenSafely, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    CAPTCHA_CHECK_FAILED: {
        mutation: 'generateSudoToken',
        variable: ['data', 'captcha'],
        code: BAD_USER_INPUT,
        type: CAPTCHA_CHECK_FAILED,
        message: 'Failed to check CAPTCHA',
        messageForUser: 'api.user.CAPTCHA_CHECK_FAILED',
    },
    DV_VERSION_MISMATCH: {
        ...COMMON_ERRORS.DV_VERSION_MISMATCH,
        mutation: 'generateSudoToken',
    },
    WRONG_SENDER_FORMAT: {
        ...COMMON_ERRORS.WRONG_SENDER_FORMAT,
        mutation: 'generateSudoToken',
    },
    CREDENTIAL_VALIDATION_FAILED: {
        mutation: 'generateSudoToken',
        code: BAD_USER_INPUT,
        type: CREDENTIAL_VALIDATION_FAILED,
        message: 'User credentials validation failed',
        messageForUser: 'api.user.CREDENTIAL_VALIDATION_FAILED',
    },
    GENERATE_TOKEN_ERROR: {
        mutation: 'generateSudoToken',
        code: INTERNAL_ERROR,
        type: GENERATE_TOKEN_FAILED,
        message: 'Generate token failed',
    },
    USER_IDENTITY_INVALID: {
        mutation: 'generateSudoToken',
        code: BAD_USER_INPUT,
        type: USER_IDENTITY_INVALID,
        message: 'Email or phone cannot be empty',
    },
    NOT_ENOUGH_AUTH_FACTORS: {
        mutation: 'generateSudoToken',
        code: BAD_USER_INPUT,
        type: NOT_ENOUGH_AUTH_FACTORS,
        message: 'Not enough auth factors',
        messageForUser: 'api.user.NOT_ENOUGH_AUTH_FACTORS',
    },
}

const GenerateSudoTokenService = new GQLCustomSchema('GenerateSudoTokenService', {
    types: [
        {
            access: true,
            type: 'input GenerateSudoTokenUserIdentifierInput { phone: String, email: String, userType: UserTypeType! }',
        },
        {
            access: true,
            type: 'input GenerateSudoTokenAuthFactorsInput { confirmPhoneToken: String, password: String, confirmEmailToken: String }',
        },
        {
            access: true,
            type: 'input GenerateSudoTokenInput { dv: Int!, sender: SenderFieldInput!, captcha: String!, user: GenerateSudoTokenUserIdentifierInput!, authFactors: GenerateSudoTokenAuthFactorsInput! }',
        },
        {
            access: true,
            type: 'type GenerateSudoTokenOutput { token: String! }',
        },
    ],

    mutations: [
        {
            access: access.canGenerateSudoToken,
            schema: 'generateSudoToken(data: GenerateSudoTokenInput!): GenerateSudoTokenOutput',
            doc: {
                description: 'Generates a sudo token to confirm changes to sensitive data.' +
                    ' The user\'s submitted credentials are checked and if they are valid, a sudo token is returned to the user.',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { captcha, user, authFactors, dv, sender } = data

                const authedItemId = get(context, 'authedItem.id', null)

                const normalizedEmail = normalizeEmail(user.email)
                const normalizedPhone = normalizePhone(user.phone)

                await authGuards({ email: normalizedEmail, phone: normalizedPhone, userType: user.userType }, context)

                if (user.userType !== SERVICE) {
                    const { error: captchaError } = await captchaCheck(context, captcha)
                    if (captchaError) {
                        throw new GQLError({ ...ERRORS.CAPTCHA_CHECK_FAILED, data: { error: captchaError } }, context)
                    }
                }

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                const validation = await validateUserCredentials(
                    { email: normalizedEmail, phone: normalizedPhone, userType: user.userType },
                    { password: authFactors.password, confirmPhoneToken: authFactors.confirmPhoneToken, confirmEmailToken: authFactors.confirmEmailToken },
                )

                if (!validation.success) {
                    if (validation._error?.errorType === ERROR_TYPES.NOT_ENOUGH_AUTH_FACTORS) {
                        if (validation._error.is2FAEnabled) {
                            throw new GQLError({
                                ...ERRORS.NOT_ENOUGH_AUTH_FACTORS,
                                authDetails: {
                                    is2FAEnabled: validation._error.is2FAEnabled,
                                    userId: validation._error.userId,
                                    availableSecondFactors: validation._error.availableSecondFactors,
                                    maskedData: validation._error.maskedData,
                                },
                            }, context)
                        }
                    }

                    throw new GQLError(ERRORS.CREDENTIAL_VALIDATION_FAILED, context)
                }

                if (authedItemId && authedItemId !== validation.user.id) {
                    throw new GQLError(ERRORS.CREDENTIAL_VALIDATION_FAILED, context)
                }

                const { error: tokenError, token } = generateTokenSafely(TOKEN_TYPES.SUDO)
                if (tokenError) {
                    throw new GQLError({ ...ERRORS.GENERATE_TOKEN_ERROR, data: { error: tokenError } }, context)
                }

                const sudoToken = await UserSudoToken.create(context, {
                    token,
                    expiresAt: dayjs().add(TOKEN_LIFETIME_IN_MIN, 'minutes').toISOString(),
                    user: { connect: { id: authedItemId ? authedItemId : validation.user.id } },
                    remainingUses: MAX_NUMBER_OF_TOKEN_USES,
                    dv, sender,
                }, 'id token')

                if (validation.confirmPhoneAction) {
                    await ConfirmPhoneAction.update(context, validation.confirmPhoneAction.id, {
                        dv, sender,
                        completedAt: new Date().toISOString(),
                    })
                }

                if (validation.confirmEmailAction) {
                    await ConfirmEmailAction.update(context, validation.confirmEmailAction.id, {
                        dv, sender,
                        completedAt: new Date().toISOString(),
                    })
                }

                return {
                    token: sudoToken.token,
                }
            },
        },
    ],

})

module.exports = {
    GenerateSudoTokenService,
}
