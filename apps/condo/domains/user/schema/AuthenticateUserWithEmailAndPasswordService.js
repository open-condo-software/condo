/**
 * Generated by `createservice user.AuthenticateUserWithEmailAndPasswordService --type mutations`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, getSchemaCtx } = require('@open-condo/keystone/schema')

const { COMMON_ERRORS, WRONG_EMAIL_VALUE } = require('@condo/domains/common/constants/errors')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const access = require('@condo/domains/user/access/AuthenticateUserWithEmailAndPasswordService')
const { SERVICE } = require('@condo/domains/user/constants/common')
const { WRONG_CREDENTIALS, CAPTCHA_CHECK_FAILED } = require('@condo/domains/user/constants/errors')
const { captchaCheck } = require('@condo/domains/user/utils/hCaptcha')
const { authGuards, validateUserCredentials } = require('@condo/domains/user/utils/serverSchema/auth')


/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    WRONG_EMAIL_FORMAT: {
        mutation: 'authenticateUserWithEmailAndPassword',
        code: BAD_USER_INPUT,
        type: WRONG_EMAIL_VALUE,
        variable: ['data', 'email'],
        message: 'Wrong format of provided email',
        correctExample: 'example@example.com',
        messageForUser: 'api.common.INVALID_EMAIL_FORMAT',
    },
    WRONG_CREDENTIALS: {
        mutation: 'authenticateUserWithEmailAndPassword',
        code: BAD_USER_INPUT,
        type: WRONG_CREDENTIALS,
        message: 'Wrong email or password',
        messageForUser: 'api.user.authenticateUserWithEmailAndPassword.WRONG_CREDENTIALS',
    },
    CAPTCHA_CHECK_FAILED: {
        mutation: 'authenticateUserWithEmailAndPassword',
        variable: ['data', 'captcha'],
        code: BAD_USER_INPUT,
        type: CAPTCHA_CHECK_FAILED,
        message: 'Failed to check CAPTCHA',
        messageForUser: 'api.user.CAPTCHA_CHECK_FAILED',
    },
    DV_VERSION_MISMATCH: {
        ...COMMON_ERRORS.DV_VERSION_MISMATCH,
        mutation: 'authenticateUserWithEmailAndPassword',
    },
    WRONG_SENDER_FORMAT: {
        ...COMMON_ERRORS.WRONG_SENDER_FORMAT,
        mutation: 'authenticateUserWithEmailAndPassword',
    },
}

const AuthenticateUserWithEmailAndPasswordService = new GQLCustomSchema('AuthenticateUserWithEmailAndPasswordService', {
    types: [
        {
            access: true,
            type: 'input AuthenticateUserWithEmailAndPasswordInput { dv: Int!, sender: SenderFieldInput!, captcha: String, userType: UserTypeType!, email: String! password: String! }',
        },
        {
            access: true,
            type: 'type AuthenticateUserWithEmailAndPasswordOutput { item: User, token: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canAuthenticateUserWithEmailAndPassword,
            schema: 'authenticateUserWithEmailAndPassword(data: AuthenticateUserWithEmailAndPasswordInput!): AuthenticateUserWithEmailAndPasswordOutput',
            doc: {
                summary: 'This mutation authorizes the user by email and password',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const {
                    password,
                    captcha,
                    dv,
                    sender,
                    userType,
                } = data

                const email = normalizeEmail(data.email)

                await authGuards({ email, userType }, context)

                if (captcha && userType !== SERVICE) {
                    const { error: captchaError } = await captchaCheck(context, captcha)
                    if (captchaError) {
                        throw new GQLError({ ...ERRORS.CAPTCHA_CHECK_FAILED, data: { error: captchaError } }, context)
                    }
                }

                checkDvAndSender({ dv, sender }, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                if (!email) {
                    throw new GQLError(ERRORS.WRONG_EMAIL_FORMAT, context)
                }

                const { success, user } = await validateUserCredentials(
                    { email, userType },
                    { password }
                )

                if (!success) {
                    throw new GQLError(ERRORS.WRONG_CREDENTIALS, context)
                }

                const { keystone } = getSchemaCtx('User')
                const token = await context.startAuthedSession({
                    item: user,
                    list: keystone.lists['User'],
                    meta: {
                        source: 'gql',
                        provider: 'authenticateUserWithEmailAndPassword',
                    },
                })

                return {
                    item: user,
                    token,
                }
            },
        },
    ],
    
})

module.exports = {
    AuthenticateUserWithEmailAndPasswordService,
}
