/**
 * Generated by `createservice user.ChangeTwoFactorAuthenticationService --type mutations`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, getByCondition } = require('@open-condo/keystone/schema')

const { COMMON_ERRORS } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/user/access/ChangeTwoFactorAuthenticationService')
const { INVALID_TOKEN, UNSUPPORTED_TOKEN, TOKEN_NOT_FOUND, USER_NOT_FOUND } = require('@condo/domains/user/constants/errors')
const { User, UserSudoToken } = require('@condo/domains/user/utils/serverSchema')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')
const { detectTokenTypeSafely, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    DV_VERSION_MISMATCH: {
        ...COMMON_ERRORS.DV_VERSION_MISMATCH,
        mutation: 'changeTwoFactorAuthentication',
    },
    WRONG_SENDER_FORMAT: {
        ...COMMON_ERRORS.WRONG_SENDER_FORMAT,
        mutation: 'changeTwoFactorAuthentication',
    },
    INVALID_TOKEN: {
        mutation: 'changeTwoFactorAuthentication',
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: INVALID_TOKEN,
        message: 'Invalid token',
        messageForUser: 'api.user.changeTwoFactorAuthentication.INVALID_TOKEN',
    },
    UNSUPPORTED_TOKEN: {
        mutation: 'changeTwoFactorAuthentication',
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: UNSUPPORTED_TOKEN,
        message: 'Unsupported token',
        messageForUser: 'api.user.changeTwoFactorAuthentication.UNSUPPORTED_TOKEN',
    },
    TOKEN_NOT_FOUND: {
        mutation: 'changeTwoFactorAuthentication',
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: TOKEN_NOT_FOUND,
        message: 'Unable to find non-expired UserSudoToken by specified token',
        messageForUser: 'api.user.changeTwoFactorAuthentication.TOKEN_NOT_FOUND',
    },
    USER_NOT_FOUND: {
        mutation: 'changeTwoFactorAuthentication',
        code: BAD_USER_INPUT,
        type: USER_NOT_FOUND,
        message: 'User not found',
        messageForUser: 'api.user.changeTwoFactorAuthentication.USER_NOT_FOUND',
    },
    OPERATION_FAILED: {
        mutation: 'changeTwoFactorAuthentication',
        code: BAD_USER_INPUT,
        type: 'OPERATION_FAILED',
        message: 'The operation failed',
        messageForUser: 'api.user.changeTwoFactorAuthentication.OPERATION_FAILED',
    },
    INSUFFICIENT_AUTHENTICATION_FACTORS: {
        mutation: 'changeTwoFactorAuthentication',
        code: BAD_USER_INPUT,
        type: 'INSUFFICIENT_AUTHENTICATION_FACTORS',
        message: 'Insufficient authentication factors. At least three must be specified. For example, password, verified phone and verified email.',
        // TODO(DOMA-12404): add translations for errors
        messageForUser: 'api.user.changeTwoFactorAuthentication.INSUFFICIENT_AUTHENTICATION_FACTORS',
    },
}

const DAY_IN_SEC = 60 * 60 * 24

const redisGuard = new RedisGuard()

async function changeTwoFactorAuthenticationGuard (context) {
    const ip = context.req.ip
    const userId = context?.authedItem?.id

    const guards = [{
        key: ['changeTwoFactorAuthentication', 'daily', 'ip', ip].join(':'),
        windowLimit: 30,
        windowSizeInSec: DAY_IN_SEC,
    }, {
        key: ['changeTwoFactorAuthentication', 'daily', 'userId', userId].join(':'),
        windowLimit: 10,
        windowSizeInSec: DAY_IN_SEC,
    }]

    await redisGuard.checkMultipleCustomLimitCounters(guards, context)
}

const ChangeTwoFactorAuthenticationService = new GQLCustomSchema('ChangeTwoFactorAuthenticationService', {
    types: [
        {
            access: true,
            type: 'input ChangeTwoFactorAuthenticationInput { dv: Int!, sender: SenderFieldInput!, token: String!, isEnabled: Boolean! }',
        },
        {
            access: true,
            type: 'type ChangeTwoFactorAuthenticationOutput { status: String! }',
        },
    ],
    
    mutations: [
        {
            doc: {
                summary: 'This mutation changes the "isTwoFactorAuthenticationEnabled" field in the "User" schema. ' +
                    '\nTo perform this operation, you must obtain and pass a sudo token.',
                errors: ERRORS,
            },
            access: access.canChangeTwoFactorAuthentication,
            schema: 'changeTwoFactorAuthentication(data: ChangeTwoFactorAuthenticationInput!): ChangeTwoFactorAuthenticationOutput',
            resolver: async (parent, args, context) => {
                const { data } = args
                const { token, isEnabled, sender } = data

                await changeTwoFactorAuthenticationGuard(context)

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                const { error: tokenError, tokenType } = detectTokenTypeSafely(token)
                if (tokenError) {
                    throw new GQLError({ ...ERRORS.INVALID_TOKEN, data: { error: tokenError } }, context)
                }

                if (TOKEN_TYPES.SUDO !== tokenType) {
                    throw new GQLError(ERRORS.UNSUPPORTED_TOKEN, context)
                }

                const sudoToken = await getByCondition('UserSudoToken', {
                    deletedAt: null,
                    token,
                    expiresAt_gte: new Date().toISOString(),
                    remainingUses_gt: 0,
                })

                if (!sudoToken) throw new GQLError(ERRORS.TOKEN_NOT_FOUND, context)

                const authedItemId = context?.authedItem?.id || null
                if (authedItemId && authedItemId !== sudoToken.user) {
                    throw new GQLError(ERRORS.OPERATION_FAILED, context)
                }

                const user = await getByCondition('User', {
                    deletedAt: null,
                    id: sudoToken.user,
                })

                if (!user) throw new GQLError(ERRORS.USER_NOT_FOUND, context)

                if (
                    isEnabled
                    && (
                        !user.password
                        || !user.phone || !user.isPhoneVerified
                        || !user.email || !user.isEmailVerified
                    )
                ) {
                    throw new GQLError(ERRORS.INSUFFICIENT_AUTHENTICATION_FACTORS, context)
                }

                await User.update(context, user.id, {
                    dv: 1, sender,
                    isTwoFactorAuthenticationEnabled: isEnabled,
                })

                await UserSudoToken.update(context, sudoToken.id, {
                    dv: 1, sender,
                    remainingUses: sudoToken.remainingUses - 1,
                })

                return {
                    status: 'ok',
                }
            },
        },
    ],
})

module.exports = {
    ChangeTwoFactorAuthenticationService,
}
