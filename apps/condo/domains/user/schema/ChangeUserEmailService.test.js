/**
 * Generated by `createservice user.ChangeUserEmailService --type mutations`
 */

const { faker } = require('@faker-js/faker')

const { makeLoggedInAdminClient,
    makeClient,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowGQLErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { STAFF } = require('@condo/domains/user/constants/common')
const {
    makeClientWithStaffUser,
    changeUserEmailByTestClient,
    updateTestUser,
    generateSudoTokenByTestClient,
    createTestEmail,
    UserAdmin,
    UserSudoToken,
} = require('@condo/domains/user/utils/testSchema')
const { generateToken, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


function getCaptcha () {
    return faker.random.alphaNumeric(32)
}

describe('ChangeUserEmailService', () => {
    let adminClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
    })

    describe('Accesses', () => {
        describe('User', () => {
            test('Can execute', async () => {
                const staffClient = await makeClientWithStaffUser()
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })
                const [result] = await changeUserEmailByTestClient(staffClient, {
                    token: sudoToken.token,
                    newEmail: createTestEmail(),
                })
                expect(result.status).toBe('ok')
            })

            test('Soft-deleted user cannot execute', async () => {
                const staffClient = await makeClientWithStaffUser()
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })
                const [deletedUser] = await updateTestUser(adminClient, staffClient.user.id, {
                    deletedAt: new Date().toISOString(),
                })
                expect(deletedUser.deletedAt).not.toBeNull()
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await changeUserEmailByTestClient(staffClient, {
                        token: sudoToken.token,
                        newEmail: createTestEmail(),
                    })
                })
            })
        })

        describe('Anonymous', () => {
            test('Cannot execute', async () => {
                const staffClient = await makeClientWithStaffUser()
                const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                    captcha: getCaptcha(),
                    user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                    authFactors: { password: staffClient.userAttrs.password },
                })
                const anonymousClient = await makeClient()
                await expectToThrowAuthenticationErrorToResult(async () => {
                    await changeUserEmailByTestClient(anonymousClient, {
                        token: sudoToken.token,
                        newEmail: createTestEmail(),
                    })
                })
            })
        })
    })

    describe('Basic logic', () => {
        test('Should change user email to new email and set isEmailVerified to false', async () => {
            const staffClient = await makeClientWithStaffUser({
                isEmailVerified: true,
            })
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })
            const newEmail = createTestEmail()
            const [result] = await changeUserEmailByTestClient(staffClient, {
                token: sudoToken.token,
                newEmail,
            })
            expect(result.status).toBe('ok')

            const updatedUser = await UserAdmin.getOne(adminClient, { id: staffClient.user.id })
            expect(updatedUser.email).toBe(newEmail)
            expect(updatedUser.isEmailVerified).toBeFalsy()
        })

        test('Should reset user email if new email is null', async () => {
            const staffClient = await makeClientWithStaffUser({
                isEmailVerified: true,
            })
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })
            const newEmail = null
            const [result] = await changeUserEmailByTestClient(staffClient, {
                token: sudoToken.token,
                newEmail,
            })
            expect(result.status).toBe('ok')

            const updatedUser = await UserAdmin.getOne(adminClient, { id: staffClient.user.id })
            expect(updatedUser.email).toBeNull()
            expect(updatedUser.isEmailVerified).toBeFalsy()
        })

        test('Should be marked ConfirmEmailAction as used after operation', async () => {
            const staffClient = await makeClientWithStaffUser()
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })
            const [result] = await changeUserEmailByTestClient(staffClient, {
                token: sudoToken.token,
                newEmail: createTestEmail(),
            })
            expect(result.status).toBe('ok')

            const updatedSudoToken = await UserSudoToken.getOne(adminClient, {
                token: sudoToken.token,
            })
            expect(updatedSudoToken.remainingUses).toBe(0)
        })

        test('throw error if new email invalid', async () => {
            const staffClient = await makeClientWithStaffUser({
                isEmailVerified: true,
            })
            const [sudoToken] = await generateSudoTokenByTestClient(staffClient, {
                captcha: getCaptcha(),
                user: { phone: staffClient.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient.userAttrs.password },
            })
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserEmailByTestClient(staffClient, {
                    token: sudoToken.token,
                    newEmail: faker.random.alphaNumeric(8),
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'WRONG_EMAIL_VALUE',
                message: 'Wrong email format',
            })
        })

        test('throw error if unsupported token', async () => {
            const staffClient = await makeClientWithStaffUser({
                isEmailVerified: true,
            })
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserEmailByTestClient(staffClient, {
                    token: generateToken(TOKEN_TYPES.CONFIRM_EMAIL),
                    newEmail: createTestEmail(),
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'UNSUPPORTED_TOKEN',
                message: 'Unsupported token',
            })
        })

        test('throw error if invalid token', async () => {
            const staffClient = await makeClientWithStaffUser({
                isEmailVerified: true,
            })
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserEmailByTestClient(staffClient, {
                    token: faker.random.alphaNumeric(8),
                    newEmail: createTestEmail(),
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'INVALID_TOKEN',
                message: 'Invalid token',
            })
        })

        test('throw error if token is not exists', async () => {
            const staffClient = await makeClientWithStaffUser({
                isEmailVerified: true,
            })
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserEmailByTestClient(staffClient, {
                    token: generateToken(TOKEN_TYPES.SUDO),
                    newEmail: createTestEmail(),
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'TOKEN_NOT_FOUND',
                message: 'Unable to find non-expired UserSudoToken by specified token',
            })
        })

        test('throw error if sudo token from other user', async () => {
            const staffClient = await makeClientWithStaffUser()
            const staffClient2 = await makeClientWithStaffUser()
            const [sudoToken2] = await generateSudoTokenByTestClient(staffClient2, {
                captcha: getCaptcha(),
                user: { phone: staffClient2.userAttrs.phone, userType: STAFF },
                authFactors: { password: staffClient2.userAttrs.password },
            })
            await expectToThrowGQLErrorToResult(async () => {
                await changeUserEmailByTestClient(staffClient, {
                    token: sudoToken2.token,
                    newEmail: createTestEmail(),
                })
            }, {
                code: 'BAD_USER_INPUT',
                type: 'OPERATION_FAILED',
                message: 'The operation failed',
            })
        })
    })
})
