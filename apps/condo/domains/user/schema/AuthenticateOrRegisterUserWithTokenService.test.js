/**
 * Generated by `createservice user.AuthenticateOrRegisterUserWithTokenService --type mutations`
 */

const { faker } = require('@faker-js/faker')

const { generateGqlQueries } = require('@open-condo/codegen/generate.gql')
const { generateGQLTestUtils } = require('@open-condo/codegen/generate.test.utils')
const {
    makeLoggedInAdminClient,
    makeClient,
    expectToThrowGQLErrorToResult,
} = require('@open-condo/keystone/test.utils')

const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { RESIDENT, SERVICE, STAFF } = require('@condo/domains/user/constants/common')
const {
    authenticateOrRegisterUserWithTokenByTestClient,
    makeLoggedInClient,
    createTestConfirmPhoneAction,
    createTestUser,
    createTestPhone,
    resetUserByTestClient,
    ConfirmPhoneAction,
    User,
} = require('@condo/domains/user/utils/testSchema')


// NOTE: We need custom utilities because the generic utilities don't have some fields that need to be checked in tests
const USER_FIELDS = 'type name meta isPhoneVerified isEmailVerified isAdmin isSupport password_is_set email phone id'
const UserAdmin = generateGqlQueries('User', `{ ${USER_FIELDS} }`)
const UserAdminUtils = generateGQLTestUtils(UserAdmin)


describe('AuthenticateOrRegisterUserWithTokenService', () => {
    let adminClient, anonymousClient

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
    })

    beforeEach(async () => {
        anonymousClient = await makeClient()
    })

    describe('Accesses', () => {
        describe('User', () => {
            test('can execute', async () => {
                const userClient = await makeLoggedInClient()
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await authenticateOrRegisterUserWithTokenByTestClient(userClient, {
                    token: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
                expect(result.token).not.toHaveLength(0)
                expect(result.user.id).toBeDefined()
                // NOTE: Users must not be the same as a new user is registering
                expect(result.user.id).not.toBe(userClient.user.id)
            })
        })

        describe('Anonymous (anyone)', () => {
            test('can execute', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                    token: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
                expect(result.token).not.toHaveLength(0)
                expect(result.user.id).toBeDefined()
            })
        })
    })

    describe('Base logic', () => {
        describe('For user type = "resident"', () => {
            test('should register and sign in resident with confirmed phone token if a resident with such a phone is not registered yet', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                    token: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
                expect(result.token).not.toHaveLength(0)
                expect(result.user.id).toBeDefined()
                const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
                expect(user.type).toBe(RESIDENT)
                expect(user.isAdmin).toBeFalsy()
                expect(user.isSupport).toBeFalsy()
                expect(user.name).toBeNull()
                expect(user.email).toBeNull()
                expect(user.isEmailVerified).toBeFalsy()
                expect(user.phone).toBe(confirmPhoneAction.phone)
                expect(user.isPhoneVerified).toBeTruthy()
                expect(user.meta).toBeNull()
                expect(user.password_is_set).toBeFalsy()
            })

            test('should sign in resident with confirmed phone token if a resident with such a phone is already registered', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                    token: confirmPhoneAction.token,
                    userType: RESIDENT,
                })
                expect(result.token).not.toHaveLength(0)
                expect(result.user.id).toBeDefined()
                const user1 = await UserAdminUtils.getOne(adminClient, { id: result.user.id })

                const anonymousClient2 = await makeClient()
                const [confirmPhoneAction2] = await createTestConfirmPhoneAction(adminClient, {
                    isPhoneVerified: true, phone: confirmPhoneAction.phone,
                })
                const [result2] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient2, {
                    token: confirmPhoneAction2.token,
                    userType: RESIDENT,
                })
                expect(result2.token).not.toHaveLength(0)
                expect(result2.user.id).toBeDefined()
                const user2 = await UserAdminUtils.getOne(adminClient, { id: result2.user.id })
                expect(user1).toEqual(user2)
            })

            describe('if an staff or service user with such a phone is already registered', () => {
                let staffUser, serviceUser, phone

                beforeEach(async () => {
                    phone = createTestPhone();
                    [staffUser] = await createTestUser(adminClient, {
                        type: STAFF,
                        phone: phone,
                    });
                    [serviceUser] = await createTestUser(adminClient, {
                        type: SERVICE,
                        phone: phone,
                    })
                })

                test('should register and sign in a resident with a verified phone token', async () => {
                    const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, phone: phone,
                    })
                    const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: RESIDENT,
                    })
                    expect(result.token).not.toHaveLength(0)
                    expect(result.user.id).toBeDefined()
                    const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
                    expect(user.id).not.toBe(staffUser.id)
                    expect(user.type).toBe(RESIDENT)
                    expect(user.phone).toBe(phone)
                })

                test('should sign in a resident with a verified phone token if a resident with such a phone is already registered', async () => {
                    const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, phone: phone,
                    })
                    const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: RESIDENT,
                    })
                    expect(result.token).not.toHaveLength(0)
                    expect(result.user.id).toBeDefined()
                    const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
                    expect(user.type).toBe(RESIDENT)
                    expect(user.id).not.toBe(staffUser.id)
                    expect(user.phone).toBe(phone)

                    const anonymousClient2 = await makeClient()
                    const [confirmPhoneAction2] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, phone: phone,
                    })
                    const [result2] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient2, {
                        token: confirmPhoneAction2.token,
                        userType: RESIDENT,
                    })
                    expect(result2.token).not.toHaveLength(0)
                    expect(result2.user.id).toBeDefined()
                    const user2 = await UserAdminUtils.getOne(adminClient, { id: result2.user.id })
                    expect(user).toEqual(user2)
                })
            })
        })

        describe('For user type = "staff"', () => {
            test('should register and sign in staff with confirmed phone token if a staff with such a phone is not registered yet', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result, attrs] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                    token: confirmPhoneAction.token,
                    userType: STAFF,
                    userData: {
                        name: faker.name.fullName(),
                        password: faker.internet.password(16),
                    },
                })
                expect(result.token).not.toHaveLength(0)
                expect(result.user.id).toBeDefined()
                const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
                expect(user.type).toBe(STAFF)
                expect(user.isAdmin).toBeFalsy()
                expect(user.isSupport).toBeFalsy()
                expect(user.name).toBe(attrs.userData.name)
                expect(user.email).toBeNull()
                expect(user.isEmailVerified).toBeFalsy()
                expect(user.phone).toBe(confirmPhoneAction.phone)
                expect(user.isPhoneVerified).toBeTruthy()
                expect(user.meta).toBeNull()
                expect(user.password_is_set).toBeTruthy()
            })

            test('should sign in staff with confirmed phone token if a staff with such a phone is already registered', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                    token: confirmPhoneAction.token,
                    userType: STAFF,
                    userData: {
                        name: faker.name.fullName(),
                        password: faker.internet.password(16),
                    },
                })
                expect(result.token).not.toHaveLength(0)
                expect(result.user.id).toBeDefined()
                const user1 = await UserAdminUtils.getOne(adminClient, { id: result.user.id })

                const anonymousClient2 = await makeClient()
                const [confirmPhoneAction2] = await createTestConfirmPhoneAction(adminClient, {
                    isPhoneVerified: true, phone: confirmPhoneAction.phone,
                })
                const [result2] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient2, {
                    token: confirmPhoneAction2.token,
                    userType: STAFF,
                })
                expect(result2.token).not.toHaveLength(0)
                expect(result2.user.id).toBeDefined()
                const user2 = await UserAdminUtils.getOne(adminClient, { id: result2.user.id })
                expect(user1).toEqual(user2)
            })

            describe('if an resident or service user with such a phone is already registered', () => {
                let residentUser, serviceUser, phone

                beforeEach(async () => {
                    phone = createTestPhone();
                    [residentUser] = await createTestUser(adminClient, {
                        type: RESIDENT,
                        phone: phone,
                    });
                    [serviceUser] = await createTestUser(adminClient, {
                        type: SERVICE,
                        phone: phone,
                    })
                })

                test('should register and sign in a staff with a verified phone token', async () => {
                    const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, phone: phone,
                    })
                    const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: STAFF,
                        userData: {
                            name: faker.name.fullName(),
                            password: faker.internet.password(16),
                        },
                    })
                    expect(result.token).not.toHaveLength(0)
                    expect(result.user.id).toBeDefined()
                    const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
                    expect(user.id).not.toBe(residentUser.id)
                    expect(user.type).toBe(STAFF)
                    expect(user.phone).toBe(phone)
                })

                test('should sign in a staff with a verified phone token if a staff with such a phone is already registered', async () => {
                    const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, phone: phone,
                    })
                    const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: STAFF,
                        userData: {
                            name: faker.name.fullName(),
                            password: faker.internet.password(16),
                        },
                    })
                    expect(result.token).not.toHaveLength(0)
                    expect(result.user.id).toBeDefined()
                    const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
                    expect(user.type).toBe(STAFF)
                    expect(user.id).not.toBe(residentUser.id)
                    expect(user.phone).toBe(phone)

                    const anonymousClient2 = await makeClient()
                    const [confirmPhoneAction2] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, phone: phone,
                    })
                    const [result2] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient2, {
                        token: confirmPhoneAction2.token,
                        userType: STAFF,
                    })
                    expect(result2.token).not.toHaveLength(0)
                    expect(result2.user.id).toBeDefined()
                    const user2 = await UserAdminUtils.getOne(adminClient, { id: result2.user.id })
                    expect(user).toEqual(user2)
                })
            })

            test('should throw an error if the user is not registered and the required user data (phone, email, password) is missing', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: STAFF,
                    })
                }, {
                    code: 'BAD_USER_INPUT',
                    type: 'REQUIRED_USER_DATA_IS_MISSING',
                    message: 'Some required user data was missing: name, password',
                    variable: ['data', 'userData', 'name'],
                    messageForUser: 'api.user.authenticateOrRegisterUserWithToken.REQUIRED_USER_DATA_IS_MISSING',
                })

                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: STAFF,
                        userData: {
                            password: faker.internet.password(16),
                        },
                    })
                }, {
                    code: 'BAD_USER_INPUT',
                    type: 'REQUIRED_USER_DATA_IS_MISSING',
                    message: 'Some required user data was missing: name',
                    variable: ['data', 'userData', 'name'],
                    messageForUser: 'api.user.authenticateOrRegisterUserWithToken.REQUIRED_USER_DATA_IS_MISSING',
                })

                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: STAFF,
                        userData: {
                            name: faker.name.fullName(),
                        },
                    })
                }, {
                    code: 'BAD_USER_INPUT',
                    type: 'REQUIRED_USER_DATA_IS_MISSING',
                    message: 'Some required user data was missing: password',
                    variable: ['data', 'userData', 'password'],
                    messageForUser: 'api.user.authenticateOrRegisterUserWithToken.REQUIRED_USER_DATA_IS_MISSING',
                })
            })
        })

        describe('For user type = "service"', () => {
            test('should should throw if try register service with confirmed phone token', async () => {
                const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
                await expectToThrowGQLErrorToResult(async () => {
                    await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                        token: confirmPhoneAction.token,
                        userType: SERVICE,
                    })
                }, {
                    query: 'authenticateOrRegisterUserWithToken',
                    code: 'BAD_USER_INPUT',
                    type: 'UNAVAILABLE_TOKEN_FOR_REGISTRATION',
                    message: 'It is not possible to register a user with the type {userType} using {identifierType}',
                    messageInterpolation: { userType: 'service', identifierType: 'phone' },
                })
            })

            test('should sign in service with confirmed phone token if a service with such a phone is already registered', async () => {
                const [createdUser, userAttrs] = await createTestUser(adminClient, {
                    isPhoneVerified: true, type: SERVICE,
                })
                const user1 = await UserAdminUtils.getOne(adminClient, { id: createdUser.id })

                const anonymousClient2 = await makeClient()
                const [confirmPhoneAction2] = await createTestConfirmPhoneAction(adminClient, {
                    isPhoneVerified: true, phone: userAttrs.phone,
                })
                const [result2] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient2, {
                    token: confirmPhoneAction2.token,
                    userType: SERVICE,
                })
                expect(result2.token).not.toHaveLength(0)
                expect(result2.user.id).toBeDefined()
                const user2 = await UserAdminUtils.getOne(adminClient, { id: result2.user.id })
                expect(user1).toEqual(user2)
            })

            describe('if an staff or resident user with such a phone is already registered', () => {
                let staffUser, resident, phone

                beforeEach(async () => {
                    phone = createTestPhone();
                    [staffUser] = await createTestUser(adminClient, {
                        type: STAFF,
                        phone: phone,
                    });
                    [resident] = await createTestUser(adminClient, {
                        type: RESIDENT,
                        phone: phone,
                    })
                })

                test('should should throw if try register service with confirmed phone token', async () => {
                    const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, phone: phone,
                    })
                    await expectToThrowGQLErrorToResult(async () => {
                        await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                            token: confirmPhoneAction.token,
                            userType: SERVICE,
                        })
                    }, {
                        query: 'authenticateOrRegisterUserWithToken',
                        code: 'BAD_USER_INPUT',
                        type: 'UNAVAILABLE_TOKEN_FOR_REGISTRATION',
                        message: 'It is not possible to register a user with the type {userType} using {identifierType}',
                        messageInterpolation: { userType: 'service', identifierType: 'phone' },
                    })
                })

                test('should sign in a service with a verified phone token if a service with such a phone is already registered', async () => {
                    const [createdUser] = await createTestUser(adminClient, {
                        isPhoneVerified: true, type: SERVICE, phone,
                    })
                    const user = await UserAdminUtils.getOne(adminClient, { id: createdUser.id })

                    const anonymousClient2 = await makeClient()
                    const [confirmPhoneAction2] = await createTestConfirmPhoneAction(adminClient, {
                        isPhoneVerified: true, phone,
                    })
                    const [result2] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient2, {
                        token: confirmPhoneAction2.token,
                        userType: SERVICE,
                    })
                    expect(result2.token).not.toHaveLength(0)
                    expect(result2.user.id).toBeDefined()
                    const user2 = await UserAdminUtils.getOne(adminClient, { id: result2.user.id })
                    expect(user).toEqual(user2)
                })
            })
        })
    })

    test('should register a user with the specified user data', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
        const [result, attrs] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
            token: confirmPhoneAction.token,
            userType: STAFF,
            userData: {
                name: faker.name.fullName(),
                email: faker.internet.email(),
                phone: confirmPhoneAction.phone,
                password: faker.internet.password(16),
            },
        })
        expect(result.token).not.toHaveLength(0)
        expect(result.user.id).toBeDefined()
        const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
        expect(user.type).toBe(STAFF)
        expect(user.isAdmin).toBeFalsy()
        expect(user.isSupport).toBeFalsy()
        expect(user.name).toBe(attrs.userData.name)
        expect(user.email).toBe(normalizeEmail(attrs.userData.email))
        expect(user.isEmailVerified).toBeFalsy()
        expect(user.phone).toBe(confirmPhoneAction.phone)
        expect(user.phone).toBe(attrs.userData.phone)
        expect(user.isPhoneVerified).toBeTruthy()
        expect(user.meta).toBeNull()
        expect(user.password_is_set).toBeTruthy()
    })

    test('should be set empty user data from the specified user data if the user is already registered', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
        const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
            token: confirmPhoneAction.token,
            userType: RESIDENT,
        })
        expect(result.token).not.toHaveLength(0)
        expect(result.user.id).toBeDefined()
        const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
        expect(user.type).toBe(RESIDENT)
        expect(user.isAdmin).toBeFalsy()
        expect(user.isSupport).toBeFalsy()
        expect(user.name).toBeNull()
        expect(user.email).toBeNull()
        expect(user.isEmailVerified).toBeFalsy()
        expect(user.phone).toBe(confirmPhoneAction.phone)
        expect(user.isPhoneVerified).toBeTruthy()
        expect(user.meta).toBeNull()
        expect(user.password_is_set).toBeFalsy()

        const [confirmPhoneAction2] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, phone: confirmPhoneAction.phone,
        })
        const [result2, attrs2] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
            token: confirmPhoneAction2.token,
            userType: RESIDENT,
            userData: {
                name: faker.name.fullName(),
                email: faker.internet.email(),
                phone: confirmPhoneAction.phone,
                password: faker.internet.password(16),
            },
        })
        expect(result2.token).not.toHaveLength(0)
        expect(result2.user.id).toBeDefined()
        const user2 = await UserAdminUtils.getOne(adminClient, { id: result2.user.id })
        expect(user2.type).toBe(RESIDENT)
        expect(user2.isAdmin).toBeFalsy()
        expect(user2.isSupport).toBeFalsy()
        expect(user2.name).toBe(attrs2.userData.name)
        expect(user2.email).toBe(normalizeEmail(attrs2.userData.email))
        expect(user2.isEmailVerified).toBeFalsy()
        expect(user2.phone).toBe(user.phone)
        expect(user2.isPhoneVerified).toBe(user.isPhoneVerified)
        expect(user.meta).toBeNull()
        expect(user2.password_is_set).toBeTruthy()
    })

    test('should set the flag "isPhoneVerified" to TRUE if an existing user with an unverified phone sign in with a verified phone token', async () => {
        const [residentUser, userAttrs] = await createTestUser(adminClient, { type: RESIDENT })
        expect(residentUser.isPhoneVerified).toBeFalsy()

        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, phone: userAttrs.phone,
        })
        const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
            token: confirmPhoneAction.token,
            userType: RESIDENT,
        })
        expect(result.user.id).toBe(residentUser.id)
        const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
        expect(user.type).toBe(RESIDENT)
        expect(user.phone).toBe(userAttrs.phone)
        expect(user.isPhoneVerified).toBeTruthy()
    })

    test('should save current non-empty user data if the user is already registered and new user data is passed in the payload', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
        const [result, attrs] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
            token: confirmPhoneAction.token,
            userType: RESIDENT,
            userData: {
                name: faker.name.fullName(),
                email: faker.internet.email(),
                phone: confirmPhoneAction.phone,
                password: faker.internet.password(16),
            },
        })
        expect(result.token).not.toHaveLength(0)
        expect(result.user.id).toBeDefined()
        const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
        expect(user.type).toBe(RESIDENT)
        expect(user.isAdmin).toBeFalsy()
        expect(user.isSupport).toBeFalsy()
        expect(user.name).toBe(attrs.userData.name)
        expect(user.email).toBe(normalizeEmail(attrs.userData.email))
        expect(user.isEmailVerified).toBeFalsy()
        expect(user.phone).toBe(attrs.userData.phone)
        expect(user.isPhoneVerified).toBeTruthy()
        expect(user.meta).toBeNull()
        expect(user.password_is_set).toBeTruthy()

        const [confirmPhoneAction2] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, phone: confirmPhoneAction.phone,
        })
        const [result2] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
            token: confirmPhoneAction2.token,
            userType: RESIDENT,
            userData: {
                name: faker.name.fullName(),
                email: faker.internet.email(),
                phone: confirmPhoneAction.phone,
                password: faker.internet.password(16),
            },
        })
        expect(result2.token).not.toHaveLength(0)
        expect(result2.user.id).toBeDefined()
        const user2 = await UserAdminUtils.getOne(adminClient, { id: result2.user.id })
        expect(user).toEqual(user2)
    })

    test('should register a new user if the user with the same phone number was reset', async () => {
        const [resetUser, resetUserAttrs] = await createTestUser(adminClient)
        await resetUserByTestClient(adminClient, { user: { id: resetUser.id } })

        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, phone: resetUserAttrs.phone,
        })
        const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
            token: confirmPhoneAction.token,
            userType: resetUserAttrs.type,
            userData: {
                name: faker.name.fullName(),
                password: faker.internet.password(16),
            },
        })
        expect(result.token).not.toHaveLength(0)
        expect(result.user.id).toBeDefined()
        const user = await UserAdminUtils.getOne(adminClient, { id: result.user.id })
        expect(user.id).not.toBe(resetUser.id)
        expect(user.type).toBe(resetUserAttrs.type)
        expect(user.phone).toBe(resetUserAttrs.phone)
    })

    test('should be marked as used a phone token after user sing in', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
        const [result] = await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
            token: confirmPhoneAction.token,
            userType: RESIDENT,
        })
        expect(result.token).not.toHaveLength(0)
        expect(result.user.id).toBeDefined()
        const usedConfirmPhoneAction = await ConfirmPhoneAction.getOne(adminClient, { token: confirmPhoneAction.token })
        expect(usedConfirmPhoneAction.completedAt).not.toBeNull()
    })

    test('should throw error if phone from phone token is not equal phone from user data', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: STAFF,
                userData: {
                    phone: createTestPhone(),
                },
            })
        }, {
            mutation: 'authenticateOrRegisterUserWithToken',
            variable: ['data', 'userData', 'phone'],
            code: 'BAD_USER_INPUT',
            type: 'DIFFERENT_PHONES',
            message: 'The verified phone and the phone from the payload cannot be different',
            messageForUser: 'api.user.authenticateOrRegisterUserWithToken.DIFFERENT_PHONES',
        })
    })

    test('should throw an error if the user with the same phone number was soft deleted', async () => {
        const [softDeletedUser, softDeletedUserAttrs] = await createTestUser(adminClient)
        await User.softDelete(adminClient, softDeletedUser.id)
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, phone: softDeletedUserAttrs.phone,
        })
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: STAFF,
                userData: {
                    phone: softDeletedUserAttrs.phone,
                },
            })
        }, {
            mutation: 'authenticateOrRegisterUserWithToken',
            code: 'BAD_USER_INPUT',
            type: 'OPERATION_FAILED',
            message: 'The operation failed',
            messageForUser: 'api.user.authenticateOrRegisterUserWithToken.OPERATION_FAILED',
        })
    })

    test('should throw error if confirm token is not supported', async () => {
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: faker.datatype.uuid(),
                userType: RESIDENT,
            })
        }, {
            query: 'authenticateOrRegisterUserWithToken',
            code: 'BAD_USER_INPUT',
            type: 'INVALID_TOKEN',
            message: 'Invalid token',
            messageForUser: 'api.user.authenticateOrRegisterUserWithToken.INVALID_TOKEN',
        })
    })

    test('should throw error if confirm token is empty', async () => {
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: '',
                userType: RESIDENT,
            })
        }, {
            query: 'authenticateOrRegisterUserWithToken',
            code: 'BAD_USER_INPUT',
            type: 'INVALID_TOKEN',
            message: 'Invalid token',
            messageForUser: 'api.user.authenticateOrRegisterUserWithToken.INVALID_TOKEN',
        })
    })

    test('should throw error if phone token is expired', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, expiresAt: new Date().toISOString(),
        })
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: RESIDENT,
            })
        }, {
            query: 'authenticateOrRegisterUserWithToken',
            code: 'BAD_USER_INPUT',
            type: 'INVALID_TOKEN',
            message: 'Invalid token',
            messageForUser: 'api.user.authenticateOrRegisterUserWithToken.INVALID_TOKEN',
        })
    })

    test('should throw error if phone token is used', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, completedAt: new Date().toISOString(),
        })
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: RESIDENT,
            })
        }, {
            query: 'authenticateOrRegisterUserWithToken',
            code: 'BAD_USER_INPUT',
            type: 'INVALID_TOKEN',
            message: 'Invalid token',
            messageForUser: 'api.user.authenticateOrRegisterUserWithToken.INVALID_TOKEN',
        })
    })

    test('should throw error if phone token is deleted', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, completedAt: new Date().toISOString(),
        })
        await ConfirmPhoneAction.softDelete(adminClient, confirmPhoneAction.id)
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: RESIDENT,
            })
        }, {
            query: 'authenticateOrRegisterUserWithToken',
            code: 'BAD_USER_INPUT',
            type: 'INVALID_TOKEN',
            message: 'Invalid token',
            messageForUser: 'api.user.authenticateOrRegisterUserWithToken.INVALID_TOKEN',
        })
    })

    test('should throw error if phone token is not confirmed', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: false })
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: RESIDENT,
            })
        }, {
            query: 'authenticateOrRegisterUserWithToken',
            code: 'BAD_USER_INPUT',
            type: 'INVALID_TOKEN',
            message: 'Invalid token',
            messageForUser: 'api.user.authenticateOrRegisterUserWithToken.INVALID_TOKEN',
        })
    })

    test('should throw error if there are a lot of requests by ip per hour', async () => {
        for (let i = 0; i < 10; i++) {
            const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: RESIDENT,
            })
        }

        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: RESIDENT,
            })
        }, {
            code: 'BAD_USER_INPUT',
            type: 'TOO_MANY_REQUESTS',
            message: 'You have to wait {secondsRemaining} seconds to be able to send request again',
        })
    })

    // TODO(DOMA-9749): update test after migrate from addFieldValidationError to GQLError
    test('should throw error if an internal error occurs while creating or updating a user', async () => {
        const [staffWithSameEmail, staffWithSameEmailAttrs] = await createTestUser(adminClient, {
            email: faker.internet.email(),
        })
        const [staff, staffAttrs] = await createTestUser(adminClient, { email: undefined })

        // case with registered user
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, phone: staffAttrs.phone,
        })

        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: staff.type,
                userData: {
                    name: faker.name.fullName(),
                    password: faker.internet.password(16),
                    email: staffWithSameEmailAttrs.email,
                },
            })
        }, {
            'code': 'INTERNAL_ERROR',
            'message': '[unique:email:multipleFound] user already exists',
            'messageForDeveloper': expect.stringContaining('[error] Update User internal error'),
            'type': 'SUB_GQL_ERROR',
        })

        // case with unregistered user
        const [confirmPhoneAction2] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })

        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction2.token,
                userType: staff.type,
                userData: {
                    name: faker.name.fullName(),
                    password: faker.internet.password(16),
                    email: staffWithSameEmailAttrs.email,
                },
            })
        }, {
            'code': 'INTERNAL_ERROR',
            'message': '[unique:email:multipleFound] user already exists',
            'messageForDeveloper': expect.stringContaining('[error] Create User internal error'),
            'type': 'SUB_GQL_ERROR',
        })

        // case with invalid password
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction2.token,
                userType: staff.type,
                userData: {
                    name: faker.name.fullName(),
                    password: '123321123321',
                },
            })
        }, {
            'code': 'BAD_USER_INPUT',
            'message': 'Password must contain at least 4 different characters',
            'messageForDeveloper': expect.stringContaining('[error] Create User internal error'),
            'type': 'PASSWORD_CONSISTS_OF_SMALL_SET_OF_CHARACTERS',
            'variable': ['data', 'password'],
        })
    })

    test('should throw error if dv and sender not valid', async () => {
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, { isPhoneVerified: true })
        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: RESIDENT,
                dv: 123,
            })
        }, {
            query: 'authenticateOrRegisterUserWithToken',
            variable: ['data', 'dv'],
            code: 'BAD_USER_INPUT',
            type: 'DV_VERSION_MISMATCH',
            message: 'Wrong value for data version number',
        })

        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: RESIDENT,
                sender: { dv: 1, fingerprint: '-' },
            })
        }, {
            query: 'authenticateOrRegisterUserWithToken',
            variable: ['data', 'sender'],
            code: 'BAD_USER_INPUT',
            type: 'WRONG_FORMAT',
            message: 'Invalid format of "sender" field value. {details}',
            correctExample: '{ "dv": 1, "fingerprint": "uniq-device-or-container-id" }',
            messageInterpolation: { details: 'Please, check the example for details' },
        })
    })

    test('should throw error if try log in by confirm phone token if user phone is not verified, but email is verified', async () => {
        const [user, userAttrs] = await createTestUser(adminClient, { isEmailVerified: true, isPhoneVerified: false, type: RESIDENT })
        const [confirmPhoneAction] = await createTestConfirmPhoneAction(adminClient, {
            isPhoneVerified: true, phone: userAttrs.phone,
        })

        await expectToThrowGQLErrorToResult(async () => {
            await authenticateOrRegisterUserWithTokenByTestClient(anonymousClient, {
                token: confirmPhoneAction.token,
                userType: userAttrs.type,
            })
        }, {
            mutation: 'authenticateOrRegisterUserWithToken',
            code: 'BAD_USER_INPUT',
            type: 'SHOULD_AUTHORIZE_WITH_EMAIL',
            message: 'You should log in to your account using a verified email to be able to log in by phone',
            messageForUser: 'api.user.authenticateOrRegisterUserWithToken.SHOULD_AUTHORIZE_WITH_EMAIL',
        })
    })
})
