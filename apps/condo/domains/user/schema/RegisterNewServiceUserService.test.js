/**
 * Generated by `createservice user.RegisterNewServiceUserService`
 */
const dayjs = require('dayjs')

const { GQLInternalErrorTypes, GQLErrorCode } = require('@open-condo/keystone/errors')
const {
    makeLoggedInAdminClient, makeClient,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationError,
    expectToThrowUniqueConstraintViolationError, expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { SERVICE } = require('@condo/domains/user/constants/common')
const { GET_MY_USERINFO } = require('@condo/domains/user/gql')
const {
    registerNewServiceUserByTestClient,
    makeLoggedInClient,
    makeClientWithSupportUser,
    makeClientWithNewRegisteredAndLoggedInUser,
    User,
} = require('@condo/domains/user/utils/testSchema')

const { PASS_LENGTH, PASS_ALPHABET } = require('./RegisterNewServiceUserService')


describe('RegisterNewServiceUserService', () => {
    let admin
    let support
    let user
    let anonymous
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()
    })
    describe('Access tests', () => {
        test('Admin can create service user', async () => {
            const [{ email, password }] = await registerNewServiceUserByTestClient(admin)
            const serviceClient = await makeLoggedInClient({ email: email, password: password })
            const { data: { user } } = await serviceClient.query(GET_MY_USERINFO)
            expect(user.id).toEqual(serviceClient.user.id)
            expect(user.type).toEqual(SERVICE)
        })
        test('Support can create service user', async () => {
            const [{ email, password }] = await registerNewServiceUserByTestClient(support)
            const serviceClient = await makeLoggedInClient({ email: email, password: password })
            const { data: { user } } = await serviceClient.query(GET_MY_USERINFO)
            expect(user.id).toEqual(serviceClient.user.id)
            expect(user.type).toEqual(SERVICE)
        })
        test('User can not create service user', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerNewServiceUserByTestClient(user)
            })
        })
        test('Deleted support can not register service user', async () => {
            const anotherSupport = await makeClientWithSupportUser()
            await User.update(admin, anotherSupport.user.id, {
                dv: 1,
                sender: { dv: 1, fingerprint: 'tests' },
                deletedAt: dayjs().toISOString(),
            })
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerNewServiceUserByTestClient(anotherSupport)
            })
        })
        test('Anonymous can not register service user', async () => {
            await expectToThrowAuthenticationError(async () => {
                await registerNewServiceUserByTestClient(anonymous)
            }, 'result')
        })
    })
    describe('Logic tests', () => {
        test('can not register service user with existed email', async () => {
            const [, userAttrs] = await registerNewServiceUserByTestClient(admin)
            const email = userAttrs.email
            // TODO(DOMA-3146): change error format it's not friendly
            await expectToThrowGQLError(async () => {
                await registerNewServiceUserByTestClient(admin, { email })
            }, {
                'code': GQLErrorCode.INTERNAL_ERROR,
                'type': GQLInternalErrorTypes.SUB_GQL_ERROR,
                'message': '[unique:email:multipleFound] user already exists',
            }, 'result')
        })
        test('service user cannot be registered again if email registered for soft deleted user', async () => {
            const [user, userAttrs] = await registerNewServiceUserByTestClient(admin)
            await User.softDelete(admin, user.id)
            const email = userAttrs.email
            await expectToThrowUniqueConstraintViolationError(async () => {
                await registerNewServiceUserByTestClient(admin, { email })
            }, 'unique_type_and_email')
        })
        test('Password must be strong enough', async () => {
            const [{ password }] = await registerNewServiceUserByTestClient(admin)
            expect(password).toMatch(new RegExp(`^[${PASS_ALPHABET}]{${PASS_LENGTH}}$`))
        })
    })
})
