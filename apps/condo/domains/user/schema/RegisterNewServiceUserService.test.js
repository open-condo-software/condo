/**
 * Generated by `createservice user.RegisterNewServiceUserService`
 */
const dayjs = require('dayjs')

const { makeLoggedInAdminClient, makeClient } = require('@open-condo/keystone/test.utils')
const { expectToThrowAccessDeniedErrorToResult, expectToThrowAuthenticationError, catchErrorFrom } = require('@open-condo/keystone/test.utils')

const { SERVICE } = require('@condo/domains/user/constants/common')
const { EMAIL_ALREADY_REGISTERED_ERROR } = require('@condo/domains/user/constants/errors')
const { GET_MY_USERINFO } = require('@condo/domains/user/gql')
const {
    registerNewServiceUserByTestClient,
    makeLoggedInClient,
    makeClientWithSupportUser,
    makeClientWithNewRegisteredAndLoggedInUser,
    User,
} = require('@condo/domains/user/utils/testSchema')

const { PASS_LENGTH, PASS_ALPHABET } = require('./RegisterNewServiceUserService')

describe('RegisterNewServiceUserService', () => {
    let admin
    let support
    let user
    let anonymous
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeClientWithSupportUser()
        user = await makeClientWithNewRegisteredAndLoggedInUser()
        anonymous = await makeClient()
    })
    describe('Access tests', () => {
        test('Admin can create service user', async () => {
            const [{ email, password }] = await registerNewServiceUserByTestClient(admin)
            const serviceClient = await makeLoggedInClient({ email: email, password: password })
            const { data: { user } } = await serviceClient.query(GET_MY_USERINFO)
            expect(user.id).toEqual(serviceClient.user.id)
            expect(user.type).toEqual(SERVICE)
        })
        test('Support can create service user', async () => {
            const [{ email, password }] = await registerNewServiceUserByTestClient(support)
            const serviceClient = await makeLoggedInClient({ email: email, password: password })
            const { data: { user } } = await serviceClient.query(GET_MY_USERINFO)
            expect(user.id).toEqual(serviceClient.user.id)
            expect(user.type).toEqual(SERVICE)
        })
        test('User can not create service user', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerNewServiceUserByTestClient(user)
            })
        })
        test('Deleted support can not register service user', async () => {
            const anotherSupport = await makeClientWithSupportUser()
            await User.update(admin, anotherSupport.user.id, { dv: 1, sender: { dv: 1, fingerprint: 'tests' }, deletedAt: dayjs().toISOString() })
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await registerNewServiceUserByTestClient(anotherSupport)
            })
        })
        test('Anonymous can not register service user', async () => {
            await expectToThrowAuthenticationError(async () => {
                await registerNewServiceUserByTestClient(anonymous)
            }, 'result')
        })
    })
    describe('Logic tests', () => {
        test('can not register service user with existed email', async () => {
            const [, userAttrs] = await registerNewServiceUserByTestClient(admin)
            const email = userAttrs.email
            // TODO(DOMA-3146): use the GQLError util
            await catchErrorFrom(async () => {
                await registerNewServiceUserByTestClient(admin, { email })
            }, ({ errors }) => {
                expect(errors[0].originalError.errors[0].data.messages[0]).toEqual(
                    expect.stringContaining(EMAIL_ALREADY_REGISTERED_ERROR))
            })
        })
        test('Password must be strong enough', async () => {
            const [{ password }] = await registerNewServiceUserByTestClient(admin)
            expect(password).toMatch(new RegExp(`^[${PASS_ALPHABET}]{${PASS_LENGTH}}$`))
        })
    })
})
