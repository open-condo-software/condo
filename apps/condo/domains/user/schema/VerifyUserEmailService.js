/**
 * Generated by `createservice user.VerifyUserEmailService --type mutations`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, getByCondition } = require('@open-condo/keystone/schema')

const { COMMON_ERRORS } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/user/access/VerifyUserEmailService')
const { INVALID_TOKEN, UNSUPPORTED_TOKEN, TOKEN_NOT_FOUND } = require('@condo/domains/user/constants/errors')
const { User, ConfirmEmailAction } = require('@condo/domains/user/utils/serverSchema')
const { changeOrVerifyUserEmailGuard } = require('@condo/domains/user/utils/serverSchema/userEmailGuards')
const { detectTokenTypeSafely, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    DV_VERSION_MISMATCH: {
        ...COMMON_ERRORS.DV_VERSION_MISMATCH,
        mutation: 'verifyUserEmail',
    },
    WRONG_SENDER_FORMAT: {
        ...COMMON_ERRORS.WRONG_SENDER_FORMAT,
        mutation: 'verifyUserEmail',
    },
    INVALID_TOKEN: {
        mutation: 'verifyUserEmail',
        variable: ['data', 'confirmEmailToken'],
        code: BAD_USER_INPUT,
        type: INVALID_TOKEN,
        message: 'Invalid token',
        messageForUser: 'api.user.verifyUserEmail.INVALID_TOKEN',
    },
    UNSUPPORTED_TOKEN: {
        mutation: 'verifyUserEmail',
        variable: ['data', 'confirmEmailToken'],
        code: BAD_USER_INPUT,
        type: UNSUPPORTED_TOKEN,
        message: 'Unsupported token',
        messageForUser: 'api.user.verifyUserEmail.UNSUPPORTED_TOKEN',
    },
    TOKEN_NOT_FOUND: {
        mutation: 'verifyUserEmail',
        variable: ['data', 'confirmEmailToken'],
        code: BAD_USER_INPUT,
        type: TOKEN_NOT_FOUND,
        message: 'Unable to find non-expired ConfirmEmailAction by specified token',
        messageForUser: 'api.user.verifyUserEmail.TOKEN_NOT_FOUND',
    },
    DIFFERENT_EMAILS: {
        mutation: 'verifyUserEmail',
        code: BAD_USER_INPUT,
        type: 'DIFFERENT_EMAILS',
        message: 'The verified email and actual email cannot be different',
        messageForUser: 'api.user.verifyUserEmail.DIFFERENT_EMAILS',
    },
    EMPTY_USER_EMAIL: {
        mutation: 'verifyUserEmail',
        code: BAD_USER_INPUT,
        type: 'EMPTY_USER_EMAIL',
        message: 'User email is empty',
        messageForUser: 'api.user.verifyUserEmail.EMPTY_USER_EMAIL',
    },
}

const VerifyUserEmailService = new GQLCustomSchema('VerifyUserEmailService', {
    types: [
        {
            access: true,
            type: 'input VerifyUserEmailInput { dv: Int!, sender: SenderFieldInput!, confirmEmailToken: String! }',
        },
        {
            access: true,
            type: 'type VerifyUserEmailOutput { status: String! }',
        },
    ],

    mutations: [
        {
            access: access.canVerifyUserEmail,
            schema: 'verifyUserEmail(data: VerifyUserEmailInput!): VerifyUserEmailOutput',
            doc: {
                summary: 'Verifies the user\'s current email',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { confirmEmailToken, sender } = data

                await changeOrVerifyUserEmailGuard(context)

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                const { error: tokenError, tokenType } = detectTokenTypeSafely(confirmEmailToken)
                if (tokenError) {
                    throw new GQLError({ ...ERRORS.INVALID_TOKEN, data: { error: tokenError } }, context)
                }

                if (tokenType !== TOKEN_TYPES.CONFIRM_EMAIL) {
                    throw new GQLError(ERRORS.UNSUPPORTED_TOKEN, context)
                }

                const confirmEmailAction = await getByCondition('ConfirmEmailAction', {
                    token: confirmEmailToken,
                    expiresAt_gte: new Date().toISOString(),
                    completedAt: null,
                    isEmailVerified: true,
                    deletedAt: null,
                })

                if (!confirmEmailAction) {
                    throw new GQLError(ERRORS.TOKEN_NOT_FOUND, context)
                }

                const confirmedEmail = confirmEmailAction.email
                const actualEmail = context?.authedItem?.email
                const actualIsEmailVerified = context?.authedItem?.isEmailVerified

                if (!actualEmail) {
                    throw new GQLError(ERRORS.EMPTY_USER_EMAIL, context)
                }

                if (confirmedEmail !== actualEmail) {
                    throw new GQLError(ERRORS.DIFFERENT_EMAILS, context)
                }

                const currentUserId = context?.authedItem?.id
                await User.update(context, currentUserId, {
                    dv: 1,
                    sender,
                    isEmailVerified: true,
                })

                await ConfirmEmailAction.update(context, confirmEmailAction.id, {
                    dv: 1,
                    sender,
                    completedAt: new Date().toISOString(),
                })

                return {
                    status: 'ok',
                }
            },
        },
    ],

})

module.exports = {
    VerifyUserEmailService,
}
