/**
 * Generated by `createschema user.UserSudoToken 'token:Text; expiresAt:DateTimeUtc; user:Relationship:User:CASCADE; remainingUses:Integer'`
 */

const {
    makeLoggedInAdminClient, makeClient,
    DATETIME_RE,
    expectValuesOfCommonFields,
    expectToThrowGQLError,
    expectToThrowValidationFailureError,
    catchErrorFrom,
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAccessDeniedErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { MAX_NUMBER_OF_TOKEN_USES } = require('@condo/domains/user/constants/sudoToken')
const { 
    UserSudoToken,
    createTestUserSudoToken,
    updateTestUserSudoToken,
    createTestUser,
    makeClientWithSupportUser,
    makeClientWithResidentUser,
    makeClientWithStaffUser,
    makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')


describe('UserSudoToken', () => {
    let adminClient, supportClient, staffClient, residentClient, serviceClient, anonymousClient,
        user

    beforeAll(async () => {
        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()

        staffClient = await makeClientWithStaffUser()
        residentClient = await makeClientWithResidentUser()
        serviceClient = await makeClientWithServiceUser()

        anonymousClient = await makeClient();

        [user] = await createTestUser(adminClient)
    })

    describe('Accesses', () => {
        describe('Admin', () => {
            test('Can create', async () => {
                const [sudoToken, attrs] = await createTestUserSudoToken(adminClient, user)
                expectValuesOfCommonFields(sudoToken, attrs, adminClient)
                expect(sudoToken.token).toBeDefined()
                expect(sudoToken.token).not.toBeNull()
                expect(sudoToken.token).not.toBe('')
                expect(sudoToken.expiresAt).toMatch(DATETIME_RE)
                expect(sudoToken.user.id).toBe(user.id)
                expect(sudoToken.remainingUses).toBeDefined()
                expect(Number.isInteger(sudoToken.remainingUses)).toBeTruthy()
            })

            test('Can read', async () => {
                const [createdSudoToken] = await createTestUserSudoToken(adminClient, user)
                const token = await UserSudoToken.getOne(adminClient, { id: createdSudoToken.id })
                expect(token.id).toBe(createdSudoToken.id)
            })

            test('Can update', async () => {
                const [createdSudoToken] = await createTestUserSudoToken(adminClient, user)
                const [updatedSudoToken] = await updateTestUserSudoToken(adminClient, createdSudoToken.id, { deletedAt: new Date().toISOString() })
                expect(updatedSudoToken.id).toBe(createdSudoToken.id)
                expect(updatedSudoToken.deletedAt).not.toBeNull()
            })

            test('Cannot delete', async () => {
                const [createdSudoToken] = await createTestUserSudoToken(adminClient, user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await UserSudoToken.delete(adminClient, createdSudoToken.id)
                })
            })
        })

        describe('Support', () => {
            test('Cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestUserSudoToken(supportClient, user)
                })
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestUserSudoToken(supportClient, supportClient.user)
                })
            })

            test('Cannot read', async () => {
                const [sudoToken] = await createTestUserSudoToken(adminClient, user)
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, supportClient.user)
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await UserSudoToken.getAll(supportClient, { id_in: [sudoToken.id, selfSudoToken.id] })
                })
            })

            test('Cannot update', async () => {
                const [createdSudoToken] = await createTestUserSudoToken(adminClient, user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestUserSudoToken(supportClient, createdSudoToken.id, { deletedAt: new Date().toISOString() })
                })
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, supportClient.user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestUserSudoToken(supportClient, selfSudoToken.id, { deletedAt: new Date().toISOString() })
                })
            })

            test('Cannot delete', async () => {
                const [createdSudoToken] = await createTestUserSudoToken(adminClient, user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await UserSudoToken.delete(supportClient, createdSudoToken.id)
                })
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, supportClient.user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await UserSudoToken.delete(supportClient, selfSudoToken.id)
                })
            })
        })

        describe('User (staff)', () => {
            test('Cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestUserSudoToken(staffClient, staffClient.user)
                })
            })

            test('Cannot read', async () => {
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, staffClient.user)
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await UserSudoToken.getAll(staffClient, { id_in: [selfSudoToken.id] })
                })
            })

            test('Cannot update', async () => {
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, staffClient.user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestUserSudoToken(staffClient, selfSudoToken.id, { deletedAt: new Date().toISOString() })
                })
            })

            test('Cannot delete', async () => {
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, staffClient.user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await UserSudoToken.delete(staffClient, selfSudoToken.id)
                })
            })
        })

        describe('User (resident)', () => {
            test('Cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestUserSudoToken(residentClient, residentClient.user)
                })
            })

            test('Cannot read', async () => {
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, residentClient.user)
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await UserSudoToken.getAll(residentClient, { id_in: [selfSudoToken.id] })
                })
            })

            test('Cannot update', async () => {
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, residentClient.user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestUserSudoToken(residentClient, selfSudoToken.id, { deletedAt: new Date().toISOString() })
                })
            })

            test('Cannot delete', async () => {
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, residentClient.user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await UserSudoToken.delete(residentClient, selfSudoToken.id)
                })
            })
        })

        describe('User (service)', () => {
            test('Cannot create', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestUserSudoToken(serviceClient, serviceClient.user)
                })
            })

            test('Cannot read', async () => {
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, serviceClient.user)
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await UserSudoToken.getAll(serviceClient, { id_in: [selfSudoToken.id] })
                })
            })

            test('Cannot update', async () => {
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, serviceClient.user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestUserSudoToken(serviceClient, selfSudoToken.id, { deletedAt: new Date().toISOString() })
                })
            })

            test('Cannot delete', async () => {
                const [selfSudoToken] = await createTestUserSudoToken(adminClient, serviceClient.user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await UserSudoToken.delete(serviceClient, selfSudoToken.id)
                })
            })
        })

        describe('Anonymous', () => {
            test('Cannot create', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestUserSudoToken(anonymousClient, user)
                })
            })

            test('Cannot read', async () => {
                const [sudoToken] = await createTestUserSudoToken(adminClient, user)
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await UserSudoToken.getAll(anonymousClient, { id_in: [sudoToken.id] })
                })
            })

            test('Cannot update', async () => {
                const [sudoToken] = await createTestUserSudoToken(adminClient, user)
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestUserSudoToken(anonymousClient, sudoToken.id, { deletedAt: new Date().toISOString() })
                })
            })

            test('Cannot delete', async () => {
                const [sudoToken] = await createTestUserSudoToken(adminClient, user)
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await UserSudoToken.delete(anonymousClient, sudoToken.id)
                })
            })
        })
    })

    describe('Validations', () => {
        test('Should throw error if "remainingUses" less then 0', async () => {
            await expectToThrowGQLError(async () => {
                await createTestUserSudoToken(adminClient, user, { remainingUses: -1 })
            }, {
                variable: ['data', 'remainingUses'],
                code: 'INTERNAL_ERROR',
                type: 'REMAINING_USES_INVALID',
                message: `"remainingUses" field should not be less than 0 and not be more then ${MAX_NUMBER_OF_TOKEN_USES}`,
            })

            const [sudoToken] = await createTestUserSudoToken(adminClient, user, { remainingUses: 0 })
            await expectToThrowGQLError(async () => {
                await updateTestUserSudoToken(adminClient, sudoToken.id, { remainingUses: -1 })
            }, {
                variable: ['data', 'remainingUses'],
                code: 'INTERNAL_ERROR',
                type: 'REMAINING_USES_INVALID',
                message: `"remainingUses" field should not be less than 0 and not be more then ${MAX_NUMBER_OF_TOKEN_USES}`,
            })
        })

        test(`Should throw error if "remainingUses" more then ${MAX_NUMBER_OF_TOKEN_USES}`, async () => {
            await expectToThrowGQLError(async () => {
                await createTestUserSudoToken(adminClient, user, { remainingUses: MAX_NUMBER_OF_TOKEN_USES + 1 })
            }, {
                variable: ['data', 'remainingUses'],
                code: 'INTERNAL_ERROR',
                type: 'REMAINING_USES_INVALID',
                message: `"remainingUses" field should not be less than 0 and not be more then ${MAX_NUMBER_OF_TOKEN_USES}`,
            })
        })

        test('Should throw error if "remainingUses" increase', async () => {
            const [sudoToken] = await createTestUserSudoToken(adminClient, user, { remainingUses: 0 })
            await expectToThrowGQLError(async () => {
                await updateTestUserSudoToken(adminClient, sudoToken.id, { remainingUses: 1 })
            }, {
                variable: ['data', 'remainingUses'],
                code: 'BAD_USER_INPUT',
                type: 'INCREASE_REMAINING_USES_IS_NOT_AVAILABLE',
                message: 'Value of "remainingUses" field can only decrease',
            })
        })

        test('Should update token if "remainingUses" decrease', async () => {
            const [sudoToken] = await createTestUserSudoToken(adminClient, user, { remainingUses: 1 })
            const [updatedSudoToken] = await updateTestUserSudoToken(adminClient, sudoToken.id, { remainingUses: 0 })
            expect(updatedSudoToken.remainingUses).toBe(0)
        })

        test('Should throw error if pass empty "user" field', async () => {
            // TODO(pahaz): DOMA-10368 use expectToThrow??
            await catchErrorFrom(async () => {
                await createTestUserSudoToken(adminClient, user, { user: undefined })
            }, ({ errors }) => {
                expect(errors[0].message).toMatch('null value in column "user" of relation "UserSudoToken" violates not-null constraint')
                expect(errors).toMatchObject([{
                    name: 'GraphQLError',
                    path: ['obj'],
                }])
            })
        })

        test('Should throw error if pass empty "token" field', async () => {
            await expectToThrowValidationFailureError(async () => {
                await createTestUserSudoToken(adminClient, user, { token: undefined })
            }, 'Required field "token" is null or undefined.')
        })

        test('Should throw error if pass empty "expiresAt" field', async () => {
            await expectToThrowValidationFailureError(async () => {
                await createTestUserSudoToken(adminClient, user, { expiresAt: undefined })
            }, 'Required field "expiresAt" is null or undefined.')
        })

        test('Should throw error if pass empty "remainingUses" field', async () => {
            await expectToThrowValidationFailureError(async () => {
                await createTestUserSudoToken(adminClient, user, { remainingUses: undefined })
            }, 'Required field "remainingUses" is null or undefined.')
        })
    })
})
