/**
 * Generated by `createservice user.ConfirmEmailActionService --type queries`
 */

const get = require('lodash/get')
const isEmpty = require('lodash/isEmpty')
const pick = require('lodash/pick')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const { EMAIL_VERIFY_CODE_MESSAGE_TYPE } = require('@condo/domains/notification/constants/constants')
const { sendMessage } = require('@condo/domains/notification/utils/serverSchema')
const {
    LOCK_TIMEOUT,
    CONFIRM_EMAIL_MAX_RETRIES,
    MAX_REQUESTS_FOR_IP_PER_DAY,
    MAX_REQUESTS_FOR_EMAIL_PER_DAY,
    EMAIL_CODE_TTL,
    CONFIRM_EMAIL_ACTION_EXPIRY,
} = require('@condo/domains/user/constants/common')
const {
    CAPTCHA_CHECK_FAILED,
    UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION,
    EMAIL_CODE_EXPIRED,
    EMAIL_CODE_MAX_RETRIES_REACHED,
    EMAIL_CODE_VERIFICATION_FAILED,
    GENERATE_TOKEN_FAILED,
    GQL_ERRORS,
    DV_VERSION_MISMATCH,
    WRONG_FORMAT,
    WRONG_EMAIL_FORMAT,
} = require('@condo/domains/user/constants/errors')
const { EMAIL_COUNTER_LIMIT_TYPE } = require('@condo/domains/user/constants/limits')
const { captchaCheck } = require('@condo/domains/user/utils/hCaptcha')
const { ConfirmEmailAction, generateEmailCode } =  require('@condo/domains/user/utils/serverSchema')
const { RedisGuard } = require('@condo/domains/user/utils/serverSchema/guards')
const { TOKEN_TYPES, generateTokenSafely } = require('@condo/domains/user/utils/tokens')
const { extractReqLocale } = require('@dev-portal-api/domains/common/utils/messages')


const redisGuard = new RedisGuard() 

/** 
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    DV_VERSION_MISMATCH: {
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
    },
    WRONG_SENDER_FORMAT: {
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value. {details}',
        correctExample: '{ "dv": 1, "fingerprint": "uniq-device-or-container-id" }',
        messageInterpolation: { details: 'Please, check the example for details' },
    },
    CAPTCHA_CHECK_FAILED: {
        variable: ['data', 'captcha'],
        code: BAD_USER_INPUT,
        type: CAPTCHA_CHECK_FAILED,
        message: 'Failed to check CAPTCHA',
        messageForUser: 'api.user.CAPTCHA_CHECK_FAILED',
    },
    UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION: {
        variable: ['data', 'token'],
        code: BAD_USER_INPUT,
        type: UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION,
        message: 'Confirm email action was expired or it could not be found. Try to initiate email confirmation again',
        messageForUser: 'api.user.UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION',
    },
    WRONG_EMAIL_FORMAT: {
        mutation: 'startConfirmEmailAction',
        variable: ['data', 'email'],
        code: BAD_USER_INPUT,
        type: WRONG_EMAIL_FORMAT,
        message: 'Wrong format of provided email address',
        correctExample: 'mail@example.com',
        messageForUser: 'api.common.WRONG_EMAIL_FORMAT',
    },
    EMAIL_CODE_EXPIRED: {
        mutation: 'completeConfirmEmailAction',
        variable: ['data', 'emailCode'],
        code: BAD_USER_INPUT,
        type: EMAIL_CODE_EXPIRED,
        message: 'Email code expired. Try to initiate email confirmation again',
        messageForUser: 'api.user.completeConfirmEmailAction.EMAIL_CODE_EXPIRED',
    },
    EMAIL_CODE_MAX_RETRIES_REACHED: {
        mutation: 'completeConfirmEmailAction',
        variable: ['data', 'emailCode'],
        code: BAD_USER_INPUT,
        type: EMAIL_CODE_VERIFICATION_FAILED,
        message: 'Max retries reached for email code confirmation. Try to initiate email confirmation again',
        messageForUser: 'api.user.completeConfirmEmailAction.EMAIL_CODE_VERIFICATION_FAILED',
    },
    EMAIL_CODE_VERIFICATION_FAILED: {
        mutation: 'completeConfirmEmailAction',
        variable: ['data', 'emailCode'],
        code: BAD_USER_INPUT,
        type: EMAIL_CODE_MAX_RETRIES_REACHED,
        message: 'Email code verification mismatch',
        messageForUser: 'api.user.completeConfirmEmailAction.EMAIL_CODE_MAX_RETRIES_REACHED',
    },
    GENERATE_TOKEN_ERROR: {
        mutation: 'completeConfirmEmailAction',
        code: INTERNAL_ERROR,
        type: GENERATE_TOKEN_FAILED,
        message: 'Generate token failed',
    },
}

const emailWhiteList = Object.keys(conf.EMAIL_WHITE_LIST ? JSON.parse(conf.EMAIL_WHITE_LIST) : {})
const ipWhiteList = conf.IP_WHITE_LIST ? JSON.parse(conf.IP_WHITE_LIST) : []
const maxEmailForIpByDay = Number(conf['MAX_REQUESTS_FOR_IP_PER_DAY']) || MAX_REQUESTS_FOR_IP_PER_DAY
const maxSendForEmailByDay = Number(conf['MAX_REQUESTS_FOR_EMAIL_PER_DAY']) || MAX_REQUESTS_FOR_EMAIL_PER_DAY
const APP_ID_HEADER = 'x-request-app'

const checkEmailDayLimitCounters = async (email, rawIp, context) => {
    const ip = rawIp.split(':').pop()
    const byEmailCounter = await redisGuard.incrementDayCounter(`${EMAIL_COUNTER_LIMIT_TYPE}:${email}`)
    if (byEmailCounter > maxSendForEmailByDay && !emailWhiteList.includes(email)) {
        throw new GQLError(GQL_ERRORS.DAILY_REQUEST_LIMIT_FOR_EMAIL_REACHED, context)
    }
    const byIpCounter = await redisGuard.incrementDayCounter(`${EMAIL_COUNTER_LIMIT_TYPE}:${ip}`)
    if (byIpCounter > maxEmailForIpByDay && !ipWhiteList.includes(ip)) {
        throw new GQLError(GQL_ERRORS.DAILY_REQUEST_LIMIT_FOR_IP_REACHED, context)
    }
}

const ConfirmEmailActionService = new GQLCustomSchema('ConfirmEmailActionService', {
    types: [
        {
            access: true,
            type: 'input GetEmailByConfirmEmailActionInput { token: String!, captcha: String! }',
        },
        {
            access: true,
            type: 'type GetEmailByConfirmEmailActionOutput { email: String!, isEmailVerified: Boolean! }',
        },
        {
            access: true,
            type: 'input StartConfirmEmailActionInput { dv: Int!, sender: SenderFieldInput!, captcha: String!, email: String! }',
        },
        {
            access: true,
            type: 'type StartConfirmEmailActionOutput { token: String! }',
        },
        {
            access: true,
            type: 'input ResendConfirmEmailActionInput { dv: Int!, sender: SenderFieldInput!, captcha: String!, token: String! }',
        },
        {
            access: true,
            type: 'type ResendConfirmEmailActionOutput { status: String! }',
        },
        {
            access: true,
            type: 'input CompleteConfirmEmailActionInput { dv: Int!, sender: SenderFieldInput!, captcha: String!, token: String!, emailCode: Int! }',
        },
        {
            access: true,
            type: 'type CompleteConfirmEmailActionOutput { status: String! }',
        },
    ],
    queries: [
        {
            access: true,
            schema: 'getEmailByConfirmEmailAction(data: GetEmailByConfirmEmailActionInput!): GetEmailByConfirmEmailActionOutput',
            doc: {
                summary: 'Returns email information from ConfirmEmailAction that matches the provided search conditions',
                errors: pick(ERRORS, [
                    CAPTCHA_CHECK_FAILED,
                    UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION,
                ]), 
            },
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data } = args
                const { token, captcha } = data
                const { error } = await captchaCheck(context, captcha)
                if (error) {
                    throw new GQLError({ ...ERRORS.CAPTCHA_CHECK_FAILED, mutation: 'getEmailByConfirmEmailAction', data: { error } }, context)
                }
                const now = extra.extraNow || Date.now()
                const actions = await ConfirmEmailAction.getAll(context, {
                    token,
                    expiresAt_gte: new Date(now).toISOString(),
                    completedAt: null,
                }, 'email isEmailVerified')
                if (isEmpty(actions)) {
                    throw new GQLError({ ...ERRORS.UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION, mutation: 'getEmailByConfirmEmailAction' }, context)
                }
                console.log('actions', actions)
                const { email, isEmailVerified } = actions[0]
                return { email, isEmailVerified }
            },
        },
    ],
    mutations: [
        {
            access: true,
            schema: 'startConfirmEmailAction(data: StartConfirmEmailActionInput!): StartConfirmEmailActionOutput',
            doc: {
                summary: 'Sends a confirmation email and returns a confirmation token. Use the token for completeConfirmEmailAction mutation to verify the email.',
                errors: {
                    ...pick(ERRORS, [
                        CAPTCHA_CHECK_FAILED,
                        WRONG_EMAIL_FORMAT,
                    ]),
                    TOO_MANY_REQUESTS: GQL_ERRORS.TOO_MANY_REQUESTS,
                    DAILY_REQUEST_LIMIT_FOR_EMAIL_REACHED: GQL_ERRORS.DAILY_REQUEST_LIMIT_FOR_EMAIL_REACHED,
                    DAILY_REQUEST_LIMIT_FOR_IP_REACHED: GQL_ERRORS.DAILY_REQUEST_LIMIT_FOR_IP_REACHED,
                },
            },
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data } = args
                const { email: inputEmail, sender, captcha } = data
                checkDvAndSender(data, { ...ERRORS.DV_VERSION_MISMATCH, mutation: 'startConfirmEmailAction' }, { ...ERRORS.WRONG_SENDER_FORMAT, mutation: 'startConfirmEmailAction' }, context)
                const { error } = await captchaCheck(context, captcha)
                if (error) {
                    throw new GQLError({ ...ERRORS.CAPTCHA_CHECK_FAILED, mutation: 'startConfirmEmailAction', data: { error } }, context)
                }
                const email = normalizeEmail(inputEmail)
                if (!email) {
                    throw new GQLError(ERRORS.WRONG_EMAIL_FORMAT, context)
                }
                await checkEmailDayLimitCounters(email, context.req.ip, context)
                await redisGuard.checkLock(email, 'sendemail', context)
                await redisGuard.lock(email, 'sendemail', EMAIL_CODE_TTL)
                const { error: tokenError, token } = generateTokenSafely(TOKEN_TYPES.CONFIRM_EMAIL)
                if (tokenError) {
                    throw new GQLError({ ...ERRORS.GENERATE_TOKEN_ERROR, data: { error: tokenError } }, context)
                }
                const now = extra.extraNow || Date.now()
                const requestedAt = new Date(now).toISOString()
                const expiresAt = new Date(now + CONFIRM_EMAIL_ACTION_EXPIRY * 1000).toISOString()
                const emailCode = generateEmailCode(email)
                const emailCodeRequestedAt = new Date(now).toISOString()
                const emailCodeExpiresAt = new Date(now + EMAIL_CODE_TTL * 1000).toISOString()
                const variables = {
                    dv: 1,
                    sender,
                    email,
                    emailCode,
                    token,
                    emailCodeRequestedAt,
                    emailCodeExpiresAt,
                    requestedAt,
                    expiresAt,
                }

                const isInvalidData = await redisGuard.isLocked(captcha, 'validation-failed')
                if (isInvalidData) return { token }

                await ConfirmEmailAction.create(context, variables)

                const appId = get(context.req, ['headers', APP_ID_HEADER])
                const locale = extractReqLocale(context.req)
                await sendMessage(context, {
                    to: { email },
                    lang: locale,
                    type: EMAIL_VERIFY_CODE_MESSAGE_TYPE,
                    meta: {
                        dv: 1,
                        emailCode,
                        appId,
                    },
                    sender,
                })
                return { token }
            },
        },
        {
            access: true,
            schema: 'resendConfirmEmailAction(data: ResendConfirmEmailActionInput!): ResendConfirmEmailActionOutput',
            doc: {
                summary: 'Resend the confirm email message for existing token',
                errors: {
                    ...pick(ERRORS, [
                        CAPTCHA_CHECK_FAILED,
                        UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION,
                    ]),
                    TOO_MANY_REQUESTS: GQL_ERRORS.TOO_MANY_REQUESTS,
                    DAILY_REQUEST_LIMIT_FOR_EMAIL_REACHED: GQL_ERRORS.DAILY_REQUEST_LIMIT_FOR_EMAIL_REACHED,
                    DAILY_REQUEST_LIMIT_FOR_IP_REACHED: GQL_ERRORS.DAILY_REQUEST_LIMIT_FOR_IP_REACHED,
                },
            },
            resolver: async (parent, args, context, info, extra) => {
                const { data } = args
                const { token, sender, captcha } = data
                checkDvAndSender(data, { ...ERRORS.DV_VERSION_MISMATCH, mutation: 'resendConfirmEmailAction' }, { ...ERRORS.WRONG_SENDER_FORMAT, mutation: 'resendConfirmEmailAction' }, context)
                const { error } = await captchaCheck(context, captcha)
                if (error) {
                    throw new GQLError({ ...ERRORS.CAPTCHA_CHECK_FAILED, mutation: 'resendConfirmEmailAction', data: { error } }, context)
                }

                const now = extra.extraNow || Date.now()
                const actions = await ConfirmEmailAction.getAll(context, {
                    token,
                    expiresAt_gte: new Date(now).toISOString(),
                    completedAt: null,
                }, 'id email')
                if (isEmpty(actions)) {
                    throw new GQLError({ ...ERRORS.UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION, mutation: 'resendConfirmEmailAction' }, context)
                }
                const { id, email } = actions[0]
                await checkEmailDayLimitCounters(email, context.req.ip, context)
                await redisGuard.checkLock(email, 'sendemail', context)
                await redisGuard.lock(email, 'sendemail', EMAIL_CODE_TTL)
                const newEmailCode = generateEmailCode(email)
                await ConfirmEmailAction.update(context, id, {
                    dv: 1,
                    sender,
                    emailCode: newEmailCode,
                    emailCodeExpiresAt: new Date(now + EMAIL_CODE_TTL * 1000).toISOString(),
                    emailCodeRequestedAt: new Date(now).toISOString(),
                })

                const appId = get(context.req, ['headers', APP_ID_HEADER])
                const locale = extractReqLocale(context.req)
                await sendMessage(context, {
                    to: { email },
                    lang: locale,
                    type: EMAIL_VERIFY_CODE_MESSAGE_TYPE,
                    meta: {
                        dv: 1,
                        emailCode: newEmailCode,
                        appId,
                    },
                    sender,
                })
                
                return { status: 'ok' }
            },
        },
        {
            access: true,
            schema: 'completeConfirmEmailAction(data: CompleteConfirmEmailActionInput!): CompleteConfirmEmailActionOutput',
            doc: {
                summary: 'Completes the email confirmation process using the token from startConfirmEmailAction and the code from the email.',
                errors: {
                    ...pick(ERRORS, [
                        CAPTCHA_CHECK_FAILED,
                        UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION,
                        EMAIL_CODE_EXPIRED,
                        EMAIL_CODE_MAX_RETRIES_REACHED,
                        EMAIL_CODE_VERIFICATION_FAILED,
                    ]),
                    TOO_MANY_REQUESTS: GQL_ERRORS.TOO_MANY_REQUESTS,
                },
            },
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data } = args
                const { token, emailCode, sender, captcha } = data
                checkDvAndSender(data, { ...ERRORS.DV_VERSION_MISMATCH, mutation: 'completeConfirmEmailAction' }, { ...ERRORS.WRONG_SENDER_FORMAT, mutation: 'completeConfirmEmailAction' }, context)
                const { error } = await captchaCheck(context, captcha)
                if (error) {
                    throw new GQLError({ ...ERRORS.CAPTCHA_CHECK_FAILED, mutation: 'completeConfirmEmailAction', data: { error } }, context)
                }
                const now = extra.extraNow || Date.now()
                const actions = await ConfirmEmailAction.getAll(context, {
                    token,
                    expiresAt_gte: new Date(now).toISOString(),
                    completedAt: null,
                }, 'id emailCode retries emailCodeExpiresAt')
                if (isEmpty(actions)) {
                    throw new GQLError({ ...ERRORS.UNABLE_TO_FIND_CONFIRM_EMAIL_ACTION, mutation: 'completeConfirmEmailAction' }, context)
                }
                await redisGuard.checkLock(token, 'confirm', context)
                await redisGuard.lock(token, 'confirm', LOCK_TIMEOUT)
                const { id, emailCode: actionEmailCode, retries, emailCodeExpiresAt } = actions[0]
                const isExpired = (new Date(emailCodeExpiresAt) < new Date(now))
                if (isExpired) {
                    throw new GQLError(ERRORS.EMAIL_CODE_EXPIRED, context)
                }
                if (retries >= CONFIRM_EMAIL_MAX_RETRIES) {
                    await ConfirmEmailAction.update(context, id, {
                        dv: 1,
                        sender,
                        completedAt: new Date(now).toISOString(),
                    })
                    throw new GQLError(ERRORS.EMAIL_CODE_MAX_RETRIES_REACHED, context)
                }
                if (actionEmailCode !== emailCode) {
                    await ConfirmEmailAction.update(context, id, {
                        dv: 1,
                        sender,
                        retries: retries + 1,
                    })
                    throw new GQLError(ERRORS.EMAIL_CODE_VERIFICATION_FAILED, context)
                }
                await ConfirmEmailAction.update(context, id, {
                    dv: 1,
                    sender,
                    isEmailVerified: true,
                })
                return { status: 'ok' }
            },
        },
    ],
})

module.exports = {
    ConfirmEmailActionService,
}
