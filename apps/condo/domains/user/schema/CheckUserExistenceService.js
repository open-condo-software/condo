/**
 * Generated by `createservice user.CheckUserExistenceService --type queries`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, getByCondition } = require('@open-condo/keystone/schema')

const { NOT_FOUND, COMMON_ERRORS } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/user/access/CheckUserExistenceService')
const { CAPTCHA_CHECK_FAILED, INVALID_TOKEN, UNSUPPORTED_TOKEN } = require('@condo/domains/user/constants/errors')
const { GQL_ERRORS: USER_ERRORS } = require('@condo/domains/user/constants/errors')
const { captchaCheck } = require('@condo/domains/user/utils/hCaptcha')
const { ConfirmPhoneAction, ConfirmEmailAction } = require('@condo/domains/user/utils/serverSchema')
const {
    checkDailyRequestLimitCountersByIp,
    checkDailyRequestLimitCountersByPhone,
    checkDailyRequestLimitCountersByEmail,
} = require('@condo/domains/user/utils/serverSchema/requestLimitHelpers')
const { detectTokenTypeSafely, TOKEN_TYPES } = require('@condo/domains/user/utils/tokens')


/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    TOKEN_NOT_FOUND: {
        query: 'checkUserExistence',
        variable: ['data', 'token'],
        code: NOT_FOUND,
        type: 'TOKEN_NOT_FOUND',
        message: 'Token not found',
    },
    CAPTCHA_CHECK_FAILED: {
        query: 'checkUserExistence',
        variable: ['data', 'captcha'],
        code: BAD_USER_INPUT,
        type: CAPTCHA_CHECK_FAILED,
        message: 'Failed to check CAPTCHA',
        messageForUser: 'api.user.CAPTCHA_CHECK_FAILED',
    },
    DV_VERSION_MISMATCH: {
        ...COMMON_ERRORS.DV_VERSION_MISMATCH,
        query: 'checkUserExistence',
    },
    WRONG_SENDER_FORMAT: {
        ...COMMON_ERRORS.WRONG_SENDER_FORMAT,
        query: 'checkUserExistence',
    },
    INVALID_TOKEN: {
        query: 'checkUserExistence',
        code: BAD_USER_INPUT,
        type: INVALID_TOKEN,
        message: 'Invalid token',
    },
    UNSUPPORTED_TOKEN: {
        query: 'checkUserExistence',
        code: BAD_USER_INPUT,
        type: UNSUPPORTED_TOKEN,
        message: 'Unsupported token',
    },
    DAILY_REQUEST_LIMIT_FOR_IP_REACHED: {
        ...USER_ERRORS.DAILY_REQUEST_LIMIT_FOR_IP_REACHED,
    },
    DAILY_REQUEST_LIMIT_FOR_PHONE_REACHED: {
        ...USER_ERRORS.DAILY_REQUEST_LIMIT_FOR_PHONE_REACHED,
    },
}

const SUPPORTED_TOKENS = [
    TOKEN_TYPES.CONFIRM_PHONE,
    TOKEN_TYPES.CONFIRM_EMAIL,
]

const CheckUserExistenceService = new GQLCustomSchema('CheckUserExistenceService', {
    types: [
        {
            access: true,
            type: 'input CheckUserExistenceInput { dv: Int!, sender: SenderFieldInput!, token: String!, userType: UserTypeType!, captcha: String }',
        },
        {
            access: true,
            type: 'type CheckUserExistenceOutput { isUserExists: Boolean!, isNameSet: Boolean!, isEmailSet: Boolean!, isPhoneSet: Boolean!, isPasswordSet: Boolean! }',
        },
    ],

    queries: [
        {
            access: access.canCheckUserExistence,
            schema: 'checkUserExistence(data: CheckUserExistenceInput!): CheckUserExistenceOutput',
            doc: {
                summary: 'Using an action token with a verified phone number,' +
                    ' checks whether a user with the specified type (resident, staff, service) is registered.\n' +
                    'As a result, information about the completion of some important fields (name, email, phone, password) is also returned.',
                description: 'Token can be: \n' +
                    ' - confirmPhoneToken' +
                    ' - confirmEmailToken',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args
                const { token, userType, captcha } = data

                await checkDailyRequestLimitCountersByIp(context, 'checkUserExistence', context.req.ip)

                const { error: captchaError } = await captchaCheck(context, captcha)
                if (captchaError) {
                    throw new GQLError({ ...ERRORS.CAPTCHA_CHECK_FAILED, data: { error: captchaError } }, context)
                }

                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                if (!token) throw new GQLError(ERRORS.TOKEN_NOT_FOUND, context)

                const { error: tokenError, tokenType } = detectTokenTypeSafely(token)
                if (tokenError) {
                    throw new GQLError({ ...ERRORS.INVALID_TOKEN, data: { error: tokenError } }, context)
                }

                if (!SUPPORTED_TOKENS.includes(tokenType)) {
                    throw new GQLError(ERRORS.UNSUPPORTED_TOKEN, context)
                }

                let user

                if (tokenType === TOKEN_TYPES.CONFIRM_PHONE) {
                    const action = await ConfirmPhoneAction.getOne(context,
                        {
                            token: token,
                            expiresAt_gte: new Date().toISOString(),
                            completedAt: null,
                            isPhoneVerified: true,
                            deletedAt: null,
                        },
                        'id phone'
                    )
                    if (!action) throw new GQLError(ERRORS.TOKEN_NOT_FOUND, context)

                    await checkDailyRequestLimitCountersByPhone(context, 'checkUserExistence', action.phone)

                    user = await getByCondition('User', {
                        type: userType,
                        phone: action.phone,
                        deletedAt: null,
                    })
                } else if (tokenType === TOKEN_TYPES.CONFIRM_EMAIL) {
                    const action = await ConfirmEmailAction.getOne(context,
                        {
                            token: token,
                            expiresAt_gte: new Date().toISOString(),
                            completedAt: null,
                            isEmailVerified: true,
                            deletedAt: null,
                        },
                        'id email'
                    )
                    if (!action) throw new GQLError(ERRORS.TOKEN_NOT_FOUND, context)

                    await checkDailyRequestLimitCountersByEmail(context, 'checkUserExistence', action.email)

                    user = await getByCondition('User', {
                        type: userType,
                        email: action.email,
                        deletedAt: null,
                    })
                }

                const result = {
                    isUserExists: false,
                    isNameSet: false,
                    isEmailSet: false,
                    isPhoneSet: false,
                    isPasswordSet: false,
                }

                if (!user) return result

                result.isUserExists = true
                result.isNameSet = Boolean(user?.name ?? null)
                result.isEmailSet = Boolean(user?.email ?? null)
                result.isPhoneSet = Boolean(user?.phone ?? null)
                result.isPasswordSet = Boolean(user?.password ?? null)

                return result
            },
        },
    ],
})

module.exports = {
    CheckUserExistenceService,
    ERRORS,
}
