/**
 * Generated by `createschema user.UserExternalIdentity`
 */

const { GQLError } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/user/access/UserExternalIdentity')
const { USER_TYPES } = require('@condo/domains/user/constants/common')
const { ERRORS } = require('@condo/domains/user/constants/errors')
const { RUNTIME_IDP_TYPES } = require('@condo/domains/user/constants/identityProviders')

const UserExternalIdentity = new GQLListSchema('UserExternalIdentity', {
    schemaDoc: 'Individual user external identity link. Used primarily for authorization and linking to external identity provider purposes. Think of `User` as a technical entity, not a business actor.',
    fields: {
        user: {
            schemaDoc: 'User associated with this external identity.',
            type: 'Relationship',
            ref: 'User',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },
        identityId: {
            schemaDoc: 'Identifier provided by the external identity provider.',
            type: 'Text',
            isRequired: true,
        },
        identityType: {
            schemaDoc: 'Type of external identity provider associated with this link.',
            type: 'Text',
            isRequired: true,
            hooks: {
                validateInput: async ({ resolvedData, context }) => {
                    const identityType = resolvedData['identityType']
                    if (!RUNTIME_IDP_TYPES.includes(identityType)) {
                        throw new GQLError(ERRORS.WRONG_USER_EXTERNAL_IDENTITY_TYPE, context)
                    }
                },
            },
        },
        userType: {
            schemaDoc: 'Type of the linked user.',
            type: 'Select',
            options: USER_TYPES,
            isRequired: true,
        },
        meta: {
            schemaDoc: 'Metadata returned by the external identity provider.',
            type: 'Json',
        },
    },
    hooks: {
        validateInput: async ({ context, operation, resolvedData, existingItem }) => {
            const userIsUpdated = resolvedData?.user && resolvedData.user !== existingItem?.user
            const userTypeIsUpdated = resolvedData?.userType && resolvedData.userType !== existingItem?.userType
            if (operation === 'create' || userIsUpdated || userTypeIsUpdated) {
                const newUserId = resolvedData?.user || existingItem?.user
                const newUserType = resolvedData?.userType || existingItem?.userType
                const user = await getById('User', newUserId)
                if (user.type !== newUserType) {
                    throw new GQLError(ERRORS.WRONG_USER_TYPE, context)
                }
            }

        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['identityId', 'identityType', 'userType'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'userExternalIdentity_unique_identityid_and_identitytype_and_usertype',
            },
        ],
    },
    plugins: [
        uuided(),
        versioned(),
        tracked(),
        softDeleted(),
        dvAndSender(),
        historical(),
    ],
    access: {
        read: access.canReadUserExternalIdentities,
        create: access.canManageUserExternalIdentities,
        update: access.canManageUserExternalIdentities,
        delete: false,
        auth: true,
    },
})

module.exports = {
    UserExternalIdentity,
}
