/**
 * Generated by `createschema user.UserExternalIdentity`
 */

const { get } = require('lodash')
const { Text, Select, Relationship } = require('@keystonejs/fields')
const { Json } = require('@open-condo/keystone/fields')
const { GQLListSchema, getById } = require('@open-condo/keystone/schema')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')

const { IDP_TYPES, RESIDENT } = require('@condo/domains/user/constants/common')

const access = require('@condo/domains/user/access/UserExternalIdentity')

const UserExternalIdentity = new GQLListSchema('UserExternalIdentity', {
    schemaDoc: 'Individual user external identity link. Used primarily for authorization and linking to external idp purposes. Think of `User` as a technical entity, not a business actor.',
    fields: {
        user: {
            schemaDoc: 'Link to user',
            type: Relationship,
            ref: 'User',
            isRequired: false,
            knexOptions: { isNotNullable: false }, // Required relationship only!
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            hooks: {
                validateInput: async ({ operation, resolvedData, fieldPath, addFieldValidationError }) => {
                    if (operation === 'create') {
                        const userId = get(resolvedData, fieldPath)
                        if (!userId) {
                            addFieldValidationError('No user specified')
                            return
                        }
                        const user = await getById('User', userId)
                        const userType = get(user, 'type')
                        if ( userType !== RESIDENT) {
                            addFieldValidationError('Cannot create UserExternalIdentity to non-resident type of user')
                        }
                    }
                },
            },
        },
        identityId: {
            schemaDoc: 'External identity id. The value of this field should be populated from an external identity provider',
            type: Text,
        },
        identityType: {
            schemaDoc: 'The type of external identity that was a source for this link',
            type: Select,
            dataType: 'enum',
            options: IDP_TYPES,
            isRequired: true,
        },
        meta: {
            schemaDoc: 'External identity provider user metadata',
            type: Json,
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['identityId', 'identityType'],
                name: 'unique_identityid_and_identitytype',
            },
        ],
    },
    plugins: [
        uuided(),
        versioned(),
        tracked(),
        softDeleted(),
        dvAndSender(),
        historical(),
    ],
    access: {
        read: access.canReadUserExternalIntegrations,
        create: access.canManageUserExternalIntegrations,
        update: access.canManageUserExternalIntegrations,
        delete: access.canManageUserExternalIntegrations,
        auth: true,
    },
})

module.exports = {
    UserExternalIdentity,
}
