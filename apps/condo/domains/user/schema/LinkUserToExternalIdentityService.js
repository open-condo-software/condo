/**
 * Generated by `createservice user.LinkUserToExternalIdentityService`
 */
const { isNil, get } = require('lodash')

const { GQLCustomSchema } = require('@open-condo/keystone/schema')
const access = require('@condo/domains/user/access/LinkUserToExternalIdentityService')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')


const { UserExternalIdentity, registerUserExternalIdentity } = require('@condo/domains/user/utils/serverSchema')
const { getIdentityIntegration } = require('@condo/domains/user/integration/identity')
const { IDENTITY_INTEGRATION_DOES_NOT_SUPPORT_LOGIN_FORM, EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR } = require('@condo/domains/user/constants/errors')
const { DV_VERSION_MISMATCH, WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const errors = {
    DV_VERSION_MISMATCH: {
        mutation: 'linkUserToExternalIdentity',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Unsupported value for dv',
    },
    WRONG_SENDER_FORMAT: {
        mutation: 'linkUserToExternalIdentity',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value. {details}',
        correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
    },
    IDENTITY_INTEGRATION_DOES_NOT_SUPPORT_LOGIN_FORM: {
        mutation: 'linkUserToExternalIdentity',
        variable: ['data', 'identityType'],
        code: BAD_USER_INPUT,
        type: IDENTITY_INTEGRATION_DOES_NOT_SUPPORT_LOGIN_FORM,
        message: 'Identity integration does not support login form',
    },
    EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR: {
        mutation: 'linkUserToExternalIdentity',
        variable: ['data', 'tokenSet'],
        code: BAD_USER_INPUT,
        type: EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR,
        message: 'External identity already registered',
        messageForUser: 'api.user.registerNewUserThroughExternalIdentity.EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR',
    },
}

const LinkUserToExternalIdentityService = new GQLCustomSchema('LinkUserToExternalIdentityService', {
    types: [
        {
            access: true,
            type: 'input LinkUserToExternalIdentityInput { dv: Int! sender: SenderFieldInput!, identityType: IdentityType!, tokenSet: JSON! }',
        },
        {
            access: true,
            type: 'type LinkUserToExternalIdentityOutput { id: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canLinkUserToExternalIdentity,
            schema: 'linkUserToExternalIdentity(data: LinkUserToExternalIdentityInput!): LinkUserToExternalIdentityOutput',
            resolver: async (parent, { data }, context) => {
                const { sender, identityType, tokenSet } = data
                const authedItemId = get(context, 'authedItem.id')

                // validate dv & sender
                checkDvAndSender(data, errors.DV_VERSION_MISMATCH, errors.WRONG_SENDER_FORMAT, context)

                // get & validate integration
                const integration = getIdentityIntegration(identityType)

                // in some case identityType can not support login form
                if (isNil(integration)) {
                    throw new GQLError(errors.IDENTITY_INTEGRATION_DOES_NOT_SUPPORT_LOGIN_FORM, context)
                }

                // get user info from external service
                const userInfo = await integration.getUserInfo(tokenSet)
                const userIdentities = await UserExternalIdentity.getAll(context, {
                    identityType,
                    identityId: userInfo.id,
                })

                if (userIdentities.length > 0) {
                    throw new GQLError(errors.EXTERNAL_IDENTITY_ALREADY_REGISTERED_ERROR, context)
                }

                // register UserExternalIdentity
                const { id } = await registerUserExternalIdentity(context, {
                    sender,
                    user: { id: authedItemId },
                    identityId: userInfo.id,
                    identityType,
                    meta: userInfo,
                })

                return {
                    id,
                }
            },
        },
    ],
    
})

module.exports = {
    LinkUserToExternalIdentityService,
}
