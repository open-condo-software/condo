/**
 * Generated by `createschema user.ConfirmEmailAction 'email:Text;token:Text;secretCode:Text;secretCodeRequestedAt:DateTimeUtc;secretCodeExpiresAt:DateTimeUtc;retries:Integer;isEmailVerified:Checkbox;requestedAt:DateTimeUtc;expiresAt:DateTimeUtc;completedAt:DateTimeUtc;'`
 */

const { GQLError } = require('@open-condo/keystone/errors')
const { historical, uuided, softDeleted, dvAndSender, versioned } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const { COMMON_ERRORS, WRONG_VALUE } = require('@condo/domains/common/constants/errors')
const { normalizeEmail } = require('@condo/domains/common/utils/mail')
const access = require('@condo/domains/user/access/ConfirmEmailAction')
const { SECRET_CODE_LENGTH } = require('@condo/domains/user/constants/common')


const ERRORS = {
    WRONG_SECRET_CODE_VALUE: {
        variable: ['data', 'secretCode'],
        code: 'WRONG_SECRET_CODE_LENGTH',
        type: WRONG_VALUE,
        message: `Wrong value for secret code. Length should be ${SECRET_CODE_LENGTH}`,
    },
}

const ConfirmEmailAction = new GQLListSchema('ConfirmEmailAction', {
    schemaDoc: 'Represents an email confirmation action.',
    fields: {

        email: {
            schemaDoc: 'Normalized email for confirm action',
            type: 'Text',
            isRequired: true,
            hooks: {
                resolveInput: ({ resolvedData, fieldPath }) => {
                    const newValue = resolvedData[fieldPath]

                    if (newValue) {
                        return normalizeEmail(newValue) || newValue
                    }
                },
                validateInput: ({ resolvedData, fieldPath, context }) => {
                    const newValue = resolvedData[fieldPath]

                    if (newValue && newValue !== normalizeEmail(newValue)) {
                        throw new GQLError(COMMON_ERRORS.WRONG_EMAIL_FORMAT, context)
                    }
                },
            },
        },

        token: {
            schemaDoc: 'Unique token used to complete the confirmation.',
            type: 'Text',
            isUnique: true,
            isRequired: true,
        },

        secretCode: {
            schemaDoc: 'Most recent secret code sent to the user.',
            type: 'Text',
            isRequired: true,
            hooks: {
                validateInput: ({ resolvedData, fieldPath, context }) => {
                    const newValue = resolvedData[fieldPath]

                    if (typeof newValue === 'string' && newValue.length !== SECRET_CODE_LENGTH) {
                        throw new GQLError(ERRORS.WRONG_SECRET_CODE_VALUE, context)
                    }
                },
            },
        },

        secretCodeRequestedAt: {
            schemaDoc: 'Timestamp when the secret code was requested.',
            type: 'DateTimeUtc',
            isRequired: true,
        },

        secretCodeExpiresAt: {
            schemaDoc: 'Timestamp when the secret code expires.',
            type: 'DateTimeUtc',
            isRequired: true,
        },

        retries: {
            schemaDoc: 'Number of failed attempts to enter the secret code.',
            type: 'Integer',
            defaultValue: 0,
        },

        isEmailVerified: {
            schemaDoc: 'Indicates whether the user confirmed the email address by entering the secret code.',
            type: 'Checkbox',
            defaultValue: false,
        },

        requestedAt: {
            schemaDoc: 'Timestamp when the email confirmation action was created.',
            type: 'DateTimeUtc',
            isRequired: true,
        },

        expiresAt: {
            schemaDoc: 'Timestamp when the email confirmation action expires.',
            type: 'DateTimeUtc',
            isRequired: true,
        },

        completedAt: {
            schemaDoc: 'Timestamp when the email confirmation action was completed.',
            type: 'DateTimeUtc',
            isRequired: false,
        },

    },
    plugins: [uuided(), softDeleted(), dvAndSender(), historical(), versioned()],
    access: {
        read: access.canReadConfirmEmailActions,
        create: access.canManageConfirmEmailActions,
        update: access.canManageConfirmEmailActions,
        delete: false,
        auth: true,
    },
})

module.exports = {
    ConfirmEmailAction,
}
