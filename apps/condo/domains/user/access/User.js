/**
 * Generated by `createschema user.User name:Text; password?:Password; isAdmin?:Checkbox; email?:Text; isEmailVerified?:Checkbox; phone?:Text; isPhoneVerified?:Checkbox; avatar?:File; meta:Json; importId:Text;`
 */
const get = require('lodash/get')

const access = require('@open-condo/keystone/access')
const { isFilteringBy, isDirectListQuery } = require('@open-condo/keystone/access')
const { throwAuthenticationError } = require('@open-condo/keystone/apolloErrorFormatter')

const { SERVICE, RESIDENT } = require('@condo/domains/user/constants/common')
const { canDirectlyReadSchemaObjects, canDirectlyReadSchemaField } = require('@condo/domains/user/utils/directAccess')
const { getIdentificationUserRequiredFields } = require('@condo/domains/user/utils/serverSchema/userHelpers')


const IDENTIFICATION_USER_REQUIRED_FIELDS = getIdentificationUserRequiredFields()

async function canReadUsers ({ authentication: { item: user }, listKey, args }) {
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false
    if (user.isAdmin || user.isSupport) return true

    const hasDirectAccess = await canDirectlyReadSchemaObjects(user, listKey)
    if (hasDirectAccess) return true

    const where = get(args, 'where', {})

    return !isFilteringBy(where, ['phone', 'email'])
}

async function canManageUsers ({ authentication: { item: user }, operation, itemId }) {
    if (!user) return throwAuthenticationError()
    if (user.deletedAt) return false
    if (user.isSupport || user.isAdmin) return true

    if (operation === 'create') return false
    if (operation === 'update') return itemId === user.id

    return false
}

const readByAnyUpdateByAdminField = {
    read: true,
    create: access.userIsAdmin,
    update: access.userIsAdmin,
}

const readBySupportUpdateByAdminField = {
    read: access.userIsAdminOrIsSupport,
    create: access.userIsAdmin,
    update: access.userIsAdmin,
}

const canAccessToEmailField = {
    read: async (args) => {
        const nonDirectAccess = access.userIsAdminOrIsThisItem(args)

        if (nonDirectAccess) {
            return nonDirectAccess
        }

        const { existingItem, authentication: { item: user }, listKey, fieldKey } = args

        // Service users with right set (dev-portal) can read only emails of service users
        if (user.type === SERVICE && existingItem.type === SERVICE) {
            return await canDirectlyReadSchemaField(user, listKey, fieldKey)
        }

        // Otherwise no access
        return false
    },
    create: access.userIsAdmin,
    // TODO(DOMA-12133): Should to update accesses when adding a mutation to change user email address
    // TODO(pahaz): !!! change it to access.userIsAdmin
    update: (args) => {
        if (!access.userIsAuthenticated(args)) return false

        const { authentication: { item: user } } = args
        const userType = user.type
        const requiredIdentificationFields = IDENTIFICATION_USER_REQUIRED_FIELDS?.[userType]

        // NOTE: backward compatibility!
        if (userType === SERVICE
            || (
                Array.isArray(requiredIdentificationFields)
                && requiredIdentificationFields.length === 1
                && requiredIdentificationFields.includes('phone')
            )
        ) {
            return access.userIsAdminOrIsThisItem(args)
        }

        return access.userIsAdmin(args)
    },
}

const canAccessToPhoneField = {
    read: access.userIsAdminOrIsThisItem,
    create: access.userIsAdmin,
    // TODO(DOMA-12134): Should to update accesses when adding a mutation to change user phone
    // TODO(pahaz): !!! change it to access.userIsAdmin
    update: (args) => {
        if (!access.userIsAuthenticated(args)) return false

        const { authentication: { item: user }, existingItem, originalInput } = args
        const userType = user.type
        const requiredIdentificationFields = IDENTIFICATION_USER_REQUIRED_FIELDS?.[userType]

        const updateByResidentToTheSamePhone = Boolean(existingItem && user.type === RESIDENT && existingItem.id === user.id && originalInput.phone === existingItem.phone)

        // NOTE: backward compatibility!
        if (updateByResidentToTheSamePhone
            && (
                Array.isArray(requiredIdentificationFields)
                && requiredIdentificationFields.length === 1
                && requiredIdentificationFields.includes('phone')
            )
        ) {
            return true
        }

        return access.userIsAdmin(args)
    },
}

const canAccessToPasswordField = {
    // 3. Only admins can see if a password is set. No-one can read their own or other user's passwords.
    read: access.userIsAdmin,
    create: access.userIsAdmin,
    // 4. Users can not update their own password. Admins can update anyone's password.
    update: access.userIsAdmin,
}
const canManageToIsAdminField = {
    read: true,
    create: access.userIsAdmin,
    update: access.userIsAdmin,
}

const canAccessToIsAdminField = {
    read: access.userIsAdmin,
    create: access.userIsAdmin,
    update: access.userIsAdmin,
}

const canManageUserType = {
    read: true,
    create: canManageUsers,
    // TODO Change access.userIsAdmin to FALSE
    update: access.userIsAdmin,
}

const canAccessToIsEmailVerifiedField = readByAnyUpdateByAdminField
const canAccessToIsPhoneVerifiedField = readByAnyUpdateByAdminField
const canAccessToImportField = readByAnyUpdateByAdminField
const canAccessToEmployeesField = readBySupportUpdateByAdminField
const canAccessToRelatedOrganizationsField = readBySupportUpdateByAdminField
const canAccessCustomAccessField = {
    create: access.userIsAdmin,
    read: access.userIsAdmin,
    update: access.userIsAdmin,
}

async function canReadUserNameField (args) {
    const { authentication: { item: user }, listKey, existingItem } = args

    // NOTE: Order of checks is important. Outside allUsers / User we want to keep default behaviour
    // Including access for non-authorized users in queries such as signIn / registerNewUser
    // But inside User / allUsers we want to restrict access to name field

    if (isDirectListQuery(args)) {
        if (!user) return throwAuthenticationError()
        if (user.deletedAt) return false
        if (user.isAdmin || user.isSupport) return true

        const hasDirectAccess = await canDirectlyReadSchemaObjects(user, listKey)
        if (hasDirectAccess) return true

        return existingItem.id === user.id
    }

    // NOTE: Managed by default list / custom query access
    return true
}

const canAccessMarketingConsent = {
    read: true,
    create: access.userIsAdminOrIsSupport,
    update: access.userIsAdminOrIsThisItem,
}

/*
  Rules are logical functions that used for list access, and may return a boolean (meaning
  all or no items are available) or a set of filters that limit the available items.
*/
module.exports = {
    canReadUsers,
    canManageUsers,
    canManageUserType,
    canAccessToEmailField,
    canAccessToPhoneField,
    canAccessToPasswordField,
    canAccessToIsAdminField,
    canAccessToIsEmailVerifiedField,
    canAccessToIsPhoneVerifiedField,
    canAccessToImportField,
    canManageToIsAdminField,
    canAccessToRelatedOrganizationsField,
    canAccessToEmployeesField,
    canAccessCustomAccessField,
    canReadUserNameField,
    canAccessMarketingConsent,
}
