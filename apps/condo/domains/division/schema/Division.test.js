/**
 * Generated by `createschema division.Division 'name:Text; organization:Relationship:Organization:CASCADE; responsible:Relationship:OrganizationEmployee:PROTECT;'`
 */
const { pick } = require('lodash')

const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE } = require('@core/keystone/test.utils')

const { Division, createTestDivision, updateTestDivision } = require('@condo/domains/division/utils/testSchema')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
} = require('@condo/domains/common/utils/testSchema')
const { createTestOrganization, createTestOrganizationEmployee, createTestOrganizationEmployeeRole } = require('@condo/domains/organization/utils/testSchema')
const { makeEmployeeUserClientWithAbilities } = require('@condo/domains/organization/utils/testSchema')
const { expectToThrowGraphQLRequestError, expectToThrowValidationFailureError } = require('@condo/domains/common/utils/testSchema')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema/Organization')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { buildingMapJson } = require('@condo/domains/property/constants/property')

describe('Division', () => {
    describe('Create', () => {
        it('can be connected to responsible which has `canBeAssignedAsResponsible` ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [obj, attrs] = await createTestDivision(adminClient, userClient.organization, userClient.employee)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
            expect(obj.name).toEqual(attrs.name)
        })

        it('can be created by employee with `canManageDivisions` ability in organization in question', async () => {
            const userClient = await makeEmployeeUserClientWithAbilities({
                canManageDivisions: true,
                canBeAssignedAsResponsible: true,
            })

            const [obj, attrs] = await createTestDivision(userClient, userClient.organization, userClient.employee)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
            expect(obj.name).toEqual(attrs.name)
            expect(obj.organization.id).toEqual(userClient.organization.id)
        })

        it('cannot be created by employee without `canManageDivisions` ability in organization in question', async () => {
            const userClient = await makeEmployeeUserClientWithAbilities({
                canManageDivisions: false,
                canBeAssignedAsResponsible: true,
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestDivision(userClient, userClient.organization, userClient.employee)
            })
        })

        it('cannot be connected to responsible from another organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [anotherOrganization] = await registerNewOrganization(adminClient)

            await expectToThrowValidationFailureError(async () => {
                await createTestDivision(adminClient, anotherOrganization, userClient.employee)
            }, 'Cannot be connected to responsible from another organization')
        })

        it('can be connected to properties from the same organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [property1] = await createTestProperty(adminClient, userClient.organization, { map: buildingMapJson })
            const [property2] = await createTestProperty(adminClient, userClient.organization, { map: buildingMapJson })

            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee, {
                properties: {
                    connect: [
                        { id: property1.id },
                        { id: property2.id },
                    ],
                },
            })
            expect(objCreated.properties).toHaveLength(2)
            expect(objCreated.properties).toEqual(
                expect.arrayContaining([
                    expect.objectContaining(pick(property1, ['id', 'name'])),
                ])
            )
            expect(objCreated.properties).toEqual(
                expect.arrayContaining([
                    expect.objectContaining(pick(property2, ['id', 'name'])),
                ])
            )
        })

        it('cannot be connected to properties from other organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [property1] = await createTestProperty(adminClient, anotherOrganization, { map: buildingMapJson })
            const [property2] = await createTestProperty(adminClient, anotherOrganization, { map: buildingMapJson })

            const ids = [property1.id, property2.id].join()
            await expectToThrowValidationFailureError(async () => {
                await createTestDivision(adminClient, userClient.organization, userClient.employee, {
                    properties: {
                        connect: [
                            { id: property1.id },
                            { id: property2.id },
                        ],
                    },
                })
            }, `Cannot be connected to following property(s), because they are belonging to another organization(s): ${ids}`)
        })

        it('can be connected to executors from the same organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [role] = await createTestOrganizationEmployeeRole(adminClient, userClient.organization, {
                canBeAssignedAsExecutor: true,
            })
            const [executor1] = await createTestOrganizationEmployee(adminClient, userClient.organization, userClient.user, role)
            const [executor2] = await createTestOrganizationEmployee(adminClient, userClient.organization, userClient.user, role)

            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee, {
                executors: {
                    connect: [
                        { id: executor1.id },
                        { id: executor2.id },
                    ],
                },
            })
            expect(objCreated.executors).toHaveLength(2)
            expect(objCreated.executors).toEqual(
                expect.arrayContaining([
                    expect.objectContaining(pick(executor1, ['id', 'name'])),
                ])
            )
            expect(objCreated.executors).toEqual(
                expect.arrayContaining([
                    expect.objectContaining(pick(executor2, ['id', 'name'])),
                ])
            )
        })

        it('cannot be connected to executors from other organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const executor1 = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsExecutor: true,
            })
            const executor2 = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsExecutor: true,
            })

            const ids = [executor1.employee.id, executor2.employee.id].join()
            await expectToThrowValidationFailureError(async () => {
                await createTestDivision(adminClient, userClient.organization, userClient.employee, {
                    executors: {
                        connect: [
                            { id: executor1.employee.id },
                            { id: executor2.employee.id },
                        ],
                    },
                })
            }, `Cannot be connected to following employee(s) as executors, because they are belonging to another organization(s): ${ids}`)
        })

        it('cannot be connected to executors without canBeAssignedAsExecutor ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [role] = await createTestOrganizationEmployeeRole(adminClient, userClient.organization, {
                canBeAssignedAsExecutor: false,
            })
            const [executor1] = await createTestOrganizationEmployee(adminClient, userClient.organization, userClient.user, role)
            const [executor2] = await createTestOrganizationEmployee(adminClient, userClient.organization, userClient.user, role)

            const ids = [executor1.id, executor2.id].join()
            await expectToThrowValidationFailureError(async () => {
                await createTestDivision(adminClient, userClient.organization, userClient.employee, {
                    executors: {
                        connect: [
                            { id: executor1.id },
                            { id: executor2.id },
                        ],
                    },
                })
            }, `Cannot be connected to following employee(s) as executors, because they does not have 'canBeAssignedAsExecutor' role ability: ${ids}`)
        })

        it('cannot be connected to responsible without `canBeAssignedAsResponsible` ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: false,
            })

            await expectToThrowValidationFailureError(async () => {
                await createTestDivision(adminClient, userClient.organization, userClient.employee)
            }, 'Cannot be connected to responsible which does not have `canBeAssignedAsResponsible` ability')
        })

        it('cannot be created by anonymous', async () => {
            const userClient = await makeEmployeeUserClientWithAbilities({
                canManageDivisions: true,
            })

            const anonymous = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestDivision(anonymous, userClient.organization, userClient.employee)
            })
        })
    })

    describe('Update', () => {
        it('can be updated by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [objUpdated, attrs] = await updateTestDivision(adminClient, objCreated.id)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.name).toEqual(attrs.name)
        })

        it('can be updated by employee with `canManageDivisions` ability in current organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canManageDivisions: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [objUpdated, attrs] = await updateTestDivision(userClient, objCreated.id)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.name).toEqual(attrs.name)
        })

        it('cannot be updated by employee without `canManageDivisions` ability in current organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: false,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestDivision(userClient, objCreated.id)
            })
        })

        it('cannot be connected to responsible from another organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anotherUserClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const payload = {
                responsible: { connect: { id: anotherUserClient.employee.id } },
            }

            await expectToThrowValidationFailureError(async () => {
                await updateTestDivision(adminClient, objCreated.id, payload)
            }, 'Cannot be connected to responsible from another organization')
        })

        it('can be connected to properties from the same organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [property1] = await createTestProperty(adminClient, userClient.organization, { map: buildingMapJson })
            const [property2] = await createTestProperty(adminClient, userClient.organization, { map: buildingMapJson })
            const [objUpdated] = await updateTestDivision(adminClient, objCreated.id, {
                properties: {
                    connect: [
                        { id: property1.id },
                        { id: property2.id },
                    ],
                },
            })

            expect(objUpdated.properties).toHaveLength(2)
            expect(objUpdated.properties).toEqual(
                expect.arrayContaining([
                    expect.objectContaining(pick(property1, ['id', 'name'])),
                ])
            )
            expect(objUpdated.properties).toEqual(
                expect.arrayContaining([
                    expect.objectContaining(pick(property2, ['id', 'name'])),
                ])
            )
        })

        it('cannot be connected to properties from other organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [property1] = await createTestProperty(adminClient, anotherOrganization, { map: buildingMapJson })
            const [property2] = await createTestProperty(adminClient, anotherOrganization, { map: buildingMapJson })

            const ids = [property1.id, property2.id].join()
            await expectToThrowValidationFailureError(async () => {
                await updateTestDivision(adminClient, objCreated.id, {
                    properties: {
                        connect: [
                            { id: property1.id },
                            { id: property2.id },
                        ],
                    },
                })
            }, `Cannot be connected to following property(s), because they are belonging to another organization(s): ${ids}`)
        })

        it('can be connected to executors from the same organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [role] = await createTestOrganizationEmployeeRole(adminClient, userClient.organization, {
                canBeAssignedAsExecutor: true,
            })
            const [executor1] = await createTestOrganizationEmployee(adminClient, userClient.organization, userClient.user, role)
            const [executor2] = await createTestOrganizationEmployee(adminClient, userClient.organization, userClient.user, role)

            const [objUpdated] = await updateTestDivision(adminClient, objCreated.id, {
                executors: {
                    connect: [
                        { id: executor1.id },
                        { id: executor2.id },
                    ],
                },
            })
            expect(objUpdated.executors).toHaveLength(2)
            expect(objUpdated.executors).toEqual(
                expect.arrayContaining([
                    expect.objectContaining(pick(executor1, ['id', 'name'])),
                ])
            )
            expect(objUpdated.executors).toEqual(
                expect.arrayContaining([
                    expect.objectContaining(pick(executor2, ['id', 'name'])),
                ])
            )
        })

        it('cannot be connected to executors from other organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const executor1 = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsExecutor: true,
            })
            const executor2 = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsExecutor: true,
            })

            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const ids = [executor1.employee.id, executor2.employee.id].join()
            await expectToThrowValidationFailureError(async () => {
                await updateTestDivision(adminClient, objCreated.id, {
                    executors: {
                        connect: [
                            { id: executor1.employee.id },
                            { id: executor2.employee.id },
                        ],
                    },
                })
            }, `Cannot be connected to following employee(s) as executors, because they are belonging to another organization(s): ${ids}`)
        })

        it('cannot be connected to executors without canBeAssignedAsExecutor ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [role] = await createTestOrganizationEmployeeRole(adminClient, userClient.organization, {
                canBeAssignedAsExecutor: false,
            })
            const [executor1] = await createTestOrganizationEmployee(adminClient, userClient.organization, userClient.user, role)
            const [executor2] = await createTestOrganizationEmployee(adminClient, userClient.organization, userClient.user, role)

            const ids = [executor1.id, executor2.id]
            await expectToThrowValidationFailureError(async () => {
                await updateTestDivision(adminClient, objCreated.id, {
                    executors: {
                        connect: [
                            { id: executor1.id },
                            { id: executor2.id },
                        ],
                    },
                })
            }, `Cannot be connected to following employee(s) as executors, because they does not have 'canBeAssignedAsExecutor' role ability: ${ids}`)
        })

        it('cannot be connected to responsible which does not have `canBeAssignedAsResponsible` ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const userClientThatCannotBeResponsible = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: false,
            })

            const payload = {
                responsible: { connect: { id: userClientThatCannotBeResponsible.employee.id } },
            }

            await expectToThrowValidationFailureError(async () => {
                await updateTestDivision(adminClient, objCreated.id, payload)
            }, 'Cannot be connected to responsible which does not have `canBeAssignedAsResponsible` ability')
        })

        it('does not have organization in update payload', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [anotherOrganization] = await createTestOrganization(adminClient)

            const payload = {
                organization: { connect: { id: anotherOrganization.id } },
            }

            await expectToThrowGraphQLRequestError(async () => {
                await updateTestDivision(adminClient, objCreated.id, payload)
            }, 'Field "organization" is not defined by type "DivisionUpdateInput".')
        })

        it('cannot be updated by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anonymous = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestDivision(anonymous, objCreated.id)
            })
        })
    })

    describe('Read', () => {
        it('can be read by admin', async () => {
            const admin = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({ canBeAssignedAsResponsible: true })
            const [obj, attrs] = await createTestDivision(admin, userClient.organization, userClient.employee)

            const objs = await Division.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

            expect(objs.length).toBeGreaterThanOrEqual(1)
            expect(objs).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    id: obj.id,
                    sender: attrs.sender,
                    createdBy: expect.objectContaining({ id: admin.user.id }),
                    updatedBy: expect.objectContaining({ id: admin.user.id }),
                    createdAt: obj.createdAt,
                    updatedAt: obj.updatedAt,
                    name: attrs.name,
                }),
            ]))
        })

        it('can be read by employee only in scope of its organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anotherUserClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            await createTestDivision(adminClient, anotherUserClient.organization, anotherUserClient.employee)

            const objs = await Division.getAll(userClient)

            expect(objs).toHaveLength(1)
            expect(objs[0].id).toMatch(obj.id)
        })

        it('cannot be read by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anonymous = await makeClient()

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await Division.getAll(anonymous)
            })
        })
    })

    describe('Delete', () => {
        it('can be soft-deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [objUpdated, attrs] = await Division.softDelete(adminClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('can be soft-deleted by employee with `canManageDivisions` ability in current organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [objUpdated, attrs] = await Division.softDelete(userClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('cannot be soft-deleted by employee with `canManageDivisions` ability in another organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anotherUserClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            await createTestDivision(adminClient, anotherUserClient.organization, anotherUserClient.employee)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Division.softDelete(anotherUserClient, obj.id)
            })
        })

        it('cannot be soft-deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anonymous = await makeClient()

            await expectToThrowAuthenticationErrorToObj(async () => {
                await Division.softDelete(anonymous, obj.id)
            })
        })

        it('cannot be deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Division.delete(adminClient, obj.id)
            })
        })

        it('cannot be deleted by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Division.delete(userClient, obj.id)
            })
        })

        it('cannot be deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anonymous = await makeClient()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Division.delete(anonymous, obj.id)
            })
        })
    })
})
