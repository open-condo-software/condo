/**
 * Generated by `createschema division.Division 'name:Text; organization:Relationship:Organization:CASCADE; responsible:Relationship:OrganizationEmployee:PROTECT;'`
 */

const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE } = require('@core/keystone/test.utils')

const { Division, createTestDivision, updateTestDivision } = require('@condo/domains/division/utils/testSchema')
const {
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAuthenticationErrorToObj,
} = require('@condo/domains/common/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { makeEmployeeUserClientWithAbilities } = require('@condo/domains/organization/utils/testSchema')
const { catchErrorFrom } = require('../../common/utils/testSchema')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema/Organization')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { buildingMapJson } = require('@condo/domains/property/constants/property')

describe('Division', () => {
    describe('Create', () => {
        it('can be connected to responsible which has `canBeAssignedAsResponsible` ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [obj, attrs] = await createTestDivision(adminClient, userClient.organization, userClient.employee)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
            expect(obj.name).toEqual(attrs.name)
        })

        it('can be created by employee with `canManageDivisions` ability in organization in question', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canManageDivisions: true,
                canBeAssignedAsResponsible: true,
            })

            const [obj, attrs] = await createTestDivision(userClient, userClient.organization, userClient.employee)
            expect(obj.id).toMatch(UUID_RE)
            expect(obj.dv).toEqual(1)
            expect(obj.sender).toEqual(attrs.sender)
            expect(obj.v).toEqual(1)
            expect(obj.newId).toEqual(null)
            expect(obj.deletedAt).toEqual(null)
            expect(obj.createdBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(obj.createdAt).toMatch(DATETIME_RE)
            expect(obj.updatedAt).toMatch(DATETIME_RE)
            expect(obj.name).toEqual(attrs.name)
            expect(obj.organization.id).toEqual(userClient.organization.id)
        })

        it('cannot be created by employee without `canManageDivisions` ability in organization in question', async () => {
            const userClient = await makeEmployeeUserClientWithAbilities({
                canManageDivisions: false,
                canBeAssignedAsResponsible: true,
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestDivision(userClient, userClient.organization, userClient.employee)
            })
        })

        it('cannot be connected to responsible from another organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [anotherOrganization] = await registerNewOrganization(adminClient)

            await catchErrorFrom(async () => {
                await createTestDivision(adminClient, anotherOrganization, userClient.employee)
            }, ({ errors, data }) => {
                expect(errors[0].data.messages[0]).toMatch('Cannot be connected to responsible from another organization')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('cannot be connected to properties from other organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [property1] = await createTestProperty(adminClient, anotherOrganization, { map: buildingMapJson })
            const [property2] = await createTestProperty(adminClient, anotherOrganization, { map: buildingMapJson })

            await catchErrorFrom(async () => {
                await createTestDivision(adminClient, userClient.organization, userClient.employee, {
                    properties: {
                        connect: [
                            { id: property1.id },
                            { id: property2.id },
                        ],
                    },
                })
            }, ({ errors, data }) => {
                const ids = [property1.id, property2.id]
                expect(errors[0].data.messages[0]).toMatch(`Cannot be connected to following property(s), because they are belonging to another organization(s): ${ids.join()}`)
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('cannot be connected to responsible without `canBeAssignedAsResponsible` ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: false,
            })

            await catchErrorFrom(async () => {
                await createTestDivision(adminClient, userClient.organization, userClient.employee)
            }, ({ errors, data }) => {
                expect(errors[0].data.messages[0]).toMatch('Cannot be connected to responsible which does not have `canBeAssignedAsResponsible` ability')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('cannot be created by anonymous', async () => {
            const userClient = await makeEmployeeUserClientWithAbilities({
                canManageDivisions: true,
            })

            const anonymous = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await createTestDivision(anonymous, userClient.organization, userClient.employee)
            })
        })
    })

    describe('Update', () => {
        it('can be updated by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [objUpdated, attrs] = await updateTestDivision(adminClient, objCreated.id)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.name).toEqual(attrs.name)
        })

        it('can be updated by employee with `canManageDivisions` ability in current organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canManageDivisions: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [objUpdated, attrs] = await updateTestDivision(userClient, objCreated.id)

            expect(objUpdated.id).toEqual(objCreated.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.v).toEqual(2)
            expect(objUpdated.newId).toEqual(null)
            expect(objUpdated.deletedAt).toEqual(null)
            expect(objUpdated.createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objUpdated.updatedBy).toEqual(expect.objectContaining({ id: userClient.user.id }))
            expect(objUpdated.createdAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
            expect(objUpdated.name).toEqual(attrs.name)
        })

        it('cannot be updated by employee without `canManageDivisions` ability in current organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: false,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestDivision(userClient, objCreated.id)
            })
        })

        it('cannot be connected to responsible from another organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anotherUserClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const payload = {
                responsible: { connect: { id: anotherUserClient.employee.id } },
            }

            await catchErrorFrom(async () => {
                await updateTestDivision(adminClient, objCreated.id, payload)
            }, ({ errors, data }) => {
                expect(errors[0].data.messages[0]).toMatch('Cannot be connected to responsible from another organization')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('cannot be connected to properties from other organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [anotherOrganization] = await createTestOrganization(adminClient)
            const [property1] = await createTestProperty(adminClient, anotherOrganization, { map: buildingMapJson })
            const [property2] = await createTestProperty(adminClient, anotherOrganization, { map: buildingMapJson })

            await catchErrorFrom(async () => {
                await updateTestDivision(adminClient, objCreated.id, {
                    properties: {
                        connect: [
                            { id: property1.id },
                            { id: property2.id },
                        ],
                    },
                })
            }, ({ errors, data }) => {
                const ids = [property1.id, property2.id]
                expect(errors[0].data.messages[0]).toMatch(`Cannot be connected to following property(s), because they are belonging to another organization(s): ${ids.join()}`)
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('cannot be connected to responsible which does not have `canBeAssignedAsResponsible` ability', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const userClientThatCannotBeResponsible = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: false,
            })

            const payload = {
                responsible: { connect: { id: userClientThatCannotBeResponsible.employee.id } },
            }

            await catchErrorFrom(async () => {
                await updateTestDivision(adminClient, objCreated.id, payload)
            }, ({ errors, data }) => {
                expect(errors[0].data.messages[0]).toMatch('Cannot be connected to responsible which does not have `canBeAssignedAsResponsible` ability')
                expect(data).toEqual({ 'obj': null })
            })
        })

        it('does not have organization in update payload', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [anotherOrganization] = await createTestOrganization(adminClient)

            const payload = {
                organization: { connect: { id: anotherOrganization.id } },
            }

            await catchErrorFrom(async () => {
                await updateTestDivision(adminClient, objCreated.id, payload)
            }, ({ errors, data }) => {
                expect(errors[0]).toMatchObject({
                    'name': 'UserInputError',
                    'extensions': {
                        'code': 'BAD_USER_INPUT',
                    },
                })
                expect(errors[0].message).toMatch('Field "organization" is not defined by type "DivisionUpdateInput".')
                expect(data).toBeUndefined()
            })
        })

        it('cannot be updated by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [objCreated] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anonymous = await makeClient()
            await expectToThrowAuthenticationErrorToObj(async () => {
                await updateTestDivision(anonymous, objCreated.id)
            })
        })
    })

    describe('Read', () => {
        it('can be read by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [obj, attrs] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const objs = await Division.getAll(adminClient, {}, { sortBy: ['updatedAt_DESC'] })

            expect(objs.length >= 1).toBeTruthy()
            expect(objs[0].id).toMatch(obj.id)
            expect(objs[0].dv).toEqual(1)
            expect(objs[0].sender).toEqual(attrs.sender)
            expect(objs[0].v).toEqual(1)
            expect(objs[0].newId).toEqual(null)
            expect(objs[0].deletedAt).toEqual(null)
            expect(objs[0].createdBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objs[0].updatedBy).toEqual(expect.objectContaining({ id: adminClient.user.id }))
            expect(objs[0].createdAt).toMatch(obj.createdAt)
            expect(objs[0].updatedAt).toMatch(obj.updatedAt)
            expect(objs[0].name).toEqual(attrs.name)
        })

        it('can be read by employee only in scope of its organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anotherUserClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            await createTestDivision(adminClient, anotherUserClient.organization, anotherUserClient.employee)

            const objs = await Division.getAll(userClient)

            expect(objs).toHaveLength(1)
            expect(objs[0].id).toMatch(obj.id)
        })

        it('cannot be read by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anonymous = await makeClient()

            await expectToThrowAuthenticationErrorToObjects(async () => {
                await Division.getAll(anonymous)
            })
        })
    })

    describe('Delete', () => {
        it('can be soft-deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })

            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [objUpdated, attrs] = await Division.softDelete(adminClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('can be soft-deleted by employee with `canManageDivisions` ability in current organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const [objUpdated, attrs] = await Division.softDelete(userClient, obj.id)

            expect(objUpdated.id).toEqual(obj.id)
            expect(objUpdated.dv).toEqual(1)
            expect(objUpdated.sender).toEqual(attrs.sender)
            expect(objUpdated.deletedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).toMatch(DATETIME_RE)
            expect(objUpdated.updatedAt).not.toEqual(objUpdated.createdAt)
        })

        it('cannot be soft-deleted by employee with `canManageDivisions` ability in another organization', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anotherUserClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            await createTestDivision(adminClient, anotherUserClient.organization, anotherUserClient.employee)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Division.softDelete(anotherUserClient, obj.id)
            })
        })

        it('cannot be soft-deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anonymous = await makeClient()

            await expectToThrowAuthenticationErrorToObj(async () => {
                await Division.softDelete(anonymous, obj.id)
            })
        })

        it('cannot be deleted by admin', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Division.delete(adminClient, obj.id)
            })
        })

        it('cannot be deleted by user', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
                canManageDivisions: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Division.delete(userClient, obj.id)
            })
        })

        it('cannot be deleted by anonymous', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeEmployeeUserClientWithAbilities({
                canBeAssignedAsResponsible: true,
            })
            const [obj] = await createTestDivision(adminClient, userClient.organization, userClient.employee)

            const anonymous = await makeClient()

            await expectToThrowAccessDeniedErrorToObj(async () => {
                await Division.delete(anonymous, obj.id)
            })
        })
    })
})
