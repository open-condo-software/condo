/**
 * Generated by `createservice ticket.TicketAnalyticsReportService`
 */

const dayjs = require('dayjs')
const get = require('lodash/get')
const sum = require('lodash/sum')

const conf = require('@open-condo/config')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, getByCondition } = require('@open-condo/keystone/schema')
const { extractReqLocale } = require('@open-condo/locales/extractReqLocale')

const access = require('@condo/domains/analytics/access/TicketAnalyticsReportService')
const { UNKNOWN_GROUP_BY_FILTER } = require('@condo/domains/analytics/constants/errors')
const { aggregateData } = require('@condo/domains/analytics/utils/serverSchema/analytics.helper')
const assigneePercentSingleDataMapper = require('@condo/domains/analytics/utils/serverSchema/assigneePercentSingleDataMapper')
const assigneePercentSummaryDataMapper = require('@condo/domains/analytics/utils/serverSchema/assigneePercentSummaryDataMapper')
const assigneeSingleDataMapper = require('@condo/domains/analytics/utils/serverSchema/assigneeSingleDataMapper')
const assigneeSummaryDataMapper = require('@condo/domains/analytics/utils/serverSchema/assigneeSummaryDataMapper')
const categoryClassifierPercentSingleDataMapper = require('@condo/domains/analytics/utils/serverSchema/categoryClassifierPercentSingleDataMapper')
const categoryClassifierPercentSummaryDataMapper = require('@condo/domains/analytics/utils/serverSchema/categoryClassifierPercentSummaryDataMapper')
const categoryClassifierSingleDataMapper = require('@condo/domains/analytics/utils/serverSchema/categoryClassifierSingleDataMapper')
const categoryClassifierSummaryDataMapper = require('@condo/domains/analytics/utils/serverSchema/categoryClassifierSummaryDataMapper')
const dayGroupDataMapper = require('@condo/domains/analytics/utils/serverSchema/dayGroupDataMapper')
const executorPercentSingleDataMapper = require('@condo/domains/analytics/utils/serverSchema/executorPercentSingleDataMapper')
const executorPercentSummaryDataMapper = require('@condo/domains/analytics/utils/serverSchema/executorPercentSummaryDataMapper')
const executorSingleDataMapper = require('@condo/domains/analytics/utils/serverSchema/executorSingleDataMapper')
const executorSummaryDataMapper = require('@condo/domains/analytics/utils/serverSchema/executorSummaryDataMapper')
const propertyPercentDataMapper = require('@condo/domains/analytics/utils/serverSchema/propertyPercentDataMapper')
const propertySingleDataMapper = require('@condo/domains/analytics/utils/serverSchema/propertySingleDataMapper')
const propertySummaryDataMapper = require('@condo/domains/analytics/utils/serverSchema/propertySummaryDataMapper')
const propertySummaryPercentDataMapper = require('@condo/domains/analytics/utils/serverSchema/propertySummaryPercentDataMapper')
const { TicketDataLoader } = require('@condo/domains/analytics/utils/services/dataLoaders/ticket')
const { createExportFile } = require('@condo/domains/common/utils/createExportFile')
const { getHeadersTranslations, TICKETS_REPORTS_PREFIX } = require('@condo/domains/common/utils/exportToExcel')
const { Ticket } = require('@condo/domains/ticket/utils/serverSchema')

const ERRORS = {
    UNKNOWN_GROUP_BY_FILTER: {
        query: 'exportTicketAnalyticsToExcel',
        variable: ['data', 'groupBy'],
        code: BAD_USER_INPUT,
        type: UNKNOWN_GROUP_BY_FILTER,
        message: 'Unknown groupBy filter {value}',
    },
}

const getXLSXDataMapper = (groupByToken, isSummary, context) => {
    let dataMapper = null
    switch (groupByToken) {
        case 'status-day':
        case 'status-week':
            dataMapper = dayGroupDataMapper
            break
        case 'status-property':
            dataMapper = isSummary ? propertySummaryDataMapper : propertySingleDataMapper
            break
        case 'property-status':
            dataMapper = isSummary ? propertySummaryPercentDataMapper : propertyPercentDataMapper
            break
        case 'status-categoryClassifier':
            dataMapper = isSummary ? categoryClassifierSummaryDataMapper : categoryClassifierSingleDataMapper
            break
        case 'categoryClassifier-status':
            dataMapper = isSummary ? categoryClassifierPercentSummaryDataMapper : categoryClassifierPercentSingleDataMapper
            break
        case 'status-executor':
            dataMapper = isSummary ? executorSummaryDataMapper : executorSingleDataMapper
            break
        case 'executor-status':
            dataMapper = isSummary ? executorPercentSummaryDataMapper : executorPercentSingleDataMapper
            break
        case 'status-assignee':
            dataMapper = isSummary ? assigneeSummaryDataMapper : assigneeSingleDataMapper
            break
        case 'assignee-status':
            dataMapper = isSummary ? assigneePercentSummaryDataMapper : assigneePercentSingleDataMapper
            break
        default:
            throw new GQLError({
                ...ERRORS.UNKNOWN_GROUP_BY_FILTER,
                messageInterpolation: {
                    value: groupByToken,
                },
            }, context)
    }
    return dataMapper
}

const TicketAnalyticsReportService = new GQLCustomSchema('TicketAnalyticsReportService', {
    types: [
        {
            access: true,
            type: 'enum TicketAnalyticsGroupBy { day week month status property categoryClassifier executor assignee qualityControlValue }',
        },
        {
            access: true,
            type: 'input TicketAnalyticsReportInput { where: TicketWhereInput!, groupBy: [TicketAnalyticsGroupBy!], nullReplaces: TicketAnalyticsNullReplaces! }',
        },
        {
            access: true,
            type: 'type TicketLabel { label: String!, color: String!, value: String! }',
        },
        {
            access: true,
            type: 'type TicketAnalyticsReportOutput { groups: [TicketGroupedCounter!], ticketLabels: [TicketLabel] }',
        },
        {
            access: true,
            type: 'type TicketGroupedCounter { count: Int!, status: String, property: String, dayGroup: String!, categoryClassifier: String, executor: String, assignee: String, qualityControlValue: String }', //NOSONAR GQL types are not code duplication
        },
        {
            access: true,
            type: 'input TicketAnalyticsNullReplaces { categoryClassifier: String!, executor: String!, assignee: String! }',
        },
        {
            access: true,
            type: 'input ExportTicketAnalyticsToExcelTranslates { property: String, assignee: String, executor: String, categoryClassifier: String }',
        },
        {
            access: true,
            type: 'input ExportTicketAnalyticsToExcelInput { where: TicketWhereInput!, groupBy: [TicketAnalyticsGroupBy!], translates: ExportTicketAnalyticsToExcelTranslates!, nullReplaces: TicketAnalyticsNullReplaces! }',
        },
        {
            access: true,
            type: 'type ExportTicketAnalyticsToExcelOutput { link: String! }',
        },
    ],
    queries: [
        {
            access: access.canReadTicketAnalyticsReport,
            schema: 'ticketAnalyticsReport(data: TicketAnalyticsReportInput): TicketAnalyticsReportOutput',
            resolver: async (parent, args, context) => {
                const { data: { where = {}, groupBy = [], nullReplaces = {} } } = args
                const ticketDataLoader = new TicketDataLoader({ context })
                const { ticketCounts: groups, translates } = await ticketDataLoader.get({
                    context, where, groupBy, nullReplaces,
                })
                const ticketLabels = get(translates, 'status', [])
                return { groups, ticketLabels }
            },
        },
        {
            access: access.canReadExportTicketAnalyticsToExcel,
            schema: 'exportTicketAnalyticsToExcel(data: ExportTicketAnalyticsToExcelInput): ExportTicketAnalyticsToExcelOutput',
            resolver: async (parent, args, context) => {
                const { data: { where = {}, groupBy = [], translates = {}, nullReplaces } } = args
                const ticketDataLoader = new TicketDataLoader({ context })
                const { ticketCounts } = await ticketDataLoader.get({
                    context, where, groupBy, nullReplaces, extraLabels: { status: 'type' },
                })
                const { result, groupKeys } = aggregateData(ticketCounts, groupBy)
                const ticketAccessCheck = await Ticket.getAll(context, where, { first: 1 })
                const [groupBy1, groupBy2] = groupKeys

                // TODO(sitozzz): find way to collect organization locale without additional request
                const organization = await getByCondition('Organization', {
                    id: where.organization.id,
                })

                const locale = organization.country || extractReqLocale(context.req) || conf.DEFAULT_LOCALE

                let rowColumns = []
                const groupByToken = groupBy.join('-')
                const address = get(translates, 'property', '')
                const categoryClassifier = get(translates, 'categoryClassifier', '')
                const assignee = get(translates, 'assignee', '')
                const executor = get(translates, 'executor', '')

                switch (groupByToken) {
                    case 'status-day':
                    case 'status-week':
                        rowColumns = [...new Set(Object.values(result).flatMap(e => Object.keys(e)))]
                        break
                    case 'status-property':
                    case 'property-status':
                        rowColumns = address.includes('@') ? address.split('@') : []
                        break
                    case 'status-categoryClassifier':
                    case 'categoryClassifier-status':
                        rowColumns = categoryClassifier.includes('@') ? categoryClassifier.split('@') : []
                        break
                    case 'status-executor':
                    case 'executor-status':
                        rowColumns = executor.includes('@') ? executor.split('@') : []
                        break
                    case 'status-assignee':
                    case 'assignee-status':
                        rowColumns = assignee.includes('@') ? assignee.split('@') : []
                        break
                    default:
                        throw new GQLError({
                            ...ERRORS.UNKNOWN_GROUP_BY_FILTER,
                            messageInterpolation: {
                                value: groupByToken,
                            },
                        }, context)
                }

                const tickets = []
                const totalCount = Object.values(result)
                    .reduce((prevCount, currentAggregateObject) =>
                        prevCount + sum(Object.values(currentAggregateObject)), 0)

                const isSummary = rowColumns.length === 0
                const mapperInstance = getXLSXDataMapper(groupByToken, isSummary, context)
                if (isSummary) {
                    const tableColumns = {}
                    Object.entries(result).forEach(([ticketType, dataObject]) => {
                        const { rows } = mapperInstance({
                            row: dataObject,
                            constants: { totalCount, address, categoryClassifier, executor, assignee },
                        })
                        Object.entries(rows).filter(([rowType]) => rowType === ticketType).forEach(([tableRow, getValue]) => {
                            tableColumns[tableRow] = getValue()
                        })
                        tableColumns.address = rows.address()
                        tableColumns.executor = rows.executor !== undefined ? rows.executor() : ''
                        tableColumns.assignee = rows.assignee !== undefined ? rows.assignee() : ''
                        tableColumns.categoryClassifier = rows.categoryClassifier !== undefined ? rows.categoryClassifier() : ''
                    })
                    tickets.push(tableColumns)
                } else {
                    const totalCounts = {}
                    Object.values(result).forEach((dataObj) => {
                        Object.entries(dataObj).forEach(([groupByField, count]) => {
                            get(totalCounts, groupByField, false)
                                ? (totalCounts[groupByField] += count)
                                : (totalCounts[groupByField] = count)
                        })
                    })
                    rowColumns.forEach(filterColumn => {
                        const tableColumns = {}
                        Object.entries(result).forEach(([ticketType, dataObj]) => {
                            const mapperData = { row: dataObj, constants: { totalCounts, address } }
                            switch (groupBy2) {
                                case 'status':
                                case 'property':
                                    mapperData['constants']['address'] = filterColumn
                                    break
                                case 'categoryClassifier':
                                    mapperData['constants']['categoryClassifier'] = filterColumn
                                    break
                                case 'executor':
                                    mapperData['constants']['executor'] = filterColumn
                                    break
                                case 'assignee':
                                    mapperData['constants']['assignee'] = filterColumn
                                    break
                                case 'dayGroup':
                                    mapperData['row'] = result
                                    mapperData['constants']['date'] = filterColumn
                                    break
                                default:
                                    throw new GQLError({
                                        ...ERRORS.UNKNOWN_GROUP_BY_FILTER,
                                        messageInterpolation: {
                                            value: groupBy2,
                                        },
                                    }, context)
                            }
                            const { rows } = mapperInstance(mapperData)

                            tableColumns.address = rows.address()
                            tableColumns.date = rows.date !== undefined ? rows.date() : ''
                            tableColumns.executor = rows.executor !== undefined ? rows.executor() : ''
                            tableColumns.assignee = rows.assignee !== undefined ? rows.assignee() : ''
                            tableColumns.categoryClassifier = rows.categoryClassifier !== undefined ? rows.categoryClassifier() : ''
                            tableColumns[ticketType] = rows[ticketType]()
                        })
                        tickets.push(tableColumns)
                    })
                }

                const i18n = getHeadersTranslations(`${TICKETS_REPORTS_PREFIX}${groupBy1}_${groupBy2}`, locale)

                const { url: link } = await createExportFile({
                    fileName: `ticket_analytics_${dayjs().format('DD_MM')}.xlsx`,
                    templatePath: `./domains/analytics/templates/TicketAnalyticsExportTemplate[${groupBy1}_${groupBy2}].xlsx`,
                    replaces: { tickets, i18n },
                    meta: {
                        listkey: 'Ticket',
                        id: ticketAccessCheck[0].id,
                    },
                })
                return { link }
            },
        },
    ],
})

module.exports = { TicketAnalyticsReportService }
