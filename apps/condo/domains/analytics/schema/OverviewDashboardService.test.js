/**
 * Generated by `createservice analytics.OverviewDashboardService`
 */
const dayjs = require('dayjs')

const { makeClient, expectToThrowAuthenticationErrorToResult } = require('@open-condo/keystone/test.utils')

const { PAYMENT_DONE_STATUS } = require('@condo/domains/acquiring/constants/payment')
const { makePayerAndPayments } = require('@condo/domains/acquiring/utils/testSchema')
const { updateTestPayment } = require('@condo/domains/acquiring/utils/testSchema')
const { overviewDashboardByTestClient } = require('@condo/domains/analytics/utils/testSchema')
const { createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const { TICKET_STATUS_TYPES } = require('@condo/domains/ticket/constants')
const { createTestTicket, createTestTicketClassifier } = require('@condo/domains/ticket/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')

const dateFrom = dayjs().toISOString()
const dateTo = dayjs().endOf('day').toISOString()

describe('OverviewDashboardService', () => {
    let admin
    let organization
    let property
    let organizationAdminUser
    let payment
    let ticket

    beforeAll(async () => {
        const payerAndPayments = await makePayerAndPayments()

        admin = payerAndPayments.admin
        organization = payerAndPayments.organization
        property = payerAndPayments.property
        payment = payerAndPayments.payments[0]
        organizationAdminUser = await makeClientWithNewRegisteredAndLoggedInUser()
        organizationAdminUser.organization = organization


        const [adminRole] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageOrganization: true,
        })
        const [executor] = await createTestOrganizationEmployee(admin, organization, organizationAdminUser.user, adminRole, { isAccepted: true, name: organizationAdminUser.user.name })

        await updateTestPayment(admin, payment.id, { status: PAYMENT_DONE_STATUS })
        const [classifier] = await createTestTicketClassifier(admin)
        const [createdTicket] = await createTestTicket(admin, organization, property, {
            executor: { connect: { id: executor.user.id } },
            classifier: { connect: { id: classifier.id } },
        })

        ticket = createdTicket
    })

    describe('Admin', () => {
        it('can query with any organization provided', async () => {
            const [organization] = await createTestOrganization(admin)
            const [data] = await overviewDashboardByTestClient(admin, {
                where: { organization: organization.id, dateFrom, dateTo },
                groupBy: { aggregatePeriod: 'month' },
            })

            expect(data).toHaveProperty('overview')
            expect(data.overview).toHaveProperty(['payment', 'payments'])
            expect(data.overview).toHaveProperty(['resident', 'residents'])
            expect(data.overview).toHaveProperty(['receipt', 'receipts'])
            expect(data.overview).toHaveProperty(['ticketByDay', 'tickets'])
            expect(data.overview).toHaveProperty(['ticketByProperty', 'tickets'])
            expect(data.overview).toHaveProperty(['ticketByExecutor', 'tickets'])
            expect(data.overview).toHaveProperty(['ticketByCategory', 'tickets'])
        })
    })

    describe('User', () => {
        it('can query if it has an organization administrator role', async () => {
            const payload = { where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'month' } }
            const [data] = await overviewDashboardByTestClient(organizationAdminUser, payload)

            expect(data.overview).toHaveProperty(['payment', 'payments', '0', 'count'], '1')
            expect(data.overview).toHaveProperty(['payment', 'sum'])
        })
    })

    describe('Anonymous', () => {
        it('can\'t query OverviewDashboard', async () => {
            const client = await makeClient()
            await expectToThrowAuthenticationErrorToResult(async () => {
                await overviewDashboardByTestClient(client, {
                    where: {
                        organization: organization.id,
                        dateFrom: dayjs().startOf('month').toISOString(),
                        dateTo: dayjs().toISOString(),
                    },
                    groupBy: { aggregatePeriod: 'week' },
                })
            })
        })
    })

    describe('Aggregation', () => {
        describe('Ticket', () => {
            describe('Grouped by date', () => {
                it('should return tickets aggregated by day', async () => {
                    const [data] = await overviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                    })

                    expect(data.overview.ticketByDay.tickets).toHaveLength(TICKET_STATUS_TYPES.length)
                    expect(data.overview.ticketByDay.tickets.some(e => e.count === 1)).toBeTruthy()
                    expect(data.overview.ticketByDay.tickets.every(e => e.dayGroup === dayjs(dateFrom).format('DD.MM.YYYY'))).toBeTruthy()
                })

                it('should return tickets aggregated by week', async () => {
                    const [data] = await overviewDashboardByTestClient(organizationAdminUser, {
                        where: {
                            organization: organization.id,
                            dateFrom: dayjs().subtract(7, 'days').toISOString(),
                            dateTo,
                        },
                        groupBy: { aggregatePeriod: 'week' },
                    })

                    expect(data.overview.ticketByDay.tickets).toBeDefined()
                    expect(data.overview.ticketByDay.tickets.some(e => e.count === 1)).toBeTruthy()
                })
            })
            describe('Grouped by property', () => {
                it('should return tickets aggregated by property', async () => {
                    const [data] = await overviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                    })

                    expect(data.overview.ticketByProperty.tickets).toHaveLength(TICKET_STATUS_TYPES.length)
                    expect(data.overview.ticketByProperty.tickets.every(e => e.property === property.address)).toBeTruthy()
                    expect(data.overview.ticketByProperty.tickets.some(e => e.count === 1)).toBeTruthy()
                })
            })
            describe('Grouped by executor', () => {
                it('should return tickets aggregated by executor', async () => {
                    const [data] = await overviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                    })

                    const filteredByExecutor = data.overview.ticketByExecutor.tickets.filter(e => e.executor === organizationAdminUser.user.name)

                    expect(filteredByExecutor).toHaveLength(TICKET_STATUS_TYPES.length)
                    expect(filteredByExecutor.some(e => e.count === 1)).toBeTruthy()
                })
            })
            describe('Grouped by category', () => {
                it('should return tickets aggregated by category classifier', async () => {
                    const [data] = await overviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                    })

                    const filteredByClassifier = data.overview.ticketByCategory.tickets.filter(e => e.categoryClassifier === ticket.classifier.category.name)

                    expect(filteredByClassifier).toHaveLength(TICKET_STATUS_TYPES.length)
                    expect(filteredByClassifier.some(e => e.count === 1)).toBeTruthy()
                })
            })
        })
        describe('Payment', () => {
        //
        })
        describe('Receipt', () => {
        //
        })
        describe('Resident', () => {
        //
        })
    })
})
