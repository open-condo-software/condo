/**
 * Generated by `createservice analytics.GetOverviewDashboardService`
 */
const { faker } = require('@faker-js/faker')
const Big = require('big.js')
const dayjs = require('dayjs')

const {
    makeClient,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowGQLError,
    expectToThrowGraphQLRequestError,
    setFeatureFlag,
} = require('@open-condo/keystone/test.utils')
const { i18n } = require('@open-condo/locales/loader')

const {
    PAYMENT_DONE_STATUS,
    PAYMENT_WITHDRAWN_STATUS,
    PAYMENT_PROCESSING_STATUS,
    MULTIPAYMENT_PROCESSING_STATUS,
} = require('@condo/domains/acquiring/constants/payment')
const {
    makePayerAndPayments,
    updateTestPayment,
    createTestPayment,
    Payment,
    createTestMultiPayment,
    updateTestMultiPayment,
} = require('@condo/domains/acquiring/utils/testSchema')
const { ERRORS } = require('@condo/domains/analytics/schema/GetOverviewDashboardService')
const { getOverviewDashboardByTestClient } = require('@condo/domains/analytics/utils/testSchema')
const { updateTestBillingIntegrationOrganizationContext } = require('@condo/domains/billing/utils/testSchema')
const { ANALYTICS_V3 } = require('@condo/domains/common/constants/featureflags')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const {
    createTestOrganization,
    createTestOrganizationEmployeeRole,
    createTestOrganizationEmployee,
} = require('@condo/domains/organization/utils/testSchema')
const { buildingMapJson } = require('@condo/domains/property/constants/property')
const { updateTestProperty } = require('@condo/domains/property/utils/testSchema')
const { TICKET_STATUS_TYPES } = require('@condo/domains/ticket/constants')
const { QUALITY_CONTROL_VALUES_BY_KEY } = require('@condo/domains/ticket/constants/qualityControl')
const {
    createTestTicket,
    createTestTicketClassifier,
    createTestIncident,
    createTestIncidentProperty,
} = require('@condo/domains/ticket/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser } = require('@condo/domains/user/utils/testSchema')

const dateFrom = dayjs().toISOString()
const dateTo = dayjs().endOf('day').toISOString()
const INCIDENT_PAYLOAD = {
    details: faker.lorem.sentence(),
    workStart: faker.date.recent().toISOString(),
}

beforeEach(() => {
    setFeatureFlag(ANALYTICS_V3, true)
})

afterAll(() => {
    setFeatureFlag(ANALYTICS_V3, false)
})

describe('GetOverviewDashboardService', () => {
    let admin
    let organization
    let property
    let organizationAdminUser
    let acquiringContext
    let payments
    let receipts
    let resident
    let ticket
    let residentClient
    let incident

    beforeAll(async () => {
        const payerAndPayments = await makePayerAndPayments(3)
        admin = payerAndPayments.admin
        acquiringContext = payerAndPayments.acquiringContext
        organization = payerAndPayments.organization
        property = payerAndPayments.property
        payments = payerAndPayments.payments
        receipts = payerAndPayments.billingReceipts
        resident = payerAndPayments.resident
        residentClient = payerAndPayments.client
        organizationAdminUser = await makeClientWithNewRegisteredAndLoggedInUser()
        organizationAdminUser.organization = organization

        const [multiPayment] = await createTestMultiPayment(admin, [payments[1]], residentClient.user, payerAndPayments.acquiringIntegration)
        const [adminRole] = await createTestOrganizationEmployeeRole(admin, organization, {
            canManageOrganization: true,
        })
        const [executor] = await createTestOrganizationEmployee(admin, organization, organizationAdminUser.user, adminRole, {
            isAccepted: true, name: organizationAdminUser.user.name,
        })

        await updateTestBillingIntegrationOrganizationContext(admin, payerAndPayments.billingContext.id, {
            status: CONTEXT_FINISHED_STATUS,
        })
        await updateTestPayment(admin, payments[0].id, { status: PAYMENT_DONE_STATUS })
        await updateTestPayment(admin, payments[1].id, {
            status: PAYMENT_PROCESSING_STATUS, explicitFee: '0.0', multiPayment: { connect: { id: multiPayment.id } },
        })
        await updateTestMultiPayment(admin, multiPayment.id, {
            explicitFee: '0.0',
            explicitServiceCharge: '0.0',
            status: MULTIPAYMENT_PROCESSING_STATUS,
        })
        await updateTestPayment(admin, payments[1].id, {
            status: PAYMENT_WITHDRAWN_STATUS, advancedAt: dayjs().toISOString(),
        })

        const [classifier] = await createTestTicketClassifier(admin)
        const [createdTicket] = await createTestTicket(admin, organization, property, {
            executor: { connect: { id: executor.user.id } },
            classifier: { connect: { id: classifier.id } },
        })
        await createTestTicket(admin, organization, property, {
            qualityControlValue: QUALITY_CONTROL_VALUES_BY_KEY.GOOD,
        })
        await createTestTicket(admin, organization, property, {
            qualityControlValue: QUALITY_CONTROL_VALUES_BY_KEY.GOOD,
            feedbackValue: QUALITY_CONTROL_VALUES_BY_KEY.BAD,
        })
        payments = await Payment.getAll(admin, {
            organization: { id: organization.id },
            status_in: [PAYMENT_DONE_STATUS, PAYMENT_WITHDRAWN_STATUS],
        })

        ticket = createdTicket

        const [createdIncident] = await createTestIncident(admin, organization, INCIDENT_PAYLOAD)
        incident = createdIncident
        await createTestIncidentProperty(admin, incident, property)
    })

    describe('Admin', () => {
        it('can query with any organization provided', async () => {
            const [organization] = await createTestOrganization(admin)
            const [data] = await getOverviewDashboardByTestClient(admin, {
                where: { organization: organization.id, dateFrom, dateTo },
                groupBy: { aggregatePeriod: 'day' },
            })

            expect(data).toHaveProperty('overview')
            expect(data.overview).toHaveProperty(['payment', 'payments'])
            expect(data.overview).toHaveProperty(['resident', 'residents'])
            expect(data.overview).toHaveProperty(['receipt', 'receipts'])
            expect(data.overview).toHaveProperty(['property', 'sum'])
            expect(data.overview).toHaveProperty(['ticketByDay', 'tickets'])
            expect(data.overview).toHaveProperty(['ticketByProperty', 'tickets'])
            expect(data.overview).toHaveProperty(['ticketByExecutor', 'tickets'])
            expect(data.overview).toHaveProperty(['ticketByCategory', 'tickets'])
            expect(data.overview).toHaveProperty(['ticketQualityControlValue', 'tickets'])
        })
    })

    describe('User', () => {
        it('can query if it has an organization administrator role', async () => {
            const payload = { where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' } }
            const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, payload)

            expect(data.overview).toHaveProperty(['payment', 'payments', '0', 'count'], '2')
            expect(data.overview).toHaveProperty(['payment', 'sum'])
        })

        it('can\'t query if it has no canManageOrganization organization access', async () => {
            const organizationEmployee = await makeClientWithNewRegisteredAndLoggedInUser()
            organizationEmployee.organization = organization
            const [role] = await createTestOrganizationEmployeeRole(admin, organization, {
                canManageOrganization: false,
            })
            await createTestOrganizationEmployee(admin, organization, organizationEmployee.user, role, {
                isAccepted: true, name: organizationEmployee.user.name,
            })

            await expectToThrowAccessDeniedErrorToResult(async () => {
                await getOverviewDashboardByTestClient(organizationEmployee, {
                    where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                })
            })
        })

        it('can\'t query from another organization', async () => {
            const [organization] = await createTestOrganization(admin)

            await expectToThrowAccessDeniedErrorToResult(async () => {
                await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: {
                        organization: organization.id,
                        dateFrom: dayjs().startOf('month').toISOString(),
                        dateTo: dayjs().toISOString(),
                    },
                    groupBy: { aggregatePeriod: 'week' },
                })
            })
        })
    })

    describe('Resident', () => {
        it('can\'t query OverviewDashboard', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await getOverviewDashboardByTestClient(residentClient, {
                    where: {
                        organization: organization.id,
                        dateFrom: dayjs().startOf('month').toISOString(),
                        dateTo: dayjs().toISOString(),
                    },
                    groupBy: { aggregatePeriod: 'week' },
                })
            })
        })
    })

    describe('Anonymous', () => {
        it('can\'t query OverviewDashboard', async () => {
            const client = await makeClient()
            await expectToThrowAuthenticationErrorToResult(async () => {
                await getOverviewDashboardByTestClient(client, {
                    where: {
                        organization: organization.id,
                        dateFrom: dayjs().startOf('month').toISOString(),
                        dateTo: dayjs().toISOString(),
                    },
                    groupBy: { aggregatePeriod: 'week' },
                })
            })
        })
    })

    describe('Aggregation', () => {
        describe('Ticket', () => {
            describe('Grouped by date', () => {
                it('should return tickets aggregated by day', async () => {
                    const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo },
                        groupBy: { aggregatePeriod: 'day' },
                        entities: ['ticketByDay'],
                    })

                    expect(data.overview.ticketByDay.tickets).toHaveLength(TICKET_STATUS_TYPES.length)
                    expect(data.overview.ticketByDay.tickets.some(e => e.count === 3)).toBeTruthy()
                    expect(data.overview.ticketByDay.tickets.every(e => e.dayGroup === dayjs(dateFrom).format('DD.MM.YYYY'))).toBeTruthy()
                })

                it('should return each day for provided filter', async () => {
                    const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                        where: {
                            organization: organization.id,
                            dateFrom: dayjs().subtract(7, 'days').toISOString(),
                            dateTo,
                        },
                        groupBy: { aggregatePeriod: 'day' },
                    })

                    const dataWithTicket = data.overview.ticketByDay.tickets.find(e => e.count === 3)

                    expect(dataWithTicket).toBeDefined()
                    expect(data.overview.ticketByDay.tickets).toHaveLength(TICKET_STATUS_TYPES.length * 8)
                    expect(dataWithTicket.dayGroup).toMatch(dayjs().format('DD.MM.YYYY'))
                })

                it('should return tickets aggregated by week', async () => {
                    const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                        where: {
                            organization: organization.id,
                            dateFrom: dayjs().subtract(7, 'days').toISOString(),
                            dateTo,
                        },
                        groupBy: { aggregatePeriod: 'week' },
                    })

                    expect(data.overview.ticketByDay.tickets).toBeDefined()
                    expect(data.overview.ticketByDay.tickets.some(e => e.count === 3)).toBeTruthy()
                })
            })
            describe('Grouped by property', () => {
                it('should return tickets aggregated by property', async () => {
                    const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                    })

                    expect(data.overview.ticketByProperty.tickets).toHaveLength(TICKET_STATUS_TYPES.length)
                    expect(data.overview.ticketByProperty.tickets.every(e => e.property === property.address)).toBeTruthy()
                    expect(data.overview.ticketByProperty.tickets.some(e => e.count === 3)).toBeTruthy()
                })
            })
            describe('Grouped by executor', () => {
                it('should return tickets aggregated by executor', async () => {
                    const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                    })

                    const filteredByExecutor = data.overview.ticketByExecutor.tickets.filter(e => e.executor === organizationAdminUser.user.name)

                    expect(filteredByExecutor).toHaveLength(TICKET_STATUS_TYPES.length)
                    expect(filteredByExecutor.some(e => e.count === 1)).toBeTruthy()
                })
            })
            describe('Grouped by category', () => {
                it('should return tickets aggregated by category classifier', async () => {
                    const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                    })

                    const filteredByClassifier = data.overview.ticketByCategory.tickets.filter(e => e.categoryClassifier === ticket.classifier.category.name)

                    expect(filteredByClassifier).toHaveLength(TICKET_STATUS_TYPES.length)
                    expect(filteredByClassifier.some(e => e.count === 1)).toBeTruthy()
                })
            })
            describe('Grouped by ticket quality control value', () => {
                it('should count all tickets with quality control value', async () => {
                    const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                    })

                    const ticketsByQualityControlValue = data.overview.ticketQualityControlValue.tickets

                    const goodLabel = i18n('ticket.qualityControl.good')
                    const badLabel = i18n('ticket.qualityControl.bad')

                    expect(ticketsByQualityControlValue).toHaveLength(2)
                    expect(ticketsByQualityControlValue.find(e => e.qualityControlValue === goodLabel)).toHaveProperty('count', 1)
                    expect(ticketsByQualityControlValue.find(e => e.qualityControlValue === badLabel)).toHaveProperty('count', 1)
                })

                it('should able to filter tickets with quality control value by properties', async () => {
                    const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                        where: { organization: organization.id, dateFrom, dateTo, propertyIds: [property.id] },
                        groupBy: { aggregatePeriod: 'day' },
                        entities: ['ticketQualityControlValue'],
                    })

                    const ticketsByQualityControlValue = data.overview.ticketQualityControlValue.tickets

                    const goodLabel = i18n('ticket.qualityControl.good')
                    const badLabel = i18n('ticket.qualityControl.bad')

                    expect(ticketsByQualityControlValue).toHaveLength(2)
                    expect(ticketsByQualityControlValue.find(e => e.qualityControlValue === goodLabel)).toHaveProperty('count', 1)
                    expect(ticketsByQualityControlValue.find(e => e.qualityControlValue === badLabel)).toHaveProperty('count', 1)
                })
            })
        })
        describe('Payment', () => {
            it('should return sum for selected period of completed payments', async () => {
                const [payment] = await createTestPayment(admin, organization, null, acquiringContext, {
                    status: PAYMENT_DONE_STATUS,
                    period: dayjs().subtract(1, 'month').startOf('month').format('YYYY-MM-DD'),
                    advancedAt: dayjs().subtract(1, 'day').endOf('day').toISOString(),
                })

                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                })

                const completedPaymentsSum = payments
                    .reduce((prev, curr) => new Big(prev).plus(curr.amount), 0)

                expect(payments).toHaveLength(2)
                expect(data.overview).toHaveProperty(['payment', 'sum'], completedPaymentsSum.toFixed(2))

                const [selectedPeriodData] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: {
                        organization: organization.id,
                        dateFrom: dayjs().subtract(1, 'day').startOf('day').toISOString(),
                        dateTo: dayjs().subtract(1, 'day').endOf('day').toISOString(),
                    },
                    groupBy: { aggregatePeriod: 'day' },
                })

                expect(selectedPeriodData.overview).toHaveProperty(['payment', 'sum'], Number(payment.amount).toFixed(2))
            })

            it('should return sum for selected period included other periods', async () => {
                const [previousMonthPayment] = await createTestPayment(admin, organization, null, acquiringContext, {
                    status: PAYMENT_DONE_STATUS,
                    period: dayjs().subtract(1, 'month').startOf('month').format('YYYY-MM-DD'),
                    advancedAt: dayjs().toISOString(),
                })

                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                })

                const completedPaymentsSum = [...payments, previousMonthPayment]
                    .reduce((prev, curr) => new Big(prev).plus(curr.amount), 0)

                expect(data.overview).toHaveProperty(['payment', 'sum'], completedPaymentsSum.toFixed(2))
            })

            it('should return total payments grouped by period and createdBy fields', async () => {
                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                })

                const totalPaymentsSum = payments.reduce((prev, curr) => new Big(prev).plus(curr.amount), 0)

                expect(data.overview.payment.payments).toHaveLength(1)
                expect(data.overview).toHaveProperty(['payment', 'payments', '0', 'count'], '2')
                expect(data.overview).toHaveProperty(['payment', 'payments', '0', 'sum'], totalPaymentsSum.toFixed(2))
                expect(data.overview).toHaveProperty(['payment', 'payments', '0', 'createdBy'], admin.user.id)
            })

            it('should filter payments by resident property', async () => {
                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: { organization: organization.id, dateFrom, dateTo, propertyIds: [property.id] },
                    groupBy: { aggregatePeriod: 'day' },
                    entities: ['payment'],
                })

                expect(data.overview.payment.payments).toBeDefined()
            })
        })
        describe('Receipt', () => {
            it('should return sum for last month of created receipts', async () => {
                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                })

                const totalReceiptsSum = receipts.reduce((prev, curr) => new Big(prev).plus(curr.charge), 0)

                expect(data.overview).toHaveProperty(['receipt', 'sum'], totalReceiptsSum.toFixed(2))
            })

            it('should return total receipts grouped by month', async () => {
                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                })

                const totalReceiptsSum = receipts.reduce((prev, curr) => new Big(prev).plus(curr.charge), 0)

                expect(data.overview.receipt.receipts).toHaveLength(1)
                expect(data.overview).toHaveProperty(['receipt', 'receipts', '0', 'count'], '3')
                expect(data.overview).toHaveProperty(['receipt', 'receipts', '0', 'dayGroup'], dayjs().startOf('month').format('01.MM.YYYY'))
                expect(data.overview).toHaveProperty(['receipt', 'receipts', '0', 'sum'], totalReceiptsSum.toFixed(2))
            })
        })
        describe('Resident', () => {
            it('should return total residents of organization grouped by it\'s addresses', async () => {
                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: { organization: organization.id, dateFrom, dateTo }, groupBy: { aggregatePeriod: 'day' },
                })

                expect(data.overview.resident.residents).toHaveLength(1)
                expect(data.overview).toHaveProperty(['resident', 'residents', '0', 'count'], '1')
                expect(data.overview).toHaveProperty(['resident', 'residents', '0', 'address'], resident.address)
            })

            it('should return total residents filtered by property ids', async () => {
                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: {
                        organization: organization.id, dateFrom, dateTo, propertyIds: [property.id],
                    },
                    groupBy: { aggregatePeriod: 'day' },
                })

                expect(data.overview.resident.residents).toHaveLength(1)
                expect(data.overview).toHaveProperty(['resident', 'residents', '0', 'count'], '1')
            })
        })
        describe('Property', () => {
            it('should return total count of organization property living units', async () => {
                const [updatedProperty] = await updateTestProperty(admin, property.id, {
                    map: buildingMapJson,
                })

                expect(updatedProperty.unitsCount).toBeGreaterThan(0)

                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser,
                    {
                        where: {
                            organization: organization.id,
                            dateFrom,
                            dateTo,
                        },
                        groupBy: { aggregatePeriod: 'day' },
                        entities: ['property'],
                    })

                expect(data.overview).toHaveProperty(['property', 'sum'], String(updatedProperty.unitsCount))
            })
        })
        describe('Incident', () => {
            it('should return total incidents for all properties', async () => {
                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: { organization: organization.id, dateFrom, dateTo },
                    groupBy: { aggregatePeriod: 'day' },
                    entities: ['incident'],
                })

                expect(data.overview).toHaveProperty(['incident', 'count'], '1')
            })

            it('should return incidents count with filter by property', async () => {
                const [data] = await getOverviewDashboardByTestClient(organizationAdminUser, {
                    where: { organization: organization.id, dateFrom, dateTo, propertyIds: [property.id] },
                    groupBy: { aggregatePeriod: 'day' },
                    entities: ['incident'],
                })

                expect(data.overview).toHaveProperty(['incident', 'count'], '1')
            })
        })
    })

    describe('Validations', () => {
        it('cannot query OverviewDashboard without organization feature provided', async () => {
            setFeatureFlag(ANALYTICS_V3, false)
            const [organization] = await createTestOrganization(admin)

            await expectToThrowGQLError(async () => {
                await getOverviewDashboardByTestClient(admin, {
                    where: { organization: organization.id, dateFrom, dateTo },
                    groupBy: { aggregatePeriod: 'day' },
                })
            }, ERRORS.FEATURE_IS_DISABLED, 'result')
        })

        it('cannot query OverviewDashboard with unsupported period type', async () => {
            await expectToThrowGraphQLRequestError(async () => {
                await getOverviewDashboardByTestClient(admin, {
                    where: { organization: organization.id, dateFrom, dateTo },
                    groupBy: { aggregatePeriod: 'year' },
                })
            }, 'got invalid value')
        })
    })
})
