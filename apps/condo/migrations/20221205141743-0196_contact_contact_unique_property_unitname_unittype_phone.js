// auto generated by kmigrator
// KMIGRATOR:0196_contact_contact_unique_property_unitname_unittype_phone:IyBHZW5lcmF0ZWQgYnkgRGphbmdvIDQuMSBvbiAyMDIyLTEyLTA1IDA5OjE3Cgpmcm9tIGRqYW5nby5kYiBpbXBvcnQgbWlncmF0aW9ucywgbW9kZWxzCgoKY2xhc3MgTWlncmF0aW9uKG1pZ3JhdGlvbnMuTWlncmF0aW9uKToKCiAgICBkZXBlbmRlbmNpZXMgPSBbCiAgICAgICAgKCdfZGphbmdvX3NjaGVtYScsICcwMTk1X2FsdGVyX21ldGVycmVhZGluZ3NvdXJjZV90eXBlJyksCiAgICBdCgogICAgb3BlcmF0aW9ucyA9IFsKICAgICAgICBtaWdyYXRpb25zLkFkZENvbnN0cmFpbnQoCiAgICAgICAgICAgIG1vZGVsX25hbWU9J2NvbnRhY3QnLAogICAgICAgICAgICBjb25zdHJhaW50PW1vZGVscy5VbmlxdWVDb25zdHJhaW50KGNvbmRpdGlvbj1tb2RlbHMuUSgoJ2RlbGV0ZWRBdF9faXNudWxsJywgVHJ1ZSkpLCBmaWVsZHM9KCdwcm9wZXJ0eScsICd1bml0TmFtZScsICd1bml0VHlwZScsICdwaG9uZScpLCBuYW1lPSdjb250YWN0X3VuaXF1ZV9wcm9wZXJ0eV91bml0TmFtZV91bml0VHlwZV9waG9uZScpLAogICAgICAgICksCiAgICBdCg==

exports.up = async (knex) => {
    await knex.raw(`
    BEGIN;
    
    --
    -- [CUSTOM] Set Statement Timeout to some large amount - 25 min (25 * 60 => 1500 sec)
    --
    SET statement_timeout = '1500s';  
    
    --
    -- [CUSTOM] Set unitType to NULL in Tickets and Contacts which have unitName null and not null unitType 
    --
    UPDATE "Ticket"
    SET "unitType" = NULL
    WHERE "unitName" IS NULL AND "unitType" IS NOT NULL;
    
    UPDATE "Contact"
    SET "unitType" = NULL
    WHERE "unitName" IS NULL AND "unitType" IS NOT NULL;
    
    --
    -- [CUSTOM] Gets contacts with tickets to understand which contact from duplicates should remain
    --
    CREATE OR REPLACE FUNCTION getContactsWithTickets(contactIds uuid[])
        RETURNS uuid[]
    AS
    $getContactsWithTickets$
    DECLARE
        contactId           uuid;
        contactsWithTickets uuid[];
    BEGIN
        FOREACH contactId IN ARRAY contactIds
            LOOP
                IF EXISTS (
                       SELECT count(id)
                       FROM "Ticket"
                       WHERE contact = contactId
                         AND "deletedAt" IS NULL
                       LIMIT 1
                   )
                THEN
                    contactsWithTickets := array_append(contactsWithTickets, contactId);
                END IF;
            END LOOP;
    
        RETURN contactsWithTickets;
    END;
    $getContactsWithTickets$ LANGUAGE plpgsql;
    

    CREATE OR REPLACE FUNCTION getLastCreatedContactId(contactIds uuid[])
        RETURNS uuid
    AS
    $getLastCreatedContact$
    BEGIN
        RETURN (
            SELECT id
            FROM "Contact"
            WHERE id = ANY (contactIds)
              AND "deletedAt" IS NULL
            ORDER BY "createdAt" DESC
            LIMIT 1
        );
    END
    $getLastCreatedContact$ LANGUAGE plpgsql;
    
    
    --
    -- [CUSTOM] Deletes contacts duplicates and updates contact from tickets and meter readings with the remain contact
    --
    CREATE OR REPLACE FUNCTION deleteContactDuplicates()
        RETURNS void
    AS
    $deleteContactDuplicates$
    DECLARE
        duplicateData        RECORD;
        contactIds           uuid[];
        contactsWithTickets  uuid[];
        lastCreatedContactId uuid;
        contactIdsToDelete   uuid[];
    BEGIN
        FOR duplicateData IN
            SELECT "phone", "property", "unitName", "unitType"
            FROM "Contact"
            WHERE "deletedAt" IS NULL
            GROUP BY "phone", "property", "unitName", "unitType"
            HAVING count(*) > 1
            LOOP
                contactIds := array(
                        SELECT id
                        FROM "Contact"
                        WHERE "phone" = duplicateData.phone
                          AND "property" = duplicateData.property
                          AND "unitName" = duplicateData."unitName"
                          AND "unitType" = duplicateData."unitType"
                          AND "deletedAt" IS NULL
                    );
    
                contactsWithTickets := getContactsWithTickets(contactIds);
    
                -- Find the last created contact among those that have tickets, 
                -- If there are no tickets, then just the last created contact.
                -- The remaining contacts are deleted.
                IF contactsWithTickets IS NULL
                THEN
                    lastCreatedContactId := getLastCreatedContactId(contactIds);
                    contactIdsToDelete := array_remove(contactIds, lastCreatedContactId);
                ELSE
                    BEGIN
                        lastCreatedContactId := getLastCreatedContactId(contactsWithTickets);
                        contactIdsToDelete := array_remove(contactIds, lastCreatedContactId);
                    END;
                END IF;
    
                UPDATE "Ticket"
                SET "contact" = lastCreatedContactId
                WHERE "contact" = ANY (contactIdsToDelete);
    
                UPDATE "MeterReading"
                SET "contact" = lastCreatedContactId
                WHERE "contact" = ANY (contactIdsToDelete);
    
                UPDATE "Contact"
                SET "deletedAt" = now()
                WHERE id = ANY (contactIdsToDelete);
            END LOOP;
    END
    $deleteContactDuplicates$ LANGUAGE plpgsql;
    
    DO
    $$
        BEGIN
            PERFORM deleteContactDuplicates();
        END
    $$;
    
    DROP FUNCTION deleteContactDuplicates;
    DROP FUNCTION getLastCreatedContactId;
    DROP FUNCTION getContactsWithTickets;

--
-- Create constraint contact_unique_property_unitName_unitType_phone on model contact
--
CREATE UNIQUE INDEX "contact_unique_property_unitName_unitType_phone" ON "Contact" ("property", "unitName", "unitType", "phone") WHERE "deletedAt" IS NULL;

--
-- [CUSTOM] Revert Statement Timeout to default amount - 10 secs
--
SET statement_timeout = '10s';

COMMIT;

    `)
}

exports.down = async (knex) => {
    await knex.raw(`
    BEGIN;
--
-- Create constraint contact_unique_property_unitName_unitType_phone on model contact
--
DROP INDEX IF EXISTS "contact_unique_property_unitName_unitType_phone";
COMMIT;

    `)
}