/**
 * Generated by `createservice miniapp.RegisterAppServiceUserService`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')

const { makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { SERVICE } = require('@condo/domains/user/constants/common')
const { REMOTE_SYSTEM } = require('@dev-api/domains/common/constants/common')
const { PROD_ENVIRONMENT, DEV_ENVIRONMENT } = require('@dev-api/domains/miniapp/constants/publishing')
const {
    B2CAppAccessRight,
    createTestB2CApp,
    registerAppUserServiceByTestClient,
} = require('@dev-api/domains/miniapp/utils/testSchema')
const {
    makeLoggedInAdminClient,
    makeLoggedInSupportClient,
    makeRegisteredAndLoggedInUser,
    makeLoggedInCondoAdminClient,
    verifyEmailByTestClient,
    startConfirmEmailActionByTestClient,
    updateTestConfirmEmailAction,
    CondoUser,
} = require('@dev-api/domains/user/utils/testSchema')

const { ERRORS } = require('./RegisterAppServiceUserService')
 
describe('RegisterAppServiceUserService', () => {
    let admin
    let support
    let user
    let anotherUser
    let anonymous
    let condoAdmin
    let app
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeLoggedInSupportClient()
        user = await makeRegisteredAndLoggedInUser()
        anotherUser = await makeRegisteredAndLoggedInUser()
        anonymous = await makeClient()
        condoAdmin = await makeLoggedInCondoAdminClient()
    })
    describe('Access tests', () => {
        beforeEach(async () => {
            [app] = await createTestB2CApp(user)
        })
        test('Admin can register service user for any app', async () => {
            const confirmAction = await verifyEmailByTestClient(admin, admin)
            const [result] = await registerAppUserServiceByTestClient(admin, app, confirmAction)
            expect(result).toBeDefined()
            expect(result).toHaveProperty('id')
            expect(result.id).not.toBeNull()
        })
        test('Support can register service user for any app', async () => {
            const confirmAction = await verifyEmailByTestClient(support, admin)
            const [result] = await registerAppUserServiceByTestClient(support, app, confirmAction)
            expect(result).toBeDefined()
            expect(result).toHaveProperty('id')
            expect(result.id).not.toBeNull()
        })
        describe('User', () => {
            test('Can register service user for app he created', async () => {
                const confirmAction = await verifyEmailByTestClient(user, admin)
                const [result] = await registerAppUserServiceByTestClient(user, app, confirmAction)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('id')
                expect(result.id).not.toBeNull()
            })
            test('Cannot register service user for other apps', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await registerAppUserServiceByTestClient(anotherUser, app, { id: faker.datatype.uuid() })
                })
            })
        })
        test('Anonymous cannot register any service user', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await registerAppUserServiceByTestClient(anonymous, app, { id: faker.datatype.uuid() })
            })
        })
    })
    describe('Logic tests',  () => {
        describe('App tests', () => {
            test('Cannot register user for non-existing app', async () => {
                await expectToThrowGQLError(async () => {
                    await registerAppUserServiceByTestClient(support, { id: faker.datatype.uuid() }, { id: faker.datatype.uuid() })
                }, ERRORS.APP_NOT_FOUND, 'result')
            })
            test('Cannot register user if app already have linked user in access rights', async () => {
                const newUser = await makeRegisteredAndLoggedInUser()
                const [newApp] = await createTestB2CApp(newUser)
                const confirmAction = await verifyEmailByTestClient(newUser, admin)

                const [result] = await registerAppUserServiceByTestClient(newUser, newApp, confirmAction)
                expect(result).toBeDefined()

                const anotherAction = await verifyEmailByTestClient(newUser, admin)
                await expectToThrowGQLError(async () => {
                    await registerAppUserServiceByTestClient(newUser, newApp, anotherAction)
                }, ERRORS.ACCESS_RIGHT_ALREADY_EXISTS, 'result')
            })
            test('Proper access right must be created', async () => {
                const newUser = await makeRegisteredAndLoggedInUser()
                const [newApp] = await createTestB2CApp(newUser)
                const confirmAction = await verifyEmailByTestClient(newUser, admin)

                const [result] = await registerAppUserServiceByTestClient(newUser, newApp, confirmAction)
                expect(result).toBeDefined()

                const accessRight = await B2CAppAccessRight.getOne(newUser, { app: { id: newApp.id } })
                expect(accessRight).toBeDefined()
                expect(accessRight).toHaveProperty('condoUserId', result.id)
                expect(accessRight).toHaveProperty(['app', 'id'], newApp.id)
            })
            test('Each app can have separate access right for each environment', async () => {
                const newUser = await makeRegisteredAndLoggedInUser()
                const [newApp] = await createTestB2CApp(newUser)
                const firstConfirmAction = await verifyEmailByTestClient(newUser, admin)
                const secondConfirmAction = await verifyEmailByTestClient(newUser, admin)
                const [firstResult] = await registerAppUserServiceByTestClient(newUser, newApp, firstConfirmAction)
                expect(firstResult).toBeDefined()
                const [secondResult] = await registerAppUserServiceByTestClient(newUser, newApp, secondConfirmAction, { environment: PROD_ENVIRONMENT })
                expect(secondResult).toBeDefined()

                const accessRights = await B2CAppAccessRight.getAll(newUser, { app: { id: newApp.id } })
                expect(accessRights).toEqual(expect.arrayContaining([
                    expect.objectContaining({ environment: PROD_ENVIRONMENT }),
                    expect.objectContaining({ environment: DEV_ENVIRONMENT }),
                ]))
            })
        })
        describe('ConfirmEmailAction tests', () => {
            test('Cannot register user with non-existing action', async () => {
                const [newApp] = await createTestB2CApp(user)
                await expectToThrowGQLError(async () => {
                    await registerAppUserServiceByTestClient(user, newApp, { id: faker.datatype.uuid() })
                }, ERRORS.ACTION_NOT_FOUND, 'result')
            })
            const actionCases = [
                ['expired', 'expiresAt'],
                ['deleted', 'deletedAt'],
            ]
            test.each(actionCases)('Cannot register user with %p action', async (_, fieldName) => {
                const newUser = await makeRegisteredAndLoggedInUser()
                const [newApp] = await createTestB2CApp(newUser)
                const confirmAction = await verifyEmailByTestClient(newUser, admin)
                await updateTestConfirmEmailAction(admin, confirmAction.id, { [fieldName]: dayjs().toISOString() })

                await expectToThrowGQLError(async () => {
                    await registerAppUserServiceByTestClient(newUser, newApp, confirmAction)
                }, ERRORS.ACTION_NOT_FOUND, 'result')
            })
            test('Cannot register user with non-verified action', async () => {
                const newUser = await makeRegisteredAndLoggedInUser()
                const [newApp] = await createTestB2CApp(newUser)
                const [{ actionId }] = await startConfirmEmailActionByTestClient(newUser)

                await expectToThrowGQLError(async () => {
                    await registerAppUserServiceByTestClient(newUser, newApp, { id: actionId })
                }, ERRORS.ACTION_NOT_FOUND, 'result')
            })
            test('Cannot register user with the same action twice', async () => {
                const newUser = await makeRegisteredAndLoggedInUser()
                const [newApp] = await createTestB2CApp(newUser)
                const confirmAction = await verifyEmailByTestClient(newUser, admin)
                const [result] = await registerAppUserServiceByTestClient(newUser, newApp, confirmAction)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('id')
                expect(result.id).not.toBeNull()

                await expectToThrowGQLError(async () => {
                    await registerAppUserServiceByTestClient(newUser, newApp, confirmAction)
                }, ERRORS.ACTION_NOT_FOUND, 'result')
            })
        })
        describe('User tests', () => {
            test('Cannot register multiple users with same email', async () => {
                const newUser = await makeRegisteredAndLoggedInUser()
                const [firstApp] = await createTestB2CApp(newUser)
                const email = faker.internet.email()
                const firstConfirmAction = await verifyEmailByTestClient(newUser, admin, email)

                const [result] = await registerAppUserServiceByTestClient(newUser, firstApp, firstConfirmAction)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('id')
                expect(result.id).not.toBeNull()

                const secondConfirmAction = await verifyEmailByTestClient(newUser, admin, email)
                const [secondApp] = await createTestB2CApp(newUser)
                await expectToThrowGQLError(async () => {
                    await registerAppUserServiceByTestClient(newUser, secondApp, secondConfirmAction)
                }, ERRORS.CONDO_USER_ALREADY_EXISTS, 'result')
            })
            test('Proper condo user must be created', async () => {
                const newUser = await makeRegisteredAndLoggedInUser()
                const [newApp] = await createTestB2CApp(newUser)
                const confirmAction = await verifyEmailByTestClient(newUser, admin)

                const [result] = await registerAppUserServiceByTestClient(newUser, newApp, confirmAction)
                expect(result).toBeDefined()
                expect(result).toHaveProperty('id')
                expect(result.id).not.toBeNull()

                const condoUser = await CondoUser.getOne(condoAdmin, { id: result.id })
                expect(condoUser).toHaveProperty('name')
                expect(condoUser.name.toLowerCase()).toContain('b2c')
                expect(condoUser.name.toLowerCase()).toContain(REMOTE_SYSTEM.toLowerCase())
                expect(condoUser.name.toLowerCase()).toContain(newApp.name.toLowerCase())
                expect(condoUser).toHaveProperty('meta', expect.objectContaining({
                    appType: 'B2C',
                    appId: newApp.id,
                }))
                expect(condoUser).toHaveProperty('type', SERVICE)
            })
        })
    })
})