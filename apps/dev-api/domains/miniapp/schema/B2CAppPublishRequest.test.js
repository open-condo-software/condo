/**
 * Generated by `createschema miniapp.B2CAppPublishRequest 'app:Relationship:B2CApp:CASCADE; status:Text'`
 */

const dayjs = require('dayjs')

const { GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj,
    expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
    expectToThrowUniqueConstraintViolationError,
    expectToThrowGQLError,
    catchErrorFrom,
} = require('@open-condo/keystone/test.utils')

const { B2C_APP_PUBLISH_REQUEST_UNIQUE_CONSTRAINT } = require('@dev-api/domains/miniapp/constants/constraints')
const { APPROVE_NOT_ALLOWED } = require('@dev-api/domains/miniapp/constants/errors')
const { PUBLISH_REQUEST_PENDING_STATUS, PUBLISH_REQUEST_APPROVED_STATUS } = require('@dev-api/domains/miniapp/constants/publishing')
const {
    B2CAppPublishRequest,
    createTestB2CAppPublishRequest,
    updateTestB2CAppPublishRequest,
    createTestB2CApp,
} = require('@dev-api/domains/miniapp/utils/testSchema')
const {
    makeLoggedInAdminClient,
    makeLoggedInSupportClient,
    makeRegisteredAndLoggedInUser,
} = require('@dev-api/domains/user/utils/testSchema')


describe('B2CAppPublishRequest', () => {
    let admin
    let support
    let creator
    let anotherUser
    let anonymous
    let app
    let request
    const prerequisitesFields = [
        'isAppTested',
        'isContractSigned',
        'isInfoApproved',
    ]
    beforeAll(async () => {
        admin = await makeLoggedInAdminClient()
        support = await makeLoggedInSupportClient()
        creator = await makeRegisteredAndLoggedInUser()
        anotherUser = await makeRegisteredAndLoggedInUser()
        anonymous = await makeClient();
        [app] = await createTestB2CApp(creator)
    })
    afterEach(async () => {
        if (request) {
            await updateTestB2CAppPublishRequest(admin, request.id, {
                deletedAt: dayjs().toISOString(),
            })
            request = undefined
        }
    })
    describe('CRUD tests', () => {
        describe('Create', () => {
            test('Admin can', async () => {
                [request] = await createTestB2CAppPublishRequest(admin, app)
                expect(request).toHaveProperty('id')
            })
            test('Support can', async () => {
                [request] = await createTestB2CAppPublishRequest(support, app)
                expect(request).toHaveProperty('id')
            })
            describe('User', () => {
                test('App creator can', async () => {
                    [request] = await createTestB2CAppPublishRequest(creator, app)
                    expect(request).toHaveProperty('id')
                })
                test('Other users cannot', async () => {
                    await expectToThrowAccessDeniedErrorToObj(async () => {
                        await createTestB2CAppPublishRequest(anotherUser, app)
                    })
                })
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestB2CAppPublishRequest(anonymous, app)
                })
            })
        })
        describe('Update', () => {
            beforeEach(async () => {
                [request] = await createTestB2CAppPublishRequest(admin, app)
            })
            test('Admin can update and soft-delete', async () => {
                const [updatedRequest] = await updateTestB2CAppPublishRequest(admin, request.id, {
                    isAppTested: true,
                })
                expect(updatedRequest).toHaveProperty('isAppTested', true)
                const [deletedRequest] = await updateTestB2CAppPublishRequest(admin, request.id, {
                    deletedAt: dayjs().toISOString(),
                })
                expect(deletedRequest).toHaveProperty('deletedAt')
                expect(deletedRequest.deletedAt).not.toBeNull()
                // Prevent re-deletion in cleanup
                request = undefined
            })
            test('Support can update and soft-delete', async () => {
                const [updatedRequest] = await updateTestB2CAppPublishRequest(support, request.id, {
                    isAppTested: true,
                })
                expect(updatedRequest).toHaveProperty('isAppTested', true)
                const [deletedRequest] = await updateTestB2CAppPublishRequest(support, request.id, {
                    deletedAt: dayjs().toISOString(),
                })
                expect(deletedRequest).toHaveProperty('deletedAt')
                expect(deletedRequest.deletedAt).not.toBeNull()
                // Prevent re-deletion in cleanup
                request = undefined
            })
            test('User cannot', async () => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2CAppPublishRequest(creator, request.id, {})
                })
            })
            test('Anonymous', async () => {
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestB2CAppPublishRequest(anonymous, request.id, {})
                })
            })
        })
        describe('Read', () => {
            let appRequest
            let anotherRequest
            beforeAll(async () => {
                [appRequest] = await createTestB2CAppPublishRequest(creator, app)
                const [anotherApp] = await createTestB2CApp(anotherUser);
                [anotherRequest] = await createTestB2CAppPublishRequest(anotherUser, anotherApp)
            })
            afterAll(async () => {
                await updateTestB2CAppPublishRequest(admin, appRequest.id, {
                    deletedAt: dayjs().toISOString(),
                })
            })
            test('Admin can read all', async ()=> {
                const requests = await B2CAppPublishRequest.getAll(admin, { id_in: [appRequest.id, anotherRequest.id] })
                expect(requests).toHaveLength(2)
            })
            test('Support can read all', async ()=> {
                const requests = await B2CAppPublishRequest.getAll(support, { id_in: [appRequest.id, anotherRequest.id] })
                expect(requests).toHaveLength(2)
            })
            test('User can read only requests related to app he created', async () => {
                const requests = await B2CAppPublishRequest.getAll(creator, { id_in: [appRequest.id, anotherRequest.id] })
                expect(requests).toEqual([
                    expect.objectContaining({ id: appRequest.id }),
                ])
            })
            test('Anonymous cannot', async () => {
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await B2CAppPublishRequest.getAll(anonymous, { id_in: [appRequest.id, anotherRequest.id] })
                })
            })
        })
        test('Hard-delete is prohibited', async () => {
            [request] = await createTestB2CAppPublishRequest(admin, app)
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await B2CAppPublishRequest.delete(admin, request.id)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await B2CAppPublishRequest.delete(support, request.id)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await B2CAppPublishRequest.delete(creator, request.id)
            })
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await B2CAppPublishRequest.delete(anonymous, request.id)
            })
        })
    })
    describe('Field accesses', () => {
        test('app field cannot be changed', async () => {
            [request] = await createTestB2CAppPublishRequest(admin, app)
            const [anotherApp] = await createTestB2CApp(anotherUser)

            await catchErrorFrom(async () => {
                await updateTestB2CAppPublishRequest(admin, request.id, {
                    app: { connect: { id: anotherApp.id } },
                })
            }, ({ errors }) => {
                expect(errors).toHaveLength(1)
                expect(errors[0].message).toContain('Field "app" is not defined by type "B2CAppPublishRequestUpdateInput"')
            })
        })
        describe('Checkbox fields are not available for modifying by app creator', () => {
            test.each(prerequisitesFields)('%p field', async (field) => {
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2CAppPublishRequest(creator, app, {
                        [field]: true,
                    })
                });
                [request] = await createTestB2CAppPublishRequest(support, app, {
                    [field]: true,
                })
                expect(request).toHaveProperty(field, true)
            })
        })
        test('status field is not available for modifying for app creator', async () => {
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await createTestB2CAppPublishRequest(creator, app, {
                    status: PUBLISH_REQUEST_PENDING_STATUS,
                })
            });
            [request] = await createTestB2CAppPublishRequest(support, app, {
                status: PUBLISH_REQUEST_PENDING_STATUS,
            })
            expect(request).toHaveProperty('status', PUBLISH_REQUEST_PENDING_STATUS)
        })
    })
    describe('Validations', () => {
        test('All checkboxes must be false by default', async () => {
            [request] = await createTestB2CAppPublishRequest(creator, app)
            const expectedPayload = Object.assign({}, ...prerequisitesFields.map(field => ({ [field]: false })))
            expect(request).toEqual(expect.objectContaining(expectedPayload))
        })
        test(`Status must be ${PUBLISH_REQUEST_PENDING_STATUS} by default`, async () => {
            [request] = await createTestB2CAppPublishRequest(creator, app)
            expect(request).toHaveProperty('status', PUBLISH_REQUEST_PENDING_STATUS)
        })
        test(`Cannot change status to ${PUBLISH_REQUEST_APPROVED_STATUS} until all prerequisites are met`, async () => {
            [request] = await createTestB2CAppPublishRequest(creator, app)
            await expectToThrowGQLError(async () => {
                await updateTestB2CAppPublishRequest(support, request.id, {
                    status: PUBLISH_REQUEST_APPROVED_STATUS,
                })
            }, {
                code: BAD_USER_INPUT,
                type: APPROVE_NOT_ALLOWED,
            })
            for (let i = 0; i < prerequisitesFields.length; i++) {
                const field = prerequisitesFields[i]
                const [updatedRequest] = await updateTestB2CAppPublishRequest(support, request.id, {
                    [field]: true,
                })
                expect(updatedRequest).toHaveProperty(field, true)
                if (i < prerequisitesFields.length - 1) {
                    // eslint-disable-next-line @typescript-eslint/no-loop-func
                    await expectToThrowGQLError(async () => {
                        await updateTestB2CAppPublishRequest(support, request.id, {
                            status: PUBLISH_REQUEST_APPROVED_STATUS,
                        })
                    }, {
                        code: BAD_USER_INPUT,
                        type: APPROVE_NOT_ALLOWED,
                    })
                } else {
                    const [approvedRequest] = await updateTestB2CAppPublishRequest(support, request.id, {
                        status: PUBLISH_REQUEST_APPROVED_STATUS,
                    })
                    expect(approvedRequest).toHaveProperty('status', PUBLISH_REQUEST_APPROVED_STATUS)
                }
            }
        })
    })
    describe('Constraints', () => {
        test('Cannot create multiple publish requests for a single app', async () => {
            [request] = await createTestB2CAppPublishRequest(creator, app)
            expect(request).toHaveProperty('id')

            await expectToThrowUniqueConstraintViolationError(async () => {
                await createTestB2CAppPublishRequest(admin, app)
            }, B2C_APP_PUBLISH_REQUEST_UNIQUE_CONSTRAINT)

            await updateTestB2CAppPublishRequest(admin, request.id, {
                deletedAt: dayjs().toISOString(),
            });

            [request] = await createTestB2CAppPublishRequest(creator, app)
            expect(request).toHaveProperty('id')
        })
    })
})
