/**
 * Generated by `createservice miniapp.UpdateOIDCClientUrlService`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { REMOTE_SYSTEM } = require('@dev-api/domains/common/constants/common')
const { productionClient, developmentClient } = require('@dev-api/domains/common/utils/serverClients')
const { CondoOIDCClientGql } = require('@dev-api/domains/condo/gql')
const access = require('@dev-api/domains/miniapp/access/UpdateOIDCClientUrlService')
const { OIDC_CLIENT_NOT_FOUND, INVALID_URL, HTTPS_ONLY } = require('@dev-api/domains/miniapp/constants/errors')
const { PROD_ENVIRONMENT } = require('@dev-api/domains/miniapp/constants/publishing')

const ERRORS = {
    OIDC_CLIENT_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: OIDC_CLIENT_NOT_FOUND,
        message: 'OIDC client for the specified application was not found',
        messageForUser: 'errors.OIDC_CLIENT_NOT_FOUND.message',
    },
    INVALID_URL: {
        code: BAD_USER_INPUT,
        type: INVALID_URL,
        message: 'The specified redirectUri is not a valid URL',
        messageForUser: 'errors.INVALID_URL.message',
    },
    HTTPS_ONLY: {
        code: BAD_USER_INPUT,
        type: HTTPS_ONLY,
        message: 'The URL has a non-valid protocol. Only https is allowed for the selected environment',
        messageForUser: 'errors.HTTPS_ONLY.message',
    },
}

const UpdateOIDCClientUrlService = new GQLCustomSchema('UpdateOIDCClientUrlService', {
    types: [
        {
            access: true,
            type: 'input UpdateOIDCClientUrlInput { dv: Int!, sender: SenderFieldInput!, app: AppWhereUniqueInput!, environment: AppEnvironment!, redirectUri: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canUpdateOIDCClientUrl,
            schema: 'updateOIDCClientUrl(data: UpdateOIDCClientUrlInput!): OIDCClient',
            resolver: async (parent, args, context) => {
                const { data: { app, environment, dv, sender, redirectUri } } = args

                let url
                try {
                    url = new URL(redirectUri)
                } catch {
                    throw new GQLError(ERRORS.INVALID_URL, context)
                }

                const proto = url.protocol
                if (proto !== 'https:' && proto !== 'http:') {
                    throw new GQLError(ERRORS.INVALID_URL, context)
                }

                if (environment === PROD_ENVIRONMENT && proto !== 'https:') {
                    throw new GQLError(ERRORS.HTTPS_ONLY, context)
                }

                const serverClient = environment === PROD_ENVIRONMENT
                    ? productionClient
                    : developmentClient

                const oidcClients = await serverClient.getModels({
                    modelGql: CondoOIDCClientGql,
                    where: {
                        clientId: app.id,
                        importId: app.id,
                        importRemoteSystem: REMOTE_SYSTEM,
                    },
                })

                if (!oidcClients.length) {
                    throw new GQLError(ERRORS.OIDC_CLIENT_NOT_FOUND, context)
                }

                const oidcClient = oidcClients[0]
                const updatedClient = await serverClient.updateModel({
                    modelGql: CondoOIDCClientGql,
                    id: oidcClient.id,
                    updateInput: {
                        dv,
                        sender,
                        payload: { ...oidcClient.payload, redirect_uris: [url.toString()] },
                    },
                })

                return {
                    id: updatedClient.id,
                    clientId: updatedClient.clientId,
                    redirectUri: updatedClient.payload.redirect_uris[0],
                }
            },
        },
    ],
    
})

module.exports = {
    UpdateOIDCClientUrlService,
}
