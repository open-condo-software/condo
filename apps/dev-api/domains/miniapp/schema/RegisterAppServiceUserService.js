/**
 * Generated by `createservice miniapp.RegisterAppServiceUserService`
 */

const dayjs = require('dayjs')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, getByCondition } = require('@open-condo/keystone/schema')

const { productionClient, developmentClient } = require('@dev-api/domains/common/utils/serverClients')
const access = require('@dev-api/domains/miniapp/access/RegisterAppServiceUserService')
const { APP_NOT_FOUND } = require('@dev-api/domains/miniapp/constants/errors')
const { PROD_ENVIRONMENT } = require('@dev-api/domains/miniapp/constants/publishing')
const { B2CAppAccessRight } = require('@dev-api/domains/miniapp/utils/serverSchema')
const { ACTION_NOT_FOUND } = require('@dev-api/domains/user/constants/errors')
const { ConfirmEmailAction } = require('@dev-api/domains/user/utils/serverSchema')

const ERRORS = {
    ACTION_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: ACTION_NOT_FOUND,
        message: 'ConfirmEmailAction with the specified ID is not verified, expired, or does not exist',
        messageForUser: 'errors.ACTION_NOT_FOUND.email.message',
    },
    APP_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: APP_NOT_FOUND,
        message: 'The application with the specified ID was not found',
        messageForUser: 'errors.APP_NOT_FOUND.message',
    },
}

const RegisterAppServiceUserService = new GQLCustomSchema('RegisterAppServiceUserService', {
    types: [
        {
            access: true,
            type: 'enum AppType { B2B B2C }',
        },
        {
            access: true,
            type: 'input RegisterAppUserServiceInput { dv: Int!, sender: SenderFieldInput!, app: AppWhereUniqueInput!, environment: AppEnvironment!, confirmEmailAction: ConfirmEmailActionWhereUniqueInput! }',
        },
        {
            access: true,
            type: 'type RegisterAppUserServiceOutput { id: ID! }',
        },
    ],
    
    mutations: [
        {
            access: access.canRegisterAppUserService,
            schema: 'registerAppUserService(data: RegisterAppUserServiceInput!): RegisterAppUserServiceOutput',
            resolver: async (parent, args, context) => {
                const { data: { dv, sender, app: { id: appId }, environment, confirmEmailAction: { id: actionId } } } = args

                const b2cApp = await getByCondition('B2CApp', { id: appId, deletedAt: null })
                if (!b2cApp) {
                    throw new GQLError(ERRORS.APP_NOT_FOUND, context)
                }

                const currentTime = dayjs().toISOString()

                const confirmAction = await ConfirmEmailAction.getOne(context, {
                    id: actionId,
                    expiresAt_gte: currentTime,
                    deletedAt: null,
                    isVerified: true,
                })

                if (!confirmAction) {
                    throw new GQLError(ERRORS.ACTION_NOT_FOUND, context)
                }

                // NOTE: Mark action as used by deleting it
                await ConfirmEmailAction.update(context, confirmAction.id, {
                    deletedAt: currentTime,
                    dv,
                    sender,
                })

                const { email: normalizedEmail } = confirmAction

                const serverClient = environment === PROD_ENVIRONMENT
                    ? productionClient
                    : developmentClient

                const appType = 'B2C'
                const appName = b2cApp.name

                const condoUser = await serverClient.registerServiceUser({
                    email: normalizedEmail,
                    dv,
                    sender,
                    name: `[DEV-API][${appType}] ${appName}`,
                    meta: {
                        appType,
                        appId,
                    },
                })

                await B2CAppAccessRight.create(context, {
                    dv,
                    sender,
                    condoUserId: condoUser.id,
                    environment,
                    app: { connect: { id: appId } },
                })


                return {
                    id: condoUser.id,
                }
            },
        },
    ],
    
})

module.exports = {
    RegisterAppServiceUserService,
}
