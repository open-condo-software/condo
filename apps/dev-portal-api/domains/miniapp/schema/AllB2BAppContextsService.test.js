/**
 * Generated by `createservice miniapp.AllB2BAppContextsService`
 */

const { faker } = require('@faker-js/faker')
const dayjs = require('dayjs')
const omit = require('lodash/omit')

const { GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { makeClient } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAccessDeniedErrorToResult,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')

const { CONTEXT_FINISHED_STATUS, CONTEXT_IN_PROGRESS_STATUS } = require('@condo/domains/miniapp/constants')
const { APP_NOT_FOUND } = require('@dev-portal-api/domains/miniapp/constants/errors')
const { PROD_ENVIRONMENT, DEV_ENVIRONMENT } = require('@dev-portal-api/domains/miniapp/constants/publishing')
const { PUBLISH_REQUEST_APPROVED_STATUS } = require('@dev-portal-api/domains/miniapp/constants/publishing')
const {
    createTestB2BApp,
    updateCondoB2BApp,
    publishB2BAppByTestClient,
    B2BApp,
    createCondoB2BAppContexts,
    createTestB2BAppPublishRequest,
    allB2BAppContextsByTestClient,
} = require('@dev-portal-api/domains/miniapp/utils/testSchema')
const {
    makeLoggedInAdminClient,
    makeLoggedInSupportClient,
    makeRegisteredAndLoggedInUser,
    makeLoggedInCondoAdminClient,
} = require('@dev-portal-api/domains/user/utils/testSchema')

const STATUS_ORDER = [
    CONTEXT_IN_PROGRESS_STATUS,
    CONTEXT_FINISHED_STATUS,
]

function compareContexts (a, b) {
    const statusDiff = STATUS_ORDER.indexOf(a.status) - STATUS_ORDER.indexOf(b.status)
    if (statusDiff !== 0) {
        return statusDiff
    }

    const createdDiff = (new Date(a.createdAt)).getTime() - (new Date(b.createdAt)).getTime()
    if (createdDiff !== 0) {
        return -createdDiff
    }

    return a.id.localeCompare(b.id)
}

function randomizeCase (str) {
    return str.split('').map(char => {
        return Math.random() > 0.5 ? char.toUpperCase() : char.toLowerCase()
    }).join('')
}

function filterContextsBySearch (contexts, search) {
    const searchLower = search.toLowerCase()
    return contexts.filter(ctx => {
        const nameLower = ctx.organization.name.toLowerCase()
        const tinLower = (ctx.organization.tin || '').toLowerCase()
        return nameLower.includes(searchLower) || tinLower.includes(searchLower)
    })
}

describe('AllB2BAppContextsService', () => {
    let condoAdmin
    let admin
    let support
    let user
    let anotherUser
    let anonymous

    let app
    let devContexts
    let prodContexts
    beforeAll(async () => {
        condoAdmin = await makeLoggedInCondoAdminClient()
        admin = await makeLoggedInAdminClient()
        support = await makeLoggedInSupportClient()
        user = await makeRegisteredAndLoggedInUser()
        anotherUser = await makeRegisteredAndLoggedInUser()
        anonymous = await makeClient();

        [app] = await createTestB2BApp(user)
        await createTestB2BAppPublishRequest(support, app, {
            isAppTested: true,
            isContractSigned: true,
            isInfoApproved: true,
            status: PUBLISH_REQUEST_APPROVED_STATUS,
        })

        // NOTE: Code below is hacky :),
        // since in test environment single condo instance is used as prod and dev stand at the same time,
        // publish mutation will merge this case into single app,
        // so allB2BAppContext query will return properties from both stands, so we'll have x2 results
        // To achieve separation I'll explicitly set importId for apps to null, so findExportedModel will work as for separate stands
        await publishB2BAppByTestClient(user, app)
        app = await B2BApp.getOne(user, { id: app.id })
        await updateCondoB2BApp(condoAdmin, { id: app.developmentExportId }, { importId: null, importRemoteSystem: null })
        await publishB2BAppByTestClient(user, app, { info: true }, PROD_ENVIRONMENT)
        app = await B2BApp.getOne(user, { id: app.id })
        await updateCondoB2BApp(condoAdmin, { id: app.productionExportId }, { importId: null, importRemoteSystem: null })

        const [devConnectedContexts] = await createCondoB2BAppContexts(condoAdmin, { id: app.developmentExportId }, 15, CONTEXT_FINISHED_STATUS)
        const [devInProgressContexts] = await createCondoB2BAppContexts(condoAdmin, { id: app.developmentExportId }, 15, CONTEXT_IN_PROGRESS_STATUS)
        const [prodConnectedContexts] = await createCondoB2BAppContexts(condoAdmin, { id: app.productionExportId }, 15, CONTEXT_FINISHED_STATUS)
        const [prodInProgressContexts] = await createCondoB2BAppContexts(condoAdmin, { id: app.productionExportId }, 15, CONTEXT_IN_PROGRESS_STATUS)
        devContexts = [...devConnectedContexts, ...devInProgressContexts].toSorted(compareContexts).map(ctx => omit(ctx, 'app', 'createdAt'))
        prodContexts = [...prodConnectedContexts, ...prodInProgressContexts].toSorted(compareContexts).map(ctx => omit(ctx, 'app', 'createdAt'))
    })
    describe('Access tests', () => {
        test('Admin can see properties of all apps', async () => {
            const [devResult] = await allB2BAppContextsByTestClient(admin, app, DEV_ENVIRONMENT)
            expect(devResult).toHaveProperty(['meta', 'count'], 30)
            expect(devResult).toHaveProperty('objs', expect.arrayContaining(devContexts))
            const [prodResult] = await allB2BAppContextsByTestClient(admin, app, PROD_ENVIRONMENT)
            expect(prodResult).toHaveProperty(['meta', 'count'], 30)
            expect(prodResult).toHaveProperty('objs', expect.arrayContaining(prodContexts))
        })
        test('Support can see properties of all apps', async () => {
            const [devResult] = await allB2BAppContextsByTestClient(support, app, DEV_ENVIRONMENT)
            expect(devResult).toHaveProperty(['meta', 'count'], 30)
            expect(devResult).toHaveProperty('objs', expect.arrayContaining(devContexts))
            const [prodResult] = await allB2BAppContextsByTestClient(support, app, PROD_ENVIRONMENT)
            expect(prodResult).toHaveProperty(['meta', 'count'], 30)
            expect(prodResult).toHaveProperty('objs', expect.arrayContaining(prodContexts))
        })
        describe('User', () => {
            test('Can see properties of app he created', async () => {
                const [devResult] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT)
                expect(devResult).toHaveProperty(['meta', 'count'], 30)
                expect(devResult).toHaveProperty('objs', expect.arrayContaining(devContexts))
                const [prodResult] = await allB2BAppContextsByTestClient(user, app, PROD_ENVIRONMENT)
                expect(prodResult).toHaveProperty(['meta', 'count'], 30)
                expect(prodResult).toHaveProperty('objs', expect.arrayContaining(prodContexts))
            })
            test('Cannot see properties of another apps', async () => {
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await allB2BAppContextsByTestClient(anotherUser, app, DEV_ENVIRONMENT)
                })
                await expectToThrowAccessDeniedErrorToResult(async () => {
                    await allB2BAppContextsByTestClient(anotherUser, app, PROD_ENVIRONMENT)
                })
            })
        })
        test('Anonymous cannot see any properties', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await allB2BAppContextsByTestClient(anonymous, app, DEV_ENVIRONMENT)
            })
            await expectToThrowAuthenticationErrorToResult(async () => {
                await allB2BAppContextsByTestClient(anonymous, app, PROD_ENVIRONMENT)
            })
        })
    })
    describe('Logic tests', () => {
        test('Meta count must not change because of pagination', async () => {
            const [devResult] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT, {
                first: 10,
                skip: 5,
            })
            expect(devResult).toHaveProperty(['meta', 'count'], 30)
            expect(devResult).toHaveProperty('objs')
            expect(devResult.objs).toHaveLength(10)
        })
        test('Must throw APP_NOT_FOUND error, if invalid app id passed', async () => {
            await expectToThrowGQLError(async () => {
                await allB2BAppContextsByTestClient(support, { id: faker.datatype.uuid() }, DEV_ENVIRONMENT)
            }, {
                code: BAD_USER_INPUT,
                type: APP_NOT_FOUND,
            }, 'result')
            await expectToThrowGQLError(async () => {
                await allB2BAppContextsByTestClient(support, { id: faker.datatype.uuid() }, PROD_ENVIRONMENT)
            }, {
                code: BAD_USER_INPUT,
                type: APP_NOT_FOUND,
            }, 'result')
        })
        test('Must throw APP_NOT_FOUND error, if app has no export id field', async () => {
            const [devOnlyApp] = await createTestB2BApp(user)
            await expectToThrowGQLError(async () => {
                await allB2BAppContextsByTestClient(user, devOnlyApp, DEV_ENVIRONMENT)
            }, {
                code: BAD_USER_INPUT,
                type: APP_NOT_FOUND,
            }, 'result')

            await publishB2BAppByTestClient(user, devOnlyApp)
            const updatedDevOnlyApp = await B2BApp.getOne(user, { id: devOnlyApp.id })
            expect(updatedDevOnlyApp).toHaveProperty('developmentExportId', expect.stringContaining(''))
            expect(updatedDevOnlyApp).toHaveProperty('productionExportId', null)

            const [devResult] = await allB2BAppContextsByTestClient(user, updatedDevOnlyApp, DEV_ENVIRONMENT)
            expect(devResult).toHaveProperty(['meta', 'count'], 0)
            expect(devResult).toHaveProperty('objs', [])

            await expectToThrowGQLError(async () => {
                await allB2BAppContextsByTestClient(user, updatedDevOnlyApp, PROD_ENVIRONMENT)
            }, {
                code: BAD_USER_INPUT,
                type: APP_NOT_FOUND,
            }, 'result')
        })
        test('Must throw APP_NOT_FOUND error, if app was deleted in condo', async () => {
            let [app] = await createTestB2BApp(user)
            await createTestB2BAppPublishRequest(support, app, {
                isAppTested: true,
                isContractSigned: true,
                isInfoApproved: true,
                status: PUBLISH_REQUEST_APPROVED_STATUS,
            })
            await publishB2BAppByTestClient(user, app)
            app = await B2BApp.getOne(user, { id: app.id })
            await updateCondoB2BApp(condoAdmin, { id: app.developmentExportId }, { importId: null, importRemoteSystem: null })
            await publishB2BAppByTestClient(user, app, { info: true }, PROD_ENVIRONMENT)
            app = await B2BApp.getOne(user, { id: app.id })
            await updateCondoB2BApp(condoAdmin, { id: app.productionExportId }, { importId: null, importRemoteSystem: null })

            const [devResult] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT)
            expect(devResult).toHaveProperty(['meta', 'count'], 0)
            const [prodResult] = await allB2BAppContextsByTestClient(user, app, PROD_ENVIRONMENT)
            expect(prodResult).toHaveProperty(['meta', 'count'], 0)

            await updateCondoB2BApp(condoAdmin, { id: app.developmentExportId }, {
                deletedAt: dayjs().toISOString(),
            })

            await expectToThrowGQLError(async () => {
                await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT)
            }, {
                code: BAD_USER_INPUT,
                type: APP_NOT_FOUND,
            }, 'result')
            const [secondProdResult] = await allB2BAppContextsByTestClient(user, app, PROD_ENVIRONMENT)
            expect(secondProdResult).toHaveProperty(['meta', 'count'], 0)

            await updateCondoB2BApp(condoAdmin, { id: app.productionExportId }, {
                deletedAt: dayjs().toISOString(),
            })
            await expectToThrowGQLError(async () => {
                await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT)
            }, {
                code: BAD_USER_INPUT,
                type: APP_NOT_FOUND,
            }, 'result')
            await expectToThrowGQLError(async () => {
                await allB2BAppContextsByTestClient(user, app, PROD_ENVIRONMENT)
            }, {
                code: BAD_USER_INPUT,
                type: APP_NOT_FOUND,
            }, 'result')
        })
        test('Pagination must work', async () => {
            const [firstDevResult] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT, {
                first: 20,
                skip: 0,
            })
            expect(firstDevResult.objs).toHaveLength(20)
            const [secondDevResult] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT, {
                first: 20,
                skip: 20,
            })
            expect(secondDevResult.objs).toHaveLength(10)
            const totalDevResult = firstDevResult.objs.concat(secondDevResult.objs)
            expect(totalDevResult).toEqual(expect.arrayContaining(devContexts))

            const [firstProdResult] = await allB2BAppContextsByTestClient(user, app, PROD_ENVIRONMENT, {
                first: 20,
                skip: 0,
            })
            expect(firstProdResult.objs).toHaveLength(20)
            const [secondProdResult] = await allB2BAppContextsByTestClient(user, app, PROD_ENVIRONMENT, {
                first: 20,
                skip: 20,
            })
            expect(secondProdResult.objs).toHaveLength(10)
            const totalProdResult = firstProdResult.objs.concat(secondProdResult.objs)
            expect(totalProdResult).toEqual(expect.arrayContaining(prodContexts))
        })
        test(`"${CONTEXT_IN_PROGRESS_STATUS}" context must be shown before "${CONTEXT_FINISHED_STATUS}" and newer contexts should also be shown first`, async () => {
            const [devResult] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT)
            expect(devResult.objs).toEqual(devContexts)
            const [prodResult] = await allB2BAppContextsByTestClient(user, app, PROD_ENVIRONMENT)
            expect(prodResult.objs).toEqual(prodContexts)
        })

        describe('Search functionality', () => {
            test('Without search parameter everything is returned', async () => {
                const [devResult] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT)
                expect(devResult).toHaveProperty(['meta', 'count'], 30)
                expect(devResult.objs).toHaveLength(30)

                const [prodResult] = await allB2BAppContextsByTestClient(user, app, PROD_ENVIRONMENT)
                expect(prodResult).toHaveProperty(['meta', 'count'], 30)
                expect(prodResult.objs).toHaveLength(30)
            })

            test('Full search by TIN case insensitive', async () => {
                const randomIndex = Math.floor(Math.random() * devContexts.length)
                const targetContext = devContexts[randomIndex]
                const searchTin = targetContext.organization.tin
                expect(searchTin).toBeDefined()
                expect(searchTin.length).toBeGreaterThanOrEqual(4)

                const randomCaseTin = randomizeCase(searchTin)
                const expectedContexts = filterContextsBySearch(devContexts, searchTin)

                const [result] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT, {
                    search: randomCaseTin,
                })

                expect(result).toHaveProperty(['meta', 'count'], expectedContexts.length)
                expect(result.objs).toHaveLength(expectedContexts.length)
                expect(result.objs).toEqual(expect.arrayContaining(expectedContexts))
            })

            test('Full search by name case insensitive', async () => {
                const randomIndex = Math.floor(Math.random() * devContexts.length)
                const targetContext = devContexts[randomIndex]
                const searchName = targetContext.organization.name
                expect(searchName).toBeDefined()
                expect(searchName.length).toBeGreaterThanOrEqual(4)

                const randomCaseName = randomizeCase(searchName)
                const expectedContexts = filterContextsBySearch(devContexts, searchName)

                const [result] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT, {
                    search: randomCaseName,
                })

                expect(result).toHaveProperty(['meta', 'count'], expectedContexts.length)
                expect(result.objs).toHaveLength(expectedContexts.length)
                expect(result.objs).toEqual(expect.arrayContaining(expectedContexts))
            })

            test('Search by substring of TIN case insensitive', async () => {
                const randomIndex = Math.floor(Math.random() * devContexts.length)
                const targetContext = devContexts[randomIndex]
                const fullTin = targetContext.organization.tin
                expect(fullTin).toBeDefined()
                expect(fullTin.length).toBeGreaterThanOrEqual(4)

                const substringTin = fullTin.substring(1, 5)
                const randomCaseSubstring = randomizeCase(substringTin)
                const expectedContexts = filterContextsBySearch(devContexts, substringTin)

                const [result] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT, {
                    search: randomCaseSubstring,
                })

                expect(result).toHaveProperty(['meta', 'count'], expectedContexts.length)
                expect(result.objs).toHaveLength(expectedContexts.length)
                expect(result.objs).toEqual(expect.arrayContaining(expectedContexts))
            })

            test('Search by substring of name case insensitive', async () => {
                const randomIndex = Math.floor(Math.random() * devContexts.length)
                const targetContext = devContexts[randomIndex]
                const fullName = targetContext.organization.name
                expect(fullName).toBeDefined()
                expect(fullName.length).toBeGreaterThanOrEqual(4)

                const substringName = fullName.substring(1, 5)
                const randomCaseSubstring = randomizeCase(substringName)
                const expectedContexts = filterContextsBySearch(devContexts, substringName)

                const [result] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT, {
                    search: randomCaseSubstring,
                })

                expect(result).toHaveProperty(['meta', 'count'], expectedContexts.length)
                expect(result.objs).toHaveLength(expectedContexts.length)
                expect(result.objs).toEqual(expect.arrayContaining(expectedContexts))
            })

            test('Search returns empty result when no matches found', async () => {
                const nonExistentSearch = 'NONEXISTENT123456789'

                const [result] = await allB2BAppContextsByTestClient(user, app, DEV_ENVIRONMENT, {
                    search: nonExistentSearch,
                })

                expect(result).toHaveProperty(['meta', 'count'], 0)
                expect(result.objs).toHaveLength(0)
            })
        })
    })
})