/**
 * Generated by `createservice miniapp.PublishB2CAppService`
 */

const fs = require('fs')

const dayjs = require('dayjs')
const got = require('got')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { getLogger } = require('@open-condo/keystone/logging')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { REMOTE_SYSTEM } = require('@dev-portal-api/domains/common/constants/common')
const { developmentClient, productionClient } = require('@dev-portal-api/domains/common/utils/serverClients')
const {
    CondoB2CAppGql,
    CondoB2CAppBuildGql,
    CondoOIDCClientGql,
    CondoB2CAppAccessRightGql,
} = require('@dev-portal-api/domains/condo/gql')
const access = require('@dev-portal-api/domains/miniapp/access/PublishB2CAppService')
const { DEFAULT_COLOR_SCHEMA } = require('@dev-portal-api/domains/miniapp/constants/b2c')
const {
    FIRST_PUBLISH_WITHOUT_INFO,
    APP_NOT_FOUND,
    CONDO_APP_NOT_FOUND,
    BUILD_NOT_FOUND,
    PUBLISH_NOT_ALLOWED,
} = require('@dev-portal-api/domains/miniapp/constants/errors')
const {
    AVAILABLE_ENVIRONMENTS,
    PROD_ENVIRONMENT,
    B2C_APP_DEFAULT_LOGO_PATH,
    PUBLISH_REQUEST_APPROVED_STATUS,
} = require('@dev-portal-api/domains/miniapp/constants/publishing')
const {
    B2CApp,
    B2CAppBuild,
    B2CAppPublishRequest,
    B2CAppAccessRight,
} = require('@dev-portal-api/domains/miniapp/utils/serverSchema/index')

const { getOIDCClientWhere } = require('./GetOIDCClientService')

const ERRORS = {
    FIRST_PUBLISH_WITHOUT_INFO: {
        code: BAD_USER_INPUT,
        type: FIRST_PUBLISH_WITHOUT_INFO,
        message: 'The first publication of the application should include information about the application',
        messageForUser: 'api.miniapp.publishB2CApp.FIRST_PUBLISH_WITHOUT_INFO',
    },
    APP_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: APP_NOT_FOUND,
        message: 'The application with the specified ID was not found',
        messageForUser: 'api.miniapp.B2CApp.APP_NOT_FOUND',
    },
    CONDO_APP_NOT_FOUND: {
        code: INTERNAL_ERROR,
        type: CONDO_APP_NOT_FOUND,
        message: 'The application was probably deleted on remote server. Try to publish app info to recreate it',
        messageForUser: 'api.miniapp.publishB2CApp.CONDO_APP_NOT_FOUND',
    },
    BUILD_NOT_FOUND: {
        code: BAD_USER_INPUT,
        type: BUILD_NOT_FOUND,
        message: 'Application build with the specified ID was not found',
        messageForUser: 'api.miniapp.publishB2CApp.BUILD_NOT_FOUND',
    },
    PUBLISH_NOT_ALLOWED: {
        code: BAD_USER_INPUT,
        type: PUBLISH_NOT_ALLOWED,
        message: 'The application cannot be published to the specified stand, as this requires additional verification',
        messageForUser: 'api.miniapp.publishB2CApp.PUBLISH_NOT_ALLOWED',
    },
}

const logger = getLogger()

function getExportIdField (environment) {
    return `${environment}ExportId`
}

async function publishAppChanges ({ app, condoApp, serverClient, args, context }) {
    const { data: { dv, sender, environment } } = args
    logger.info({
        msg: 'started app publishing',
        entityId: app.id,
        entity: 'B2CApp',
        environment,
    })
    const exportIdField = getExportIdField(environment)
    const exportId = app[exportIdField]

    // Step 1. Prepare payload
    const appPayload = {
        dv,
        sender,
        name: app.name,
        developer: app.developer || app.createdBy.name,
        colorSchema: DEFAULT_COLOR_SCHEMA,
        logo: app.logo
            ? serverClient.createUploadFile({
                stream: got.stream(app.logo.publicUrl),
                filename: app.logo.originalFilename,
            })
            : serverClient.createUploadFile({
                stream: fs.createReadStream(B2C_APP_DEFAULT_LOGO_PATH),
            }),
        importId: app.id,
        importRemoteSystem: REMOTE_SYSTEM,
    }

    // Step 2. Update / create app in condo
    let updatedCondoApp
    if (condoApp) {
        // App found -> update
        logger.info({
            msg: 'found existing condo app',
            entityId: app.id,
            entity: 'B2CApp',
            environment,
            data: { condoAppId: condoApp.id },
        })
        updatedCondoApp = await serverClient.updateModel({
            modelGql: CondoB2CAppGql,
            id: condoApp.id,
            updateInput: appPayload,
        })
        logger.info({
            msg: 'condo app successfully updated',
            entityId: app.id,
            entity: 'B2CApp',
            data: { condoAppId: condoApp.id },
            environment,
        })
    } else {
        // App not found -> create new one
        logger.info({
            msg: 'condo app not found. Creating new one',
            entityId: app.id,
            entity: 'B2CApp',
            environment,
        })
        updatedCondoApp = await serverClient.createModel({
            modelGql: CondoB2CAppGql,
            createInput: appPayload,
        })
        logger.info({
            msg: 'condo app successfully created',
            entityId: app.id,
            entity: 'B2CApp',
            environment,
            data: { condoAppId: updatedCondoApp.id },
        })
    }
    // Update exportIdField if needed
    if (!exportId || exportId !== updatedCondoApp.id) {
        await B2CApp.update(context, app.id, {
            dv,
            sender,
            [exportIdField]: updatedCondoApp.id,
        })
        logger.info({
            msg: 'dev-portal app exportId updated',
            entityId: app.id,
            entity: 'B2CApp',
            environment,
            data: { condoAppId: updatedCondoApp.id },
        })
    }

    return updatedCondoApp
}

async function publishBuildChanges ({ build, condoBuild, app, condoApp, context, args, serverClient }) {
    const { data: { dv, sender, environment } } = args
    const exportIdField = getExportIdField(environment)
    const exportId = build[exportIdField]
    let buildToUpdate = condoBuild
    if (!buildToUpdate) {
        logger.info({
            msg: 'condo build not found, creating new one',
            entityId: app.id,
            entity: 'B2CApp',
            environment,
            data: {
                condoAppId: condoApp.id,
                version: build.version,
            },
        })
        buildToUpdate = await serverClient.createModel({
            modelGql: CondoB2CAppBuildGql,
            createInput: {
                dv,
                sender,
                app: { connect: { id: condoApp.id } },
                version: build.version,
                data: serverClient.createUploadFile({
                    stream: got.stream(build.data.publicUrl),
                    filename: build.data.originalFilename,
                    mimetype: build.data.mimetype,
                    encoding: build.data.encoding,
                }),
                importId: build.id,
                importRemoteSystem: REMOTE_SYSTEM,
            },
        })
        logger.info({ msg: 'condo build created',
            environment,
            entityId: app.id,
            entity: 'B2CApp',
            data: { version: build.version, condoAppId: condoApp.id },
        })
    }

    logger.info({
        msg: 'updating condo app current build',
        environment,
        entityId: app.id,
        entity: 'B2CApp',
        data: { condoAppId: condoApp.id, version: build.version, condoBuildId: buildToUpdate.id },
    })
    await serverClient.updateModel({
        modelGql: CondoB2CAppGql,
        id: condoApp.id,
        updateInput: {
            dv,
            sender,
            currentBuild: { connect: { id: buildToUpdate.id } },
        },
    })
    logger.info({
        msg: 'current build successfully updated',
        environment,
        entityId: app.id,
        entity: 'B2CApp',
        data: { condoAppId: condoApp.id, version: build.version, condoBuildId: buildToUpdate.id },
    })

    if (!exportId || exportId !== buildToUpdate.id) {
        await B2CAppBuild.update(context, build.id, {
            dv,
            sender,
            [exportIdField]: buildToUpdate.id,
        })
        logger.info({
            msg: 'dev-portal build exportId updated',
            entityId: app.id,
            entity: 'B2CApp',
            environment,
            data: { condoAppId: condoApp.id, version: build.version, condoBuildId: buildToUpdate.id },
        })
    }
}

async function syncOIDCClient ({ args, serverClient, condoApp }) {
    const { data: { dv, sender, app, environment } } = args

    const oidcClients = await serverClient.getModels({
        modelGql: CondoOIDCClientGql,
        where: getOIDCClientWhere(app),
        first: 1,
    })

    if (!oidcClients.length) {
        logger.info({
            msg: 'no OIDC clients found for app',
            entityId: app.id,
            entity: 'B2CApp',
            environment,
        })
        return
    }

    const oidcClient = oidcClients[0]

    if (!oidcClient.isEnabled) {
        await serverClient.updateModel({
            modelGql: CondoOIDCClientGql,
            id: oidcClient.id,
            updateInput: {
                dv,
                sender,
                isEnabled: true,
            },
        })
        logger.info({
            msg: 'OIDC client is enabled now',
            entityId: app.id,
            entity: 'B2CApp',
            environment,
            data: { oidcClientId: oidcClient.id },
        })
    }



    if (!condoApp.oidcClient || condoApp.oidcClient.deletedAt) {
        await serverClient.updateModel({
            modelGql: CondoB2CAppGql,
            id: condoApp.id,
            updateInput: {
                dv,
                sender,
                oidcClient: { connect: { id: oidcClient.id } },
            },
        })
        logger.info({
            msg: 'B2CApp is connected to OIDC client',
            entityId: app.id,
            entity: 'B2CApp',
            environment,
            data: { oidcClientId: oidcClient.id },
        })
    }
}

async function addAccessRight ({ args, serverClient, context, condoApp }) {
    const { data: { dv, sender, app: { id }, environment } } = args
    const exportField = `${environment}ExportId`

    const accessRight = await B2CAppAccessRight.getOne(context, {
        app: { id },
        environment,
        deletedAt: null,
    }, 'id condoUserId')

    if (accessRight) {
        logger.info({
            msg: 'access right found for app',
            entityId: id,
            entity: 'B2CApp',
            environment,
            data: { accessRightId: accessRight.id },
        })

        const condoRights = await serverClient.getModels({
            modelGql: CondoB2CAppAccessRightGql,
            where: {
                app: { id: condoApp.id },
            },
            first: 1,
        })
        if (condoRights.length) {
            const condoRight = condoRights[0]
            logger.info({
                msg: 'existing condo access right found for app',
                entityId: id,
                entity: 'B2CApp',
                environment,
                data: { accessRightId: accessRight.id, condoAccessRightId: condoRight.id  },
            })
            const condoUserId = condoRight.user?.id

            if (condoUserId === accessRight.condoUserId) {
                return
            } else {
                logger.info({
                    msg: 'existing condo access right user does not match with dev-portal one',
                    entityId: id,
                    entity: 'B2CApp',
                    environment,
                    data: { accessRightId: accessRight.id, condoAccessRightId: condoRight.id  },
                })
                await serverClient.updateModel({
                    modelGql: CondoB2CAppAccessRightGql,
                    id: condoRight.id,
                    updateInput: {
                        dv: 1,
                        sender,
                        deletedAt: dayjs().toISOString(),
                    },
                })
                logger.info({
                    msg: 'existing condo access right successfully deleted',
                    entityId: id,
                    entity: 'B2CApp',
                    environment,
                    data: { accessRightId: accessRight.id, condoAccessRightId: condoRight.id  },
                })
            }
        }

        logger.info({
            msg: 'creating new condo access right',
            entityId: id,
            entity: 'B2CApp',
            environment,
            data: { accessRightId: accessRight.id },
        })
        const condoRight = await serverClient.createModel({
            modelGql: CondoB2CAppAccessRightGql,
            createInput: {
                dv,
                sender,
                app: { connect: { id: condoApp.id } },
                user: { connect: { id: accessRight.condoUserId } },
                importId: accessRight.id,
                importRemoteSystem: REMOTE_SYSTEM,
            },
        })
        logger.info({
            msg: 'Updating dev-portal access right info',
            entityId: id,
            entity: 'B2CApp',
            environment,
            data: { accessRightId: accessRight.id, condoAccessRightId: condoRight.id },
        })
        await B2CAppAccessRight.update(context, accessRight.id, {
            dv,
            sender,
            [exportField]: condoRight.id,
        })
    }
}

const PublishB2CAppService = new GQLCustomSchema('PublishB2CAppService', {
    types: [
        {
            access: true,
            type: 'input B2CAppPublishOptions { info: Boolean, build: B2CAppBuildWhereUniqueInput }',
        },
        {
            access: true,
            type: `enum AppEnvironment { ${AVAILABLE_ENVIRONMENTS.join(' ')} }`,
        },
        {
            access: true,
            type: 'input PublishB2CAppInput { dv: Int!, sender: SenderFieldInput!, app: B2CAppWhereUniqueInput!, environment: AppEnvironment!, options: B2CAppPublishOptions! }',
        },
        {
            access: true,
            type: 'type PublishB2CAppOutput { success: Boolean! }',
        },
    ],
    
    mutations: [
        {
            access: access.canPublishB2CApp,
            schema: 'publishB2CApp(data: PublishB2CAppInput!): PublishB2CAppOutput',
            resolver: async (parent, args, context) => {
                const { data: { app: { id }, options, environment } } = args

                const app = await B2CApp.getOne(
                    context,
                    { id, deletedAt: null },
                    'id developmentExportId productionExportId name developer createdBy { name } logo { publicUrl originalFilename }'
                )
                if (!app) {
                    throw new GQLError(ERRORS.APP_NOT_FOUND, context)
                }

                const exportIdField = getExportIdField(environment)
                let exportId = app[exportIdField]

                if (!exportId && !options.info) {
                    throw new GQLError(ERRORS.FIRST_PUBLISH_WITHOUT_INFO, context)
                }

                if (environment === PROD_ENVIRONMENT) {
                    const publishRequest = await B2CAppPublishRequest.getOne(context, {
                        app: { id: app.id },
                        deletedAt: null,
                        status: PUBLISH_REQUEST_APPROVED_STATUS,
                    })
                    if (!publishRequest) {
                        throw new GQLError(ERRORS.PUBLISH_NOT_ALLOWED, context)
                    }
                }

                const serverClient = environment === PROD_ENVIRONMENT
                    ? productionClient
                    : developmentClient

                let condoApp = await serverClient.findExportedModel({
                    modelGql: CondoB2CAppGql,
                    exportId,
                    id: app.id,
                    context,
                })

                // Step 1. Create / update app if needed
                if (options.info) {
                    condoApp = await publishAppChanges({
                        app,
                        condoApp,
                        serverClient,
                        args,
                        context,
                    })
                }

                if (!condoApp) {
                    throw new GQLError(ERRORS.CONDO_APP_NOT_FOUND, context)
                }

                // Step 2. Create build if needed and update app's currentBuild
                if (options.build) {
                    const build = await B2CAppBuild.getOne(context, {
                        id: options.build.id,
                        deletedAt: null,
                        app: { id: app.id },
                    }, 'id developmentExportId productionExportId version data { publicUrl originalFilename mimetype encoding }')
                    if (!build) {
                        throw new GQLError(ERRORS.BUILD_NOT_FOUND, context)
                    }
                    const condoBuild = await serverClient.findExportedModel({
                        modelGql: CondoB2CAppBuildGql,
                        exportId: build[exportIdField],
                        id: build.id,
                        context,
                    })

                    await publishBuildChanges({
                        build,
                        condoBuild,
                        app,
                        condoApp,
                        context,
                        args,
                        serverClient,
                    })
                }

                // Step 3. Create accessRight is necessary
                await addAccessRight({ args, serverClient, context, condoApp })

                // Step 4. If OIDC client was created, publish must enable it for usage
                await syncOIDCClient({ args, serverClient, condoApp })

                return {
                    success: true,
                }
            },
        },
    ],
})

module.exports = {
    PublishB2CAppService,
}
