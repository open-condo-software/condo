/**
 * Generated by `createservice address.ActualizeAddressesService --type mutations 'addresses:[AddressWhereUniqueInput!]!'`
 */

const get = require('lodash/get')

const { getLogger } = require('@open-condo/keystone/logging')
const { GQLCustomSchema, getById, find, getByCondition } = require('@open-condo/keystone/schema')

const access = require('@address-service/domains/address/access/ActualizeAddressesService')
const { Address, AddressSource } = require('@address-service/domains/address/utils/serverSchema')
const { DADATA_PROVIDER, GOOGLE_PROVIDER, PULLENTI_PROVIDER } = require('@address-service/domains/common/constants/providers')
const { generateAddressKey } = require('@address-service/domains/common/utils/addressKeyUtils')
const { DadataSuggestionProvider } = require('@address-service/domains/common/utils/services/suggest/providers')

const logger = getLogger()

const ActualizeAddressesService = new GQLCustomSchema('ActualizeAddressesService', {
    types: [
        {
            access: true,
            type: 'input ActualizeAddressesInput { dv: Int!, sender: SenderFieldInput!, addresses:[AddressWhereUniqueInput!]! }',
        },
        {
            access: true,
            type: 'type ActualizeAddressesFailuresOutput { addressId: ID!, errorMessage: String! }',
        },
        {
            access: true,
            type: 'type ActualizeAddressesOutput { successIds: [ID]!, failures: [ActualizeAddressesFailuresOutput]! }',
        },
    ],

    mutations: [
        {
            access: access.canActualizeAddresses,
            schema: 'actualizeAddresses(data: ActualizeAddressesInput!): ActualizeAddressesOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { dv, sender, addresses } } = args
                const successIds = [], failures = []

                for (const { id: addressId } of addresses) {
                    const dataForLog = { addressId }
                    const addressModelData = await getById('Address', addressId)
                    if (!addressModelData) {
                        failures.push({ addressId, errorMessage: 'Address not found' })
                        continue
                    }

                    const { key, meta } = addressModelData
                    const { provider: { name: providerName } } = meta

                    if (providerName === DADATA_PROVIDER) {
                        let fiasId

                        dataForLog.providerName = providerName

                        if (meta.provider?.rawData?.data?.house_fias_id) {
                            fiasId = meta.provider.rawData.data.house_fias_id
                        } else {
                            failures.push({ addressId, errorMessage: 'No house_fias_id in meta.provider.rawData.data' })
                            continue
                        }

                        dataForLog.fiasId = fiasId

                        const provider = new DadataSuggestionProvider(context)

                        // Logic partially similar to SearchByFiasId plugin
                        const denormalizedResult = await provider.getAddressByFiasId(fiasId)
                        if (!denormalizedResult) {
                            failures.push({ addressId, errorMessage: `Address not found with provider=${providerName}` })
                            continue
                        }

                        const [searchResult] = provider.normalize([denormalizedResult])
                        const addressKey = generateAddressKey(searchResult)

                        dataForLog.denormalizedResult = denormalizedResult
                        dataForLog.addressKey = addressKey

                        if (key === addressKey) {
                            failures.push({ addressId, errorMessage: `The addressKey was not changed: ${addressKey}` })
                            continue
                        }

                        const existingAddress = await getByCondition('Address', { key: addressKey })
                        if (existingAddress) {
                            // There must be only one: the updating address
                            dataForLog.existingAddress = existingAddress
                            const addressSources = await find('AddressSource', { address: { id: existingAddress.id } })
                            const updatedAddressSources = []
                            for (const addressSource of addressSources) {
                                const updatedAddressSource = await AddressSource.update(context, addressSource.id, {
                                    dv,
                                    sender,
                                    address: { connect: { id: addressId } },
                                })
                                updatedAddressSources.push(updatedAddressSource)
                            }
                            dataForLog.modifiedSources = updatedAddressSources
                            dataForLog.softDeletedAddress = await Address.softDelete(
                                context,
                                existingAddress.id,
                                'id',
                                { dv, sender },
                            )
                        }

                        const newAddressData = {
                            dv,
                            sender,
                            address: searchResult.value,
                            key: addressKey,
                            meta: {
                                provider: {
                                    name: provider.getProviderName(),
                                    rawData: denormalizedResult,
                                },
                                value: searchResult.value,
                                unrestricted_value: searchResult.unrestricted_value,
                                data: get(searchResult, 'data', {}),
                            },
                        }
                        const updatedAddress = await Address.update(context, addressId, newAddressData, 'id')
                        dataForLog.actualizedAddress = updatedAddress
                        successIds.push(updatedAddress.id)
                    } else if (providerName === GOOGLE_PROVIDER) {
                        failures.push({ addressId, errorMessage: 'Google not supported yet. Be free to contribute :)' })
                        continue
                    } else if (providerName === PULLENTI_PROVIDER) {
                        failures.push({ addressId, errorMessage: 'Pullenti not supported yet. Be free to contribute :)' })
                        continue
                    } else {
                        failures.push({ addressId, errorMessage: `No provider detected (name=${providerName})` })
                        continue
                    }

                    logger.info({ msg: 'actualize address', data: dataForLog })
                }

                logger.info({ msg: 'actualize address result', data: { successIds, failures } })
                return { successIds, failures }
            },
        },
    ],

})

module.exports = {
    ActualizeAddressesService,
}
