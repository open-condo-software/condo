/**
 * @jest-environment node
 */

/**
 * Generated by `createservice address.ActualizeAddressesService --type mutations 'addresses:[AddressWhereUniqueInput!]!'`
 */
const index = require('@app/address-service/index')
const { faker } = require('@faker-js/faker')

const {
    makeClient,
    makeLoggedInClient,
    makeLoggedInAdminClient,
    expectToThrowAuthenticationErrorToResult,
    expectToThrowAccessDeniedErrorToResult,
    setFakeClientMode,
} = require('@open-condo/keystone/test.utils')

const { Address, AddressSource, buildAddressModelData } = require('@address-service/domains/address/utils/testSchema')
const { actualizeAddressesByTestClient } = require('@address-service/domains/address/utils/testSchema')
const { generateDadataSuggestionItem } = require('@address-service/domains/address/utils/testSchema/dadataUtils')
const { generateAddressKey } = require('@address-service/domains/common/utils/addressKeyUtils')
const { DadataSearchProvider } = require('@address-service/domains/common/utils/services/search/providers')
const { createOrUpdateAddressWithSource } = require('@address-service/domains/common/utils/services/search/searchServiceUtils')
const { DadataSuggestionProvider } = require('@address-service/domains/common/utils/services/suggest/providers')
const { makeClientWithSupportUser } = require('@address-service/domains/user/utils/testSchema')

const { keystone } = index

describe('ActualizeAddressesService', () => {
    let context
    let adminClient, supportClient, userClient, anonymousClient
    let dvSender
    let mockedCallToDadata

    setFakeClientMode(index)

    beforeAll(async () => {
        context = await keystone.createContext({ skipAccessControl: true })

        adminClient = await makeLoggedInAdminClient()
        supportClient = await makeClientWithSupportUser()
        userClient = await makeLoggedInClient()
        anonymousClient = await makeClient()

        dvSender = {
            dv: 1,
            sender: { dv: 1, fingerprint: faker.random.alphaNumeric(8) },
        }

        // https://jestjs.io/docs/es6-class-mocks#mocking-a-specific-method-of-a-class
        mockedCallToDadata = jest.spyOn(DadataSuggestionProvider.prototype, 'callToDadata')
    })

    afterEach(async () => {
        mockedCallToDadata.mockReset()
    })

    afterAll(async () => {
        jest.clearAllMocks()
    })

    describe('access', () => {
        test('anonymous can\'t execute', async () => {
            await expectToThrowAuthenticationErrorToResult(async () => {
                await actualizeAddressesByTestClient(anonymousClient, [])
            })
        })

        test('user can\'t execute', async () => {
            await expectToThrowAccessDeniedErrorToResult(async () => {
                await actualizeAddressesByTestClient(userClient, [])
            })
        })

        test('admin can execute', async () => {
            const id = faker.datatype.uuid()
            const addresses = [{ id }]
            const [data] = await actualizeAddressesByTestClient(adminClient, addresses)

            expect(data).toBeDefined()
        })

        test('support can execute', async () => {
            const id = faker.datatype.uuid()
            const addresses = [{ id }]
            const [data] = await actualizeAddressesByTestClient(supportClient, addresses)

            expect(data).toEqual({ successIds: [], failures: expect.any(Array) })
        })
    })

    describe('returns a failure', () => {
        test('if try to actualize a not existing address', async () => {
            const id = faker.datatype.uuid()
            const addresses = [{ id }]
            const [data] = await actualizeAddressesByTestClient(supportClient, addresses)

            expect(data).toEqual({
                successIds: [],
                failures: [{
                    addressId: id,
                    errorMessage: 'Address not found',
                }],
            })
        })
    })

    describe('implements logic correctly', () => {
        describe('for dadata provider', () => {
            describe('when returns a failure', () => {
                test('if try to actualize address without house_fias_id', async () => {
                    const suggestionItem = generateDadataSuggestionItem({}, {
                        house_fias_id: null,
                    })

                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [suggestionItem] }
                    })

                    const searchProvider = new DadataSearchProvider({ req: { id: faker.datatype.uuid() } })
                    const s = suggestionItem.value
                    const denormalizedRows = await searchProvider.get({ query: s })
                    const [searchResult] = searchProvider.normalize(denormalizedRows)
                    const addressKey = generateAddressKey(searchResult)
                    const addressData = buildAddressModelData(searchResult, addressKey, searchProvider.getProviderName(), denormalizedRows[0])
                    const createdAddress = await createOrUpdateAddressWithSource(adminClient, Address, AddressSource, addressData, s, dvSender)

                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [suggestionItem] }
                    })

                    const [actualizeResult] = await actualizeAddressesByTestClient(supportClient, [{ id: createdAddress.id }])
                    expect(actualizeResult).toEqual({
                        successIds: [],
                        failures: [{
                            addressId: createdAddress.id,
                            errorMessage: 'No house_fias_id in meta.provider.rawData.data',
                        }],
                    })
                })

                test('if try to actualize with the same key', async () => {
                    const suggestionItem = generateDadataSuggestionItem()

                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [suggestionItem] }
                    })

                    const searchProvider = new DadataSearchProvider({ req: { id: faker.datatype.uuid() } })
                    const s = suggestionItem.value
                    const denormalizedRows = await searchProvider.get({ query: s })
                    const [searchResult] = searchProvider.normalize(denormalizedRows)
                    const addressKey = generateAddressKey(searchResult)
                    const addressData = buildAddressModelData(searchResult, addressKey, searchProvider.getProviderName(), denormalizedRows[0])
                    const createdAddress = await createOrUpdateAddressWithSource(adminClient, Address, AddressSource, addressData, s, dvSender)

                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [suggestionItem] }
                    })

                    const [actualizeResult] = await actualizeAddressesByTestClient(supportClient, [{ id: createdAddress.id }])
                    expect(actualizeResult).toEqual({
                        successIds: [],
                        failures: [{
                            addressId: createdAddress.id,
                            errorMessage: `The addressKey was not changed: ${addressKey}`,
                        }],
                    })
                })

                test('if Dadata can\'t find an address', async () => {
                    const suggestionItem = generateDadataSuggestionItem()

                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [suggestionItem] }
                    })

                    const searchProvider = new DadataSearchProvider({ req: { id: faker.datatype.uuid() } })
                    const s = suggestionItem.value
                    const denormalizedRows = await searchProvider.get({ query: s })
                    const [searchResult] = searchProvider.normalize(denormalizedRows)
                    const addressKey = generateAddressKey(searchResult)
                    const addressData = buildAddressModelData(searchResult, addressKey, searchProvider.getProviderName(), denormalizedRows[0])
                    const createdAddress = await createOrUpdateAddressWithSource(adminClient, Address, AddressSource, addressData, s, dvSender)

                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [] }
                    })

                    const [actualizeResult] = await actualizeAddressesByTestClient(supportClient, [{ id: createdAddress.id }])
                    expect(actualizeResult).toEqual({
                        successIds: [],
                        failures: [{
                            addressId: createdAddress.id,
                            errorMessage: 'Address not found with provider=dadata',
                        }],
                    })
                })
            })

            describe('when the settlement became a city district', () => {

                test('if run mutation before changed address model was created', async () => {
                    const suggestionItem = generateDadataSuggestionItem()
                    const initialData = suggestionItem.data

                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [suggestionItem] }
                    })

                    const searchProvider = new DadataSearchProvider({ req: { id: faker.datatype.uuid() } })
                    const s = suggestionItem.value
                    const denormalizedRows = await searchProvider.get({ query: s })
                    const [searchResult] = searchProvider.normalize(denormalizedRows)
                    const addressKey = generateAddressKey(searchResult)
                    const addressData = buildAddressModelData(searchResult, addressKey, searchProvider.getProviderName(), denormalizedRows[0])
                    const createdAddress = await createOrUpdateAddressWithSource(adminClient, Address, AddressSource, addressData, s, dvSender)

                    mockedCallToDadata.mockImplementationOnce(() => {
                        const cityDistrictType = faker.lorem.word(2)
                        const cityDistrict = faker.lorem.word(12)
                        const data = {
                            ...initialData,
                            city_district_fias_id: faker.datatype.uuid(),
                            city_district_with_type: `${cityDistrictType} ${cityDistrict}`,
                            city_district_type: cityDistrictType,
                            city_district_type_full: `${cityDistrictType}${faker.lorem.word(4)}`,
                            city_district: cityDistrict,
                            settlement_fias_id: null,
                            settlement_with_type: null,
                            settlement_type: null,
                            settlement_type_full: null,
                            settlement: null,
                        }
                        return {
                            suggestions: [{
                                data,
                                value: `${data.city_with_type}, ${data.city_district_with_type}, ${data.street_with_type}, ${data.house_type} ${data.house}`,
                                unrestricted_value: `${data.postal_code}, ${data.region_with_type}, ${data.city_with_type}, ${data.city_district_with_type}, ${data.street_with_type}, ${data.house_type} ${data.house}`,
                            }],
                        }
                    })

                    const [actualizeResult] = await actualizeAddressesByTestClient(supportClient, [{ id: createdAddress.id }])
                    expect(actualizeResult).toEqual({
                        successIds: [createdAddress.id],
                        failures: [],
                    })
                    const actualizedAddress = await Address.getOne(supportClient, { id: createdAddress.id })
                    expect(actualizedAddress.addressKey).not.toBe(addressKey)
                    expect(createdAddress.id).toBe(actualizedAddress.id)
                })

                test('if run mutation after changed address model was created', async () => {
                    const searchProvider = new DadataSearchProvider({ req: { id: faker.datatype.uuid() } })

                    const suggestionItem = generateDadataSuggestionItem()
                    const initialData = suggestionItem.data
                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [suggestionItem] }
                    })
                    const s1 = suggestionItem.value
                    const denormalizedRows1 = await searchProvider.get({ query: s1 })
                    const [searchResult1] = searchProvider.normalize(denormalizedRows1)
                    const addressKey1 = generateAddressKey(searchResult1)
                    const addressData1 = buildAddressModelData(searchResult1, addressKey1, searchProvider.getProviderName(), denormalizedRows1[0])
                    const createdAddress1 = await createOrUpdateAddressWithSource(adminClient, Address, AddressSource, addressData1, s1, dvSender)
                    const sources1 = await AddressSource.getAll(supportClient, { address: { id: createdAddress1.id } })

                    const cityDistrictType = faker.lorem.word(2)
                    const cityDistrict = faker.lorem.word(12)
                    const changedSuggestionItem = generateDadataSuggestionItem({}, {
                        ...initialData,
                        city_district_fias_id: faker.datatype.uuid(),
                        city_district_with_type: `${cityDistrictType} ${cityDistrict}`,
                        city_district_type: cityDistrictType,
                        city_district_type_full: `${cityDistrictType}${faker.lorem.word(4)}`,
                        city_district: cityDistrict,
                        settlement_fias_id: null,
                        settlement_with_type: null,
                        settlement_type: null,
                        settlement_type_full: null,
                        settlement: null,
                    })
                    const changedData = changedSuggestionItem.data
                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [changedSuggestionItem] }
                    })
                    const s2 = changedSuggestionItem.value
                    const denormalizedRows2 = await searchProvider.get({ query: s2 })
                    const [searchResult2] = searchProvider.normalize(denormalizedRows2)
                    const addressKey2 = generateAddressKey(searchResult2)
                    const addressData2 = buildAddressModelData(searchResult2, addressKey2, searchProvider.getProviderName(), denormalizedRows2[0])
                    const createdAddress2 = await createOrUpdateAddressWithSource(adminClient, Address, AddressSource, addressData2, s2, dvSender)
                    const sources2 = await AddressSource.getAll(supportClient, { address: { id: createdAddress2.id } })

                    expect(createdAddress1.meta.data.house_fias_id).toBe(createdAddress2.meta.data.house_fias_id)

                    mockedCallToDadata.mockImplementationOnce(() => {
                        return { suggestions: [changedSuggestionItem] }
                    })
                    const [actualizeResult, actualizeAttrs] = await actualizeAddressesByTestClient(supportClient, [{ id: createdAddress1.id }])
                    expect(actualizeResult).toEqual({
                        successIds: [createdAddress1.id],
                        failures: [],
                    })
                    const actualizedAddress = await Address.getOne(supportClient, { id: createdAddress1.id })
                    expect(actualizedAddress).toEqual(expect.objectContaining({
                        key: addressKey2,
                        meta: expect.objectContaining({
                            data: expect.objectContaining({
                                settlement: null,
                                city_district: changedData.city_district,
                            }),
                        }),
                        v: 2,
                        sender: actualizeAttrs.sender,
                    }))
                    expect(createdAddress1.id).toBe(actualizedAddress.id)

                    // Must be deleted after actualizing of address1
                    const address2 = await Address.getOne(supportClient, { id: createdAddress2.id })
                    expect(address2).not.toBeDefined()

                    // all sources must be related to address1
                    const sources = await AddressSource.getAll(supportClient, { address: { id: createdAddress1.id } })
                    expect(sources).toEqual(expect.arrayContaining([
                        ...sources1.map(({ id }) => expect.objectContaining({ id })),
                        ...sources2.map(({ id }) => expect.objectContaining({ id })),
                    ]))
                })
            })
        })
    })
})
