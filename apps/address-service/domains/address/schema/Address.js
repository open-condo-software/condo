/**
 * Generated by `createschema address.Address 'source:Text; address:Text; key:Text; meta:Json'`
 */

const get = require('lodash/get')
const has = require('lodash/has')
const isEmpty = require('lodash/isEmpty')
const isPlainObject = require('lodash/isPlainObject')

const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const access = require('@address-service/domains/address/access/Address')
const { OVERRIDING_ROOT } = require('@address-service/domains/address/constants')

const Address = new GQLListSchema('Address', {
    schemaDoc: 'A model containing data on the particular building\'s address',
    labelResolver: ({ address }) => address,
    fields: {
        address: {
            schemaDoc: 'The normalized address itself in one string',
            type: 'Text',
            isRequired: true,
        },

        key: {
            schemaDoc: 'The unique key of the address',
            type: 'Text',
            isRequired: true,
        },

        meta: {
            schemaDoc: 'Some additional data for building',
            type: 'Json',
            isRequired: true,
        },

        overrides: {
            schemaDoc: `The list of overrides for address ${OVERRIDING_ROOT} field`,
            adminDoc: `This is a JSON object that must look like {"field":"value", "someField.nestedField": "value2"}. Will use to override ${OVERRIDING_ROOT}`,
            type: 'Json',
            isRequired: false,
            hooks: {
                validateInput: async (data) => {
                    const { resolvedData, addFieldValidationError, existingItem, fieldPath } = data

                    const overrides = get(resolvedData, fieldPath)

                    if (overrides === null) {
                        return
                    }

                    if (!isPlainObject(overrides)) {
                        addFieldValidationError(`The "${fieldPath}" field must be an object`)
                    } else {
                        isEmpty(overrides) && addFieldValidationError(`The "${fieldPath}" field must be a not empty object`)

                        const possibleObj = { ...existingItem, ...resolvedData }

                        Object.entries(overrides).forEach(([path, value]) => {
                            if (!has(possibleObj, `${OVERRIDING_ROOT}.${path}`)) {
                                addFieldValidationError(`${OVERRIDING_ROOT} does not contains "${path}" field`)
                            } else if (get(possibleObj, `${OVERRIDING_ROOT}.${path}`) === get(resolvedData, `${fieldPath}.${path}`)) {
                                addFieldValidationError(`You trying to override field ${OVERRIDING_ROOT}.${path} with the same value`)
                            }
                        })
                    }
                },
            },
        },
    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['key'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'address_key_unique_key',
            },
        ],
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), analytical()],
    access: {
        read: access.canReadAddresses,
        create: access.canManageAddresses,
        update: access.canManageAddresses,
        delete: false,
        auth: true,
    },
})

module.exports = {
    Address,
}
