/**
 * Generated by `createschema address.AddressSource 'source:Text;'`
 */

const { get, has } = require('lodash')
const isEmpty = require('lodash/isEmpty')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender, analytical } = require('@open-condo/keystone/plugins')
const { GQLListSchema, find } = require('@open-condo/keystone/schema')

const access = require('@address-service/domains/address/access/AddressSource')
const { SOURCE_ALREADY_EXISTS_ERROR } = require('@address-service/domains/address/constants')

const ERRORS = {
    SAME_SOURCE: {
        mutation: 'createAddressSource',
        code: BAD_USER_INPUT,
        type: SOURCE_ALREADY_EXISTS_ERROR,
        message: 'Source with the same address already exists',
    },
}

const AddressSource = new GQLListSchema('AddressSource', {
    schemaDoc: 'A model containing data on the particular building\'s address origin',
    labelResolver: ({ source }) => source,
    fields: {

        source: {
            schemaDoc: 'The string the address was found by (address origin)',
            type: 'Text',
            isRequired: true,
            hooks: {
                resolveInput: ({ resolvedData, fieldPath }) => {
                    if (has(resolvedData, fieldPath)) {
                        return get(resolvedData, fieldPath, '').toLowerCase()
                    }

                    return get(resolvedData, fieldPath)
                },
                validateInput: async ({ resolvedData, fieldPath, context, existingItem, operation }) => {
                    const lowerCasedSource = get(resolvedData, fieldPath, '').toLowerCase()
                    const isCreate = operation === 'create'
                    const isUpdateAddress = operation === 'update' && lowerCasedSource !== existingItem.source

                    if (isCreate || isUpdateAddress) {
                        const sameAddressSourceRows = await find('AddressSource', {
                            source: lowerCasedSource,
                            deletedAt: null,
                        })

                        if (!isEmpty(sameAddressSourceRows)) {
                            throw new GQLError(ERRORS.SAME_SOURCE, context)
                        }
                    }
                },
            },
        },

        address: {
            schemaDoc: 'The address which was found by the source address',
            isRequired: true,
            type: 'Relationship',
            ref: 'Address',
            many: false,
        },

    },
    kmigratorOptions: {
        constraints: [
            {
                type: 'models.UniqueConstraint',
                fields: ['source'],
                condition: 'Q(deletedAt__isnull=True)',
                name: 'addresssource_source_unique_key',
            },
        ],
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical(), analytical()],
    access: {
        read: access.canReadAddressSources,
        create: access.canManageAddressSources,
        update: access.canManageAddressSources,
        delete: false,
        auth: true,
    },
})

module.exports = {
    AddressSource,
}
