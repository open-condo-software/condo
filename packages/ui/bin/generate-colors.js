const childProcess = require('child_process')
const fs = require('fs')
const path = require('path')
const util = require('util')

const get = require('lodash/get')
const {
    jsonInputForTargetLanguage,
    InputData,
    quicktype,
} = require('quicktype-core')

const exec = util.promisify(childProcess.exec)

const TOKENS_PATH = path.join(__dirname, '../src/tokens/tokens.json')
const COLORS_PATH = path.join(__dirname, '../src/colors/colors.json')
const TYPES_PATHS = path.join(__dirname, '../src/colors/colors.ts')
const ROOT_PATH = path.join(__dirname, '../../..')

const SHRINKABLE_HEX_PATTERN = /^#(([0-9a-f])\2){3}$/gmi

/**
 * Extracts global color tokens from tokenSet in src/tokens/tokens.json,
 * Then converts <colorName>: { value: <hex>, type: 'color' } to <colorName>: <hex>
 * All hex colors values are also processed to be style-lint friendly
 * After all conversions stores global colors to src/colors/colors.json
 */
function extractColorTokens () {
    const tokens = require(TOKENS_PATH)
    const globalColorTokens = get(tokens, ['global', 'color'], {})

    const processedColors = _flatColorTokens(globalColorTokens)
    fs.writeFileSync(COLORS_PATH, JSON.stringify(processedColors, null, 2))
}

function _flatColorTokens (tokenSet) {
    const flatten = {}

    for (const key of Object.keys(tokenSet)) {
        const value = get(tokenSet, [key, 'value'])
        flatten[key] = value ? _processColorTokenValue(value) : _flatColorTokens(tokenSet[key])
    }

    return flatten
}

function _processColorTokenValue (value) {
    const shortValue = SHRINKABLE_HEX_PATTERN.test(value)
        ? `#${value.charAt(1)}${value.charAt(3)}${value.charAt(5)}`
        : value

    return shortValue.toLowerCase()
}

/**
 * Gets colors JSON stored in src/colors/colors.json
 * and generates Typescript type "ColorPalette" + converter for that schema,
 * which can be found in src/colors/colors.ts
 * @returns {Promise<void>}
 */
async function generateColorTypes () {
    const colors = require(COLORS_PATH)

    const jsonInput = jsonInputForTargetLanguage('typescript')
    await jsonInput.addSource({
        name: 'ColorPalette',
        samples: [JSON.stringify(colors)],
    })

    const inputData = new InputData()
    inputData.addInput(jsonInput)

    const { lines } = await quicktype({
        inputData,
        lang: 'typescript',
    })

    fs.writeFileSync(TYPES_PATHS, [
        '/**',
        ' * This file was generated automatically',
        ' * Do not edit directly',
        ' */',
        '',
        // NOTE 1: Need to disable this rule for autogenerated file
        '/* eslint-disable no-empty */',
        ...lines
            .map(line => {
                // NOTE 2: Some autogenerated utils are not used and need to ignored

                if (line.startsWith('function a(') || line.startsWith('function u(') || line.startsWith('function m(')) {
                    return [
                        '// eslint-disable-next-line @typescript-eslint/ban-ts-comment',
                        '// @ts-ignore',
                        line,
                    ]
                } else {
                    return line
                }
            })
            .flat(),
    ].join('\n'))
}

/**
 * Lints autogenerated Typescript "colors.ts" file to match mono-repo level code style
 * @returns {Promise<void>}
 */
async function lintColorTypes () {
    try {
        await exec(`cd ${ROOT_PATH} && yarn run eslint packages/ui/src/colors/colors.ts --fix`)
    } catch (error) {
        throw new Error(`Lint error occurred: ${error.message}`)
    }
}

(async () => {
    console.log('Extracting global colors...')
    extractColorTokens()
    console.log('Generating types from schema...')
    await generateColorTypes()
    console.log('Linting generated types file...')
    await lintColorTypes()
    console.log('\r\n')
    console.log('All done!')
})()
